
==================== FINAL INTERFACE ====================
2019-03-07 13:36:56.693904 UTC

interface sedel-0.1.0.0-AhY9khA6pZOExbzZW5SwDc:SEDEL.Source.TypeCheck 8063
  interface hash: cf77a8d7f034e6e23bbb92c2925aa583
  ABI hash: 1a302120a62bae342ae7339a304f8947
  export-list hash: 1ee7fe1b8d5c4c09ceef020f935a13ff
  orphan hash: 670ae084a17243e17c16e5478305e028
  flag hash: 5455c992fe6bc042952aad8f14bafb4c
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  SEDEL.Source.TypeCheck.tcModule
module dependencies: SEDEL.Common SEDEL.Environment
                     SEDEL.PrettyPrint SEDEL.Source.Desugar SEDEL.Source.Subtyping
                     SEDEL.Source.Syntax SEDEL.Target.Syntax SEDEL.Util
package dependencies: array-0.5.3.0 async-2.2.1 base-4.12.0.0
                      base-orphans-0.8 bifunctors-5.5.3 binary-0.8.6.0
                      bytestring-0.10.8.2 comonad-5.0.4 containers-0.6.0.1
                      deepseq-1.4.4.0 distributive-0.6 exceptions-0.10.0
                      ghc-boot-th-8.6.3 ghc-prim-0.5.3 hashable-1.2.7.0
                      integer-gmp-1.0.2.0 megaparsec-7.0.4 mtl-2.2.2
                      parser-combinators-1.0.1 pretty-1.1.3.6 prettyprinter-1.2.1
                      profunctors-5.3 protolude-0.2.3 stm-2.5.0.0 tagged-0.8.6
                      template-haskell-2.14.0.0 text-1.2.3.1 transformers-0.5.5.0
                      unbound-generics-0.4.0
orphans: sedel-0.1.0.0-AhY9khA6pZOExbzZW5SwDc:SEDEL.PrettyPrint
         sedel-0.1.0.0-AhY9khA6pZOExbzZW5SwDc:SEDEL.Source.Syntax
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.1:Data.Text.Lazy
         text-1.2.3.1:Data.Text binary-0.8.6.0:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show stm-2.5.0.0:Control.Monad.STM
         transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         bifunctors-5.5.3:Data.Bifunctor.Biff
                         bifunctors-5.5.3:Data.Bifunctor.Clown
                         bifunctors-5.5.3:Data.Bifunctor.Joker
                         bifunctors-5.5.3:Data.Bifunctor.Product
                         bifunctors-5.5.3:Data.Bifunctor.Sum
                         bifunctors-5.5.3:Data.Bifunctor.Tannen
                         containers-0.6.0.1:Data.IntMap.Internal
                         containers-0.6.0.1:Data.IntSet.Internal
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Sequence.Internal
                         containers-0.6.0.1:Data.Set.Internal containers-0.6.0.1:Data.Tree
                         ghc-boot-th-8.6.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.6.3:GHC.LanguageExtensions.Type
                         megaparsec-7.0.4:Text.Megaparsec.Error
                         megaparsec-7.0.4:Text.Megaparsec.Pos
                         megaparsec-7.0.4:Text.Megaparsec.State
                         megaparsec-7.0.4:Text.Megaparsec.Stream
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         prettyprinter-1.2.1:Data.Text.Prettyprint.Doc.Internal
                         sedel-0.1.0.0-AhY9khA6pZOExbzZW5SwDc:SEDEL.Common
                         sedel-0.1.0.0-AhY9khA6pZOExbzZW5SwDc:SEDEL.Source.Syntax
                         sedel-0.1.0.0-AhY9khA6pZOExbzZW5SwDc:SEDEL.Target.Syntax
                         tagged-0.8.6:Data.Tagged
                         template-haskell-2.14.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.1:Data.Text text-1.2.3.1:Data.Text.Lazy
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Bind
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Embed
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Ignore
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Name
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Rebind
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Rec
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Shift
import  -/  base-4.12.0.0:Control.Monad 7bd27be8172a0ce3a579caee3ae14f88
import  -/  base-4.12.0.0:Data.Bifunctor 5b0364c19dacbd8c7945623465593ba3
import  -/  base-4.12.0.0:Data.Either 946a3435d06773e1dbcad1ba5dc18a2c
import  -/  base-4.12.0.0:Data.Foldable 00188ddf89c975fee76bdfad479443c1
import  -/  base-4.12.0.0:Data.Functor 22aac80fdb6c7b7f60b4aaab86afee64
import  -/  base-4.12.0.0:Data.Maybe 1e8e1362415df45376dffd98f8a47766
import  -/  base-4.12.0.0:Data.Traversable 257e9f3b6739f5bfbaaf0ac0abb0ddc5
import  -/  base-4.12.0.0:Data.Tuple c92a835d04b6c075a7031d4e28e53c71
import  -/  base-4.12.0.0:GHC.Base cc906f98291a1b830546e99a96674547
import  -/  base-4.12.0.0:GHC.List 734a72beb76d276fb4a0ba2689a5711f
import  -/  containers-0.6.0.1:Data.Map 5f02dd6a8637b9a0d9efcbcf63409470
import  -/  containers-0.6.0.1:Data.Map.Internal e652f5f18be5bf564604b214e5c1dad8
import  -/  ghc-prim-0.5.3:GHC.Classes e0d9c979f6368701f34fa421754d2cce
import  -/  mtl-2.2.2:Control.Monad.Error.Class 396bb83814f3ba40535fffb311f79b73
import  -/  prettyprinter-1.2.1:Data.Text.Prettyprint.Doc 37bebc045f3a0cb8e8977c181970ecaf
import  -/  prettyprinter-1.2.1:Data.Text.Prettyprint.Doc.Internal 12d379fe6b8bbcab8bffc2d86df0e72f
import  -/  prettyprinter-1.2.1:Data.Text.Prettyprint.Doc.Symbols.Ascii 91602a77e9f9b3606b529aea701ac155
import  -/  protolude-0.2.3:Protolude f69a0445642f255f4ede68732259560a
import  -/  protolude-0.2.3:Protolude.Safe 7e827f8753974832182e5b409c0481e1
import  -/  protolude-0.2.3:Unsafe b23296a5ac956587fea9857759a1b278
import  -/  SEDEL.Common dd957746dc264eb9e0f081197e6a170a
  exports: 2f8960fc3866b3ed3935cca8fdf4af32
  Arith ba6e6ee2769ab90fc6f8bfe05c457547
  Comp 95be31892a65ce02162c0359b2fd7836
  Equ be009671f59de591c88946764f695cd4
  Logical 5f88c0dcda3f0bb8a2151f64e886bf39
  Neq 2a26dcc2307ec55211eb17750235a9c5
import  -/  SEDEL.Environment dd09ab7cec4a123b3558d7d0b00ebe58
  exports: 9147ac472a2f1e821b851f0b0ed9132a
  Ctx ca81ee52cb278c44b895c99ae490b259
  TcMonad da2fa251acef7941d6d91583b2d9d9cf
  askCtx 1a1ebf70096c2a33e6f0fbabaf52ff96
  errThrow b7229c9967ba113cf29eda6e7fab3691
  extendConstrainedTVarCtx 5cf2835c4ba468093ca5b4f62ed20a1d
  extendSourceLocation 8fe72655525c7bfb9cab7ccecd8fdb0c
  extendTVarCtx 315f68430492166ea6d4c793a37f3eca
  extendVarCtx e9cbff19d72e4969542dd2e372bfebe7
  localCtx e27f314a0f23365a0451b1c3aaae3363
  lookupTVarConstraint 003e983fe7e7dc927f434be6f4ac886d
  lookupTVarConstraintMaybe f66ec24bf1ff4280500288cab306d35d
  lookupTVarKindMaybe be24c90592913e69e0b410d82cb5dd3f
  lookupTmDef cd57ae14cd61248302b02b24a264d669
  lookupVarTy 8278fd705087e33db11add1b55fc941b
import  -/  SEDEL.PrettyPrint 964a7aa5b503924946d66512cb28fa7b
  exports: b619665073b2d5fb703d759aa71f3760
  DD c4c8af0adc13ffcf7715f4dadb8a43a0
  DS 250a8f715a3f686442655142323fbb07
  pprint 76491deebf3a533810afc42d5a2b1f58
import  -/  SEDEL.Source.Desugar 47f6bbc09d5e5a72113814a5c3478420
  exports: d1d2f673beea48ced3414371ca4c22eb
  desugar 77d3366a6ce6db10da54fa15114f5232
  desugarTmBind 4c28ec04c3bad0640d286bf4ed7cc1a6
  expandType ddb40bd27d0596a122e69a107bf2df94
  normalizeTmDecl 2cccf5d6cafae5d357ced365fd37ee40
import  -/  SEDEL.Source.Subtyping b1f824ad69d61844ea12036cdf482fb3
  exports: a726afbdf887c523778ca1424ab907ac
  subtype df374acba90fa8d5e219b1ab463d3e6f
import  -/  SEDEL.Source.Syntax 9f3dfb0fbf1e70ab507bf7bc9146b9c2
  exports: 896776f51a272e1a88483380dad6fd08
  And 925a0deab5f1494d2a0b687541b54c83
  App 918a358cb48a398b72ee574734721109
  Arr 7f3ab58007a52032f8ab152cb78482fc
  BoolT ca4889adf40261529b89e0c9d5bf431e
  BoolV 93aca6a693af88ac74f37fc7935cef55
  BotT 9ab456ca23d0548ed9a7e334f28d7c95
  DForall 7b47f7ef14d2f3e450438a53b39157c9
  DRec e07fcbc7a0fd33a984f61de0f28bdfe5
  DefDecl 95c541665d482dc9a308d7a2af5ed64a
  Expr 99927ad3e0e67e81b20c67bb77c39769
  If 2d5682b2eb520296b1e8ff60a4d86a76
  Kind 99927ad3e0e67e81b20c67bb77c39769
  Label fc63c6ec9c84d81eb04bc3ecb5e488a0
  Lam a73f0c9c4038056007c2673da757122d
  Let 6afba27826fe734a288382e447dc77e4
  LitV c80bd6f96bd9d2613b0a9bae82f0c711
  Merge e3248796fe6cf52c5ba98bd30af87ed8
  Module f37b2ea5c387abb3387f2f6946a7e764
  NumT 0ebddafa2ed3c6c5451c6b04aa42daf5
  Pos 3377eba098178e2ae9a952100dc6dcb4
  PrimOp 28b62497d41f87a3d7711a84a5b71172
  Proj abe331125fd2df32c0c39a52032437b1
  SDecl 779eb14115c6308ca5b1573d2323dcbe
  SRecT 97be618e64cfb25592e793cec36df4bf
  SType 99927ad3e0e67e81b20c67bb77c39769
  Star 32758b178d0da26be2d310f22b6f94a3
  TUni 8f4402952194edc25982b55c5491589d
  TVar 736de09d10876516d4ad8cbdd335ca0e
  TmBind 99927ad3e0e67e81b20c67bb77c39769
  TmName 99927ad3e0e67e81b20c67bb77c39769
  Top 89171f61139caa849a7bf003742f4c3a
  TopT 3a709bb3dd26e9623089eda40f520cdd
  Var 4766d6cf2c310c55da910cfe55fa98cf
  mainExpr f37b2ea5c387abb3387f2f6946a7e764
  moduleEntries f37b2ea5c387abb3387f2f6946a7e764
import  -/  SEDEL.Target.Syntax f888023f68f70e26c5b67291e9ceb5c1
  exports: 1ef487a441a339fc23284b959880bbbc
  UApp 455602e503d975e8bbbcc868d7a741ad
  UBoolV c705dc7fbab9b57dc66b320514abe99e
  UExpr 84598e9b5c9ffc39eabcce5cc9c9ef9e
  UIf 4139f23341b286f045fd910c7c20d661
  ULam 7dd145c43c6d79fcbf6610ac66b279ba
  ULet 79a254d847af6448bc6ae38b4bc577d0
  ULitV a85d0e8e0d2b823729cbfd954ee386d1
  UName 84598e9b5c9ffc39eabcce5cc9c9ef9e
  UP1 6fd6c8be26040228258588419fa1b0e5
  UP2 95ccfd0687aae484ba85c6274c76d93d
  UPair 8b3703424314b91dd5369c83616c6a22
  UPrimOp 29c4ab88aacde89ef863679d34417e13
  UUnit 3f3bd74bb8fd544df115e07e5e9443dc
  UVar d3b72e7aff88d0fe9b456e54b0188362
  elam e57e3eb4af8d2c2ed79ae0a4c38d7b96
  elet 26c076f6b08b5b184cb5d0a8c3adc4c3
  evar 8a49c1b6a73ada20e8b5cff8bb7afa6f
import  -/  SEDEL.Util a4cbedccad9142bbdebfefe8464a7069
  exports: 868689cda1fe2579feb39deef7b7f9c6
  translate d0b236b1da26ed7519e9598588769645
import  -/  unbound-generics-0.4.0:Unbound.Generics.LocallyNameless 36704d4dbfb3fb22f46cde363ae796f2
import  -/  unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Embed f74cff3aea20e9a2f5e6bfc539a9689b
import  -/  unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Fresh e0f8d49fe8e0f78dfcabb34436892778
import  -/  unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Name 81d6e7baa0bd0880e550478df477614a
import  -/  unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Operations d0c219408974b95413509bf76023577c
06f943ac6e3fb45aeeadae1cc6ef5968
  $s$fAlpha(,)2 ::
    Unbound.Generics.LocallyNameless.Alpha.Alpha
      (Unbound.Generics.LocallyNameless.Name.Name
         SEDEL.Source.Syntax.SType,
       Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType)
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Name.Name
                       SEDEL.Source.Syntax.SType,
                     Unbound.Generics.LocallyNameless.Embed.Embed
                       SEDEL.Source.Syntax.SType)
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fShow(,)2
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$caeq'2
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$cfvAny'2
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$cclose2
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$copen2
                  (\ (x :: (Unbound.Generics.LocallyNameless.Name.Name
                              SEDEL.Source.Syntax.SType,
                            Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType)) ->
                   case x of wild { (,) g1 g2 ->
                   case g1 of wild1 {
                     Unbound.Generics.LocallyNameless.Name.Fn ds1 ds2
                     -> let {
                          xs :: Unbound.Generics.LocallyNameless.Name.AnyName
                          = Unbound.Generics.LocallyNameless.Name.AnyName
                              @ SEDEL.Source.Syntax.SType
                              SEDEL.Source.Syntax.$fAlphaExpr_v
                              wild1
                        } in
                        case (SEDEL.Source.Syntax.$fAlphaSType_$cisTerm
                                g2
                                  `cast`
                                (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                     <SEDEL.Source.Syntax.SType>_R))
                               `cast`
                             (Data.Semigroup.Internal.N:All[0]) of wild2 {
                          GHC.Types.False
                          -> (GHC.Maybe.Nothing
                                @ [Unbound.Generics.LocallyNameless.Name.AnyName])
                               `cast`
                             (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                       <Unbound.Generics.LocallyNameless.Name.AnyName>_R))
                          GHC.Types.True
                          -> case Data.OldList.intersectBy
                                    @ Unbound.Generics.LocallyNameless.Name.AnyName
                                    Unbound.Generics.LocallyNameless.Name.$fEqAnyName_$c==1
                                    (GHC.Types.:
                                       @ Unbound.Generics.LocallyNameless.Name.AnyName
                                       xs
                                       (GHC.Types.[]
                                          @ Unbound.Generics.LocallyNameless.Name.AnyName))
                                    (GHC.Types.[]
                                       @ Unbound.Generics.LocallyNameless.Name.AnyName) of wild3 {
                               []
                               -> (GHC.Maybe.Just
                                     @ [Unbound.Generics.LocallyNameless.Name.AnyName]
                                     (GHC.Base.build
                                        @ Unbound.Generics.LocallyNameless.Name.AnyName
                                        (\ @ b
                                           (c :: Unbound.Generics.LocallyNameless.Name.AnyName
                                                 -> b -> b)[OneShot]
                                           (n :: b)[OneShot] ->
                                         c xs n)))
                                    `cast`
                                  (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                            <Unbound.Generics.LocallyNameless.Name.AnyName>_R))
                               : ds4 ds5
                               -> (GHC.Maybe.Nothing
                                     @ [Unbound.Generics.LocallyNameless.Name.AnyName])
                                    `cast`
                                  (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                            <Unbound.Generics.LocallyNameless.Name.AnyName>_R)) } }
                     Unbound.Generics.LocallyNameless.Name.Bn ipv ipv1
                     -> (GHC.Maybe.Nothing
                           @ [Unbound.Generics.LocallyNameless.Name.AnyName])
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                  <Unbound.Generics.LocallyNameless.Name.AnyName>_R)) } })
                  (\ (x :: (Unbound.Generics.LocallyNameless.Name.Name
                              SEDEL.Source.Syntax.SType,
                            Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType)) ->
                   case x of wild { (,) g1 g2 ->
                   GHC.Types.False `cast` (Sym (Data.Semigroup.Internal.N:All[0])) })
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$cisEmbed2
                  (\ (x :: (Unbound.Generics.LocallyNameless.Name.Name
                              SEDEL.Source.Syntax.SType,
                            Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType)) ->
                   case x of wild { (,) g1 g2 ->
                   (\ (i :: GHC.Integer.Type.Integer) ->
                    case GHC.Integer.Type.eqInteger#
                           i
                           Unbound.Generics.LocallyNameless.Alpha.$fAlpha()4 of wild1 {
                      DEFAULT
                      -> case GHC.Integer.Type.minusInteger
                                i
                                Unbound.Generics.LocallyNameless.Alpha.$fAlphaAnyName9 of vx { DEFAULT ->
                         Data.Either.Left
                           @ GHC.Integer.Type.Integer
                           @ Unbound.Generics.LocallyNameless.Name.AnyName
                           vx }
                      1#
                      -> Data.Either.Right
                           @ GHC.Integer.Type.Integer
                           @ Unbound.Generics.LocallyNameless.Name.AnyName
                           (Unbound.Generics.LocallyNameless.Name.AnyName
                              @ SEDEL.Source.Syntax.SType
                              SEDEL.Source.Syntax.$fAlphaExpr_v
                              g1) })
                     `cast`
                   (Sym (Unbound.Generics.LocallyNameless.Alpha.N:NthPatFind[0])) })
                  (\ (x :: (Unbound.Generics.LocallyNameless.Name.Name
                              SEDEL.Source.Syntax.SType,
                            Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType)) ->
                   case x of wild { (,) g1 g2 ->
                   (\ (nm :: Unbound.Generics.LocallyNameless.Name.AnyName) ->
                    case Unbound.Generics.LocallyNameless.Alpha.$fAlphaName4
                           @ SEDEL.Source.Syntax.SType
                           SEDEL.Source.Syntax.$fAlphaExpr_v
                           g1
                           nm of wild1 {
                      Data.Either.Left n
                      -> case GHC.Integer.Type.plusInteger
                                n
                                Unbound.Generics.LocallyNameless.Alpha.$fAlpha()4 of vx { DEFAULT ->
                         Data.Either.Left
                           @ GHC.Integer.Type.Integer
                           @ GHC.Integer.Type.Integer
                           vx }
                      Data.Either.Right ds2 -> wild1 })
                     `cast`
                   (Sym (Unbound.Generics.LocallyNameless.Alpha.N:NamePatFind[0])) })
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$cswaps'2
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$clfreshen'2
                  (Unbound.Generics.LocallyNameless.Alpha.$fAlpha(,)_$cfreshen'
                     @ (Unbound.Generics.LocallyNameless.Name.Name
                          SEDEL.Source.Syntax.SType)
                     @ (Unbound.Generics.LocallyNameless.Embed.Embed
                          SEDEL.Source.Syntax.SType)
                     SEDEL.Source.Syntax.$fAlphaExpr_$s$fAlphaName
                     SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlphaEmbed)
                  (Unbound.Generics.LocallyNameless.Alpha.$fAlpha(,)_$cacompare'
                     @ (Unbound.Generics.LocallyNameless.Name.Name
                          SEDEL.Source.Syntax.SType)
                     @ (Unbound.Generics.LocallyNameless.Embed.Embed
                          SEDEL.Source.Syntax.SType)
                     SEDEL.Source.Syntax.$fAlphaExpr_$s$fAlphaName
                     SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlphaEmbed) -}
67f66bae9d2807a01b30632760a42057
  $s$fAlpha(,)_$s$fAlpha(,)_$caeq'2 ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> (Unbound.Generics.LocallyNameless.Name.Name
          SEDEL.Source.Syntax.SType,
        Unbound.Generics.LocallyNameless.Embed.Embed
          SEDEL.Source.Syntax.SType)
    -> (Unbound.Generics.LocallyNameless.Name.Name
          SEDEL.Source.Syntax.SType,
        Unbound.Generics.LocallyNameless.Embed.Embed
          SEDEL.Source.Syntax.SType)
    -> GHC.Types.Bool
  {- Arity: 3,
     Strictness: <S(SS),1*U(U,U)><S,1*U(1*U,1*U)><S,1*U(1*U,1*U)>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ (c :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (x :: (Unbound.Generics.LocallyNameless.Name.Name
                            SEDEL.Source.Syntax.SType,
                          Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType))
                   (y :: (Unbound.Generics.LocallyNameless.Name.Name
                            SEDEL.Source.Syntax.SType,
                          Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType)) ->
                 case x of wild { (,) g1 g2 ->
                 case y of wild1 { (,) g4 g5 ->
                 case c of wild2 { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds ds1 ->
                 case ds of wild3 {
                   Unbound.Generics.LocallyNameless.Alpha.Term
                   -> case Unbound.Generics.LocallyNameless.Name.$fEqAnyName_$c==
                             @ SEDEL.Source.Syntax.SType
                             g1
                             g4 of wild4 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> SEDEL.Source.Syntax.$fAlphaSType_$caeq'
                             (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                                Unbound.Generics.LocallyNameless.Alpha.Term
                                ds1)
                             g2
                               `cast`
                             (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <SEDEL.Source.Syntax.SType>_R)
                             g5
                               `cast`
                             (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <SEDEL.Source.Syntax.SType>_R) }
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> SEDEL.Source.Syntax.$fAlphaSType_$caeq'
                        (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                           Unbound.Generics.LocallyNameless.Alpha.Term
                           ds1)
                        g2
                          `cast`
                        (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                             <SEDEL.Source.Syntax.SType>_R)
                        g5
                          `cast`
                        (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                             <SEDEL.Source.Syntax.SType>_R) } } } }) -}
a78695627645a330282a9bfc772b702e
  $s$fAlpha(,)_$s$fAlpha(,)_$cclose2 ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Alpha.NamePatFind
    -> (Unbound.Generics.LocallyNameless.Name.Name
          SEDEL.Source.Syntax.SType,
        Unbound.Generics.LocallyNameless.Embed.Embed
          SEDEL.Source.Syntax.SType)
    -> (Unbound.Generics.LocallyNameless.Name.Name
          SEDEL.Source.Syntax.SType,
        Unbound.Generics.LocallyNameless.Embed.Embed
          SEDEL.Source.Syntax.SType)
  {- Arity: 3, Strictness: <L,U(U,U)><L,U><S,1*U(1*U,1*U)>m,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (c :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (b1 :: Unbound.Generics.LocallyNameless.Alpha.NamePatFind)
                   (x :: (Unbound.Generics.LocallyNameless.Name.Name
                            SEDEL.Source.Syntax.SType,
                          Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType)) ->
                 case x of wild { (,) g1 g2 ->
                 (Unbound.Generics.LocallyNameless.Alpha.$fAlphaAnyName_$cclose1
                    @ SEDEL.Source.Syntax.SType
                    SEDEL.Source.Syntax.$fAlphaExpr_v
                    c
                    b1
                    g1,
                  case c of wild1 { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                  case ds1 of wild2 {
                    Unbound.Generics.LocallyNameless.Alpha.Term
                    -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed6
                         @ SEDEL.Source.Syntax.SType
                    Unbound.Generics.LocallyNameless.Alpha.Pat
                    -> (SEDEL.Source.Syntax.$fAlphaSType_$cclose
                          (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                             Unbound.Generics.LocallyNameless.Alpha.Term
                             ds2)
                          b1
                          g2
                            `cast`
                          (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                               <SEDEL.Source.Syntax.SType>_R))
                         `cast`
                       (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                 <SEDEL.Source.Syntax.SType>_R)) } }) }) -}
6433d3d7b24c648358cf2f7fc814a6e2
  $s$fAlpha(,)_$s$fAlpha(,)_$cfvAny'2 ::
    (Data.Functor.Contravariant.Contravariant f,
     GHC.Base.Applicative f) =>
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> (Unbound.Generics.LocallyNameless.Name.AnyName
        -> f Unbound.Generics.LocallyNameless.Name.AnyName)
    -> (Unbound.Generics.LocallyNameless.Name.Name
          SEDEL.Source.Syntax.SType,
        Unbound.Generics.LocallyNameless.Embed.Embed
          SEDEL.Source.Syntax.SType)
    -> f (Unbound.Generics.LocallyNameless.Name.Name
            SEDEL.Source.Syntax.SType,
          Unbound.Generics.LocallyNameless.Embed.Embed
            SEDEL.Source.Syntax.SType)
  {- Arity: 2, Strictness: <L,U(U,U)><L,U(U(U,U),U,U,U,U,U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ f :: * -> *
                   ($dContravariant :: Data.Functor.Contravariant.Contravariant f)
                   ($dApplicative :: GHC.Base.Applicative f) ->
                 let {
                   $dFunctor :: GHC.Base.Functor f
                   = GHC.Base.$p1Applicative @ f $dApplicative
                 } in
                 \ (c :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (nfn :: Unbound.Generics.LocallyNameless.Name.AnyName
                           -> f Unbound.Generics.LocallyNameless.Name.AnyName) ->
                 let {
                   f1 :: f (GHC.Generics.Rep
                              (Unbound.Generics.LocallyNameless.Name.Name
                                 SEDEL.Source.Syntax.SType,
                               Unbound.Generics.LocallyNameless.Embed.Embed
                                 SEDEL.Source.Syntax.SType)
                              GHC.Types.Any)
                         -> f (Unbound.Generics.LocallyNameless.Name.Name
                                 SEDEL.Source.Syntax.SType,
                               Unbound.Generics.LocallyNameless.Embed.Embed
                                 SEDEL.Source.Syntax.SType)
                   = GHC.Base.fmap
                       @ f
                       $dFunctor
                       @ (GHC.Generics.Rep
                            (Unbound.Generics.LocallyNameless.Name.Name
                               SEDEL.Source.Syntax.SType,
                             Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Source.Syntax.SType)
                            GHC.Types.Any)
                       @ (Unbound.Generics.LocallyNameless.Name.Name
                            SEDEL.Source.Syntax.SType,
                          Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType)
                       (GHC.Generics.$fGeneric(,)_$cto
                          @ (Unbound.Generics.LocallyNameless.Name.Name
                               SEDEL.Source.Syntax.SType)
                          @ (Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Source.Syntax.SType)
                          @ GHC.Types.Any)
                 } in
                 let {
                   f2 :: f (GHC.Generics.M1
                              GHC.Generics.C
                              ('GHC.Generics.MetaCons
                                 "(,)" 'GHC.Generics.PrefixI 'GHC.Types.False)
                              (GHC.Generics.S1
                                 ('GHC.Generics.MetaSel
                                    'GHC.Maybe.Nothing
                                    'GHC.Generics.NoSourceUnpackedness
                                    'GHC.Generics.NoSourceStrictness
                                    'GHC.Generics.DecidedLazy)
                                 (GHC.Generics.Rec0
                                    (Unbound.Generics.LocallyNameless.Name.Name
                                       SEDEL.Source.Syntax.SType))
                               GHC.Generics.:*: GHC.Generics.S1
                                                  ('GHC.Generics.MetaSel
                                                     'GHC.Maybe.Nothing
                                                     'GHC.Generics.NoSourceUnpackedness
                                                     'GHC.Generics.NoSourceStrictness
                                                     'GHC.Generics.DecidedLazy)
                                                  (GHC.Generics.Rec0
                                                     (Unbound.Generics.LocallyNameless.Embed.Embed
                                                        SEDEL.Source.Syntax.SType)))
                              GHC.Types.Any)
                         -> f (GHC.Generics.M1
                                 GHC.Generics.D
                                 ('GHC.Generics.MetaData
                                    "(,)" "GHC.Tuple" "ghc-prim" 'GHC.Types.False)
                                 (GHC.Generics.M1
                                    GHC.Generics.C
                                    ('GHC.Generics.MetaCons
                                       "(,)" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                    (GHC.Generics.S1
                                       ('GHC.Generics.MetaSel
                                          'GHC.Maybe.Nothing
                                          'GHC.Generics.NoSourceUnpackedness
                                          'GHC.Generics.NoSourceStrictness
                                          'GHC.Generics.DecidedLazy)
                                       (GHC.Generics.Rec0
                                          (Unbound.Generics.LocallyNameless.Name.Name
                                             SEDEL.Source.Syntax.SType))
                                     GHC.Generics.:*: GHC.Generics.S1
                                                        ('GHC.Generics.MetaSel
                                                           'GHC.Maybe.Nothing
                                                           'GHC.Generics.NoSourceUnpackedness
                                                           'GHC.Generics.NoSourceStrictness
                                                           'GHC.Generics.DecidedLazy)
                                                        (GHC.Generics.Rec0
                                                           (Unbound.Generics.LocallyNameless.Embed.Embed
                                                              SEDEL.Source.Syntax.SType))))
                                 GHC.Types.Any)
                   = GHC.Base.fmap
                       @ f
                       (GHC.Base.$p1Applicative @ f $dApplicative)
                       @ (GHC.Generics.M1
                            GHC.Generics.C
                            ('GHC.Generics.MetaCons
                               "(,)" 'GHC.Generics.PrefixI 'GHC.Types.False)
                            (GHC.Generics.S1
                               ('GHC.Generics.MetaSel
                                  'GHC.Maybe.Nothing
                                  'GHC.Generics.NoSourceUnpackedness
                                  'GHC.Generics.NoSourceStrictness
                                  'GHC.Generics.DecidedLazy)
                               (GHC.Generics.Rec0
                                  (Unbound.Generics.LocallyNameless.Name.Name
                                     SEDEL.Source.Syntax.SType))
                             GHC.Generics.:*: GHC.Generics.S1
                                                ('GHC.Generics.MetaSel
                                                   'GHC.Maybe.Nothing
                                                   'GHC.Generics.NoSourceUnpackedness
                                                   'GHC.Generics.NoSourceStrictness
                                                   'GHC.Generics.DecidedLazy)
                                                (GHC.Generics.Rec0
                                                   (Unbound.Generics.LocallyNameless.Embed.Embed
                                                      SEDEL.Source.Syntax.SType)))
                            GHC.Types.Any)
                       @ (GHC.Generics.M1
                            GHC.Generics.D
                            ('GHC.Generics.MetaData
                               "(,)" "GHC.Tuple" "ghc-prim" 'GHC.Types.False)
                            (GHC.Generics.M1
                               GHC.Generics.C
                               ('GHC.Generics.MetaCons
                                  "(,)" 'GHC.Generics.PrefixI 'GHC.Types.False)
                               (GHC.Generics.S1
                                  ('GHC.Generics.MetaSel
                                     'GHC.Maybe.Nothing
                                     'GHC.Generics.NoSourceUnpackedness
                                     'GHC.Generics.NoSourceStrictness
                                     'GHC.Generics.DecidedLazy)
                                  (GHC.Generics.Rec0
                                     (Unbound.Generics.LocallyNameless.Name.Name
                                        SEDEL.Source.Syntax.SType))
                                GHC.Generics.:*: GHC.Generics.S1
                                                   ('GHC.Generics.MetaSel
                                                      'GHC.Maybe.Nothing
                                                      'GHC.Generics.NoSourceUnpackedness
                                                      'GHC.Generics.NoSourceStrictness
                                                      'GHC.Generics.DecidedLazy)
                                                   (GHC.Generics.Rec0
                                                      (Unbound.Generics.LocallyNameless.Embed.Embed
                                                         SEDEL.Source.Syntax.SType))))
                            GHC.Types.Any)
                       (\ (v :: GHC.Generics.M1
                                  GHC.Generics.C
                                  ('GHC.Generics.MetaCons
                                     "(,)" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                  (GHC.Generics.S1
                                     ('GHC.Generics.MetaSel
                                        'GHC.Maybe.Nothing
                                        'GHC.Generics.NoSourceUnpackedness
                                        'GHC.Generics.NoSourceStrictness
                                        'GHC.Generics.DecidedLazy)
                                     (GHC.Generics.Rec0
                                        (Unbound.Generics.LocallyNameless.Name.Name
                                           SEDEL.Source.Syntax.SType))
                                   GHC.Generics.:*: GHC.Generics.S1
                                                      ('GHC.Generics.MetaSel
                                                         'GHC.Maybe.Nothing
                                                         'GHC.Generics.NoSourceUnpackedness
                                                         'GHC.Generics.NoSourceStrictness
                                                         'GHC.Generics.DecidedLazy)
                                                      (GHC.Generics.Rec0
                                                         (Unbound.Generics.LocallyNameless.Embed.Embed
                                                            SEDEL.Source.Syntax.SType)))
                                  GHC.Types.Any) ->
                        v)
                         `cast`
                       (<GHC.Generics.M1
                           GHC.Generics.C
                           ('GHC.Generics.MetaCons
                              "(,)" 'GHC.Generics.PrefixI 'GHC.Types.False)
                           (GHC.Generics.S1
                              ('GHC.Generics.MetaSel
                                 'GHC.Maybe.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.NoSourceStrictness
                                 'GHC.Generics.DecidedLazy)
                              (GHC.Generics.Rec0
                                 (Unbound.Generics.LocallyNameless.Name.Name
                                    SEDEL.Source.Syntax.SType))
                            GHC.Generics.:*: GHC.Generics.S1
                                               ('GHC.Generics.MetaSel
                                                  'GHC.Maybe.Nothing
                                                  'GHC.Generics.NoSourceUnpackedness
                                                  'GHC.Generics.NoSourceStrictness
                                                  'GHC.Generics.DecidedLazy)
                                               (GHC.Generics.Rec0
                                                  (Unbound.Generics.LocallyNameless.Embed.Embed
                                                     SEDEL.Source.Syntax.SType)))
                           GHC.Types.Any>_R
                        ->_R Sym (GHC.Generics.N:M1[0]
                                      <*>_N
                                      <GHC.Generics.D>_P
                                      <'GHC.Generics.MetaData
                                         "(,)" "GHC.Tuple" "ghc-prim" 'GHC.Types.False>_P
                                      <GHC.Generics.M1
                                         GHC.Generics.C
                                         ('GHC.Generics.MetaCons
                                            "(,)" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                         (GHC.Generics.S1
                                            ('GHC.Generics.MetaSel
                                               'GHC.Maybe.Nothing
                                               'GHC.Generics.NoSourceUnpackedness
                                               'GHC.Generics.NoSourceStrictness
                                               'GHC.Generics.DecidedLazy)
                                            (GHC.Generics.Rec0
                                               (Unbound.Generics.LocallyNameless.Name.Name
                                                  SEDEL.Source.Syntax.SType))
                                          GHC.Generics.:*: GHC.Generics.S1
                                                             ('GHC.Generics.MetaSel
                                                                'GHC.Maybe.Nothing
                                                                'GHC.Generics.NoSourceUnpackedness
                                                                'GHC.Generics.NoSourceStrictness
                                                                'GHC.Generics.DecidedLazy)
                                                             (GHC.Generics.Rec0
                                                                (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                   SEDEL.Source.Syntax.SType)))>_R) <GHC.Types.Any>_N)
                 } in
                 let {
                   f3 :: f ((GHC.Generics.:*:)
                              (GHC.Generics.S1
                                 ('GHC.Generics.MetaSel
                                    'GHC.Maybe.Nothing
                                    'GHC.Generics.NoSourceUnpackedness
                                    'GHC.Generics.NoSourceStrictness
                                    'GHC.Generics.DecidedLazy)
                                 (GHC.Generics.Rec0
                                    (Unbound.Generics.LocallyNameless.Name.Name
                                       SEDEL.Source.Syntax.SType)))
                              (GHC.Generics.S1
                                 ('GHC.Generics.MetaSel
                                    'GHC.Maybe.Nothing
                                    'GHC.Generics.NoSourceUnpackedness
                                    'GHC.Generics.NoSourceStrictness
                                    'GHC.Generics.DecidedLazy)
                                 (GHC.Generics.Rec0
                                    (Unbound.Generics.LocallyNameless.Embed.Embed
                                       SEDEL.Source.Syntax.SType)))
                              GHC.Types.Any)
                         -> f (GHC.Generics.M1
                                 GHC.Generics.C
                                 ('GHC.Generics.MetaCons
                                    "(,)" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                 (GHC.Generics.S1
                                    ('GHC.Generics.MetaSel
                                       'GHC.Maybe.Nothing
                                       'GHC.Generics.NoSourceUnpackedness
                                       'GHC.Generics.NoSourceStrictness
                                       'GHC.Generics.DecidedLazy)
                                    (GHC.Generics.Rec0
                                       (Unbound.Generics.LocallyNameless.Name.Name
                                          SEDEL.Source.Syntax.SType))
                                  GHC.Generics.:*: GHC.Generics.S1
                                                     ('GHC.Generics.MetaSel
                                                        'GHC.Maybe.Nothing
                                                        'GHC.Generics.NoSourceUnpackedness
                                                        'GHC.Generics.NoSourceStrictness
                                                        'GHC.Generics.DecidedLazy)
                                                     (GHC.Generics.Rec0
                                                        (Unbound.Generics.LocallyNameless.Embed.Embed
                                                           SEDEL.Source.Syntax.SType)))
                                 GHC.Types.Any)
                   = GHC.Base.fmap
                       @ f
                       (GHC.Base.$p1Applicative @ f $dApplicative)
                       @ ((GHC.Generics.:*:)
                            (GHC.Generics.S1
                               ('GHC.Generics.MetaSel
                                  'GHC.Maybe.Nothing
                                  'GHC.Generics.NoSourceUnpackedness
                                  'GHC.Generics.NoSourceStrictness
                                  'GHC.Generics.DecidedLazy)
                               (GHC.Generics.Rec0
                                  (Unbound.Generics.LocallyNameless.Name.Name
                                     SEDEL.Source.Syntax.SType)))
                            (GHC.Generics.S1
                               ('GHC.Generics.MetaSel
                                  'GHC.Maybe.Nothing
                                  'GHC.Generics.NoSourceUnpackedness
                                  'GHC.Generics.NoSourceStrictness
                                  'GHC.Generics.DecidedLazy)
                               (GHC.Generics.Rec0
                                  (Unbound.Generics.LocallyNameless.Embed.Embed
                                     SEDEL.Source.Syntax.SType)))
                            GHC.Types.Any)
                       @ (GHC.Generics.M1
                            GHC.Generics.C
                            ('GHC.Generics.MetaCons
                               "(,)" 'GHC.Generics.PrefixI 'GHC.Types.False)
                            (GHC.Generics.S1
                               ('GHC.Generics.MetaSel
                                  'GHC.Maybe.Nothing
                                  'GHC.Generics.NoSourceUnpackedness
                                  'GHC.Generics.NoSourceStrictness
                                  'GHC.Generics.DecidedLazy)
                               (GHC.Generics.Rec0
                                  (Unbound.Generics.LocallyNameless.Name.Name
                                     SEDEL.Source.Syntax.SType))
                             GHC.Generics.:*: GHC.Generics.S1
                                                ('GHC.Generics.MetaSel
                                                   'GHC.Maybe.Nothing
                                                   'GHC.Generics.NoSourceUnpackedness
                                                   'GHC.Generics.NoSourceStrictness
                                                   'GHC.Generics.DecidedLazy)
                                                (GHC.Generics.Rec0
                                                   (Unbound.Generics.LocallyNameless.Embed.Embed
                                                      SEDEL.Source.Syntax.SType)))
                            GHC.Types.Any)
                       (\ (v :: (GHC.Generics.:*:)
                                  (GHC.Generics.S1
                                     ('GHC.Generics.MetaSel
                                        'GHC.Maybe.Nothing
                                        'GHC.Generics.NoSourceUnpackedness
                                        'GHC.Generics.NoSourceStrictness
                                        'GHC.Generics.DecidedLazy)
                                     (GHC.Generics.Rec0
                                        (Unbound.Generics.LocallyNameless.Name.Name
                                           SEDEL.Source.Syntax.SType)))
                                  (GHC.Generics.S1
                                     ('GHC.Generics.MetaSel
                                        'GHC.Maybe.Nothing
                                        'GHC.Generics.NoSourceUnpackedness
                                        'GHC.Generics.NoSourceStrictness
                                        'GHC.Generics.DecidedLazy)
                                     (GHC.Generics.Rec0
                                        (Unbound.Generics.LocallyNameless.Embed.Embed
                                           SEDEL.Source.Syntax.SType)))
                                  GHC.Types.Any) ->
                        v)
                         `cast`
                       (<(GHC.Generics.:*:)
                           (GHC.Generics.S1
                              ('GHC.Generics.MetaSel
                                 'GHC.Maybe.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.NoSourceStrictness
                                 'GHC.Generics.DecidedLazy)
                              (GHC.Generics.Rec0
                                 (Unbound.Generics.LocallyNameless.Name.Name
                                    SEDEL.Source.Syntax.SType)))
                           (GHC.Generics.S1
                              ('GHC.Generics.MetaSel
                                 'GHC.Maybe.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.NoSourceStrictness
                                 'GHC.Generics.DecidedLazy)
                              (GHC.Generics.Rec0
                                 (Unbound.Generics.LocallyNameless.Embed.Embed
                                    SEDEL.Source.Syntax.SType)))
                           GHC.Types.Any>_R
                        ->_R Sym (GHC.Generics.N:M1[0]
                                      <*>_N
                                      <GHC.Generics.C>_P
                                      <'GHC.Generics.MetaCons
                                         "(,)" 'GHC.Generics.PrefixI 'GHC.Types.False>_P
                                      <GHC.Generics.S1
                                         ('GHC.Generics.MetaSel
                                            'GHC.Maybe.Nothing
                                            'GHC.Generics.NoSourceUnpackedness
                                            'GHC.Generics.NoSourceStrictness
                                            'GHC.Generics.DecidedLazy)
                                         (GHC.Generics.Rec0
                                            (Unbound.Generics.LocallyNameless.Name.Name
                                               SEDEL.Source.Syntax.SType))
                                       GHC.Generics.:*: GHC.Generics.S1
                                                          ('GHC.Generics.MetaSel
                                                             'GHC.Maybe.Nothing
                                                             'GHC.Generics.NoSourceUnpackedness
                                                             'GHC.Generics.NoSourceStrictness
                                                             'GHC.Generics.DecidedLazy)
                                                          (GHC.Generics.Rec0
                                                             (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                SEDEL.Source.Syntax.SType))>_R) <GHC.Types.Any>_N)
                 } in
                 let {
                   $dFunctor1 :: GHC.Base.Functor f
                   = GHC.Base.$p1Applicative @ f $dApplicative
                 } in
                 \ (x :: (Unbound.Generics.LocallyNameless.Name.Name
                            SEDEL.Source.Syntax.SType,
                          Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType)) ->
                 f1
                   (f2
                      (f3
                         (case x of wild { (,) g1 g2 ->
                          GHC.Base.<*>
                            @ f
                            $dApplicative
                            @ (GHC.Generics.M1
                                 GHC.Generics.S
                                 ('GHC.Generics.MetaSel
                                    'GHC.Maybe.Nothing
                                    'GHC.Generics.NoSourceUnpackedness
                                    'GHC.Generics.NoSourceStrictness
                                    'GHC.Generics.DecidedLazy)
                                 (GHC.Generics.Rec0
                                    (Unbound.Generics.LocallyNameless.Embed.Embed
                                       SEDEL.Source.Syntax.SType))
                                 GHC.Types.Any)
                            @ ((GHC.Generics.:*:)
                                 (GHC.Generics.M1
                                    GHC.Generics.S
                                    ('GHC.Generics.MetaSel
                                       'GHC.Maybe.Nothing
                                       'GHC.Generics.NoSourceUnpackedness
                                       'GHC.Generics.NoSourceStrictness
                                       'GHC.Generics.DecidedLazy)
                                    (GHC.Generics.Rec0
                                       (Unbound.Generics.LocallyNameless.Name.Name
                                          SEDEL.Source.Syntax.SType)))
                                 (GHC.Generics.M1
                                    GHC.Generics.S
                                    ('GHC.Generics.MetaSel
                                       'GHC.Maybe.Nothing
                                       'GHC.Generics.NoSourceUnpackedness
                                       'GHC.Generics.NoSourceStrictness
                                       'GHC.Generics.DecidedLazy)
                                    (GHC.Generics.Rec0
                                       (Unbound.Generics.LocallyNameless.Embed.Embed
                                          SEDEL.Source.Syntax.SType)))
                                 GHC.Types.Any)
                            (GHC.Base.fmap
                               @ f
                               $dFunctor1
                               @ (GHC.Generics.M1
                                    GHC.Generics.S
                                    ('GHC.Generics.MetaSel
                                       'GHC.Maybe.Nothing
                                       'GHC.Generics.NoSourceUnpackedness
                                       'GHC.Generics.NoSourceStrictness
                                       'GHC.Generics.DecidedLazy)
                                    (GHC.Generics.Rec0
                                       (Unbound.Generics.LocallyNameless.Name.Name
                                          SEDEL.Source.Syntax.SType))
                                    GHC.Types.Any)
                               @ (GHC.Generics.M1
                                    GHC.Generics.S
                                    ('GHC.Generics.MetaSel
                                       'GHC.Maybe.Nothing
                                       'GHC.Generics.NoSourceUnpackedness
                                       'GHC.Generics.NoSourceStrictness
                                       'GHC.Generics.DecidedLazy)
                                    (GHC.Generics.Rec0
                                       (Unbound.Generics.LocallyNameless.Embed.Embed
                                          SEDEL.Source.Syntax.SType))
                                    GHC.Types.Any
                                  -> (GHC.Generics.:*:)
                                       (GHC.Generics.M1
                                          GHC.Generics.S
                                          ('GHC.Generics.MetaSel
                                             'GHC.Maybe.Nothing
                                             'GHC.Generics.NoSourceUnpackedness
                                             'GHC.Generics.NoSourceStrictness
                                             'GHC.Generics.DecidedLazy)
                                          (GHC.Generics.Rec0
                                             (Unbound.Generics.LocallyNameless.Name.Name
                                                SEDEL.Source.Syntax.SType)))
                                       (GHC.Generics.M1
                                          GHC.Generics.S
                                          ('GHC.Generics.MetaSel
                                             'GHC.Maybe.Nothing
                                             'GHC.Generics.NoSourceUnpackedness
                                             'GHC.Generics.NoSourceStrictness
                                             'GHC.Generics.DecidedLazy)
                                          (GHC.Generics.Rec0
                                             (Unbound.Generics.LocallyNameless.Embed.Embed
                                                SEDEL.Source.Syntax.SType)))
                                       GHC.Types.Any)
                               (GHC.Generics.:*:
                                  @ *
                                  @ (GHC.Generics.M1
                                       GHC.Generics.S
                                       ('GHC.Generics.MetaSel
                                          'GHC.Maybe.Nothing
                                          'GHC.Generics.NoSourceUnpackedness
                                          'GHC.Generics.NoSourceStrictness
                                          'GHC.Generics.DecidedLazy)
                                       (GHC.Generics.Rec0
                                          (Unbound.Generics.LocallyNameless.Name.Name
                                             SEDEL.Source.Syntax.SType)))
                                  @ (GHC.Generics.M1
                                       GHC.Generics.S
                                       ('GHC.Generics.MetaSel
                                          'GHC.Maybe.Nothing
                                          'GHC.Generics.NoSourceUnpackedness
                                          'GHC.Generics.NoSourceStrictness
                                          'GHC.Generics.DecidedLazy)
                                       (GHC.Generics.Rec0
                                          (Unbound.Generics.LocallyNameless.Embed.Embed
                                             SEDEL.Source.Syntax.SType)))
                                  @ GHC.Types.Any)
                               (GHC.Base.fmap
                                  @ f
                                  (GHC.Base.$p1Applicative @ f $dApplicative)
                                  @ (GHC.Generics.K1
                                       GHC.Generics.R
                                       (Unbound.Generics.LocallyNameless.Name.Name
                                          SEDEL.Source.Syntax.SType)
                                       GHC.Types.Any)
                                  @ (GHC.Generics.M1
                                       GHC.Generics.S
                                       ('GHC.Generics.MetaSel
                                          'GHC.Maybe.Nothing
                                          'GHC.Generics.NoSourceUnpackedness
                                          'GHC.Generics.NoSourceStrictness
                                          'GHC.Generics.DecidedLazy)
                                       (GHC.Generics.K1
                                          GHC.Generics.R
                                          (Unbound.Generics.LocallyNameless.Name.Name
                                             SEDEL.Source.Syntax.SType))
                                       GHC.Types.Any)
                                  (\ (v :: GHC.Generics.K1
                                             GHC.Generics.R
                                             (Unbound.Generics.LocallyNameless.Name.Name
                                                SEDEL.Source.Syntax.SType)
                                             GHC.Types.Any) ->
                                   v)
                                    `cast`
                                  (<GHC.Generics.K1
                                      GHC.Generics.R
                                      (Unbound.Generics.LocallyNameless.Name.Name
                                         SEDEL.Source.Syntax.SType)
                                      GHC.Types.Any>_R
                                   ->_R Sym (GHC.Generics.N:M1[0]
                                                 <*>_N
                                                 <GHC.Generics.S>_P
                                                 <'GHC.Generics.MetaSel
                                                    'GHC.Maybe.Nothing
                                                    'GHC.Generics.NoSourceUnpackedness
                                                    'GHC.Generics.NoSourceStrictness
                                                    'GHC.Generics.DecidedLazy>_P
                                                 <GHC.Generics.K1
                                                    GHC.Generics.R
                                                    (Unbound.Generics.LocallyNameless.Name.Name
                                                       SEDEL.Source.Syntax.SType)>_R) <GHC.Types.Any>_N)
                                  (GHC.Base.fmap
                                     @ f
                                     (GHC.Base.$p1Applicative @ f $dApplicative)
                                     @ (Unbound.Generics.LocallyNameless.Name.Name
                                          SEDEL.Source.Syntax.SType)
                                     @ (GHC.Generics.K1
                                          GHC.Generics.R
                                          (Unbound.Generics.LocallyNameless.Name.Name
                                             SEDEL.Source.Syntax.SType)
                                          GHC.Types.Any)
                                     (\ (v :: Unbound.Generics.LocallyNameless.Name.Name
                                                SEDEL.Source.Syntax.SType) ->
                                      v)
                                       `cast`
                                     (<Unbound.Generics.LocallyNameless.Name.Name
                                         SEDEL.Source.Syntax.SType>_R
                                      ->_R Sym (GHC.Generics.N:K1[0]
                                                    <*>_N
                                                    <GHC.Generics.R>_P
                                                    <Unbound.Generics.LocallyNameless.Name.Name
                                                       SEDEL.Source.Syntax.SType>_R
                                                    <GHC.Types.Any>_P))
                                     (Unbound.Generics.LocallyNameless.Alpha.$fAlphaName_$cfvAny'
                                        @ SEDEL.Source.Syntax.SType
                                        SEDEL.Source.Syntax.$fAlphaExpr_v
                                        @ f
                                        $dContravariant
                                        $dApplicative
                                        c
                                        nfn
                                        g1))))
                            (GHC.Base.fmap
                               @ f
                               (GHC.Base.$p1Applicative @ f $dApplicative)
                               @ (GHC.Generics.K1
                                    GHC.Generics.R
                                    (Unbound.Generics.LocallyNameless.Embed.Embed
                                       SEDEL.Source.Syntax.SType)
                                    GHC.Types.Any)
                               @ (GHC.Generics.M1
                                    GHC.Generics.S
                                    ('GHC.Generics.MetaSel
                                       'GHC.Maybe.Nothing
                                       'GHC.Generics.NoSourceUnpackedness
                                       'GHC.Generics.NoSourceStrictness
                                       'GHC.Generics.DecidedLazy)
                                    (GHC.Generics.K1
                                       GHC.Generics.R
                                       (Unbound.Generics.LocallyNameless.Embed.Embed
                                          SEDEL.Source.Syntax.SType))
                                    GHC.Types.Any)
                               (\ (v :: GHC.Generics.K1
                                          GHC.Generics.R
                                          (Unbound.Generics.LocallyNameless.Embed.Embed
                                             SEDEL.Source.Syntax.SType)
                                          GHC.Types.Any) ->
                                v)
                                 `cast`
                               (<GHC.Generics.K1
                                   GHC.Generics.R
                                   (Unbound.Generics.LocallyNameless.Embed.Embed
                                      SEDEL.Source.Syntax.SType)
                                   GHC.Types.Any>_R
                                ->_R Sym (GHC.Generics.N:M1[0]
                                              <*>_N
                                              <GHC.Generics.S>_P
                                              <'GHC.Generics.MetaSel
                                                 'GHC.Maybe.Nothing
                                                 'GHC.Generics.NoSourceUnpackedness
                                                 'GHC.Generics.NoSourceStrictness
                                                 'GHC.Generics.DecidedLazy>_P
                                              <GHC.Generics.K1
                                                 GHC.Generics.R
                                                 (Unbound.Generics.LocallyNameless.Embed.Embed
                                                    SEDEL.Source.Syntax.SType)>_R) <GHC.Types.Any>_N)
                               (GHC.Base.fmap
                                  @ f
                                  (GHC.Base.$p1Applicative @ f $dApplicative)
                                  @ (Unbound.Generics.LocallyNameless.Embed.Embed
                                       SEDEL.Source.Syntax.SType)
                                  @ (GHC.Generics.K1
                                       GHC.Generics.R
                                       (Unbound.Generics.LocallyNameless.Embed.Embed
                                          SEDEL.Source.Syntax.SType)
                                       GHC.Types.Any)
                                  (\ (v :: Unbound.Generics.LocallyNameless.Embed.Embed
                                             SEDEL.Source.Syntax.SType) ->
                                   v)
                                    `cast`
                                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                                      SEDEL.Source.Syntax.SType>_R
                                   ->_R Sym (GHC.Generics.N:K1[0]
                                                 <*>_N
                                                 <GHC.Generics.R>_P
                                                 <Unbound.Generics.LocallyNameless.Embed.Embed
                                                    SEDEL.Source.Syntax.SType>_R
                                                 <GHC.Types.Any>_P))
                                  (Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cfvAny'
                                     @ SEDEL.Source.Syntax.SType
                                     SEDEL.Source.Syntax.$fAlphaSType
                                     @ f
                                     $dContravariant
                                     $dApplicative
                                     c
                                     nfn
                                     g2))) })))
                     `cast`
                   (<f>_R (Sym (GHC.Generics.Rep_(,)[0]
                                    <Unbound.Generics.LocallyNameless.Name.Name
                                       SEDEL.Source.Syntax.SType>_N
                                    <Unbound.Generics.LocallyNameless.Embed.Embed
                                       SEDEL.Source.Syntax.SType>_N) <GHC.Types.Any>_N))) -}
f398b13ffe94ed8d2fa52c0ada1fc709
  $s$fAlpha(,)_$s$fAlpha(,)_$cisEmbed2 ::
    (Unbound.Generics.LocallyNameless.Name.Name
       SEDEL.Source.Syntax.SType,
     Unbound.Generics.LocallyNameless.Embed.Embed
       SEDEL.Source.Syntax.SType)
    -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (ds :: (Unbound.Generics.LocallyNameless.Name.Name
                             SEDEL.Source.Syntax.SType,
                           Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Source.Syntax.SType)) ->
                 GHC.Types.False) -}
1e79426cec12c30e8b31e21ebe50eb07
  $s$fAlpha(,)_$s$fAlpha(,)_$clfreshen'2 ::
    Unbound.Generics.LocallyNameless.LFresh.LFresh m =>
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> (Unbound.Generics.LocallyNameless.Name.Name
          SEDEL.Source.Syntax.SType,
        Unbound.Generics.LocallyNameless.Embed.Embed
          SEDEL.Source.Syntax.SType)
    -> ((Unbound.Generics.LocallyNameless.Name.Name
           SEDEL.Source.Syntax.SType,
         Unbound.Generics.LocallyNameless.Embed.Embed
           SEDEL.Source.Syntax.SType)
        -> Unbound.Generics.PermM.Perm
             Unbound.Generics.LocallyNameless.Name.AnyName
        -> m b1)
    -> m b1
  {- Arity: 4,
     Strictness: <S(S(LC(C(S))LLL)LLL),1*U(1*U(A,1*C1(C1(U)),A,A,A),1*C1(C1(U)),C(C1(U)),A)><S(SL),1*U(U,A)><S,1*U(U,U)><L,C(C1(U))>,
     Inline: (sat-args=3),
     Unfolding: InlineRule (3, False, False)
                (\ @ m :: * -> *
                   @ b1
                   ($dLFresh :: Unbound.Generics.LocallyNameless.LFresh.LFresh m)
                   (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (m1 :: (Unbound.Generics.LocallyNameless.Name.Name
                             SEDEL.Source.Syntax.SType,
                           Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Source.Syntax.SType))
                   (cont :: (Unbound.Generics.LocallyNameless.Name.Name
                               SEDEL.Source.Syntax.SType,
                             Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Source.Syntax.SType)
                            -> Unbound.Generics.PermM.Perm
                                 Unbound.Generics.LocallyNameless.Name.AnyName
                            -> m b1) ->
                 case m1 of wild { (,) g1 g2 ->
                 case ctx of wild1 { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                 case ds1 of wild2 {
                   Unbound.Generics.LocallyNameless.Alpha.Term
                   -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed3 @ b1 @ m
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> Unbound.Generics.LocallyNameless.Alpha.$fAlphaName_$clfreshen'
                        @ SEDEL.Source.Syntax.SType
                        SEDEL.Source.Syntax.$fAlphaExpr_v
                        @ m
                        @ b1
                        $dLFresh
                        wild1
                        (Unbound.Generics.LocallyNameless.Alpha.$fAlphaName_$cswaps'
                           @ SEDEL.Source.Syntax.SType
                           SEDEL.Source.Syntax.$fAlphaExpr_v
                           wild1
                           (Data.Map.Internal.Tip
                              @ Unbound.Generics.LocallyNameless.Name.AnyName
                              @ Unbound.Generics.LocallyNameless.Name.AnyName)
                             `cast`
                           (Sym (Unbound.Generics.PermM.N:Perm[0]
                                     <Unbound.Generics.LocallyNameless.Name.AnyName>_N))
                           g1)
                        (\ (x1 :: Unbound.Generics.LocallyNameless.Name.Name
                                    SEDEL.Source.Syntax.SType)
                           (perm1 :: Unbound.Generics.PermM.Perm
                                       Unbound.Generics.LocallyNameless.Name.AnyName)[OneShot] ->
                         cont
                           (x1, g2)
                           (Unbound.Generics.PermM.$fMonoidPerm1
                              @ Unbound.Generics.LocallyNameless.Name.AnyName
                              Unbound.Generics.LocallyNameless.Name.$fOrdAnyName
                              perm1
                              (Data.Map.Internal.Tip
                                 @ Unbound.Generics.LocallyNameless.Name.AnyName
                                 @ Unbound.Generics.LocallyNameless.Name.AnyName)
                                `cast`
                              (Sym (Unbound.Generics.PermM.N:Perm[0]
                                        <Unbound.Generics.LocallyNameless.Name.AnyName>_N)))
                             `cast`
                           (Sym (Unbound.Generics.PermM.N:Perm[0]
                                     <Unbound.Generics.LocallyNameless.Name.AnyName>_N))) } } }) -}
cc3d376a6e41fd79b3908b3722ca0706
  $s$fAlpha(,)_$s$fAlpha(,)_$copen2 ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Alpha.NthPatFind
    -> (Unbound.Generics.LocallyNameless.Name.Name
          SEDEL.Source.Syntax.SType,
        Unbound.Generics.LocallyNameless.Embed.Embed
          SEDEL.Source.Syntax.SType)
    -> (Unbound.Generics.LocallyNameless.Name.Name
          SEDEL.Source.Syntax.SType,
        Unbound.Generics.LocallyNameless.Embed.Embed
          SEDEL.Source.Syntax.SType)
  {- Arity: 3, Strictness: <L,U(U,U)><L,U><S,1*U(1*U,1*U)>m,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (c :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (b1 :: Unbound.Generics.LocallyNameless.Alpha.NthPatFind)
                   (x :: (Unbound.Generics.LocallyNameless.Name.Name
                            SEDEL.Source.Syntax.SType,
                          Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType)) ->
                 case x of wild { (,) g1 g2 ->
                 (Unbound.Generics.LocallyNameless.Alpha.$fAlphaAnyName_$copen1
                    @ SEDEL.Source.Syntax.SType
                    SEDEL.Source.Syntax.$fAlphaExpr_v
                    c
                    b1
                    g1,
                  case c of wild1 { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                  case ds1 of wild2 {
                    Unbound.Generics.LocallyNameless.Alpha.Term
                    -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed5
                         @ SEDEL.Source.Syntax.SType
                    Unbound.Generics.LocallyNameless.Alpha.Pat
                    -> (SEDEL.Source.Syntax.$fAlphaSType_$copen
                          (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                             Unbound.Generics.LocallyNameless.Alpha.Term
                             ds2)
                          b1
                          g2
                            `cast`
                          (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                               <SEDEL.Source.Syntax.SType>_R))
                         `cast`
                       (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                 <SEDEL.Source.Syntax.SType>_R)) } }) }) -}
eeba027e02af9ef48507171a126a8578
  $s$fAlpha(,)_$s$fAlpha(,)_$cswaps'2 ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.PermM.Perm
         Unbound.Generics.LocallyNameless.Name.AnyName
    -> (Unbound.Generics.LocallyNameless.Name.Name
          SEDEL.Source.Syntax.SType,
        Unbound.Generics.LocallyNameless.Embed.Embed
          SEDEL.Source.Syntax.SType)
    -> (Unbound.Generics.LocallyNameless.Name.Name
          SEDEL.Source.Syntax.SType,
        Unbound.Generics.LocallyNameless.Embed.Embed
          SEDEL.Source.Syntax.SType)
  {- Arity: 3, Strictness: <L,U(U,U)><L,U><S,1*U(U,1*U)>m,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (perm :: Unbound.Generics.PermM.Perm
                              Unbound.Generics.LocallyNameless.Name.AnyName)
                   (x :: (Unbound.Generics.LocallyNameless.Name.Name
                            SEDEL.Source.Syntax.SType,
                          Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType)) ->
                 case x of wild { (,) g1 g2 ->
                 (Unbound.Generics.LocallyNameless.Alpha.$fAlphaName_$cswaps'
                    @ SEDEL.Source.Syntax.SType
                    SEDEL.Source.Syntax.$fAlphaExpr_v
                    ctx
                    perm
                    g1,
                  case ctx of wild1 { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                  case ds1 of wild2 {
                    Unbound.Generics.LocallyNameless.Alpha.Term -> g2
                    Unbound.Generics.LocallyNameless.Alpha.Pat
                    -> (SEDEL.Source.Syntax.$fAlphaExpr_$cswaps'
                          (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                             Unbound.Generics.LocallyNameless.Alpha.Term
                             ds2)
                          perm
                          g2
                            `cast`
                          (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                               <SEDEL.Source.Syntax.SType>_R))
                         `cast`
                       (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                 <SEDEL.Source.Syntax.SType>_R)) } }) }) -}
cfa5b4c37b88bc1037f593de0eab69a2
  $s$fAlpha(,)_$s$fAlphaEmbed ::
    Unbound.Generics.LocallyNameless.Alpha.Alpha
      (Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType)
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Embed.Embed
                       SEDEL.Source.Syntax.SType)
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fShowEmbed
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType)
                     (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Source.Syntax.SType) ->
                   SEDEL.Source.Syntax.$fAlphaSType_$caeq'
                     (case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                      Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                        Unbound.Generics.LocallyNameless.Alpha.Term
                        ds3 })
                     ds
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Source.Syntax.SType>_R)
                     ds1
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Source.Syntax.SType>_R))
                  (Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cfvAny'
                     @ SEDEL.Source.Syntax.SType
                     SEDEL.Source.Syntax.$fAlphaSType)
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (b :: Unbound.Generics.LocallyNameless.Alpha.NamePatFind)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed6
                          @ SEDEL.Source.Syntax.SType
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> (SEDEL.Source.Syntax.$fAlphaSType_$cclose
                           (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                              Unbound.Generics.LocallyNameless.Alpha.Term
                              ds2)
                           b
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R))
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <SEDEL.Source.Syntax.SType>_R)) } })
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (b :: Unbound.Generics.LocallyNameless.Alpha.NthPatFind)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed5
                          @ SEDEL.Source.Syntax.SType
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> (SEDEL.Source.Syntax.$fAlphaSType_$copen
                           (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                              Unbound.Generics.LocallyNameless.Alpha.Term
                              ds2)
                           b
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R))
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <SEDEL.Source.Syntax.SType>_R)) } })
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   case (SEDEL.Source.Syntax.$fAlphaSType_$cisTerm
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R))
                          `cast`
                        (Data.Semigroup.Internal.N:All[0]) of wild {
                     GHC.Types.False
                     -> (GHC.Maybe.Nothing
                           @ [Unbound.Generics.LocallyNameless.Name.AnyName])
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                  <Unbound.Generics.LocallyNameless.Name.AnyName>_R))
                     GHC.Types.True
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed4
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                  <Unbound.Generics.LocallyNameless.Name.AnyName>_R)) })
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   GHC.Types.False)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      SEDEL.Source.Syntax.SType>_R
                   ->_R Sym (Data.Semigroup.Internal.N:All[0]))
                  SEDEL.Source.Syntax.$fAlphaSType_$cisTerm
                    `cast`
                  (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                            <SEDEL.Source.Syntax.SType>_R)
                   ->_R Data.Semigroup.Internal.N:All[0])
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   Data.Either.Left
                     @ GHC.Integer.Type.Integer
                     @ Unbound.Generics.LocallyNameless.Name.AnyName)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      SEDEL.Source.Syntax.SType>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Alpha.N:NthPatFind[0]))
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   Unbound.Generics.LocallyNameless.Alpha.$fAlpha()2)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      SEDEL.Source.Syntax.SType>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Alpha.N:NamePatFind[0]))
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (perm :: Unbound.Generics.PermM.Perm
                                Unbound.Generics.LocallyNameless.Name.AnyName)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term -> ds
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> (SEDEL.Source.Syntax.$fAlphaExpr_$cswaps'
                           (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                              Unbound.Generics.LocallyNameless.Alpha.Term
                              ds2)
                           perm
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R))
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <SEDEL.Source.Syntax.SType>_R)) } })
                  (\ @ m :: * -> *
                     @ b
                     ($dLFresh :: Unbound.Generics.LocallyNameless.LFresh.LFresh m) ->
                   Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed2
                     @ b
                     @ m
                     @ SEDEL.Source.Syntax.SType)
                  (\ @ m :: * -> *
                     ($dFresh :: Unbound.Generics.LocallyNameless.Fresh.Fresh m)
                     (eta2 :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (eta3 :: Unbound.Generics.LocallyNameless.Embed.Embed
                                SEDEL.Source.Syntax.SType) ->
                   case eta2 of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed1
                          @ SEDEL.Source.Syntax.SType
                          @ m
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> GHC.Base.return
                          @ m
                          (Unbound.Generics.LocallyNameless.Fresh.$p1Fresh @ m $dFresh)
                          @ (Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Source.Syntax.SType,
                             Unbound.Generics.PermM.Perm
                               Unbound.Generics.LocallyNameless.Name.AnyName)
                          (eta3,
                           (Data.Map.Internal.Tip
                              @ Unbound.Generics.LocallyNameless.Name.AnyName
                              @ Unbound.Generics.LocallyNameless.Name.AnyName)
                             `cast`
                           (Sym (Unbound.Generics.PermM.N:Perm[0]
                                     <Unbound.Generics.LocallyNameless.Name.AnyName>_N))) } })
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType)
                     (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Source.Syntax.SType) ->
                   SEDEL.Source.Syntax.$fAlphaSType_$cacompare'
                     (case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                      Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                        Unbound.Generics.LocallyNameless.Alpha.Term
                        ds3 })
                     ds
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Source.Syntax.SType>_R)
                     ds1
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Source.Syntax.SType>_R)) -}
9ebb33b4b304a6f035de7ca36804a798
  $s$fAlpha(,)_$s$fShow(,)2 ::
    GHC.Show.Show
      (Unbound.Generics.LocallyNameless.Name.Name
         SEDEL.Source.Syntax.SType,
       Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Name.Name
                       SEDEL.Source.Syntax.SType,
                     Unbound.Generics.LocallyNameless.Embed.Embed
                       SEDEL.Source.Syntax.SType)
                  (GHC.Show.$fShow(,)_$cshowsPrec
                     @ (Unbound.Generics.LocallyNameless.Name.Name
                          SEDEL.Source.Syntax.SType)
                     @ (Unbound.Generics.LocallyNameless.Embed.Embed
                          SEDEL.Source.Syntax.SType)
                     (Unbound.Generics.LocallyNameless.Name.$fShowName
                        @ SEDEL.Source.Syntax.SType)
                     SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fShowEmbed)
                  (\ (x :: (Unbound.Generics.LocallyNameless.Name.Name
                              SEDEL.Source.Syntax.SType,
                            Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType)) ->
                   GHC.Show.$fShow(,)_$cshowsPrec
                     @ (Unbound.Generics.LocallyNameless.Name.Name
                          SEDEL.Source.Syntax.SType)
                     @ (Unbound.Generics.LocallyNameless.Embed.Embed
                          SEDEL.Source.Syntax.SType)
                     (Unbound.Generics.LocallyNameless.Name.$fShowName
                        @ SEDEL.Source.Syntax.SType)
                     SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fShowEmbed
                     GHC.Show.$fShow(,)1
                     x
                     (GHC.Types.[] @ GHC.Types.Char))
                  (\ (ls :: [(Unbound.Generics.LocallyNameless.Name.Name
                                SEDEL.Source.Syntax.SType,
                              Unbound.Generics.LocallyNameless.Embed.Embed
                                SEDEL.Source.Syntax.SType)])
                     (s :: GHC.Base.String) ->
                   GHC.Show.showList__
                     @ (Unbound.Generics.LocallyNameless.Name.Name
                          SEDEL.Source.Syntax.SType,
                        Unbound.Generics.LocallyNameless.Embed.Embed
                          SEDEL.Source.Syntax.SType)
                     (GHC.Show.$fShow(,)_$cshowsPrec
                        @ (Unbound.Generics.LocallyNameless.Name.Name
                             SEDEL.Source.Syntax.SType)
                        @ (Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Source.Syntax.SType)
                        (Unbound.Generics.LocallyNameless.Name.$fShowName
                           @ SEDEL.Source.Syntax.SType)
                        SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fShowEmbed
                        GHC.Show.$fShow(,)1)
                     ls
                     s) -}
62e02510b331755eb1935330067193c3
  $s$fAlpha(,)_$s$fShowEmbed ::
    GHC.Show.Show
      (Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Embed.Embed
                       SEDEL.Source.Syntax.SType)
                  (Unbound.Generics.LocallyNameless.Embed.$fShowEmbed_$cshowsPrec
                     @ SEDEL.Source.Syntax.SType
                     SEDEL.Source.Syntax.$fShowSType)
                  (\ (x :: Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Source.Syntax.SType) ->
                   GHC.CString.unpackAppendCString#
                     Unbound.Generics.LocallyNameless.Embed.$fShowEmbed3
                     (SEDEL.Source.Syntax.$fShowSType_$cshowsPrec
                        Unbound.Generics.LocallyNameless.Embed.$fShowEmbed2
                        x `cast`
                        (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                             <SEDEL.Source.Syntax.SType>_R)
                        Unbound.Generics.LocallyNameless.Embed.$fShowEmbed4))
                  (Unbound.Generics.LocallyNameless.Embed.$fShowEmbed_$cshowList
                     @ SEDEL.Source.Syntax.SType
                     SEDEL.Source.Syntax.$fShowSType) -}
a2f98ec444f362d4e9fa00d084da19a1
  $s$fAlphaEmbed_$cacompare' ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
    -> GHC.Types.Ordering
  {- Arity: 3, Strictness: <L,1*U(A,U)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType)
                   (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Source.Syntax.SType) ->
                 SEDEL.Source.Syntax.$fAlphaSType_$cacompare'
                   (case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                      Unbound.Generics.LocallyNameless.Alpha.Term
                      ds3 })
                   ds
                     `cast`
                   (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                        <SEDEL.Source.Syntax.SType>_R)
                   ds1
                     `cast`
                   (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                        <SEDEL.Source.Syntax.SType>_R)) -}
d7a342ac416d9e517babbc506ece0c68
  $s$fAlphaEmbed_$caeq' ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
    -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,1*U(A,U)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType)
                   (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Source.Syntax.SType) ->
                 SEDEL.Source.Syntax.$fAlphaSType_$caeq'
                   (case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                      Unbound.Generics.LocallyNameless.Alpha.Term
                      ds3 })
                   ds
                     `cast`
                   (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                        <SEDEL.Source.Syntax.SType>_R)
                   ds1
                     `cast`
                   (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                        <SEDEL.Source.Syntax.SType>_R)) -}
4daf35a77936e6f6368ff297d9a149e2
  $s$fAlphaEmbed_$cclose ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Alpha.NamePatFind
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
  {- Arity: 3, Strictness: <S(SS),1*U(U,U)><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (b :: Unbound.Generics.LocallyNameless.Alpha.NamePatFind)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType) ->
                 case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                 case ds1 of wild1 {
                   Unbound.Generics.LocallyNameless.Alpha.Term
                   -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed6
                        @ SEDEL.Source.Syntax.SType
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> (SEDEL.Source.Syntax.$fAlphaSType_$cclose
                         (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                            Unbound.Generics.LocallyNameless.Alpha.Term
                            ds2)
                         b
                         ds
                           `cast`
                         (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                              <SEDEL.Source.Syntax.SType>_R))
                        `cast`
                      (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R)) } }) -}
ca10b98ab43ea212e1adb5cf0f781999
  $s$fAlphaEmbed_$cfreshen' ::
    Unbound.Generics.LocallyNameless.Fresh.Fresh m =>
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
    -> m (Unbound.Generics.LocallyNameless.Embed.Embed
            SEDEL.Source.Syntax.SType,
          Unbound.Generics.PermM.Perm
            Unbound.Generics.LocallyNameless.Name.AnyName)
  {- Arity: 3,
     Strictness: <S(S(LLLC(S)L)L),1*U(1*U(A,A,A,1*C1(U),A),A)><S(SL),1*U(U,A)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   ($dFresh :: Unbound.Generics.LocallyNameless.Fresh.Fresh m)
                   (eta2 :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (eta3 :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                 case eta2 of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                 case ds1 of wild1 {
                   Unbound.Generics.LocallyNameless.Alpha.Term
                   -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed1
                        @ SEDEL.Source.Syntax.SType
                        @ m
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> GHC.Base.return
                        @ m
                        (Unbound.Generics.LocallyNameless.Fresh.$p1Fresh @ m $dFresh)
                        @ (Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Source.Syntax.SType,
                           Unbound.Generics.PermM.Perm
                             Unbound.Generics.LocallyNameless.Name.AnyName)
                        (eta3,
                         (Data.Map.Internal.Tip
                            @ Unbound.Generics.LocallyNameless.Name.AnyName
                            @ Unbound.Generics.LocallyNameless.Name.AnyName)
                           `cast`
                         (Sym (Unbound.Generics.PermM.N:Perm[0]
                                   <Unbound.Generics.LocallyNameless.Name.AnyName>_N))) } }) -}
16d62f0e0286729331a758fc0ea3e1cf
  $s$fAlphaEmbed_$cisPat ::
    Unbound.Generics.LocallyNameless.Embed.Embed
      SEDEL.Source.Syntax.SType
    -> Unbound.Generics.LocallyNameless.Alpha.DisjointSet
         Unbound.Generics.LocallyNameless.Name.AnyName
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType) ->
                 case (SEDEL.Source.Syntax.$fAlphaSType_$cisTerm
                         ds
                           `cast`
                         (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                              <SEDEL.Source.Syntax.SType>_R))
                        `cast`
                      (Data.Semigroup.Internal.N:All[0]) of wild {
                   GHC.Types.False
                   -> (GHC.Maybe.Nothing
                         @ [Unbound.Generics.LocallyNameless.Name.AnyName])
                        `cast`
                      (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                <Unbound.Generics.LocallyNameless.Name.AnyName>_R))
                   GHC.Types.True
                   -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed4
                        `cast`
                      (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                <Unbound.Generics.LocallyNameless.Name.AnyName>_R)) }) -}
bd4d2166ce0714065ce28de99a010806
  $s$fAlphaEmbed_$copen ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Alpha.NthPatFind
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
  {- Arity: 3, Strictness: <S(SS),1*U(U,U)><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (b :: Unbound.Generics.LocallyNameless.Alpha.NthPatFind)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType) ->
                 case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                 case ds1 of wild1 {
                   Unbound.Generics.LocallyNameless.Alpha.Term
                   -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed5
                        @ SEDEL.Source.Syntax.SType
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> (SEDEL.Source.Syntax.$fAlphaSType_$copen
                         (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                            Unbound.Generics.LocallyNameless.Alpha.Term
                            ds2)
                         b
                         ds
                           `cast`
                         (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                              <SEDEL.Source.Syntax.SType>_R))
                        `cast`
                      (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R)) } }) -}
1eab262c2febb1023c34c50a4747face
  $s$fAlphaEmbed_$cswaps' ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.PermM.Perm
         Unbound.Generics.LocallyNameless.Name.AnyName
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
  {- Arity: 3, Strictness: <S(SS),1*U(U,U)><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (perm :: Unbound.Generics.PermM.Perm
                              Unbound.Generics.LocallyNameless.Name.AnyName)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType) ->
                 case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                 case ds1 of wild1 {
                   Unbound.Generics.LocallyNameless.Alpha.Term -> ds
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> (SEDEL.Source.Syntax.$fAlphaExpr_$cswaps'
                         (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                            Unbound.Generics.LocallyNameless.Alpha.Term
                            ds2)
                         perm
                         ds
                           `cast`
                         (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                              <SEDEL.Source.Syntax.SType>_R))
                        `cast`
                      (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R)) } }) -}
5c602786600d9a69e7f8f962a40c4ce2
  $s$fApplicativeExceptT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
                  (SEDEL.Source.TypeCheck.$s$fApplicativeExceptT_$s$fFunctorExceptT
                     @ e)
                  (SEDEL.Source.TypeCheck.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure
                     @ e)
                  (Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                     @ GHC.Types.IO
                     @ e
                     GHC.Base.$fFunctorIO
                     GHC.Base.$fMonadIO)
                  (\ @ a
                     @ b
                     @ c
                     (f1 :: a -> b -> c)
                     (x :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a) ->
                   Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                     @ GHC.Types.IO
                     @ e
                     GHC.Base.$fFunctorIO
                     GHC.Base.$fMonadIO
                     @ b
                     @ c
                     (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                      case x `cast`
                           (Control.Monad.Trans.Except.N:ExceptT[0]
                                <e>_N <GHC.Types.IO>_R <a>_N ; GHC.Types.N:IO[0]
                                                                   <Data.Either.Either e a>_R)
                             s of ds { (#,#) ipv ipv1 ->
                      (# ipv,
                         Data.Either.$fApplicativeEither_$cfmap
                           @ e
                           @ a
                           @ (b -> c)
                           f1
                           ipv1 #) })
                       `cast`
                     (Sym (GHC.Types.N:IO[0]
                               <Data.Either.Either
                                  e (b -> c)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                            <e>_N <GHC.Types.IO>_R <b -> c>_N)))
                  (SEDEL.Source.TypeCheck.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$c*>
                     @ e)
                  (\ @ a
                     @ b
                     (x :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a) ->
                   Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                     @ GHC.Types.IO
                     @ e
                     GHC.Base.$fFunctorIO
                     GHC.Base.$fMonadIO
                     @ b
                     @ a
                     (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                      case x `cast`
                           (Control.Monad.Trans.Except.N:ExceptT[0]
                                <e>_N <GHC.Types.IO>_R <a>_N ; GHC.Types.N:IO[0]
                                                                   <Data.Either.Either e a>_R)
                             s of ds { (#,#) ipv ipv1 ->
                      (# ipv,
                         Control.Monad.Trans.Except.$fApplicativeExceptT1
                           @ e
                           @ b
                           @ a
                           ipv1 #) })
                       `cast`
                     (Sym (GHC.Types.N:IO[0]
                               <Data.Either.Either
                                  e (b -> a)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                            <e>_N <GHC.Types.IO>_R <b -> a>_N))) -}
1e6cfb54f6e973251e77855945782745
  $s$fApplicativeExceptT_$c<*>1 ::
    Control.Monad.Trans.Except.ExceptT e GHC.Types.IO (a -> b)
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Either.Either e b #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S(SS)),1*C1(U(U,1*U))><L,1*C1(U(U,1*U))><S,U>,
     Unfolding: (\ @ e
                   @ a
                   @ b
                   (w10 :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO (a -> b))
                   (w11 :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w10
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <GHC.Types.IO>_R <a -> b>_N ; GHC.Types.N:IO[0]
                                                                   <Data.Either.Either
                                                                      e (a -> b)>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   Data.Either.Left e1 -> (# ipv, Data.Either.Left @ e @ b e1 #)
                   Data.Either.Right k
                   -> case w11
                             `cast`
                           (Control.Monad.Trans.Except.N:ExceptT[0]
                                <e>_N <GHC.Types.IO>_R <a>_N ; GHC.Types.N:IO[0]
                                                                   <Data.Either.Either e a>_R)
                             ipv of ds2 { (#,#) ipv2 ipv3 ->
                      case ipv3 of wild1 {
                        Data.Either.Left e1 -> (# ipv2, Data.Either.Left @ e @ b e1 #)
                        Data.Either.Right x
                        -> (# ipv2, Data.Either.Right @ e @ b (k x) #) } } } }) -}
18f063b4178785684ff90ece20994b1c
  $s$fApplicativeExceptT_$s$fApplicativeExceptT_$c*> ::
    Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S(SS)),1*C1(U(U,1*U))><L,1*C1(U(U,U))><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a)
                   (k :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case m1
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <GHC.Types.IO>_R <a>_N ; GHC.Types.N:IO[0]
                                                              <Data.Either.Either e a>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   Data.Either.Left e1 -> (# ipv, Data.Either.Left @ e @ b e1 #)
                   Data.Either.Right x
                   -> k `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <GHC.Types.IO>_R <b>_N ; GHC.Types.N:IO[0]
                                                              <Data.Either.Either e b>_R)
                        ipv } })
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a>_R
                 ->_R <Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <Data.Either.Either
                                  e b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                     <e>_N <GHC.Types.IO>_R <b>_N)) -}
b191875b9aa100eb5f3d8344bd1ee076
  $s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure ::
    a -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ e @ a (a1 :: a) (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 (# s, Data.Either.Right @ e @ a a1 #))
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N).
                 <a>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <Data.Either.Either
                                  e a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                     <e>_N <GHC.Types.IO>_R <a>_N)) -}
7ee4ddc5bacdd4006c42db6ef16df010
  $s$fApplicativeExceptT_$s$fFunctorExceptT ::
    GHC.Base.Functor
      (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
                  (Control.Monad.Trans.Except.$fFunctorExceptT_$cfmap
                     @ GHC.Types.IO
                     @ e
                     GHC.Base.$fFunctorIO)
                  (Control.Monad.Trans.Except.$fFunctorExceptT_$c<$
                     @ GHC.Types.IO
                     @ e
                     GHC.Base.$fFunctorIO) -}
26cde5248f2b575d04440a33ff806a35
  $s$fFreshFreshMT ::
    Unbound.Generics.LocallyNameless.Fresh.Fresh
      (Unbound.Generics.LocallyNameless.Fresh.FreshMT
         (Control.Monad.Trans.Reader.ReaderT
            SEDEL.Environment.Ctx
            (Control.Monad.Trans.Except.ExceptT
               SEDEL.Environment.Err GHC.Types.IO)))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Fresh.FreshMT
                       (Control.Monad.Trans.Reader.ReaderT
                          SEDEL.Environment.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             SEDEL.Environment.Err GHC.Types.IO)))
                  (Unbound.Generics.LocallyNameless.Fresh.$fMonadFreshMT
                     @ (Control.Monad.Trans.Reader.ReaderT
                          SEDEL.Environment.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             SEDEL.Environment.Err GHC.Types.IO))
                     (SEDEL.Source.TypeCheck.$s$fFreshFreshMT_$s$fMonadReaderT
                        @ SEDEL.Environment.Ctx))
                  (Unbound.Generics.LocallyNameless.Fresh.$fFreshFreshMT1
                     @ (Control.Monad.Trans.Reader.ReaderT
                          SEDEL.Environment.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             SEDEL.Environment.Err GHC.Types.IO))
                     (SEDEL.Source.TypeCheck.$s$fFreshFreshMT_$s$fMonadReaderT
                        @ SEDEL.Environment.Ctx))
                    `cast`
                  (forall (a :: <*>_N).
                   <Unbound.Generics.LocallyNameless.Name.Name a>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Reader.ReaderT
                                    SEDEL.Environment.Ctx
                                    (Control.Monad.Trans.Except.ExceptT
                                       SEDEL.Environment.Err GHC.Types.IO)>_R
                                 <Unbound.Generics.LocallyNameless.Name.Name
                                    a>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                         SEDEL.Environment.Ctx
                                                                                                         (Control.Monad.Trans.Except.ExceptT
                                                                                                            SEDEL.Environment.Err
                                                                                                            GHC.Types.IO)>_N <Unbound.Generics.LocallyNameless.Name.Name
                                                                                                                                a>_N) -}
93562112ac57db52aafe76edd0f5e7fa
  $s$fFreshFreshMT_$s$fMonadExceptT ::
    GHC.Base.Monad (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
                  (SEDEL.Source.TypeCheck.$s$fApplicativeExceptT @ e)
                  (SEDEL.Source.TypeCheck.$s$fFreshFreshMT_$s$fMonadExceptT_$c>>=
                     @ e)
                  (SEDEL.Source.TypeCheck.$s$fFreshFreshMT_$s$fMonadExceptT_$c>> @ e)
                  (\ @ a (eta2 :: a) (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   (# s, Data.Either.Right @ e @ a eta2 #))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <Data.Either.Either
                                    e a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                       <e>_N <GHC.Types.IO>_R <a>_N))
                  (\ @ a (x :: GHC.Base.String) ->
                   GHC.Magic.noinline
                     @ (forall a1. [GHC.Types.Char] -> GHC.Types.IO a1)
                     GHC.IO.failIO1
                       `cast`
                     (forall (a1 :: <*>_N).
                      <GHC.Base.String>_R ->_R Sym (GHC.Types.N:IO[0] <a1>_R))
                     @ (Data.Either.Either e a)
                     x)
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Base.String>_R
                   ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                 <e>_N <GHC.Types.IO>_R <a>_N)) -}
24e5d4bfecde447a10cb63682b60f478
  $s$fFreshFreshMT_$s$fMonadExceptT_$c>> ::
    Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S(SS)),1*C1(U(U,1*U))><L,1*C1(U(U,U))><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a)
                   (k :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case m1
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <GHC.Types.IO>_R <a>_N ; GHC.Types.N:IO[0]
                                                              <Data.Either.Either e a>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   Data.Either.Left e1 -> (# ipv, Data.Either.Left @ e @ b e1 #)
                   Data.Either.Right x
                   -> k `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <GHC.Types.IO>_R <b>_N ; GHC.Types.N:IO[0]
                                                              <Data.Either.Either e b>_R)
                        ipv } })
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a>_R
                 ->_R <Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <Data.Either.Either
                                  e b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                     <e>_N <GHC.Types.IO>_R <b>_N)) -}
0b4e209a2288c101e0fbb1039997bd26
  $s$fFreshFreshMT_$s$fMonadExceptT_$c>>= ::
    Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a
    -> (a -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b)
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S(SS)),1*C1(U(U,1*U))><L,1*C1(C1(U(U,U)))><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a)
                   (k :: a -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case m1
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <GHC.Types.IO>_R <a>_N ; GHC.Types.N:IO[0]
                                                              <Data.Either.Either e a>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   Data.Either.Left e1 -> (# ipv, Data.Either.Left @ e @ b e1 #)
                   Data.Either.Right x
                   -> (k x)
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <GHC.Types.IO>_R <b>_N ; GHC.Types.N:IO[0]
                                                              <Data.Either.Either e b>_R)
                        ipv } })
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a>_R
                 ->_R <a -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <Data.Either.Either
                                  e b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                     <e>_N <GHC.Types.IO>_R <b>_N)) -}
6420a41e042aa9d89052cf6932aeab45
  $s$fFreshFreshMT_$s$fMonadReaderT ::
    GHC.Base.Monad
      (Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ r.
                  @ (Control.Monad.Trans.Reader.ReaderT
                       r
                       (Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO))
                  (Control.Monad.Trans.Reader.$fApplicativeReaderT
                     @ (Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO)
                     @ r
                     (SEDEL.Source.TypeCheck.$s$fApplicativeExceptT
                        @ SEDEL.Environment.Err))
                  (Control.Monad.Trans.Reader.$fMonadReaderT_$c>>=
                     @ (Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO)
                     @ r
                     (SEDEL.Source.TypeCheck.$s$fFreshFreshMT_$s$fMonadExceptT
                        @ SEDEL.Environment.Err))
                  (\ @ a @ b ->
                   Control.Monad.Trans.Reader.$fApplicativeReaderT_$c*>
                     @ (Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO)
                     @ r
                     (SEDEL.Source.TypeCheck.$s$fApplicativeExceptT
                        @ SEDEL.Environment.Err)
                     @ a
                     @ b)
                  (\ @ a (eta2 :: a) ->
                   let {
                     m1 :: GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                 Data.Either.Either SEDEL.Environment.Err a #)
                       {- Arity: 1 -}
                     = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                       (# s, Data.Either.Right @ SEDEL.Environment.Err @ a eta2 #)
                   } in
                   (\ (ds :: r) -> m1)
                     `cast`
                   ((<r>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <Data.Either.Either
                                      SEDEL.Environment.Err
                                      a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                       <SEDEL.Environment.Err>_N
                                                       <GHC.Types.IO>_R
                                                       <a>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                          <*>_N
                                                                          <r>_R
                                                                          <Control.Monad.Trans.Except.ExceptT
                                                                             SEDEL.Environment.Err
                                                                             GHC.Types.IO>_R
                                                                          <a>_N)))
                  (Control.Monad.Trans.Reader.$fMonadReaderT_$cfail
                     @ (Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO)
                     @ r
                     (SEDEL.Source.TypeCheck.$s$fFreshFreshMT_$s$fMonadExceptT
                        @ SEDEL.Environment.Err)) -}
b134603ce17a3b95359e282eaf8dfb80
  $sfromList ::
    [(SEDEL.Source.Syntax.Label, a)]
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: [(SEDEL.Source.Syntax.Label, a)]) ->
                 case ds of wild {
                   [] -> Data.Map.Internal.Tip @ SEDEL.Source.Syntax.Label @ a
                   : ds1 ds2
                   -> case ds1 of wild1 { (,) kx x ->
                      case ds2 of wild2 {
                        []
                        -> case kx of dt { DEFAULT ->
                           Data.Map.Internal.Bin
                             @ SEDEL.Source.Syntax.Label
                             @ a
                             1#
                             dt
                             x
                             (Data.Map.Internal.Tip @ SEDEL.Source.Syntax.Label @ a)
                             (Data.Map.Internal.Tip @ SEDEL.Source.Syntax.Label @ a) }
                        : ipv ipv1
                        -> case ipv of wild3 { (,) ky ds3 ->
                           case GHC.Classes.$fOrd[]_$s$ccompare1 kx ky of wild4 {
                             DEFAULT
                             -> case kx of dt { DEFAULT ->
                                SEDEL.Source.TypeCheck.$sfromList1
                                  @ a
                                  wild2
                                  (Data.Map.Internal.Bin
                                     @ SEDEL.Source.Syntax.Label
                                     @ a
                                     1#
                                     dt
                                     x
                                     (Data.Map.Internal.Tip @ SEDEL.Source.Syntax.Label @ a)
                                     (Data.Map.Internal.Tip @ SEDEL.Source.Syntax.Label @ a)) }
                             GHC.Types.LT
                             -> case kx of dt { DEFAULT ->
                                SEDEL.Source.TypeCheck.$wpoly_go13
                                  @ a
                                  1#
                                  (Data.Map.Internal.Bin
                                     @ SEDEL.Source.Syntax.Label
                                     @ a
                                     1#
                                     dt
                                     x
                                     (Data.Map.Internal.Tip @ SEDEL.Source.Syntax.Label @ a)
                                     (Data.Map.Internal.Tip @ SEDEL.Source.Syntax.Label @ a))
                                  wild2 } } } } } }) -}
0a7159b7607a0818ffd1a9cec5399aae
  $sfromList1 ::
    [(SEDEL.Source.Syntax.Label, a)]
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
6a08b14beebe37e0186591142e29379a
  $sinsertWithR_$sgo13 ::
    (a1 -> a1 -> a1)
    -> SEDEL.Source.Syntax.Label
    -> a1
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a1
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a1
  {- Arity: 4, Strictness: <L,1*C1(C1(U))><S,1*U><L,U><S,1*U> -}
8a21cef97404ee0382b427fe12e2dbe7
  $sinsertWith_$sgo13 ::
    (a1 -> a1 -> a1)
    -> SEDEL.Source.Syntax.Label
    -> a1
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a1
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a1
  {- Arity: 4, Strictness: <L,1*C1(C1(U))><S,1*U><L,U><S,1*U> -}
b085372b210f7bc7a522eff9b76139bc
  $sinsert_$sgo13 ::
    SEDEL.Source.Syntax.Label
    -> SEDEL.Source.Syntax.Label
    -> a1
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a1
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a1
  {- Arity: 4, Strictness: <L,U><S,1*U><L,U><S,1*U> -}
cdea2ff16f44742bad332d031a6abda1
  $slookup1 ::
    SEDEL.Source.Syntax.Label
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a
    -> GHC.Maybe.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
f0a7c966b7ccb37b280a57c658cad3da
  $sunionWith ::
    (a -> a -> a)
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a
  {- Arity: 3, Strictness: <L,C(C1(U))><S,1*U><S,1*U>, Inline: [~] -}
a73f80469c4d0426f587212e0c200fb8
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   SEDEL.Source.TypeCheck.$trModule3
                   SEDEL.Source.TypeCheck.$trModule1) -}
152fb2594c588a77ecb6042d5f26abe4
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.TypeCheck.$trModule2) -}
3f7a1413da2354ffba7fba5b2ebce3fe
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SEDEL.Source.TypeCheck"#) -}
53aa63604380d4115b48b0e914de831b
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.TypeCheck.$trModule4) -}
fa80b62660bcf67e109843b6360c02f3
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("sedel-0.1.0.0-AhY9khA6pZOExbzZW5SwDc"#) -}
f27a4f7cb22eba96593032a23655d199
  $w$sgo13 ::
    SEDEL.Source.Syntax.Label
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a1
    -> (# Data.Map.Internal.Map SEDEL.Source.Syntax.Label a1,
          GHC.Maybe.Maybe a1,
          Data.Map.Internal.Map SEDEL.Source.Syntax.Label a1 #)
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [2] -}
1c995ae784c6deda55c39e5b58d67ad1
  $wpoly_go13 ::
    GHC.Prim.Int#
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a
    -> [(SEDEL.Source.Syntax.Label, a)]
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U>, Inline: [2] -}
654ec9dd006a7fe9d39be3eab5ef4c9c
  tcModule ::
    SEDEL.Source.Syntax.Module
    -> SEDEL.Environment.TcMonad
         (SEDEL.Source.Syntax.SType, SEDEL.Target.Syntax.UExpr)
  {- Arity: 1, Strictness: <L,1*U(1*U,1*U)>,
     Unfolding: (\ (m :: SEDEL.Source.Syntax.Module) ->
                 let {
                   m1 :: SEDEL.Environment.TcMonad
                           (SEDEL.Source.Syntax.SType, SEDEL.Target.Syntax.UExpr)
                   = case m of wild { SEDEL.Source.Syntax.Module ds1 ds2 ->
                     SEDEL.Source.TypeCheck.tcModule_tcM
                       (GHC.Base.map
                          @ SEDEL.Source.Syntax.SDecl
                          @ SEDEL.Source.Syntax.SDecl
                          SEDEL.Source.Desugar.desugar1
                          ds1)
                       (case ds2 of wild1 {
                          SEDEL.Source.Syntax.DefDecl mainE
                          -> case mainE of wild2 { SEDEL.Source.Syntax.TmBind ds ds4 ds5 ds3 ds6 ds7 ->
                             SEDEL.Source.Syntax.TmBind
                               ds
                               ds4
                               ds5
                               (SEDEL.Source.Desugar.desugarTmBind1 ds3)
                                 `cast`
                               (Data.Functor.Identity.N:Identity[0] <SEDEL.Source.Syntax.Expr>_R)
                               ds6
                               ds7 }
                          SEDEL.Source.Syntax.TypeDecl ipv
                          -> case SEDEL.Source.TypeCheck.tcModule1
                             ret_ty SEDEL.Source.Syntax.TmBind
                             of {} }) }
                 } in
                 (\ (s1 :: GHC.Integer.Type.Integer) ->
                  let {
                    m2 :: Control.Monad.Trans.Reader.ReaderT
                            SEDEL.Environment.Ctx
                            (Control.Monad.Trans.Except.ExceptT
                               SEDEL.Environment.Err GHC.Types.IO)
                            ((SEDEL.Source.Syntax.SType, SEDEL.Target.Syntax.UExpr),
                             GHC.Integer.Type.Integer)
                    = m1
                        `cast`
                      (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0] <Control.Monad.Trans.Reader.ReaderT
                                                                              SEDEL.Environment.Ctx
                                                                              (Control.Monad.Trans.Except.ExceptT
                                                                                 SEDEL.Environment.Err
                                                                                 GHC.Types.IO)>_N <(SEDEL.Source.Syntax.SType,
                                                                                                    SEDEL.Target.Syntax.UExpr)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                        <GHC.Integer.Type.Integer>_N
                                                                                                                                        <Control.Monad.Trans.Reader.ReaderT
                                                                                                                                           SEDEL.Environment.Ctx
                                                                                                                                           (Control.Monad.Trans.Except.ExceptT
                                                                                                                                              SEDEL.Environment.Err
                                                                                                                                              GHC.Types.IO)>_R
                                                                                                                                        <(SEDEL.Source.Syntax.SType,
                                                                                                                                          SEDEL.Target.Syntax.UExpr)>_N)
                        s1
                  } in
                  (\ (r1 :: SEDEL.Environment.Ctx)
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (m2
                           `cast`
                         (Control.Monad.Trans.Reader.N:ReaderT[0]
                              <*>_N
                              <SEDEL.Environment.Ctx>_R
                              <Control.Monad.Trans.Except.ExceptT
                                 SEDEL.Environment.Err GHC.Types.IO>_R
                              <((SEDEL.Source.Syntax.SType, SEDEL.Target.Syntax.UExpr),
                                GHC.Integer.Type.Integer)>_N)
                           r1)
                          `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <SEDEL.Environment.Err>_N
                             <GHC.Types.IO>_R
                             <((SEDEL.Source.Syntax.SType, SEDEL.Target.Syntax.UExpr),
                               GHC.Integer.Type.Integer)>_N ; GHC.Types.N:IO[0]
                                                                  <Data.Either.Either
                                                                     SEDEL.Environment.Err
                                                                     ((SEDEL.Source.Syntax.SType,
                                                                       SEDEL.Target.Syntax.UExpr),
                                                                      GHC.Integer.Type.Integer)>_R)
                          s of ds1 { (#,#) ipv ipv1 ->
                   case ipv1 of wild {
                     Data.Either.Left e1 -> ds1
                     Data.Either.Right x
                     -> case x of wild1 { (,) a1 s' ->
                        case a1 of wild2 { (,) ty target -> ds1 } } } })
                    `cast`
                  ((<SEDEL.Environment.Ctx>_R
                    ->_R Sym (GHC.Types.N:IO[0]
                                  <Data.Either.Either
                                     SEDEL.Environment.Err
                                     ((SEDEL.Source.Syntax.SType, SEDEL.Target.Syntax.UExpr),
                                      GHC.Integer.Type.Integer)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                               <SEDEL.Environment.Err>_N
                                                                               <GHC.Types.IO>_R
                                                                               <((SEDEL.Source.Syntax.SType,
                                                                                  SEDEL.Target.Syntax.UExpr),
                                                                                 GHC.Integer.Type.Integer)>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                           <*>_N
                                                                                                                           <SEDEL.Environment.Ctx>_R
                                                                                                                           <Control.Monad.Trans.Except.ExceptT
                                                                                                                              SEDEL.Environment.Err
                                                                                                                              GHC.Types.IO>_R
                                                                                                                           <((SEDEL.Source.Syntax.SType,
                                                                                                                              SEDEL.Target.Syntax.UExpr),
                                                                                                                             GHC.Integer.Type.Integer)>_N)))
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <GHC.Integer.Type.Integer>_N
                           <Control.Monad.Trans.Reader.ReaderT
                              SEDEL.Environment.Ctx
                              (Control.Monad.Trans.Except.ExceptT
                                 SEDEL.Environment.Err GHC.Types.IO)>_R
                           <(SEDEL.Source.Syntax.SType,
                             SEDEL.Target.Syntax.UExpr)>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                                           SEDEL.Environment.Ctx
                                                                                                                           (Control.Monad.Trans.Except.ExceptT
                                                                                                                              SEDEL.Environment.Err
                                                                                                                              GHC.Types.IO)>_N <(SEDEL.Source.Syntax.SType,
                                                                                                                                                 SEDEL.Target.Syntax.UExpr)>_N)) -}
2e8f8f6dfabd016cb58641551e4bde3f
  tcModule1 :: (SEDEL.Source.Syntax.TmBind)
  {- Strictness: x -}
5733672ac5dcc1a2f6cd4c8129e2d784
  tcModule_tcM ::
    [SEDEL.Source.Syntax.SDecl]
    -> SEDEL.Source.Syntax.TmBind
    -> SEDEL.Environment.TcMonad
         (SEDEL.Source.Syntax.SType, SEDEL.Target.Syntax.UExpr)
  {- Arity: 2, Strictness: <S,1*U><L,U(U,A,U,U,A,A)> -}
"SPEC/SEDEL.Source.TypeCheck $fAlpha(,) @ (Name SType) @ (Embed
                                                           SType)" [orphan] forall (v1 :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                            (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                                                                                                               SEDEL.Source.Syntax.SType))
                                                                                                                                                   (v :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                           (Unbound.Generics.LocallyNameless.Name.Name
                                                                                                                                                              SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Alpha.$fAlpha(,) @ (Unbound.Generics.LocallyNameless.Name.Name
                                                         SEDEL.Source.Syntax.SType)
                                                    @ (Unbound.Generics.LocallyNameless.Embed.Embed
                                                         SEDEL.Source.Syntax.SType)
                                                    v
                                                    v1
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)2
"SPEC/SEDEL.Source.TypeCheck $fAlpha(,)_$caeq' @ (Name
                                                   SType) @ (Embed SType)" [orphan] forall ($dAlpha1 :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                 (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                                                                                                                    SEDEL.Source.Syntax.SType))
                                                                                                                                                  ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                (Unbound.Generics.LocallyNameless.Name.Name
                                                                                                                                                                   SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Alpha.$fAlpha(,)_$caeq' @ (Unbound.Generics.LocallyNameless.Name.Name
                                                                SEDEL.Source.Syntax.SType)
                                                           @ (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                SEDEL.Source.Syntax.SType)
                                                           $dAlpha
                                                           $dAlpha1
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$caeq'2
"SPEC/SEDEL.Source.TypeCheck $fAlpha(,)_$cclose @ (Name
                                                    SType) @ (Embed SType)" [orphan] forall ($dAlpha1 :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                   (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                                                                                                                      SEDEL.Source.Syntax.SType))
                                                                                                                                                    ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                  (Unbound.Generics.LocallyNameless.Name.Name
                                                                                                                                                                     SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Alpha.$fAlpha(,)_$cclose @ (Unbound.Generics.LocallyNameless.Name.Name
                                                                 SEDEL.Source.Syntax.SType)
                                                            @ (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                 SEDEL.Source.Syntax.SType)
                                                            $dAlpha
                                                            $dAlpha1
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$cclose2
"SPEC/SEDEL.Source.TypeCheck $fAlpha(,)_$cfvAny' @ (Name
                                                     SType) @ (Embed SType)" [orphan] forall ($dAlpha1 :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                     (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                                                                                                                        SEDEL.Source.Syntax.SType))
                                                                                                                                                      ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                    (Unbound.Generics.LocallyNameless.Name.Name
                                                                                                                                                                       SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Alpha.$fAlpha(,)_$cfvAny' @ (Unbound.Generics.LocallyNameless.Name.Name
                                                                  SEDEL.Source.Syntax.SType)
                                                             @ (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                  SEDEL.Source.Syntax.SType)
                                                             $dAlpha
                                                             $dAlpha1
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$cfvAny'2
"SPEC/SEDEL.Source.TypeCheck $fAlpha(,)_$cisEmbed @ (Name
                                                      SType) @ (Embed SType)" [orphan] forall ($dAlpha1 :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                       (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                                                                                                                          SEDEL.Source.Syntax.SType))
                                                                                                                                                        ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                      (Unbound.Generics.LocallyNameless.Name.Name
                                                                                                                                                                         SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Alpha.$fAlpha(,)_$cisEmbed @ (Unbound.Generics.LocallyNameless.Name.Name
                                                                   SEDEL.Source.Syntax.SType)
                                                              @ (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                   SEDEL.Source.Syntax.SType)
                                                              $dAlpha
                                                              $dAlpha1
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$cisEmbed2
"SPEC/SEDEL.Source.TypeCheck $fAlpha(,)_$clfreshen' @ (Name
                                                        SType) @ (Embed SType)" [orphan] forall ($dAlpha1 :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                           (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                                                                                                                              SEDEL.Source.Syntax.SType))
                                                                                                                                                            ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                          (Unbound.Generics.LocallyNameless.Name.Name
                                                                                                                                                                             SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Alpha.$fAlpha(,)_$clfreshen' @ (Unbound.Generics.LocallyNameless.Name.Name
                                                                     SEDEL.Source.Syntax.SType)
                                                                @ (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                     SEDEL.Source.Syntax.SType)
                                                                $dAlpha
                                                                $dAlpha1
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$clfreshen'2
"SPEC/SEDEL.Source.TypeCheck $fAlpha(,)_$copen @ (Name
                                                   SType) @ (Embed SType)" [orphan] forall ($dAlpha1 :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                 (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                                                                                                                    SEDEL.Source.Syntax.SType))
                                                                                                                                                  ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                (Unbound.Generics.LocallyNameless.Name.Name
                                                                                                                                                                   SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Alpha.$fAlpha(,)_$copen @ (Unbound.Generics.LocallyNameless.Name.Name
                                                                SEDEL.Source.Syntax.SType)
                                                           @ (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                SEDEL.Source.Syntax.SType)
                                                           $dAlpha
                                                           $dAlpha1
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$copen2
"SPEC/SEDEL.Source.TypeCheck $fAlpha(,)_$cswaps' @ (Name
                                                     SType) @ (Embed SType)" [orphan] forall ($dAlpha1 :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                     (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                                                                                                                        SEDEL.Source.Syntax.SType))
                                                                                                                                                      ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                    (Unbound.Generics.LocallyNameless.Name.Name
                                                                                                                                                                       SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Alpha.$fAlpha(,)_$cswaps' @ (Unbound.Generics.LocallyNameless.Name.Name
                                                                  SEDEL.Source.Syntax.SType)
                                                             @ (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                  SEDEL.Source.Syntax.SType)
                                                             $dAlpha
                                                             $dAlpha1
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$cswaps'2
"SPEC/SEDEL.Source.TypeCheck $fAlphaEmbed @ SType" [orphan] forall (v :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                           SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed @ SEDEL.Source.Syntax.SType
                                                      v
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlphaEmbed
"SPEC/SEDEL.Source.TypeCheck $fAlphaEmbed_$cacompare' @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                             SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cacompare' @ SEDEL.Source.Syntax.SType
                                                                  $dAlpha
  = SEDEL.Source.TypeCheck.$s$fAlphaEmbed_$cacompare'
"SPEC/SEDEL.Source.TypeCheck $fAlphaEmbed_$caeq' @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                        SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$caeq' @ SEDEL.Source.Syntax.SType
                                                             $dAlpha
  = SEDEL.Source.TypeCheck.$s$fAlphaEmbed_$caeq'
"SPEC/SEDEL.Source.TypeCheck $fAlphaEmbed_$cclose @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                         SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cclose @ SEDEL.Source.Syntax.SType
                                                              $dAlpha
  = SEDEL.Source.TypeCheck.$s$fAlphaEmbed_$cclose
"SPEC/SEDEL.Source.TypeCheck $fAlphaEmbed_$cfreshen' @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                            SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cfreshen' @ SEDEL.Source.Syntax.SType
                                                                 $dAlpha
  = SEDEL.Source.TypeCheck.$s$fAlphaEmbed_$cfreshen'
"SPEC/SEDEL.Source.TypeCheck $fAlphaEmbed_$cisPat @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                         SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cisPat @ SEDEL.Source.Syntax.SType
                                                              $dAlpha
  = SEDEL.Source.TypeCheck.$s$fAlphaEmbed_$cisPat
"SPEC/SEDEL.Source.TypeCheck $fAlphaEmbed_$copen @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                        SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$copen @ SEDEL.Source.Syntax.SType
                                                             $dAlpha
  = SEDEL.Source.TypeCheck.$s$fAlphaEmbed_$copen
"SPEC/SEDEL.Source.TypeCheck $fAlphaEmbed_$cswaps' @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                          SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cswaps' @ SEDEL.Source.Syntax.SType
                                                               $dAlpha
  = SEDEL.Source.TypeCheck.$s$fAlphaEmbed_$cswaps'
"SPEC/SEDEL.Source.TypeCheck $fApplicativeExceptT @ IO _" [orphan] forall @ e
                                                                          (v1 :: GHC.Base.Monad
                                                                                   GHC.Types.IO)
                                                                          (v :: GHC.Base.Functor
                                                                                  GHC.Types.IO)
  Control.Monad.Trans.Except.$fApplicativeExceptT @ GHC.Types.IO
                                                  @ e
                                                  v
                                                  v1
  = SEDEL.Source.TypeCheck.$s$fApplicativeExceptT @ e
"SPEC/SEDEL.Source.TypeCheck $fApplicativeExceptT_$c*> @ IO _" [orphan] forall @ e
                                                                               ($dMonad :: GHC.Base.Monad
                                                                                             GHC.Types.IO)
                                                                               ($dFunctor :: GHC.Base.Functor
                                                                                               GHC.Types.IO)
  Control.Monad.Trans.Except.$fApplicativeExceptT_$c*> @ GHC.Types.IO
                                                       @ e
                                                       $dFunctor
                                                       $dMonad
  = SEDEL.Source.TypeCheck.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$c*>
      @ e
"SPEC/SEDEL.Source.TypeCheck $fApplicativeExceptT_$cpure @ IO _" [orphan] forall @ e
                                                                                 ($dMonad :: GHC.Base.Monad
                                                                                               GHC.Types.IO)
                                                                                 ($dFunctor :: GHC.Base.Functor
                                                                                                 GHC.Types.IO)
  Control.Monad.Trans.Except.$fApplicativeExceptT_$cpure @ GHC.Types.IO
                                                         @ e
                                                         $dFunctor
                                                         $dMonad
  = SEDEL.Source.TypeCheck.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure
      @ e
"SPEC/SEDEL.Source.TypeCheck $fFreshFreshMT @ (ReaderT
                                                Ctx (ExceptT Err IO))" [orphan] forall (v :: GHC.Base.Monad
                                                                                                                                                      (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                         SEDEL.Environment.Ctx
                                                                                                                                                         (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                            SEDEL.Environment.Err
                                                                                                                                                            GHC.Types.IO)))
  Unbound.Generics.LocallyNameless.Fresh.$fFreshFreshMT @ (Control.Monad.Trans.Reader.ReaderT
                                                             SEDEL.Environment.Ctx
                                                             (Control.Monad.Trans.Except.ExceptT
                                                                SEDEL.Environment.Err GHC.Types.IO))
                                                        v
  = SEDEL.Source.TypeCheck.$s$fFreshFreshMT
"SPEC/SEDEL.Source.TypeCheck $fFunctorExceptT @ IO _" [orphan] forall @ e
                                                                      (v :: GHC.Base.Functor
                                                                              GHC.Types.IO)
  Control.Monad.Trans.Except.$fFunctorExceptT @ GHC.Types.IO @ e v
  = SEDEL.Source.TypeCheck.$s$fApplicativeExceptT_$s$fFunctorExceptT
      @ e
"SPEC/SEDEL.Source.TypeCheck $fMonadExceptT @ IO _" [orphan] forall @ e
                                                                    (v :: GHC.Base.Monad
                                                                            GHC.Types.IO)
  Control.Monad.Trans.Except.$fMonadExceptT @ GHC.Types.IO @ e v
  = SEDEL.Source.TypeCheck.$s$fFreshFreshMT_$s$fMonadExceptT @ e
"SPEC/SEDEL.Source.TypeCheck $fMonadExceptT_$c>> @ IO _" [orphan] forall @ e
                                                                         ($dMonad :: GHC.Base.Monad
                                                                                       GHC.Types.IO)
  Control.Monad.Trans.Except.$fMonadExceptT_$c>> @ GHC.Types.IO
                                                 @ e
                                                 $dMonad
  = SEDEL.Source.TypeCheck.$s$fFreshFreshMT_$s$fMonadExceptT_$c>> @ e
"SPEC/SEDEL.Source.TypeCheck $fMonadExceptT_$c>>= @ IO _" [orphan] forall @ e
                                                                          ($dMonad :: GHC.Base.Monad
                                                                                        GHC.Types.IO)
  Control.Monad.Trans.Except.$fMonadExceptT_$c>>= @ GHC.Types.IO
                                                  @ e
                                                  $dMonad
  = SEDEL.Source.TypeCheck.$s$fFreshFreshMT_$s$fMonadExceptT_$c>>=
      @ e
"SPEC/SEDEL.Source.TypeCheck $fMonadReaderT @ (ExceptT Err IO) _" [orphan] forall @ r
                                                                                  (v :: GHC.Base.Monad
                                                                                          (Control.Monad.Trans.Except.ExceptT
                                                                                             SEDEL.Environment.Err
                                                                                             GHC.Types.IO))
  Control.Monad.Trans.Reader.$fMonadReaderT @ (Control.Monad.Trans.Except.ExceptT
                                                 SEDEL.Environment.Err GHC.Types.IO)
                                            @ r
                                            v
  = SEDEL.Source.TypeCheck.$s$fFreshFreshMT_$s$fMonadReaderT @ r
"SPEC/SEDEL.Source.TypeCheck $fShow(,) @ (Name SType) @ (Embed
                                                          SType)" [orphan] forall (v1 :: GHC.Show.Show
                                                                                                                                                          (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                                                                                                             SEDEL.Source.Syntax.SType))
                                                                                                                                                 (v :: GHC.Show.Show
                                                                                                                                                         (Unbound.Generics.LocallyNameless.Name.Name
                                                                                                                                                            SEDEL.Source.Syntax.SType))
  GHC.Show.$fShow(,) @ (Unbound.Generics.LocallyNameless.Name.Name
                          SEDEL.Source.Syntax.SType)
                     @ (Unbound.Generics.LocallyNameless.Embed.Embed
                          SEDEL.Source.Syntax.SType)
                     v
                     v1
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fShow(,)2
"SPEC/SEDEL.Source.TypeCheck $fShowEmbed @ SType" [orphan] forall (v :: GHC.Show.Show
                                                                          SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fShowEmbed @ SEDEL.Source.Syntax.SType
                                                     v
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fShowEmbed
"SPEC/SEDEL.Source.TypeCheck fromList @ Label _" [orphan] forall @ a
                                                                 ($dOrd :: GHC.Classes.Ord
                                                                             SEDEL.Source.Syntax.Label)
  Data.Map.Internal.fromList @ [GHC.Types.Char] @ a $dOrd
  = SEDEL.Source.TypeCheck.$sfromList @ a
"SPEC/SEDEL.Source.TypeCheck unionWith @ Label _" [orphan] forall @ a
                                                                  ($dOrd :: GHC.Classes.Ord
                                                                              SEDEL.Source.Syntax.Label)
  Data.Map.Internal.unionWith @ [GHC.Types.Char] @ a $dOrd
  = SEDEL.Source.TypeCheck.$sunionWith @ a
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

