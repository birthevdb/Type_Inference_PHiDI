
==================== FINAL INTERFACE ====================
2019-08-12 12:24:18.082306 UTC

interface sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.Environment 8063
  interface hash: 40848472e1d0eb8047b27e195907da07
  ABI hash: d8bc650b7b97515a31f95e90c47efbdd
  export-list hash: ee616ba5663dcc7668ccee4c280f41a3
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 8c8d9447aa9e9c6d4d32bc5d14d3c2b4
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  SEDEL.Environment.addTypeSynonym
  SEDEL.Environment.addTypeSynonyms
  SEDEL.Environment.askCtx
  SEDEL.Environment.ctxMap
  SEDEL.Environment.emptyCtx
  SEDEL.Environment.errThrow
  SEDEL.Environment.extendConstrainedSTVarCtx
  SEDEL.Environment.extendConstrainedTVarCtx
  SEDEL.Environment.extendSourceLocation
  SEDEL.Environment.extendTVarCtx
  SEDEL.Environment.extendVarCtx
  SEDEL.Environment.extendVarCtxs
  SEDEL.Environment.getSourceLocation
  SEDEL.Environment.localCtx
  SEDEL.Environment.lookupTVarConstraint
  SEDEL.Environment.lookupTVarConstraintMaybe
  SEDEL.Environment.lookupTVarKindMaybe
  SEDEL.Environment.lookupTVarSynMaybe
  SEDEL.Environment.lookupTmDef
  SEDEL.Environment.lookupVarTy
  SEDEL.Environment.runTcMonad
  SEDEL.Environment.Ctx{SEDEL.Environment.Ctx bndCtx sourceLocation tyCtx varCtx}
  SEDEL.Environment.Err{SEDEL.Environment.Err}
  SEDEL.Environment.ICtx
  SEDEL.Environment.ITcMonad
  SEDEL.Environment.SCtx
  SEDEL.Environment.STcMonad
  SEDEL.Environment.SourceLocation{SEDEL.Environment.SourceLocation}
  SEDEL.Environment.TcMonad
  SEDEL.Environment.TypeValue{SEDEL.Environment.NonTerminalType SEDEL.Environment.TerminalType}
module dependencies: SEDEL.Common SEDEL.Intermediate.Syntax
                     SEDEL.PrettyPrint SEDEL.Source.Syntax
package dependencies: array-0.5.3.0 async-2.2.1 base-4.12.0.0
                      base-orphans-0.8 bifunctors-5.5.3 binary-0.8.6.0
                      bytestring-0.10.8.2 comonad-5.0.4 containers-0.6.0.1
                      deepseq-1.4.4.0 distributive-0.6 exceptions-0.10.0
                      ghc-boot-th-8.6.3 ghc-prim-0.5.3 hashable-1.2.7.0
                      integer-gmp-1.0.2.0 megaparsec-7.0.4 mtl-2.2.2
                      parser-combinators-1.0.1 pretty-1.1.3.6 prettyprinter-1.2.1
                      profunctors-5.3 protolude-0.2.3 stm-2.5.0.0 tagged-0.8.6
                      template-haskell-2.14.0.0 text-1.2.3.1 transformers-0.5.5.0
                      unbound-generics-0.4.0
orphans: sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.PrettyPrint
         sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.Source.Syntax
         sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.Intermediate.Syntax
         transformers-0.5.5.0:Control.Monad.Trans.Error
         stm-2.5.0.0:Control.Monad.STM
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.1:Data.Text.Lazy
         text-1.2.3.1:Data.Text binary-0.8.6.0:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show base-4.12.0.0:GHC.Float
         base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         bifunctors-5.5.3:Data.Bifunctor.Biff
                         bifunctors-5.5.3:Data.Bifunctor.Clown
                         bifunctors-5.5.3:Data.Bifunctor.Joker
                         bifunctors-5.5.3:Data.Bifunctor.Product
                         bifunctors-5.5.3:Data.Bifunctor.Sum
                         bifunctors-5.5.3:Data.Bifunctor.Tannen
                         containers-0.6.0.1:Data.IntMap.Internal
                         containers-0.6.0.1:Data.IntSet.Internal
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Sequence.Internal
                         containers-0.6.0.1:Data.Set.Internal containers-0.6.0.1:Data.Tree
                         ghc-boot-th-8.6.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.6.3:GHC.LanguageExtensions.Type
                         megaparsec-7.0.4:Text.Megaparsec.Error
                         megaparsec-7.0.4:Text.Megaparsec.Pos
                         megaparsec-7.0.4:Text.Megaparsec.State
                         megaparsec-7.0.4:Text.Megaparsec.Stream
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         prettyprinter-1.2.1:Data.Text.Prettyprint.Doc.Internal
                         sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.Common
                         sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.Intermediate.Syntax
                         sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.Source.Syntax
                         tagged-0.8.6:Data.Tagged
                         template-haskell-2.14.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.1:Data.Text text-1.2.3.1:Data.Text.Lazy
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Bind
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Embed
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Ignore
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Name
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Rebind
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Rec
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Shift
import  -/  base-4.12.0.0:Data.Either 946a3435d06773e1dbcad1ba5dc18a2c
import  -/  base-4.12.0.0:Data.Foldable 00188ddf89c975fee76bdfad479443c1
import  -/  base-4.12.0.0:Data.Functor 22aac80fdb6c7b7f60b4aaab86afee64
import  -/  base-4.12.0.0:Data.Tuple c92a835d04b6c075a7031d4e28e53c71
import  -/  base-4.12.0.0:GHC.Base cc906f98291a1b830546e99a96674547
import  -/  base-4.12.0.0:GHC.Show 4e438f26d903388cc6c2c5d64ed01b98
import  -/  containers-0.6.0.1:Data.Map.Internal e652f5f18be5bf564604b214e5c1dad8
import  -/  containers-0.6.0.1:Data.Map.Strict c9c15d36149113668379264c6ca4bcc8
import  -/  containers-0.6.0.1:Data.Map.Strict.Internal 6df6fcb6b071f5a925d4fa53758ddeff
import  -/  ghc-prim-0.5.3:GHC.Classes e0d9c979f6368701f34fa421754d2cce
import  -/  ghc-prim-0.5.3:GHC.Types 57064c9f957b09bc2e360061ad5cae0b
import  -/  megaparsec-7.0.4:Text.Megaparsec b1d8d167d8e2d184f840d7f8cf436244
import  -/  megaparsec-7.0.4:Text.Megaparsec.Pos 571c263c2d6d71cb16ac08411e89b660
import  -/  mtl-2.2.2:Control.Monad.Error.Class 396bb83814f3ba40535fffb311f79b73
import  -/  mtl-2.2.2:Control.Monad.Reader.Class bfd53ec9164fa16880d07775c83c6ec0
import  -/  prettyprinter-1.2.1:Data.Text.Prettyprint.Doc 37bebc045f3a0cb8e8977c181970ecaf
import  -/  prettyprinter-1.2.1:Data.Text.Prettyprint.Doc.Internal 12d379fe6b8bbcab8bffc2d86df0e72f
import  -/  protolude-0.2.3:Protolude f69a0445642f255f4ede68732259560a
import  -/  SEDEL.Intermediate.Syntax f958fad6e88fb88eb220133854cd0fcf
  exports: 205c54e0e633701a9c7db27d9e71b968
  FExpr bfd7da9f3e523c5cb9c209b4524af79c
  FType bfd7da9f3e523c5cb9c209b4524af79c
  Kind 75dced522dd6f4b8712252c258eff413
  Star fa8ba77579e6cdb1b751fc046f3dc428
  TmName bfd7da9f3e523c5cb9c209b4524af79c
  TopT 468057410ade7257fcfc41c369faaefb
  TyName bfd7da9f3e523c5cb9c209b4524af79c
import  -/  SEDEL.PrettyPrint a34bffe1a10b43afb675c089919de4ed
  exports: 143f4b15e4a5a88e60030586dbaf2fd5
  DS 976d03e5d5e922389ab372fc4ef2aca9
  FDoc 2e8709e87e2e57334d6894fd22099a50
  FPretty 45fe98a51a442638ccb5054763267604
  ppr 893322c161ba6b662705e3315cf140cd
  pprint eba184c0db88b2f2c1bf72b06d0af23e
import  -/  SEDEL.Source.Syntax ec83a0da1c10765115fe4a9f09c754b0
  exports: 9689242b0decab272007a11f45b72d7d
  CtxType 7b97ffa162fee61007782494ea4f80da
  Expr 350069ed8c9e308e7d171878eb06250d
  Kind 350069ed8c9e308e7d171878eb06250d
  SType 350069ed8c9e308e7d171878eb06250d
  Star 360a731d5e4cf3a645e5f82bd30238ed
  TmName 350069ed8c9e308e7d171878eb06250d
  TyName 350069ed8c9e308e7d171878eb06250d
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Except 492e1fc9e7bdded285216f81f05ba982
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Reader 3d5c6b0df34d74144ad9d24efee0de98
import  -/  unbound-generics-0.4.0:Unbound.Generics.LocallyNameless 36704d4dbfb3fb22f46cde363ae796f2
import  -/  unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Fresh e0f8d49fe8e0f78dfcabb34436892778
5cbe37339eb8c5f4163df0ce8d2c71ee
  $fFPrettyErr :: SEDEL.PrettyPrint.FPretty SEDEL.Environment.Err
  DFunId
  {- Arity: 3,
     Strictness: <L,A><S(SLLL),1*U(1*U(U,U,U,U,U),U,U,U)><S(SL),1*U(1*U,U)>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                SEDEL.Environment.$fFPrettyErr_$cppr
                  `cast`
                (Sym (SEDEL.PrettyPrint.N:FPretty[0] <SEDEL.Environment.Err>_N)) -}
fc46fbd8a4e7374509e058ec30026f1b
  $fFPrettyErr1 ::
    Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn
  {- Unfolding: (Data.Text.Prettyprint.Doc.Internal.$fIsStringDoc_$cfromString
                   @ SEDEL.PrettyPrint.FAnn
                   (GHC.CString.unpackCString# SEDEL.Environment.$fFPrettyErr2)) -}
af7a3ee5446767379be58cce35bb5197
  $fFPrettyErr2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("In the expression:"#) -}
5cbe37339eb8c5f4163df0ce8d2c71ee
  $fFPrettyErr_$cppr ::
    (GHC.Base.Applicative m,
     Unbound.Generics.LocallyNameless.LFresh.LFresh m) =>
    SEDEL.Environment.Err -> m SEDEL.PrettyPrint.FDoc
  {- Arity: 3,
     Strictness: <L,A><S(SLLL),1*U(1*U(U,U,U,U,U),U,U,U)><S(SL),1*U(1*U,U)>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   (w :: GHC.Base.Applicative m)
                   (w1 :: Unbound.Generics.LocallyNameless.LFresh.LFresh m)
                   (w2 :: SEDEL.Environment.Err) ->
                 case w1 of ww { Unbound.Generics.LocallyNameless.LFresh.C:LFresh ww1 ww2 ww3 ww4 ->
                 case ww1 of ww5 { GHC.Base.C:Monad ww6 ww7 ww8 ww9 ww10 ->
                 case w2 of ww11 { SEDEL.Environment.Err ww12 ww13 ->
                 SEDEL.Environment.$w$cppr
                   @ m
                   ww6
                   ww7
                   ww8
                   ww9
                   ww10
                   ww2
                   ww3
                   ww4
                   ww12
                   ww13 } } }) -}
5cbe37339eb8c5f4163df0ce8d2c71ee
  $fMonoidErr :: GHC.Base.Monoid SEDEL.Environment.Err
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ SEDEL.Environment.Err
                  SEDEL.Environment.$fSemigroupErr
                  SEDEL.Environment.$fMonoidErr_$cmempty
                  SEDEL.Environment.$fMonoidErr_$c<>
                  SEDEL.Environment.$fMonoidErr_go -}
5cbe37339eb8c5f4163df0ce8d2c71ee
  $fMonoidErr_$c<> ::
    SEDEL.Environment.Err
    -> SEDEL.Environment.Err -> SEDEL.Environment.Err
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(1*U,U)><S,1*U(1*U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: SEDEL.Environment.Err) (ds1 :: SEDEL.Environment.Err) ->
                 case ds of wild { SEDEL.Environment.Err src1 d1 ->
                 case ds1 of wild1 { SEDEL.Environment.Err src2 d2 ->
                 SEDEL.Environment.Err
                   (GHC.Base.augment
                      @ SEDEL.Environment.SourceLocation
                      (\ @ b
                         (c :: SEDEL.Environment.SourceLocation -> b -> b)[OneShot]
                         (n :: b)[OneShot] ->
                       GHC.Base.foldr @ SEDEL.Environment.SourceLocation @ b c n src1)
                      src2)
                   (Data.Text.Prettyprint.Doc.Internal.Cat
                      @ SEDEL.PrettyPrint.FAnn
                      d1
                      d2) } }) -}
5cbe37339eb8c5f4163df0ce8d2c71ee
  $fMonoidErr_$cmempty :: SEDEL.Environment.Err
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (SEDEL.Environment.Err
                   (GHC.Types.[] @ SEDEL.Environment.SourceLocation)
                   (Data.Text.Prettyprint.Doc.Internal.Empty
                      @ SEDEL.PrettyPrint.FAnn)) -}
5cbe37339eb8c5f4163df0ce8d2c71ee
  $fMonoidErr_go :: [SEDEL.Environment.Err] -> SEDEL.Environment.Err
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [SEDEL.Environment.Err]) ->
                 case SEDEL.Environment.$wgo w of ww { (#,#) ww1 ww2 ->
                 SEDEL.Environment.Err ww1 ww2 }) -}
5cbe37339eb8c5f4163df0ce8d2c71ee
  $fSemigroupErr :: GHC.Base.Semigroup SEDEL.Environment.Err
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ SEDEL.Environment.Err
                  SEDEL.Environment.$fMonoidErr_$c<>
                  SEDEL.Environment.$fSemigroupErr_$csconcat
                  SEDEL.Environment.$fSemigroupErr_$cstimes -}
5cbe37339eb8c5f4163df0ce8d2c71ee
  $fSemigroupErr_$csconcat ::
    GHC.Base.NonEmpty SEDEL.Environment.Err -> SEDEL.Environment.Err
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SS),1*U(1*U(U,U),1*U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Base.NonEmpty SEDEL.Environment.Err) ->
                 case ds of wild { GHC.Base.:| a1 as ->
                 SEDEL.Environment.$fSemigroupErr_go a1 as }) -}
5cbe37339eb8c5f4163df0ce8d2c71ee
  $fSemigroupErr_$cstimes ::
    GHC.Real.Integral b =>
    b -> SEDEL.Environment.Err -> SEDEL.Environment.Err
  {- Arity: 1, Strictness: <L,U> -}
5cbe37339eb8c5f4163df0ce8d2c71ee
  $fSemigroupErr_go ::
    SEDEL.Environment.Err
    -> [SEDEL.Environment.Err] -> SEDEL.Environment.Err
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U,U)><S,1*U>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: SEDEL.Environment.Err) (w1 :: [SEDEL.Environment.Err]) ->
                 case w of ww { SEDEL.Environment.Err ww1 ww2 ->
                 case SEDEL.Environment.$wgo1 ww1 ww2 w1 of ww3 { (#,#) ww4 ww5 ->
                 SEDEL.Environment.Err ww4 ww5 } }) -}
41702292c1492a119389dcad69854f2d
  $fShowTypeValue ::
    GHC.Show.Show typ =>
    GHC.Show.Show (SEDEL.Environment.TypeValue typ)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ typ (v :: GHC.Show.Show typ).
                  @ (SEDEL.Environment.TypeValue typ)
                  (SEDEL.Environment.$fShowTypeValue_$cshowsPrec @ typ v)
                  (SEDEL.Environment.$fShowTypeValue_$cshow @ typ v)
                  (SEDEL.Environment.$fShowTypeValue_$cshowList @ typ v) -}
385af0f4e511b7b86d06399b38ea1ea7
  $fShowTypeValue1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
7795801ccf0b90d19f18496baf8c1c35
  $fShowTypeValue2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   SEDEL.Environment.$fShowTypeValue3) -}
ee1868bde6dee758c88cfc7d6c510304
  $fShowTypeValue3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("NonTerminalType "#) -}
7deafc9e663dcab4d8122c9f68c48b02
  $fShowTypeValue4 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
64abeeb0573cc2fdaf843ccffd613f4e
  $fShowTypeValue5 :: [GHC.Types.Char] -> [GHC.Types.Char]
  {- Arity: 1,
     Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   SEDEL.Environment.$fShowTypeValue6) -}
a7a01f1cf0393a9bf9b5faf1feda88d6
  $fShowTypeValue6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   SEDEL.Environment.$fShowTypeValue7) -}
073fb4082666d5b7f171128f3b8755e6
  $fShowTypeValue7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("TerminalType"#) -}
41702292c1492a119389dcad69854f2d
  $fShowTypeValue_$cshow ::
    GHC.Show.Show typ =>
    SEDEL.Environment.TypeValue typ -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
     Unfolding: (\ @ typ
                   ($dShow :: GHC.Show.Show typ)
                   (x :: SEDEL.Environment.TypeValue typ) ->
                 case x of wild {
                   SEDEL.Environment.TerminalType
                   -> SEDEL.Environment.$fShowTypeValue6
                   SEDEL.Environment.NonTerminalType b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        SEDEL.Environment.$fShowTypeValue2
                        (GHC.Show.showsPrec
                           @ typ
                           $dShow
                           SEDEL.Environment.$fShowTypeValue4
                           b1
                           (GHC.Types.[] @ GHC.Types.Char)) }) -}
41702292c1492a119389dcad69854f2d
  $fShowTypeValue_$cshowList ::
    GHC.Show.Show typ =>
    [SEDEL.Environment.TypeValue typ] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ typ
                   ($dShow :: GHC.Show.Show typ)
                   (ls :: [SEDEL.Environment.TypeValue typ])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (SEDEL.Environment.TypeValue typ)
                   (SEDEL.Environment.$fShowTypeValue_$cshowsPrec
                      @ typ
                      $dShow
                      SEDEL.Environment.$fShowTypeValue1)
                   ls
                   s) -}
41702292c1492a119389dcad69854f2d
  $fShowTypeValue_$cshowsPrec ::
    GHC.Show.Show typ =>
    GHC.Types.Int -> SEDEL.Environment.TypeValue typ -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(U)><S,1*U>,
     Unfolding: (\ @ typ
                   ($dShow :: GHC.Show.Show typ)
                   (ds :: GHC.Types.Int)
                   (ds1 :: SEDEL.Environment.TypeValue typ) ->
                 case ds1 of wild {
                   SEDEL.Environment.TerminalType
                   -> SEDEL.Environment.$fShowTypeValue5
                   SEDEL.Environment.NonTerminalType b1
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec
                            @ typ
                            $dShow
                            SEDEL.Environment.$fShowTypeValue4
                            b1
                      } in
                      case GHC.Prim.>=# x 11# of lwild {
                        DEFAULT
                        -> \ (x1 :: GHC.Base.String) ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             SEDEL.Environment.$fShowTypeValue2
                             (g x1)
                        1#
                        -> \ (x1 :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                SEDEL.Environment.$fShowTypeValue2
                                (g (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.$fShow(,)2
                                      x1))) } } }) -}
14e40865a1b6d2551732c351de76197f
  $sinsert_$sgo1 ::
    SEDEL.Intermediate.Syntax.TyName
    -> a1
    -> Data.Map.Internal.Map SEDEL.Intermediate.Syntax.TyName a1
    -> Data.Map.Internal.Map SEDEL.Intermediate.Syntax.TyName a1
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
670619359e7586f5449391b29389c794
  $sinsert_$sgo8 ::
    SEDEL.Source.Syntax.TyName
    -> a1
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.TyName a1
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.TyName a1
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
47ff1e88ab9bb818a8fc1951ec1970dd
  $tc'Ctx :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17417177679309474780##
                   15064762768081979387##
                   SEDEL.Environment.$trModule
                   SEDEL.Environment.$tc'Ctx2
                   6#
                   SEDEL.Environment.$tc'Ctx1) -}
db88bcbdc2f7b9c6215f9d0adfece712
  $tc'Ctx1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
db19c2f57515828fe58ad6dcb77584dd
  $tc'Ctx2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Environment.$tc'Ctx3) -}
0a003f8494ab8f92ea5352e261ede398
  $tc'Ctx3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Ctx"#) -}
e1290961cae1868246f7338547536a13
  $tc'Err :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6582880480443336145##
                   14721901754218905155##
                   SEDEL.Environment.$trModule
                   SEDEL.Environment.$tc'Err2
                   0#
                   SEDEL.Environment.$tc'Err1) -}
6198dda843315e7ee989c3ce28c02281
  $tc'Err1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
2fb0bbc1e2291b919547fe4460ed9ad8
  $tc'Err2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Environment.$tc'Err3) -}
2fee9dbe9d7a0b65f37d05eb21bed3be
  $tc'Err3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Err"#) -}
616076a3854aefa698c00d647bc26f31
  $tc'NonTerminalType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1483645952383791605##
                   7076473767473038428##
                   SEDEL.Environment.$trModule
                   SEDEL.Environment.$tc'NonTerminalType2
                   1#
                   SEDEL.Environment.$tc'NonTerminalType1) -}
0448ed44998e65ed9e55aec306f80971
  $tc'NonTerminalType1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
0ecfbacb8ed09218bce3cf37ff3bb818
  $tc'NonTerminalType2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   SEDEL.Environment.$tc'NonTerminalType3) -}
542d3f0e6831a2914e01710b1e3005bd
  $tc'NonTerminalType3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NonTerminalType"#) -}
a4868bafa582a3102523555eabd1607e
  $tc'SourceLocation :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1777299051581795768##
                   17730986161006977334##
                   SEDEL.Environment.$trModule
                   SEDEL.Environment.$tc'SourceLocation2
                   1#
                   SEDEL.Environment.$tc'SourceLocation1) -}
f1e8f4ca4fd85531e40f5aa0528da929
  $tc'SourceLocation1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
bb26b8013be0f937249301aa42cba3e1
  $tc'SourceLocation2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   SEDEL.Environment.$tc'SourceLocation3) -}
04a88c78b90b83f4ac951dd47514f3af
  $tc'SourceLocation3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'SourceLocation"#) -}
d8a6d2e8263a11f5c80ff09fc6b73595
  $tc'TerminalType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3746278658622390460##
                   7343964935539726239##
                   SEDEL.Environment.$trModule
                   SEDEL.Environment.$tc'TerminalType2
                   1#
                   SEDEL.Environment.$tc'TerminalType1) -}
2c4d6e74b5fcb0bf5e558670b12492c0
  $tc'TerminalType1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
c466a39cc5488d35d7c46d9f8b27434e
  $tc'TerminalType2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   SEDEL.Environment.$tc'TerminalType3) -}
eb04214a37acafbb9435b4fabd983d06
  $tc'TerminalType3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'TerminalType"#) -}
d82b22d91c563bf6c34ac13a0edc87a4
  $tcCtx :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14493570183073880370##
                   15515864862964740481##
                   SEDEL.Environment.$trModule
                   SEDEL.Environment.$tcCtx2
                   0#
                   SEDEL.Environment.$tcCtx1) -}
4432957a53eb100a9858363a56b58261
  $tcCtx1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
0b7b8fb02a8cea5db544ba8d66530858
  $tcCtx2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Environment.$tcCtx3) -}
555c630275c63d29a4be63c1bfc00a5e
  $tcCtx3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Ctx"#) -}
5992e4b84985c74bd6f38546576b0666
  $tcErr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5464239149257021209##
                   4680439914259665204##
                   SEDEL.Environment.$trModule
                   SEDEL.Environment.$tcErr1
                   0#
                   GHC.Types.krep$*) -}
60fadcb55345d6d90d9a6383c965b7ee
  $tcErr1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Environment.$tcErr2) -}
bb621250d136180991e765e7347c8636
  $tcErr2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Err"#) -}
4acd7a73710e584d5a4ac2fe8f8e192d
  $tcSourceLocation :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2162254878823843619##
                   4622340141384796512##
                   SEDEL.Environment.$trModule
                   SEDEL.Environment.$tcSourceLocation1
                   0#
                   GHC.Types.krep$*) -}
e9033cb7e8e7e61768bf65e9fb320040
  $tcSourceLocation1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   SEDEL.Environment.$tcSourceLocation2) -}
578d044a010a6d4b7cccf4874d36c05d
  $tcSourceLocation2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SourceLocation"#) -}
1076a802d685794cb8c088bde5a80531
  $tcTypeValue :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13903539852602196703##
                   2545337239275516133##
                   SEDEL.Environment.$trModule
                   SEDEL.Environment.$tcTypeValue1
                   0#
                   GHC.Types.krep$*Arr*) -}
c6e65da77f11ab5d9b9ae2cedb242278
  $tcTypeValue1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Environment.$tcTypeValue2) -}
c9f176e6b1a1e96cf00bf6061b2fbd55
  $tcTypeValue2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("TypeValue"#) -}
f97f1f28f782876541f04c038de16668
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   SEDEL.Environment.$trModule3
                   SEDEL.Environment.$trModule1) -}
ac437741b8ea14f9ac1d564f2b2ec17c
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Environment.$trModule2) -}
47cca907e125fad372d8530d10bd8230
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SEDEL.Environment"#) -}
b295acdba869b21de3e689377d9813eb
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Environment.$trModule4) -}
8a71be4ae5e22f75ac8285b666c989e3
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ"#) -}
e00993cc22bf269a4f1b97490af91f26
  $w$cppr ::
    GHC.Base.Applicative m =>
    (forall a b. m a -> (a -> m b) -> m b)
    -> (forall a b. m a -> m b -> m b)
    -> (forall a. a -> m a)
    -> (forall a. GHC.Base.String -> m a)
    -> (forall a.
        Data.Typeable.Internal.Typeable a =>
        Unbound.Generics.LocallyNameless.Name.Name a
        -> m (Unbound.Generics.LocallyNameless.Name.Name a))
    -> (forall a.
        [Unbound.Generics.LocallyNameless.Name.AnyName] -> m a -> m a)
    -> m (Data.Set.Internal.Set
            Unbound.Generics.LocallyNameless.Name.AnyName)
    -> [SEDEL.Environment.SourceLocation]
    -> SEDEL.PrettyPrint.FDoc
    -> m SEDEL.PrettyPrint.FDoc
  {- Arity: 10,
     Strictness: <L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><S,1*U><L,U>,
     Inline: [2],
     Unfolding: (\ @ m :: * -> *
                   (ww :: GHC.Base.Applicative m)
                   (ww1 :: forall a b. m a -> (a -> m b) -> m b)
                   (ww2 :: forall a b. m a -> m b -> m b)
                   (ww3 :: forall a. a -> m a)
                   (ww4 :: forall a. GHC.Base.String -> m a)
                   (ww5 :: forall a.
                           Data.Typeable.Internal.Typeable a =>
                           Unbound.Generics.LocallyNameless.Name.Name a
                           -> m (Unbound.Generics.LocallyNameless.Name.Name a))
                   (ww6 :: forall a.
                           [Unbound.Generics.LocallyNameless.Name.AnyName] -> m a -> m a)
                   (ww7 :: m (Data.Set.Internal.Set
                                Unbound.Generics.LocallyNameless.Name.AnyName))
                   (ww8 :: [SEDEL.Environment.SourceLocation])
                   (ww9 :: SEDEL.PrettyPrint.FDoc) ->
                 case ww8 of wild {
                   [] -> ww3 @ SEDEL.PrettyPrint.FDoc ww9
                   : ds ds1
                   -> case ds of wild1 { SEDEL.Environment.SourceLocation a $dFPretty p term ->
                      let {
                        lvl8 :: Data.Text.Prettyprint.Doc.Internal.Doc
                                  SEDEL.PrettyPrint.FAnn
                        = case p of wild2 { Text.Megaparsec.Pos.SourcePos ds2 dt dt1 ->
                          Data.Text.Prettyprint.Doc.Internal.Cat
                            @ SEDEL.PrettyPrint.FAnn
                            (Data.Text.Prettyprint.Doc.Internal.$w$cpretty5
                               @ SEDEL.PrettyPrint.FAnn
                               dt)
                            (Data.Text.Prettyprint.Doc.Internal.Cat
                               @ SEDEL.PrettyPrint.FAnn
                               (Data.Text.Prettyprint.Doc.Symbols.Ascii.colon
                                  @ SEDEL.PrettyPrint.FAnn)
                               (Data.Text.Prettyprint.Doc.Internal.Cat
                                  @ SEDEL.PrettyPrint.FAnn
                                  (Data.Text.Prettyprint.Doc.Internal.$w$cpretty5
                                     @ SEDEL.PrettyPrint.FAnn
                                     dt1)
                                  (Data.Text.Prettyprint.Doc.Symbols.Ascii.colon
                                     @ SEDEL.PrettyPrint.FAnn))) }
                      } in
                      ww1
                        @ SEDEL.PrettyPrint.FDoc
                        @ SEDEL.PrettyPrint.FDoc
                        ($dFPretty `cast` (SEDEL.PrettyPrint.N:FPretty[0] <a>_N)
                           @ m
                           ww
                           (Unbound.Generics.LocallyNameless.LFresh.C:LFresh
                              @ m
                              (GHC.Base.C:Monad @ m ww ww1 ww2 ww3 ww4)
                              ww5
                              ww6
                              ww7)
                           term)
                        (\ (trm :: SEDEL.PrettyPrint.FDoc) ->
                         ww3
                           @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                           (Data.Text.Prettyprint.Doc.Internal.vsep1
                              @ SEDEL.PrettyPrint.FAnn
                              (GHC.Types.:
                                 @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                                 lvl8
                                 (GHC.Types.:
                                    @ (Data.Text.Prettyprint.Doc.Internal.Doc
                                         SEDEL.PrettyPrint.FAnn)
                                    ww9
                                    (GHC.Types.:
                                       @ (Data.Text.Prettyprint.Doc.Internal.Doc
                                            SEDEL.PrettyPrint.FAnn)
                                       SEDEL.Environment.$fFPrettyErr1
                                       (GHC.Types.:
                                          @ (Data.Text.Prettyprint.Doc.Internal.Doc
                                               SEDEL.PrettyPrint.FAnn)
                                          trm
                                          (GHC.Types.[]
                                             @ (Data.Text.Prettyprint.Doc.Internal.Doc
                                                  SEDEL.PrettyPrint.FAnn)))))))) } }) -}
f1dc7103c42c955dbf99b47656780a66
  $werrThrow ::
    SEDEL.PrettyPrint.FPretty a =>
    (forall a1 b1. m a1 -> (a1 -> m b1) -> m b1)
    -> (forall a1. SEDEL.Environment.Err -> m a1)
    -> Control.Monad.Reader.Class.MonadReader
         (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp) m =>
       a -> m b
  {- Arity: 5,
     Strictness: <L,1*C1(C1(C1(U)))><C(C(S)),1*C1(C1(U))><L,C(U)><L,1*U(A,A,A,1*C1(U))><L,U>,
     Inline: [2],
     Unfolding: (\ @ a
                   @ m :: * -> *
                   @ tm_name
                   @ scheme
                   @ ty_name
                   @ kind
                   @ typ
                   @ exp
                   @ b
                   (w :: SEDEL.PrettyPrint.FPretty a)
                   (ww :: forall a1 b1. m a1 -> (a1 -> m b1) -> m b1)
                   (ww1 :: forall a1. SEDEL.Environment.Err -> m a1)
                   (w1 :: Control.Monad.Reader.Class.MonadReader
                            (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp) m)
                   (w2 :: a) ->
                 let {
                   lvl8 :: Data.Functor.Identity.Identity SEDEL.PrettyPrint.FDoc
                   = (w `cast` (SEDEL.PrettyPrint.N:FPretty[0] <a>_N)
                        @ (Unbound.Generics.LocallyNameless.LFresh.LFreshMT
                             Data.Functor.Identity.Identity)
                        SEDEL.PrettyPrint.$s$fApplicativeLFreshMT
                        SEDEL.PrettyPrint.$s$fLFreshLFreshMT
                        w2)
                       `cast`
                     (Unbound.Generics.LocallyNameless.LFresh.N:LFreshMT[0] <Data.Functor.Identity.Identity>_N <SEDEL.PrettyPrint.FDoc>_N ; Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                                                <*>_N
                                                                                                                                                <Data.Set.Internal.Set
                                                                                                                                                   Unbound.Generics.LocallyNameless.Name.AnyName>_R
                                                                                                                                                <Data.Functor.Identity.Identity>_R
                                                                                                                                                <SEDEL.PrettyPrint.FDoc>_N)
                       (Data.Set.Internal.Tip
                          @ Unbound.Generics.LocallyNameless.Name.AnyName)
                 } in
                 ww
                   @ [SEDEL.Environment.SourceLocation]
                   @ b
                   (Control.Monad.Reader.Class.reader
                      @ (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp)
                      @ m
                      w1
                      @ [SEDEL.Environment.SourceLocation]
                      (SEDEL.Environment.sourceLocation
                         @ tm_name
                         @ scheme
                         @ ty_name
                         @ kind
                         @ typ
                         @ exp))
                   (\ (loc :: [SEDEL.Environment.SourceLocation]) ->
                    ww1
                      @ b
                      (SEDEL.Environment.Err
                         loc
                         lvl8
                           `cast`
                         (Data.Functor.Identity.N:Identity[0]
                              <SEDEL.PrettyPrint.FDoc>_R)))) -}
5cbe37339eb8c5f4163df0ce8d2c71ee
  $wgo ::
    [SEDEL.Environment.Err]
    -> (# [SEDEL.Environment.SourceLocation], SEDEL.PrettyPrint.FDoc #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [2] -}
5cbe37339eb8c5f4163df0ce8d2c71ee
  $wgo1 ::
    [SEDEL.Environment.SourceLocation]
    -> SEDEL.PrettyPrint.FDoc
    -> [SEDEL.Environment.Err]
    -> (# [SEDEL.Environment.SourceLocation], SEDEL.PrettyPrint.FDoc #)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><S,1*U>,
     Inline: [2] -}
efbeedfa89728ade1d1897d626226fa5
  $wlookupTVarConstraint ::
    (GHC.Classes.Ord ty_name,
     Data.Text.Prettyprint.Doc.Internal.Pretty ty_name) =>
    (forall a b. m a -> (a -> m b) -> m b)
    -> (forall a. a -> m a)
    -> (forall a.
        (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp -> a)
        -> m a)
    -> Control.Monad.Error.Class.MonadError SEDEL.Environment.Err m =>
       ty_name -> m typ
  {- Arity: 7,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><L,1*U(1*C1(U),A)><C(C(S)),1*C1(C1(U))><L,C(U)><L,C(U)><L,U(1*U(A,1*C1(C1(U)),A,A,A),C(U),A)><L,U>,
     Inline: [2],
     Unfolding: (\ @ ty_name
                   @ tm_name
                   @ scheme
                   @ kind
                   @ typ
                   @ exp
                   @ m :: * -> *
                   (w :: GHC.Classes.Ord ty_name)
                   (w1 :: Data.Text.Prettyprint.Doc.Internal.Pretty ty_name)
                   (ww :: forall a b. m a -> (a -> m b) -> m b)
                   (ww1 :: forall a. a -> m a)
                   (ww2 :: forall a.
                           (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp -> a)
                           -> m a)
                   (w2 :: Control.Monad.Error.Class.MonadError
                            SEDEL.Environment.Err m)
                   (w3 :: ty_name) ->
                 let {
                   lvl8 :: m typ
                   = let {
                       lvl9 :: Data.Functor.Identity.Identity SEDEL.PrettyPrint.FDoc
                       = let {
                           eta :: Data.Text.Prettyprint.Doc.Internal.Doc
                                    SEDEL.PrettyPrint.FAnn
                           = Data.Text.Prettyprint.Doc.Internal.pretty
                               @ ty_name
                               w1
                               @ SEDEL.PrettyPrint.FAnn
                               w3
                         } in
                         let {
                           eta1 :: Data.Text.Prettyprint.Doc.Internal.Doc
                                     SEDEL.PrettyPrint.FAnn
                           = Data.Text.Prettyprint.Doc.Internal.Cat
                               @ SEDEL.PrettyPrint.FAnn
                               (Data.Text.Prettyprint.Doc.Internal.line1 @ SEDEL.PrettyPrint.FAnn)
                               eta
                         } in
                         let {
                           eta2 :: Data.Text.Prettyprint.Doc.Internal.Doc
                                     SEDEL.PrettyPrint.FAnn
                           = Data.Text.Prettyprint.Doc.Internal.Cat
                               @ SEDEL.PrettyPrint.FAnn
                               SEDEL.Environment.lookupTVarConstraint1
                               eta1
                         } in
                         (SEDEL.PrettyPrint.$w$cppr13
                            @ (Unbound.Generics.LocallyNameless.LFresh.LFreshMT
                                 Data.Functor.Identity.Identity)
                            (SEDEL.PrettyPrint.$s$fApplicativeLFreshMT_$s$fFunctorReaderT_$cfmap
                               @ (Data.Set.Internal.Set
                                    Unbound.Generics.LocallyNameless.Name.AnyName))
                              `cast`
                            (forall (a :: <*>_N) (b :: <*>_N).
                             <a -> b>_R
                             ->_R Sym (Unbound.Generics.LocallyNameless.LFresh.N:LFreshMT[0]) <Data.Functor.Identity.Identity>_N <a>_N
                             ->_R Sym (Unbound.Generics.LocallyNameless.LFresh.N:LFreshMT[0]) <Data.Functor.Identity.Identity>_N <b>_N)
                            SEDEL.PrettyPrint.$s$fLFreshLFreshMT
                            (GHC.Types.:
                               @ SEDEL.PrettyPrint.D
                               (SEDEL.PrettyPrint.DS eta2)
                               (GHC.Types.[] @ SEDEL.PrettyPrint.D)))
                           `cast`
                         (Unbound.Generics.LocallyNameless.LFresh.N:LFreshMT[0] <Data.Functor.Identity.Identity>_N <SEDEL.PrettyPrint.FDoc>_N ; Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                                                    <*>_N
                                                                                                                                                    <Data.Set.Internal.Set
                                                                                                                                                       Unbound.Generics.LocallyNameless.Name.AnyName>_R
                                                                                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                                                                                    <SEDEL.PrettyPrint.FDoc>_N)
                           (Data.Set.Internal.Tip
                              @ Unbound.Generics.LocallyNameless.Name.AnyName)
                     } in
                     GHC.Base.>>=
                       @ m
                       (Control.Monad.Error.Class.$p1MonadError
                          @ SEDEL.Environment.Err
                          @ m
                          w2)
                       @ [SEDEL.Environment.SourceLocation]
                       @ typ
                       (ww2
                          @ [SEDEL.Environment.SourceLocation]
                          (SEDEL.Environment.sourceLocation
                             @ tm_name
                             @ scheme
                             @ ty_name
                             @ kind
                             @ typ
                             @ exp))
                       (\ (loc :: [SEDEL.Environment.SourceLocation]) ->
                        Control.Monad.Error.Class.throwError
                          @ SEDEL.Environment.Err
                          @ m
                          w2
                          @ typ
                          (SEDEL.Environment.Err
                             loc
                             lvl9
                               `cast`
                             (Data.Functor.Identity.N:Identity[0] <SEDEL.PrettyPrint.FDoc>_R)))
                 } in
                 ww
                   @ (Data.Map.Internal.Map
                        ty_name (kind, typ, SEDEL.Environment.TypeValue typ))
                   @ typ
                   (ww2
                      @ (Data.Map.Internal.Map
                           ty_name (kind, typ, SEDEL.Environment.TypeValue typ))
                      (SEDEL.Environment.tyCtx
                         @ tm_name
                         @ scheme
                         @ ty_name
                         @ kind
                         @ typ
                         @ exp))
                   (\ (env :: Data.Map.Internal.Map
                                ty_name (kind, typ, SEDEL.Environment.TypeValue typ)) ->
                    case Data.Map.Internal.lookup
                           @ ty_name
                           @ (kind, typ, SEDEL.Environment.TypeValue typ)
                           w
                           w3
                           env of wild {
                      GHC.Maybe.Nothing -> lvl8
                      GHC.Maybe.Just ds
                      -> case ds of wild1 { (,,) ds1 c ds2 -> ww1 @ typ c } })) -}
10ec17c6f0d41fb3c66392015de95ce8
  $wlookupTVarSynMaybe ::
    GHC.Classes.Ord ty_name =>
    Data.Map.Internal.Map
      ty_name (kind, typ, SEDEL.Environment.TypeValue typ)
    -> ty_name -> GHC.Maybe.Maybe typ
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
     Inline: [2],
     Unfolding: (\ @ ty_name
                   @ tm_name
                   @ scheme
                   @ kind
                   @ typ
                   @ exp
                   (w :: GHC.Classes.Ord ty_name)
                   (ww :: Data.Map.Internal.Map
                            ty_name (kind, typ, SEDEL.Environment.TypeValue typ))
                   (w1 :: ty_name) ->
                 case Data.Map.Internal.lookup
                        @ ty_name
                        @ (kind, typ, SEDEL.Environment.TypeValue typ)
                        w
                        w1
                        ww of wild {
                   GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ typ
                   GHC.Maybe.Just a1
                   -> case a1 of wild1 { (,,) ds ds1 t ->
                      case t of wild2 {
                        SEDEL.Environment.TerminalType -> GHC.Maybe.Nothing @ typ
                        SEDEL.Environment.NonTerminalType t1
                        -> GHC.Maybe.Just @ typ t1 } } }) -}
c566169af2ff0f4473491f31652cb5e3
  $wlookupTmDef ::
    GHC.Classes.Ord tm_name =>
    (forall a b. (a -> b) -> m a -> m b)
    -> (forall a.
        (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp -> a)
        -> m a)
    -> tm_name
    -> m (GHC.Maybe.Maybe exp)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,U>,
     Inline: [2],
     Unfolding: (\ @ tm_name
                   @ scheme
                   @ ty_name
                   @ kind
                   @ typ
                   @ exp
                   @ m :: * -> *
                   (w :: GHC.Classes.Ord tm_name)
                   (ww :: forall a b. (a -> b) -> m a -> m b)
                   (ww1 :: forall a.
                           (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp -> a)
                           -> m a)
                   (w1 :: tm_name) ->
                 ww
                   @ (Data.Map.Internal.Map tm_name exp)
                   @ (GHC.Maybe.Maybe exp)
                   (Data.Map.Internal.lookup @ tm_name @ exp w w1)
                   (ww1
                      @ (Data.Map.Internal.Map tm_name exp)
                      (SEDEL.Environment.bndCtx
                         @ tm_name
                         @ scheme
                         @ ty_name
                         @ kind
                         @ typ
                         @ exp))) -}
ab36d6bca82e11b01a3e26f7564a31cc
  $wlookupVarTy ::
    (GHC.Classes.Ord tm_name,
     Data.Text.Prettyprint.Doc.Internal.Pretty tm_name) =>
    (forall a b. m a -> (a -> m b) -> m b)
    -> (forall a. a -> m a)
    -> (forall a.
        (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp -> a)
        -> m a)
    -> Control.Monad.Error.Class.MonadError SEDEL.Environment.Err m =>
       tm_name -> m scheme
  {- Arity: 7,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><L,1*U(1*C1(U),A)><C(C(S)),1*C1(C1(U))><L,C(U)><L,C(U)><L,U(1*U(A,1*C1(C1(U)),A,A,A),C(U),A)><L,U>,
     Inline: [2],
     Unfolding: (\ @ tm_name
                   @ scheme
                   @ ty_name
                   @ kind
                   @ typ
                   @ exp
                   @ m :: * -> *
                   (w :: GHC.Classes.Ord tm_name)
                   (w1 :: Data.Text.Prettyprint.Doc.Internal.Pretty tm_name)
                   (ww :: forall a b. m a -> (a -> m b) -> m b)
                   (ww1 :: forall a. a -> m a)
                   (ww2 :: forall a.
                           (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp -> a)
                           -> m a)
                   (w2 :: Control.Monad.Error.Class.MonadError
                            SEDEL.Environment.Err m)
                   (w3 :: tm_name) ->
                 let {
                   lvl8 :: m scheme
                   = let {
                       lvl9 :: Data.Functor.Identity.Identity SEDEL.PrettyPrint.FDoc
                       = let {
                           eta :: Data.Text.Prettyprint.Doc.Internal.Doc
                                    SEDEL.PrettyPrint.FAnn
                           = Data.Text.Prettyprint.Doc.Internal.pretty
                               @ tm_name
                               w1
                               @ SEDEL.PrettyPrint.FAnn
                               w3
                         } in
                         let {
                           eta1 :: Data.Text.Prettyprint.Doc.Internal.Doc
                                     SEDEL.PrettyPrint.FAnn
                           = Data.Text.Prettyprint.Doc.Internal.Cat
                               @ SEDEL.PrettyPrint.FAnn
                               (Data.Text.Prettyprint.Doc.Internal.line1 @ SEDEL.PrettyPrint.FAnn)
                               eta
                         } in
                         let {
                           eta2 :: Data.Text.Prettyprint.Doc.Internal.Doc
                                     SEDEL.PrettyPrint.FAnn
                           = Data.Text.Prettyprint.Doc.Internal.Cat
                               @ SEDEL.PrettyPrint.FAnn
                               SEDEL.Environment.lookupTVarConstraint1
                               eta1
                         } in
                         (SEDEL.PrettyPrint.$w$cppr13
                            @ (Unbound.Generics.LocallyNameless.LFresh.LFreshMT
                                 Data.Functor.Identity.Identity)
                            (SEDEL.PrettyPrint.$s$fApplicativeLFreshMT_$s$fFunctorReaderT_$cfmap
                               @ (Data.Set.Internal.Set
                                    Unbound.Generics.LocallyNameless.Name.AnyName))
                              `cast`
                            (forall (a :: <*>_N) (b :: <*>_N).
                             <a -> b>_R
                             ->_R Sym (Unbound.Generics.LocallyNameless.LFresh.N:LFreshMT[0]) <Data.Functor.Identity.Identity>_N <a>_N
                             ->_R Sym (Unbound.Generics.LocallyNameless.LFresh.N:LFreshMT[0]) <Data.Functor.Identity.Identity>_N <b>_N)
                            SEDEL.PrettyPrint.$s$fLFreshLFreshMT
                            (GHC.Types.:
                               @ SEDEL.PrettyPrint.D
                               (SEDEL.PrettyPrint.DS eta2)
                               (GHC.Types.[] @ SEDEL.PrettyPrint.D)))
                           `cast`
                         (Unbound.Generics.LocallyNameless.LFresh.N:LFreshMT[0] <Data.Functor.Identity.Identity>_N <SEDEL.PrettyPrint.FDoc>_N ; Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                                                    <*>_N
                                                                                                                                                    <Data.Set.Internal.Set
                                                                                                                                                       Unbound.Generics.LocallyNameless.Name.AnyName>_R
                                                                                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                                                                                    <SEDEL.PrettyPrint.FDoc>_N)
                           (Data.Set.Internal.Tip
                              @ Unbound.Generics.LocallyNameless.Name.AnyName)
                     } in
                     GHC.Base.>>=
                       @ m
                       (Control.Monad.Error.Class.$p1MonadError
                          @ SEDEL.Environment.Err
                          @ m
                          w2)
                       @ [SEDEL.Environment.SourceLocation]
                       @ scheme
                       (ww2
                          @ [SEDEL.Environment.SourceLocation]
                          (SEDEL.Environment.sourceLocation
                             @ tm_name
                             @ scheme
                             @ ty_name
                             @ kind
                             @ typ
                             @ exp))
                       (\ (loc :: [SEDEL.Environment.SourceLocation]) ->
                        Control.Monad.Error.Class.throwError
                          @ SEDEL.Environment.Err
                          @ m
                          w2
                          @ scheme
                          (SEDEL.Environment.Err
                             loc
                             lvl9
                               `cast`
                             (Data.Functor.Identity.N:Identity[0] <SEDEL.PrettyPrint.FDoc>_R)))
                 } in
                 ww
                   @ (Data.Map.Internal.Map tm_name scheme)
                   @ scheme
                   (ww2
                      @ (Data.Map.Internal.Map tm_name scheme)
                      (SEDEL.Environment.varCtx
                         @ tm_name
                         @ scheme
                         @ ty_name
                         @ kind
                         @ typ
                         @ exp))
                   (\ (env :: Data.Map.Internal.Map tm_name scheme) ->
                    case Data.Map.Internal.lookup @ tm_name @ scheme w w3 env of wild {
                      GHC.Maybe.Nothing -> lvl8
                      GHC.Maybe.Just res -> ww1 @ scheme res })) -}
2ed913c243e070adb1ab7554457b7f54
  type role Ctx nominal representational nominal representational representational representational
  data Ctx tm_name scheme ty_name kind typ exp
    = Ctx {varCtx :: Data.Map.Internal.Map tm_name scheme,
           tyCtx :: Data.Map.Internal.Map
                      ty_name (kind, typ, SEDEL.Environment.TypeValue typ),
           bndCtx :: Data.Map.Internal.Map tm_name exp,
           sourceLocation :: [SEDEL.Environment.SourceLocation]}
5cbe37339eb8c5f4163df0ce8d2c71ee
  data Err
    = Err [SEDEL.Environment.SourceLocation] SEDEL.PrettyPrint.FDoc
27d1e8ec6ea19dcaec926d8f50515711
  type ICtx =
    SEDEL.Environment.Ctx
      SEDEL.Intermediate.Syntax.TmName
      SEDEL.Intermediate.Syntax.FType
      SEDEL.Intermediate.Syntax.TyName
      SEDEL.Intermediate.Syntax.Kind
      SEDEL.Intermediate.Syntax.FType
      SEDEL.Intermediate.Syntax.FExpr
a663a611543ff4fb45576a560dd27aee
  type ITcMonad =
    SEDEL.Environment.TcMonad
      SEDEL.Intermediate.Syntax.TmName
      SEDEL.Intermediate.Syntax.FType
      SEDEL.Intermediate.Syntax.TyName
      SEDEL.Intermediate.Syntax.Kind
      SEDEL.Intermediate.Syntax.FType
      SEDEL.Intermediate.Syntax.FExpr
    :: * -> *
a8e6987da1cb24e3d3606dff7a039d9c
  type SCtx =
    SEDEL.Environment.Ctx
      SEDEL.Source.Syntax.TmName
      SEDEL.Source.Syntax.CtxType
      SEDEL.Source.Syntax.TyName
      SEDEL.Source.Syntax.Kind
      SEDEL.Source.Syntax.SType
      SEDEL.Source.Syntax.Expr
bb11cf842b3626b2d0a16273640f848c
  type STcMonad =
    SEDEL.Environment.TcMonad
      SEDEL.Source.Syntax.TmName
      SEDEL.Source.Syntax.CtxType
      SEDEL.Source.Syntax.TyName
      SEDEL.Source.Syntax.Kind
      SEDEL.Source.Syntax.SType
      SEDEL.Source.Syntax.Expr
    :: * -> *
a9e1c76117495638f7b19812378e203a
  data SourceLocation where
    SourceLocation :: SEDEL.PrettyPrint.FPretty a =>
                      Text.Megaparsec.Pos.SourcePos -> a -> SourceLocation
c81239cacbf71ecb1bed566c1788ba93
  type TcMonad tm_name scheme ty_name kind typ exp =
    Unbound.Generics.LocallyNameless.Fresh.FreshMT
      (Control.Monad.Trans.Reader.ReaderT
         (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp)
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO))
    :: * -> *
41702292c1492a119389dcad69854f2d
  data TypeValue typ = TerminalType | NonTerminalType typ
35ee88d3269604dddf892b1c00f6b865
  addTypeSynonym ::
    GHC.Classes.Ord ty_name =>
    ty_name
    -> typ
    -> kind
    -> SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
    -> SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
  {- Arity: 5,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><L,1*U><L,U><L,U><L,U(1*U,1*U,1*U,1*U)>m,
     Unfolding: InlineRule (5, True, False)
                (\ @ ty_name
                   @ typ
                   @ kind
                   @ tm_name
                   @ scheme
                   @ exp
                   ($dOrd :: GHC.Classes.Ord ty_name)
                   (v :: ty_name)
                   (t :: typ)
                   (k :: kind)
                   (eta :: SEDEL.Environment.Ctx
                             tm_name scheme ty_name kind typ exp) ->
                 SEDEL.Environment.Ctx
                   @ tm_name
                   @ scheme
                   @ ty_name
                   @ kind
                   @ typ
                   @ exp
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 -> ds })
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 ->
                    Data.Map.Strict.Internal.insert
                      @ ty_name
                      @ (kind, typ, SEDEL.Environment.TypeValue typ)
                      $dOrd
                      v
                      (k, t, SEDEL.Environment.NonTerminalType @ typ t)
                      ds1 })
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 -> ds2 })
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 ->
                    ds3 })) -}
489c85a22410e399c58a77ffb766106f
  addTypeSynonyms ::
    GHC.Classes.Ord ty_name =>
    [(ty_name, typ, kind)]
    -> SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
    -> SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
  {- Arity: 3,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U><L,U(U,U,U,U)>,
     Unfolding: (\ @ ty_name
                   @ typ
                   @ kind
                   @ tm_name
                   @ scheme
                   @ exp
                   ($dOrd :: GHC.Classes.Ord ty_name)
                   (eta :: [(ty_name, typ, kind)])
                   (eta1 :: SEDEL.Environment.Ctx
                              tm_name scheme ty_name kind typ exp) ->
                 letrec {
                   go :: [(ty_name, typ, kind)]
                         -> SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [(ty_name, typ, kind)]) ->
                     case ds of wild {
                       [] -> eta1
                       : y ys
                       -> case y of wild1 { (,,) v t k ->
                          let {
                            eta2 :: SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
                            = go ys
                          } in
                          SEDEL.Environment.Ctx
                            @ tm_name
                            @ scheme
                            @ ty_name
                            @ kind
                            @ typ
                            @ exp
                            (case eta2 of wild2 { SEDEL.Environment.Ctx ds1 ds2 ds3 ds4 ->
                             ds1 })
                            (case eta2 of wild2 { SEDEL.Environment.Ctx ds1 ds2 ds3 ds4 ->
                             Data.Map.Strict.Internal.insert
                               @ ty_name
                               @ (kind, typ, SEDEL.Environment.TypeValue typ)
                               $dOrd
                               v
                               (k, t, SEDEL.Environment.NonTerminalType @ typ t)
                               ds2 })
                            (case eta2 of wild2 { SEDEL.Environment.Ctx ds1 ds2 ds3 ds4 ->
                             ds3 })
                            (case eta2 of wild2 { SEDEL.Environment.Ctx ds1 ds2 ds3 ds4 ->
                             ds4 }) } }
                 } in
                 go eta) -}
7c1fc2ffe7762d1407261a9db8098ead
  askCtx ::
    SEDEL.Environment.TcMonad
      tm_name
      scheme
      ty_name
      kind
      typ
      exp
      (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                SEDEL.Environment.askCtx1
                  `cast`
                (forall (tm_name :: <*>_N) (scheme :: <*>_N) (ty_name :: <*>_N) (kind :: <*>_N) (typ :: <*>_N) (exp :: <*>_N).
                 (<GHC.Integer.Type.Integer>_R
                  ->_R (<SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp>_R
                        ->_R Sym (GHC.Types.N:IO[0]
                                      <Data.Either.Either
                                         SEDEL.Environment.Err
                                         (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp,
                                          GHC.Integer.Type.Integer)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                   <SEDEL.Environment.Err>_N
                                                                                   <GHC.Types.IO>_R
                                                                                   <(SEDEL.Environment.Ctx
                                                                                       tm_name
                                                                                       scheme
                                                                                       ty_name
                                                                                       kind
                                                                                       typ
                                                                                       exp,
                                                                                     GHC.Integer.Type.Integer)>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                               <*>_N
                                                                                                                               <SEDEL.Environment.Ctx
                                                                                                                                  tm_name
                                                                                                                                  scheme
                                                                                                                                  ty_name
                                                                                                                                  kind
                                                                                                                                  typ
                                                                                                                                  exp>_R
                                                                                                                               <Control.Monad.Trans.Except.ExceptT
                                                                                                                                  SEDEL.Environment.Err
                                                                                                                                  GHC.Types.IO>_R
                                                                                                                               <(SEDEL.Environment.Ctx
                                                                                                                                   tm_name
                                                                                                                                   scheme
                                                                                                                                   ty_name
                                                                                                                                   kind
                                                                                                                                   typ
                                                                                                                                   exp,
                                                                                                                                 GHC.Integer.Type.Integer)>_N)) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                            <GHC.Integer.Type.Integer>_N
                                                                                                                                                                            <Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                               (SEDEL.Environment.Ctx
                                                                                                                                                                                  tm_name
                                                                                                                                                                                  scheme
                                                                                                                                                                                  ty_name
                                                                                                                                                                                  kind
                                                                                                                                                                                  typ
                                                                                                                                                                                  exp)
                                                                                                                                                                               (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                  SEDEL.Environment.Err
                                                                                                                                                                                  GHC.Types.IO)>_R
                                                                                                                                                                            <SEDEL.Environment.Ctx
                                                                                                                                                                               tm_name
                                                                                                                                                                               scheme
                                                                                                                                                                               ty_name
                                                                                                                                                                               kind
                                                                                                                                                                               typ
                                                                                                                                                                               exp>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                                                                                                      (SEDEL.Environment.Ctx
                                                                                                                                                                                                                                                         tm_name
                                                                                                                                                                                                                                                         scheme
                                                                                                                                                                                                                                                         ty_name
                                                                                                                                                                                                                                                         kind
                                                                                                                                                                                                                                                         typ
                                                                                                                                                                                                                                                         exp)
                                                                                                                                                                                                                                                      (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                         SEDEL.Environment.Err
                                                                                                                                                                                                                                                         GHC.Types.IO)>_N <SEDEL.Environment.Ctx
                                                                                                                                                                                                                                                                             tm_name
                                                                                                                                                                                                                                                                             scheme
                                                                                                                                                                                                                                                                             ty_name
                                                                                                                                                                                                                                                                             kind
                                                                                                                                                                                                                                                                             typ
                                                                                                                                                                                                                                                                             exp>_N)) -}
64c1af883805ba2667b9c066df5cb136
  askCtx1 ::
    GHC.Integer.Type.Integer
    -> SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either
            SEDEL.Environment.Err
            (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp,
             GHC.Integer.Type.Integer) #)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ tm_name
                   @ scheme
                   @ ty_name
                   @ kind
                   @ typ
                   @ exp
                   (w1 :: GHC.Integer.Type.Integer)
                   (eta :: SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp)
                   (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 (# eta1,
                    Data.Either.Right
                      @ SEDEL.Environment.Err
                      @ (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp,
                         GHC.Integer.Type.Integer)
                      (eta, w1) #)) -}
2ed913c243e070adb1ab7554457b7f54
  bndCtx ::
    SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
    -> Data.Map.Internal.Map tm_name exp
  RecSel Left SEDEL.Environment.Ctx
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLSL),1*U(A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ tm_name
                   @ scheme
                   @ ty_name
                   @ kind
                   @ typ
                   @ exp
                   (ds :: SEDEL.Environment.Ctx
                            tm_name scheme ty_name kind typ exp) ->
                 case ds of wild { SEDEL.Environment.Ctx ds1 ds2 ds3 ds4 ->
                 ds3 }) -}
e05856fdbc2ec23cd488ac3017f0bd89
  ctxMap ::
    (Data.Map.Internal.Map tm_name scheme
     -> Data.Map.Internal.Map tm_name scheme)
    -> (Data.Map.Internal.Map
          ty_name (kind, typ, SEDEL.Environment.TypeValue typ)
        -> Data.Map.Internal.Map
             ty_name (kind, typ, SEDEL.Environment.TypeValue typ))
    -> (Data.Map.Internal.Map tm_name exp
        -> Data.Map.Internal.Map tm_name exp)
    -> SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
    -> SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*C1(U)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U)>m,
     Unfolding: InlineRule (4, True, False)
                (\ @ tm_name
                   @ scheme
                   @ ty_name
                   @ kind
                   @ typ
                   @ exp
                   (f1 :: Data.Map.Internal.Map tm_name scheme
                          -> Data.Map.Internal.Map tm_name scheme)
                   (f2 :: Data.Map.Internal.Map
                            ty_name (kind, typ, SEDEL.Environment.TypeValue typ)
                          -> Data.Map.Internal.Map
                               ty_name (kind, typ, SEDEL.Environment.TypeValue typ))
                   (f3 :: Data.Map.Internal.Map tm_name exp
                          -> Data.Map.Internal.Map tm_name exp)
                   (ctx :: SEDEL.Environment.Ctx
                             tm_name scheme ty_name kind typ exp) ->
                 SEDEL.Environment.Ctx
                   @ tm_name
                   @ scheme
                   @ ty_name
                   @ kind
                   @ typ
                   @ exp
                   (f1
                      (case ctx of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 -> ds }))
                   (f2
                      (case ctx of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 -> ds1 }))
                   (f3
                      (case ctx of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 -> ds2 }))
                   (case ctx of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 ->
                    ds3 })) -}
365805f3c496f52b27027b3e0c930fb7
  emptyCtx ::
    SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (\ @ tm_name @ scheme @ ty_name @ kind @ typ @ exp ->
                 SEDEL.Environment.Ctx
                   @ tm_name
                   @ scheme
                   @ ty_name
                   @ kind
                   @ typ
                   @ exp
                   (Data.Map.Internal.Tip @ tm_name @ scheme)
                   (Data.Map.Internal.Tip
                      @ ty_name
                      @ (kind, typ, SEDEL.Environment.TypeValue typ))
                   (Data.Map.Internal.Tip @ tm_name @ exp)
                   (GHC.Types.[] @ SEDEL.Environment.SourceLocation)) -}
9b366fb6bce0343330f033f46888d5f8
  errThrow ::
    (SEDEL.PrettyPrint.FPretty a,
     Control.Monad.Error.Class.MonadError SEDEL.Environment.Err m,
     Control.Monad.Reader.Class.MonadReader
       (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp) m) =>
    a -> m b
  {- Arity: 4,
     Strictness: <L,1*C1(C1(C1(U)))><S(S(LC(C(S))LLL)LL),1*U(1*U(A,1*C1(C1(U)),A,A,A),C(U),A)><L,1*U(A,A,A,1*C1(U))><L,U>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ m :: * -> *
                   @ tm_name
                   @ scheme
                   @ ty_name
                   @ kind
                   @ typ
                   @ exp
                   @ b
                   (w :: SEDEL.PrettyPrint.FPretty a)
                   (w1 :: Control.Monad.Error.Class.MonadError
                            SEDEL.Environment.Err m)
                   (w2 :: Control.Monad.Reader.Class.MonadReader
                            (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp) m)
                   (w3 :: a) ->
                 case w1 of ww { Control.Monad.Error.Class.C:MonadError ww1 ww2 ww3 ->
                 case ww1 of ww4 { GHC.Base.C:Monad ww5 ww6 ww7 ww8 ww9 ->
                 SEDEL.Environment.$werrThrow
                   @ a
                   @ m
                   @ tm_name
                   @ scheme
                   @ ty_name
                   @ kind
                   @ typ
                   @ exp
                   @ b
                   w
                   ww6
                   ww2
                   w2
                   w3 } }) -}
d9f5dbfaf00415a3e98f8dbd355b1242
  extendConstrainedSTVarCtx ::
    SEDEL.Source.Syntax.TyName
    -> SEDEL.Source.Syntax.SType
    -> SEDEL.Environment.SCtx
    -> SEDEL.Environment.SCtx
  {- Arity: 3, Strictness: <L,1*U><L,U><L,U(1*U,1*U,1*U,1*U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ (v :: SEDEL.Source.Syntax.TyName)
                   (t :: SEDEL.Source.Syntax.SType)
                   (eta :: SEDEL.Environment.Ctx
                             SEDEL.Source.Syntax.TmName
                             SEDEL.Source.Syntax.CtxType
                             SEDEL.Source.Syntax.TyName
                             SEDEL.Source.Syntax.Kind
                             SEDEL.Source.Syntax.SType
                             SEDEL.Source.Syntax.Expr) ->
                 SEDEL.Environment.Ctx
                   @ SEDEL.Source.Syntax.TmName
                   @ SEDEL.Source.Syntax.CtxType
                   @ SEDEL.Source.Syntax.TyName
                   @ SEDEL.Source.Syntax.Kind
                   @ SEDEL.Source.Syntax.SType
                   @ SEDEL.Source.Syntax.Expr
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 -> ds })
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 ->
                    SEDEL.Environment.$sinsert_$sgo8
                      @ (SEDEL.Source.Syntax.Kind, SEDEL.Source.Syntax.SType,
                         SEDEL.Environment.TypeValue SEDEL.Source.Syntax.SType)
                      v
                      (SEDEL.Source.Syntax.Star, t,
                       SEDEL.Environment.TerminalType @ SEDEL.Source.Syntax.SType)
                      ds1 })
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 -> ds2 })
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 ->
                    ds3 })) -}
5fd03972d8f6a1ec83077de64768f21f
  extendConstrainedTVarCtx ::
    SEDEL.Intermediate.Syntax.TyName
    -> SEDEL.Intermediate.Syntax.FType
    -> SEDEL.Environment.ICtx
    -> SEDEL.Environment.ICtx
  {- Arity: 3, Strictness: <L,1*U><L,U><L,U(1*U,1*U,1*U,1*U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ (v :: SEDEL.Intermediate.Syntax.TyName)
                   (t :: SEDEL.Intermediate.Syntax.FType)
                   (eta :: SEDEL.Environment.Ctx
                             SEDEL.Intermediate.Syntax.TmName
                             SEDEL.Intermediate.Syntax.FType
                             SEDEL.Intermediate.Syntax.TyName
                             SEDEL.Intermediate.Syntax.Kind
                             SEDEL.Intermediate.Syntax.FType
                             SEDEL.Intermediate.Syntax.FExpr) ->
                 SEDEL.Environment.Ctx
                   @ SEDEL.Intermediate.Syntax.TmName
                   @ SEDEL.Intermediate.Syntax.FType
                   @ SEDEL.Intermediate.Syntax.TyName
                   @ SEDEL.Intermediate.Syntax.Kind
                   @ SEDEL.Intermediate.Syntax.FType
                   @ SEDEL.Intermediate.Syntax.FExpr
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 -> ds })
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 ->
                    SEDEL.Environment.$sinsert_$sgo1
                      @ (SEDEL.Intermediate.Syntax.Kind, SEDEL.Intermediate.Syntax.FType,
                         SEDEL.Environment.TypeValue SEDEL.Intermediate.Syntax.FType)
                      v
                      (SEDEL.Intermediate.Syntax.Star, t,
                       SEDEL.Environment.TerminalType @ SEDEL.Intermediate.Syntax.FType)
                      ds1 })
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 -> ds2 })
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 ->
                    ds3 })) -}
0017739aeb1de8a127ef3095d7fba865
  extendSourceLocation ::
    (Control.Monad.Reader.Class.MonadReader
       (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp) m,
     SEDEL.PrettyPrint.FPretty t) =>
    Text.Megaparsec.Pos.SourcePos -> t -> m a -> m a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LLC(S)L),1*U(A,A,1*C1(U),A)><L,U><L,U><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ tm_name
                   @ scheme
                   @ ty_name
                   @ kind
                   @ typ
                   @ exp
                   @ m :: * -> *
                   @ t
                   @ a
                   ($dMonadReader :: Control.Monad.Reader.Class.MonadReader
                                       (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp)
                                       m)
                   ($dFPretty :: SEDEL.PrettyPrint.FPretty t)
                   (p :: Text.Megaparsec.Pos.SourcePos)
                   (t1 :: t) ->
                 let {
                   lvl8 :: SEDEL.Environment.SourceLocation
                   = SEDEL.Environment.SourceLocation @ t $dFPretty p t1
                 } in
                 Control.Monad.Reader.Class.local
                   @ (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp)
                   @ m
                   $dMonadReader
                   @ a
                   (\ (e :: SEDEL.Environment.Ctx
                              tm_name scheme ty_name kind typ exp) ->
                    case e of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 ->
                    SEDEL.Environment.Ctx
                      @ tm_name
                      @ scheme
                      @ ty_name
                      @ kind
                      @ typ
                      @ exp
                      ds
                      ds1
                      ds2
                      (GHC.Types.: @ SEDEL.Environment.SourceLocation lvl8 ds3) })) -}
bd5db6805ccf76790572a763936c5456
  extendTVarCtx ::
    SEDEL.Intermediate.Syntax.TyName
    -> SEDEL.Intermediate.Syntax.Kind
    -> SEDEL.Environment.ICtx
    -> SEDEL.Environment.ICtx
  {- Arity: 3, Strictness: <L,1*U><L,U><L,U(1*U,1*U,1*U,1*U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ (v :: SEDEL.Intermediate.Syntax.TyName)
                   (k :: SEDEL.Intermediate.Syntax.Kind)
                   (eta :: SEDEL.Environment.Ctx
                             SEDEL.Intermediate.Syntax.TmName
                             SEDEL.Intermediate.Syntax.FType
                             SEDEL.Intermediate.Syntax.TyName
                             SEDEL.Intermediate.Syntax.Kind
                             SEDEL.Intermediate.Syntax.FType
                             SEDEL.Intermediate.Syntax.FExpr) ->
                 SEDEL.Environment.Ctx
                   @ SEDEL.Intermediate.Syntax.TmName
                   @ SEDEL.Intermediate.Syntax.FType
                   @ SEDEL.Intermediate.Syntax.TyName
                   @ SEDEL.Intermediate.Syntax.Kind
                   @ SEDEL.Intermediate.Syntax.FType
                   @ SEDEL.Intermediate.Syntax.FExpr
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 -> ds })
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 ->
                    SEDEL.Environment.$sinsert_$sgo1
                      @ (SEDEL.Intermediate.Syntax.Kind, SEDEL.Intermediate.Syntax.FType,
                         SEDEL.Environment.TypeValue SEDEL.Intermediate.Syntax.FType)
                      v
                      (k, SEDEL.Intermediate.Syntax.TopT,
                       SEDEL.Environment.TerminalType @ SEDEL.Intermediate.Syntax.FType)
                      ds1 })
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 -> ds2 })
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 ->
                    ds3 })) -}
f10937fb0d700bcf9a21943ad3a4937f
  extendVarCtx ::
    GHC.Classes.Ord tm_name =>
    tm_name
    -> scheme
    -> SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
    -> SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
  {- Arity: 4,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><L,1*U><L,1*U><L,U(1*U,1*U,1*U,1*U)>m,
     Unfolding: InlineRule (4, True, False)
                (\ @ tm_name
                   @ scheme
                   @ ty_name
                   @ kind
                   @ typ
                   @ exp
                   ($dOrd :: GHC.Classes.Ord tm_name)
                   (v :: tm_name)
                   (t :: scheme)
                   (ctx :: SEDEL.Environment.Ctx
                             tm_name scheme ty_name kind typ exp) ->
                 SEDEL.Environment.Ctx
                   @ tm_name
                   @ scheme
                   @ ty_name
                   @ kind
                   @ typ
                   @ exp
                   (case ctx of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 ->
                    Data.Map.Strict.Internal.insert @ tm_name @ scheme $dOrd v t ds })
                   (case ctx of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 -> ds1 })
                   (case ctx of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 -> ds2 })
                   (case ctx of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 ->
                    ds3 })) -}
48b7a568e8f7f5e747e9c00730f1a2ff
  extendVarCtxs ::
    GHC.Classes.Ord tm_name =>
    [(tm_name, scheme)]
    -> SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
    -> SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
  {- Arity: 3,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U><L,U(U,U,U,U)>,
     Unfolding: (\ @ tm_name
                   @ scheme
                   @ ty_name
                   @ kind
                   @ typ
                   @ exp
                   ($dOrd :: GHC.Classes.Ord tm_name)
                   (eta :: [(tm_name, scheme)])
                   (eta1 :: SEDEL.Environment.Ctx
                              tm_name scheme ty_name kind typ exp) ->
                 letrec {
                   go :: [(tm_name, scheme)]
                         -> SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [(tm_name, scheme)]) ->
                     case ds of wild {
                       [] -> eta1
                       : y ys
                       -> let {
                            eta2 :: SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
                            = go ys
                          } in
                          SEDEL.Environment.Ctx
                            @ tm_name
                            @ scheme
                            @ ty_name
                            @ kind
                            @ typ
                            @ exp
                            (case y of wild1 { (,) x ds1 ->
                             case eta2 of wild2 { SEDEL.Environment.Ctx ds2 ds3 ds4 ds5 ->
                             Data.Map.Strict.Internal.insert
                               @ tm_name
                               @ scheme
                               $dOrd
                               x
                               ds1
                               ds2 } })
                            (case eta2 of wild1 { SEDEL.Environment.Ctx ds1 ds2 ds3 ds4 ->
                             ds2 })
                            (case eta2 of wild1 { SEDEL.Environment.Ctx ds1 ds2 ds3 ds4 ->
                             ds3 })
                            (case eta2 of wild1 { SEDEL.Environment.Ctx ds1 ds2 ds3 ds4 ->
                             ds4 }) }
                 } in
                 go eta) -}
10baf867c0f6190309b03abde593233d
  getSourceLocation ::
    Control.Monad.Reader.Class.MonadReader
      (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp) m =>
    m [SEDEL.Environment.SourceLocation]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLC(S)),1*U(A,A,A,1*C1(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ @ tm_name
                   @ scheme
                   @ ty_name
                   @ kind
                   @ typ
                   @ exp
                   @ m :: * -> *
                   ($dMonadReader :: Control.Monad.Reader.Class.MonadReader
                                       (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp)
                                       m) ->
                 Control.Monad.Reader.Class.reader
                   @ (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp)
                   @ m
                   $dMonadReader
                   @ [SEDEL.Environment.SourceLocation]
                   (SEDEL.Environment.sourceLocation
                      @ tm_name
                      @ scheme
                      @ ty_name
                      @ kind
                      @ typ
                      @ exp)) -}
f7079019db813b242790e85f6101c903
  localCtx ::
    (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
     -> SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp)
    -> SEDEL.Environment.TcMonad tm_name scheme ty_name kind typ exp a
    -> SEDEL.Environment.TcMonad tm_name scheme ty_name kind typ exp a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(U)><L,1*C1(C(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                (\ @ tm_name @ scheme @ ty_name @ kind @ typ @ exp @ a ->
                 SEDEL.Environment.localCtx1
                   @ a
                   @ exp
                   @ typ
                   @ kind
                   @ ty_name
                   @ scheme
                   @ tm_name)
                  `cast`
                (forall (tm_name :: <*>_N) (scheme :: <*>_N) (ty_name :: <*>_N) (kind :: <*>_N) (typ :: <*>_N) (exp :: <*>_N) (a :: <*>_N).
                 <SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
                  -> SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp>_R
                 ->_R <Unbound.Generics.LocallyNameless.Fresh.FreshMT
                         (Control.Monad.Trans.Reader.ReaderT
                            (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp)
                            (Control.Monad.Trans.Except.ExceptT
                               SEDEL.Environment.Err GHC.Types.IO))
                         a>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <GHC.Integer.Type.Integer>_N
                               <Control.Monad.Trans.Reader.ReaderT
                                  (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp)
                                  (Control.Monad.Trans.Except.ExceptT
                                     SEDEL.Environment.Err GHC.Types.IO)>_R
                               <a>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                     (SEDEL.Environment.Ctx
                                                                                                        tm_name
                                                                                                        scheme
                                                                                                        ty_name
                                                                                                        kind
                                                                                                        typ
                                                                                                        exp)
                                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                                        SEDEL.Environment.Err
                                                                                                        GHC.Types.IO)>_N <a>_N) -}
895fc8bde74c1c9ad74bb8cb0cac20cf
  localCtx1 ::
    (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
     -> SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp)
    -> Unbound.Generics.LocallyNameless.Fresh.FreshMT
         (Control.Monad.Trans.Reader.ReaderT
            (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp)
            (Control.Monad.Trans.Except.ExceptT
               SEDEL.Environment.Err GHC.Types.IO))
         a
    -> GHC.Integer.Type.Integer
    -> Control.Monad.Trans.Reader.ReaderT
         (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp)
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         (a, GHC.Integer.Type.Integer)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(U)><L,1*C1(C(U))><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ exp
                   @ typ
                   @ kind
                   @ ty_name
                   @ scheme
                   @ tm_name
                   (f :: SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
                         -> SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp)
                   (x :: Unbound.Generics.LocallyNameless.Fresh.FreshMT
                           (Control.Monad.Trans.Reader.ReaderT
                              (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp)
                              (Control.Monad.Trans.Except.ExceptT
                                 SEDEL.Environment.Err GHC.Types.IO))
                           a)
                   (x1 :: GHC.Integer.Type.Integer) ->
                 let {
                   m1 :: Control.Monad.Trans.Reader.ReaderT
                           (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp)
                           (Control.Monad.Trans.Except.ExceptT
                              SEDEL.Environment.Err GHC.Types.IO)
                           (a, GHC.Integer.Type.Integer)
                   = x `cast`
                     (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0] <Control.Monad.Trans.Reader.ReaderT
                                                                             (SEDEL.Environment.Ctx
                                                                                tm_name
                                                                                scheme
                                                                                ty_name
                                                                                kind
                                                                                typ
                                                                                exp)
                                                                             (Control.Monad.Trans.Except.ExceptT
                                                                                SEDEL.Environment.Err
                                                                                GHC.Types.IO)>_N <a>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                             <GHC.Integer.Type.Integer>_N
                                                                                                             <Control.Monad.Trans.Reader.ReaderT
                                                                                                                (SEDEL.Environment.Ctx
                                                                                                                   tm_name
                                                                                                                   scheme
                                                                                                                   ty_name
                                                                                                                   kind
                                                                                                                   typ
                                                                                                                   exp)
                                                                                                                (Control.Monad.Trans.Except.ExceptT
                                                                                                                   SEDEL.Environment.Err
                                                                                                                   GHC.Types.IO)>_R
                                                                                                             <a>_N)
                       x1
                 } in
                 (\ (x2 :: SEDEL.Environment.Ctx
                             tm_name scheme ty_name kind typ exp) ->
                  m1
                    `cast`
                  (Control.Monad.Trans.Reader.N:ReaderT[0]
                       <*>_N
                       <SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp>_R
                       <Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO>_R
                       <(a, GHC.Integer.Type.Integer)>_N)
                    (f x2))
                   `cast`
                 (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                           <*>_N
                           <SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp>_R
                           <Control.Monad.Trans.Except.ExceptT
                              SEDEL.Environment.Err GHC.Types.IO>_R
                           <(a, GHC.Integer.Type.Integer)>_N))) -}
d64d8df495afc444078c3182c43b4602
  lookupTVarConstraint ::
    (GHC.Classes.Ord ty_name,
     Data.Text.Prettyprint.Doc.Internal.Pretty ty_name,
     Control.Monad.Reader.Class.MonadReader
       (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp) m,
     Control.Monad.Error.Class.MonadError SEDEL.Environment.Err m) =>
    ty_name -> m typ
  {- Arity: 5,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><L,1*U(1*C1(U),A)><S(S(LC(C(S))LLL)LLL),1*U(1*U(A,1*C1(C1(U)),A,C(U),A),A,A,C(U))><L,U(U(A,C(C1(U)),A,A,A),C(U),A)><L,U>,
     Inline: [2],
     Unfolding: InlineRule (5, True, False)
                (\ @ ty_name
                   @ tm_name
                   @ scheme
                   @ kind
                   @ typ
                   @ exp
                   @ m :: * -> *
                   (w :: GHC.Classes.Ord ty_name)
                   (w1 :: Data.Text.Prettyprint.Doc.Internal.Pretty ty_name)
                   (w2 :: Control.Monad.Reader.Class.MonadReader
                            (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp) m)
                   (w3 :: Control.Monad.Error.Class.MonadError
                            SEDEL.Environment.Err m)
                   (w4 :: ty_name) ->
                 case w2 of ww { Control.Monad.Reader.Class.C:MonadReader ww1 ww2 ww3 ww4 ->
                 case ww1 of ww5 { GHC.Base.C:Monad ww6 ww7 ww8 ww9 ww10 ->
                 SEDEL.Environment.$wlookupTVarConstraint
                   @ ty_name
                   @ tm_name
                   @ scheme
                   @ kind
                   @ typ
                   @ exp
                   @ m
                   w
                   w1
                   ww7
                   ww9
                   ww4
                   w3
                   w4 } }) -}
02867362f7783dfaeae35b9388627767
  lookupTVarConstraint1 ::
    Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn
  {- Unfolding: (Data.Text.Prettyprint.Doc.Internal.$fIsStringDoc_$cfromString
                   @ SEDEL.PrettyPrint.FAnn
                   (GHC.CString.unpackCString#
                      SEDEL.Environment.lookupTVarConstraint2)) -}
66d1531b411b8244e047b32164ec9fdb
  lookupTVarConstraint2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Not in scope:"#) -}
3c1b519165119bd60bb522820e4e42d8
  lookupTVarConstraintMaybe ::
    GHC.Classes.Ord ty_name =>
    SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
    -> ty_name -> GHC.Maybe.Maybe typ
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><S(LSLL),1*U(A,1*U,A,A)><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ ty_name
                   @ tm_name
                   @ scheme
                   @ kind
                   @ typ
                   @ exp
                   ($dOrd :: GHC.Classes.Ord ty_name)
                   (ctx :: SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp)
                   (v :: ty_name) ->
                 case ctx of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 ->
                 case Data.Map.Internal.lookup
                        @ ty_name
                        @ (kind, typ, SEDEL.Environment.TypeValue typ)
                        $dOrd
                        v
                        ds1 of wild1 {
                   GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ typ
                   GHC.Maybe.Just a1
                   -> GHC.Maybe.Just
                        @ typ
                        (case a1 of wild2 { (,,) ds4 t ds5 -> t }) } }) -}
a2bb5dddbfd1b1f5e21f851913339cf5
  lookupTVarKindMaybe ::
    (GHC.Show.Show ty_name, GHC.Show.Show kind, GHC.Show.Show typ,
     GHC.Classes.Ord ty_name) =>
    SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
    -> ty_name -> GHC.Maybe.Maybe kind
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,A><L,A><L,A><L,U(A,C(C1(U)),A,A,A,A,A,A)><S(LSLL),1*U(A,1*U,A,A)><S,1*U>,
     Unfolding: InlineRule (6, True, False)
                (\ @ ty_name
                   @ kind
                   @ typ
                   @ tm_name
                   @ scheme
                   @ exp
                   ($dShow :: GHC.Show.Show ty_name)
                   ($dShow1 :: GHC.Show.Show kind)
                   ($dShow2 :: GHC.Show.Show typ)
                   ($dOrd :: GHC.Classes.Ord ty_name)
                   (ctx :: SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp)
                   (v :: ty_name) ->
                 case ctx of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 ->
                 case Data.Map.Internal.lookup
                        @ ty_name
                        @ (kind, typ, SEDEL.Environment.TypeValue typ)
                        $dOrd
                        v
                        ds1 of wild1 {
                   GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ kind
                   GHC.Maybe.Just a1
                   -> GHC.Maybe.Just
                        @ kind
                        (case a1 of wild2 { (,,) k ds4 ds5 -> k }) } }) -}
c90bf5afd5a52b7bd41e9b4aa96ed766
  lookupTVarSynMaybe ::
    GHC.Classes.Ord ty_name =>
    SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
    -> ty_name -> GHC.Maybe.Maybe typ
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><S(LSLL),1*U(A,1*U,A,A)><S,1*U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ ty_name
                   @ tm_name
                   @ scheme
                   @ kind
                   @ typ
                   @ exp
                   (w :: GHC.Classes.Ord ty_name)
                   (w1 :: SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp)
                   (w2 :: ty_name) ->
                 case w1 of ww { SEDEL.Environment.Ctx ww1 ww2 ww3 ww4 ->
                 SEDEL.Environment.$wlookupTVarSynMaybe
                   @ ty_name
                   @ tm_name
                   @ scheme
                   @ kind
                   @ typ
                   @ exp
                   w
                   ww2
                   w2 }) -}
c82a3c0b7eef4f69ecf35f84deb3920b
  lookupTmDef ::
    (GHC.Classes.Ord tm_name,
     Control.Monad.Reader.Class.MonadReader
       (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp) m) =>
    tm_name -> m (GHC.Maybe.Maybe exp)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><S(S(S(S(C(C(S))L)LLLLL)LLLL)LLL),1*U(1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A),A,A,1*C1(U))><L,U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ tm_name
                   @ scheme
                   @ ty_name
                   @ kind
                   @ typ
                   @ exp
                   @ m :: * -> *
                   (w :: GHC.Classes.Ord tm_name)
                   (w1 :: Control.Monad.Reader.Class.MonadReader
                            (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp) m)
                   (w2 :: tm_name) ->
                 case w1 of ww { Control.Monad.Reader.Class.C:MonadReader ww1 ww2 ww3 ww4 ->
                 case ww1 of ww5 { GHC.Base.C:Monad ww6 ww7 ww8 ww9 ww10 ->
                 case ww6 of ww11 { GHC.Base.C:Applicative ww12 ww13 ww14 ww15 ww16 ww17 ->
                 case ww12 of ww18 { GHC.Base.C:Functor ww19 ww20 ->
                 SEDEL.Environment.$wlookupTmDef
                   @ tm_name
                   @ scheme
                   @ ty_name
                   @ kind
                   @ typ
                   @ exp
                   @ m
                   w
                   ww19
                   ww4
                   w2 } } } }) -}
26f2411054e0e29e4c5317da6665eac1
  lookupVarTy ::
    (GHC.Classes.Ord tm_name,
     Data.Text.Prettyprint.Doc.Internal.Pretty tm_name,
     Control.Monad.Reader.Class.MonadReader
       (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp) m,
     Control.Monad.Error.Class.MonadError SEDEL.Environment.Err m) =>
    tm_name -> m scheme
  {- Arity: 5,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><L,1*U(1*C1(U),A)><S(S(LC(C(S))LLL)LLL),1*U(1*U(A,1*C1(C1(U)),A,C(U),A),A,A,C(U))><L,U(U(A,C(C1(U)),A,A,A),C(U),A)><L,U>,
     Inline: [2],
     Unfolding: InlineRule (5, True, False)
                (\ @ tm_name
                   @ scheme
                   @ ty_name
                   @ kind
                   @ typ
                   @ exp
                   @ m :: * -> *
                   (w :: GHC.Classes.Ord tm_name)
                   (w1 :: Data.Text.Prettyprint.Doc.Internal.Pretty tm_name)
                   (w2 :: Control.Monad.Reader.Class.MonadReader
                            (SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp) m)
                   (w3 :: Control.Monad.Error.Class.MonadError
                            SEDEL.Environment.Err m)
                   (w4 :: tm_name) ->
                 case w2 of ww { Control.Monad.Reader.Class.C:MonadReader ww1 ww2 ww3 ww4 ->
                 case ww1 of ww5 { GHC.Base.C:Monad ww6 ww7 ww8 ww9 ww10 ->
                 SEDEL.Environment.$wlookupVarTy
                   @ tm_name
                   @ scheme
                   @ ty_name
                   @ kind
                   @ typ
                   @ exp
                   @ m
                   w
                   w1
                   ww7
                   ww9
                   ww4
                   w3
                   w4 } }) -}
6af5d2db70c7d683844b6e7c51a88f12
  runTcMonad ::
    SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
    -> SEDEL.Environment.TcMonad tm_name scheme ty_name kind typ exp a
    -> GHC.Types.IO (Data.Either.Either SEDEL.Environment.Err a)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><C(C(C(S(SS)))),1*C1(C1(C1(U(U,1*U))))><S,U>,
     Unfolding: InlineRule (0, True, True)
                (\ @ tm_name @ scheme @ ty_name @ kind @ typ @ exp @ a ->
                 SEDEL.Environment.runTcMonad1
                   @ a
                   @ exp
                   @ typ
                   @ kind
                   @ ty_name
                   @ scheme
                   @ tm_name)
                  `cast`
                (forall (tm_name :: <*>_N) (scheme :: <*>_N) (ty_name :: <*>_N) (kind :: <*>_N) (typ :: <*>_N) (exp :: <*>_N) (a :: <*>_N).
                 <SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp>_R
                 ->_R <SEDEL.Environment.TcMonad
                         tm_name scheme ty_name kind typ exp a>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <Data.Either.Either SEDEL.Environment.Err a>_R)) -}
11bfaa89b6a85bb63d1323e733cc6ff5
  runTcMonad1 ::
    SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
    -> SEDEL.Environment.TcMonad tm_name scheme ty_name kind typ exp a
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either SEDEL.Environment.Err a #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><C(C(C(S(SS)))),1*C1(C1(C1(U(U,1*U))))><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ exp
                   @ typ
                   @ kind
                   @ ty_name
                   @ scheme
                   @ tm_name
                   (env :: SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp)
                   (m :: SEDEL.Environment.TcMonad
                           tm_name scheme ty_name kind typ exp a)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case ((m `cast`
                        (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0] <Control.Monad.Trans.Reader.ReaderT
                                                                                (SEDEL.Environment.Ctx
                                                                                   tm_name
                                                                                   scheme
                                                                                   ty_name
                                                                                   kind
                                                                                   typ
                                                                                   exp)
                                                                                (Control.Monad.Trans.Except.ExceptT
                                                                                   SEDEL.Environment.Err
                                                                                   GHC.Types.IO)>_N <a>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                <GHC.Integer.Type.Integer>_N
                                                                                                                <Control.Monad.Trans.Reader.ReaderT
                                                                                                                   (SEDEL.Environment.Ctx
                                                                                                                      tm_name
                                                                                                                      scheme
                                                                                                                      ty_name
                                                                                                                      kind
                                                                                                                      typ
                                                                                                                      exp)
                                                                                                                   (Control.Monad.Trans.Except.ExceptT
                                                                                                                      SEDEL.Environment.Err
                                                                                                                      GHC.Types.IO)>_R
                                                                                                                <a>_N)
                          Unbound.Generics.LocallyNameless.Fresh.runFreshM1)
                         `cast`
                       (Control.Monad.Trans.Reader.N:ReaderT[0]
                            <*>_N
                            <SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp>_R
                            <Control.Monad.Trans.Except.ExceptT
                               SEDEL.Environment.Err GHC.Types.IO>_R
                            <(a, GHC.Integer.Type.Integer)>_N)
                         env)
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <SEDEL.Environment.Err>_N
                           <GHC.Types.IO>_R
                           <(a, GHC.Integer.Type.Integer)>_N ; GHC.Types.N:IO[0]
                                                                   <Data.Either.Either
                                                                      SEDEL.Environment.Err
                                                                      (a,
                                                                       GHC.Integer.Type.Integer)>_R)
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   Data.Either.Left e1
                   -> (# ipv, Data.Either.Left @ SEDEL.Environment.Err @ a e1 #)
                   Data.Either.Right x
                   -> (# ipv,
                         Data.Either.Right
                           @ SEDEL.Environment.Err
                           @ a
                           (case x of wild1 { (,) a1 ds2 -> a1 }) #) } }) -}
2ed913c243e070adb1ab7554457b7f54
  sourceLocation ::
    SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
    -> [SEDEL.Environment.SourceLocation]
  RecSel Left SEDEL.Environment.Ctx
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLS),1*U(A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ tm_name
                   @ scheme
                   @ ty_name
                   @ kind
                   @ typ
                   @ exp
                   (ds :: SEDEL.Environment.Ctx
                            tm_name scheme ty_name kind typ exp) ->
                 case ds of wild { SEDEL.Environment.Ctx ds1 ds2 ds3 ds4 ->
                 ds4 }) -}
2ed913c243e070adb1ab7554457b7f54
  tyCtx ::
    SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
    -> Data.Map.Internal.Map
         ty_name (kind, typ, SEDEL.Environment.TypeValue typ)
  RecSel Left SEDEL.Environment.Ctx
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSLL),1*U(A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ tm_name
                   @ scheme
                   @ ty_name
                   @ kind
                   @ typ
                   @ exp
                   (ds :: SEDEL.Environment.Ctx
                            tm_name scheme ty_name kind typ exp) ->
                 case ds of wild { SEDEL.Environment.Ctx ds1 ds2 ds3 ds4 ->
                 ds2 }) -}
2ed913c243e070adb1ab7554457b7f54
  varCtx ::
    SEDEL.Environment.Ctx tm_name scheme ty_name kind typ exp
    -> Data.Map.Internal.Map tm_name scheme
  RecSel Left SEDEL.Environment.Ctx
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLLL),1*U(1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ tm_name
                   @ scheme
                   @ ty_name
                   @ kind
                   @ typ
                   @ exp
                   (ds :: SEDEL.Environment.Ctx
                            tm_name scheme ty_name kind typ exp) ->
                 case ds of wild { SEDEL.Environment.Ctx ds1 ds2 ds3 ds4 ->
                 ds1 }) -}
instance SEDEL.PrettyPrint.FPretty [SEDEL.Environment.Err]
  = SEDEL.Environment.$fFPrettyErr
instance GHC.Base.Monoid [SEDEL.Environment.Err]
  = SEDEL.Environment.$fMonoidErr
instance GHC.Base.Semigroup [SEDEL.Environment.Err]
  = SEDEL.Environment.$fSemigroupErr
instance GHC.Show.Show [SEDEL.Environment.TypeValue]
  = SEDEL.Environment.$fShowTypeValue
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

