
==================== FINAL INTERFACE ====================
2019-08-12 12:24:38.831102 UTC

interface sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.Parser.Parser 8063
  interface hash: 6fdd479a64d9ad70bac0d845db7d0c6e
  ABI hash: bb8a79a4e3aa257f41acb8b8d9d9f338
  export-list hash: 19143f0b44416c3c324979ec480ac12f
  orphan hash: 6daea9d28871cefd200dfc641051ad7a
  flag hash: 16a70dcce31f6ef91de5271d59b4cb56
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  SEDEL.Parser.Parser.parseModule
module dependencies: SEDEL.Common SEDEL.Intermediate.Syntax
                     SEDEL.Source.Syntax SEDEL.Util
package dependencies: array-0.5.3.0 async-2.2.1 base-4.12.0.0
                      base-orphans-0.8 bifunctors-5.5.3 binary-0.8.6.0
                      bytestring-0.10.8.2 case-insensitive-1.2.0.11 comonad-5.0.4
                      containers-0.6.0.1 deepseq-1.4.4.0 distributive-0.6
                      exceptions-0.10.0 ghc-boot-th-8.6.3 ghc-prim-0.5.3 hashable-1.2.7.0
                      integer-gmp-1.0.2.0 integer-logarithms-1.0.2.2 megaparsec-7.0.4
                      mtl-2.2.2 parser-combinators-1.0.1 pretty-1.1.3.6
                      prettyprinter-1.2.1 primitive-0.6.4.0 profunctors-5.3
                      protolude-0.2.3 scientific-0.3.6.2 stm-2.5.0.0 tagged-0.8.6
                      template-haskell-2.14.0.0 text-1.2.3.1 transformers-0.5.5.0
                      unbound-generics-0.4.0
orphans: sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.Source.Syntax
         sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.Intermediate.Syntax
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.1:Data.Text.Lazy
         text-1.2.3.1:Data.Text binary-0.8.6.0:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show stm-2.5.0.0:Control.Monad.STM
         transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         bifunctors-5.5.3:Data.Bifunctor.Biff
                         bifunctors-5.5.3:Data.Bifunctor.Clown
                         bifunctors-5.5.3:Data.Bifunctor.Joker
                         bifunctors-5.5.3:Data.Bifunctor.Product
                         bifunctors-5.5.3:Data.Bifunctor.Sum
                         bifunctors-5.5.3:Data.Bifunctor.Tannen
                         containers-0.6.0.1:Data.IntMap.Internal
                         containers-0.6.0.1:Data.IntSet.Internal
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Sequence.Internal
                         containers-0.6.0.1:Data.Set.Internal containers-0.6.0.1:Data.Tree
                         ghc-boot-th-8.6.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.6.3:GHC.LanguageExtensions.Type
                         megaparsec-7.0.4:Text.Megaparsec.Error
                         megaparsec-7.0.4:Text.Megaparsec.Pos
                         megaparsec-7.0.4:Text.Megaparsec.State
                         megaparsec-7.0.4:Text.Megaparsec.Stream
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         prettyprinter-1.2.1:Data.Text.Prettyprint.Doc.Internal
                         primitive-0.6.4.0:Control.Monad.Primitive
                         primitive-0.6.4.0:Data.Primitive.Array
                         sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.Common
                         sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.Intermediate.Syntax
                         sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.Source.Syntax
                         tagged-0.8.6:Data.Tagged
                         template-haskell-2.14.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.1:Data.Text text-1.2.3.1:Data.Text.Lazy
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Bind
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Embed
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Ignore
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Name
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Rebind
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Rec
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Shift
import  -/  base-4.12.0.0:Control.Applicative f4c86ba32601955aaee0c0abccbaeade
import  -/  base-4.12.0.0:Control.Arrow 69c338174663ea24b03d3720d8beceec
import  -/  base-4.12.0.0:Data.Either 946a3435d06773e1dbcad1ba5dc18a2c
import  -/  base-4.12.0.0:Data.Foldable 00188ddf89c975fee76bdfad479443c1
import  -/  base-4.12.0.0:Data.Functor 22aac80fdb6c7b7f60b4aaab86afee64
import  -/  base-4.12.0.0:Data.Maybe 1e8e1362415df45376dffd98f8a47766
import  -/  base-4.12.0.0:Data.Void be49dab333a865813434f4da73ec0f4c
import  -/  base-4.12.0.0:GHC.Base cc906f98291a1b830546e99a96674547
import  -/  base-4.12.0.0:GHC.List 734a72beb76d276fb4a0ba2689a5711f
import  -/  base-4.12.0.0:GHC.Show 4e438f26d903388cc6c2c5d64ed01b98
import  -/  base-4.12.0.0:Prelude 5c01365ec01f83bd405ac01cbb9a8d76
import  -/  megaparsec-7.0.4:Text.Megaparsec b1d8d167d8e2d184f840d7f8cf436244
import  -/  megaparsec-7.0.4:Text.Megaparsec.Char 402ebd4caeb9d2c425df07ec1c885dfd
import  -/  megaparsec-7.0.4:Text.Megaparsec.Char.Lexer 6fa2d936841839921e98fee78df1f8e5
import  -/  megaparsec-7.0.4:Text.Megaparsec.Class 1c814450d61c937971debac96a79da07
import  -/  megaparsec-7.0.4:Text.Megaparsec.Common 9caedca4da95cdf8008be8f91c0e5839
import  -/  megaparsec-7.0.4:Text.Megaparsec.Error c00fdd03998c344baa4a5c8bc868da11
import  -/  megaparsec-7.0.4:Text.Megaparsec.Lexer 6f19e5834a0cdffc2a8fdec0768f2aac
import  -/  parser-combinators-1.0.1:Control.Applicative.Combinators 70d67a1f60f27b2d11938553727ddc47
import  -/  parser-combinators-1.0.1:Control.Monad.Combinators 96f00cb3b58d741f70bc77187e641e82
import  -/  parser-combinators-1.0.1:Control.Monad.Combinators.Expr e01439513ffce752a745749fbf29ccf3
import  -/  scientific-0.3.6.2:Data.Scientific 62c85054f4a7aab32f64fcf46ce53efb
import  -/  SEDEL.Common ca6f88eb795bfe7d09e23d21fb3eb87f
  exports: 576471b9a47b800d5ba3919671488556
  Add 776209293c66bfbb867e64fd01ec5524
  Arith 477cbffa1e7281d92b0f71e3720dc821
  Comp 348f8575ea4d65185d0a29b6b8a92535
  Div 038c227c045fd71eab722d2d4ecf42f4
  Equ 67fac86250d28575acf5a4936b4d65f2
  Gt 09d0b76e11a0a36a8ec9bbc51138f538
  LAnd 61b95ad1d220eda80a50c7e39a9a6ef6
  LOr 5c15e5469fc495263fe77dda9252bfb5
  Logical 5837ab3db90e339a87f10215bf5c0d98
  Lt ec4763cf594c42d458ce6a69ab350bdf
  Mul 8b6e84ede92e2ad36aa9f079a7b05e08
  Neq a72a14e8f114dd3e7b3cb975e2df8af3
  Sub 622974ee4a8131461dc7a2973ecbc9b1
import  -/  SEDEL.Source.Syntax ec83a0da1c10765115fe4a9f09c754b0
  exports: 9689242b0decab272007a11f45b72d7d
  And 0283b9e7440c4a3e47a1281e02970dde
  App c363422f50778c82e96747329eb9877e
  Arr df83e91aec2f80dc9d042375099bb771
  BoolT 21df8d7d01d510390fe4d585a4a596cd
  BoolV a99acac4209ebf13e71934080c423400
  BotT 77bd90a3bcfd29395ef1007b8a6a4ee6
  DefDecl 0bcb0cf0edd018dbef851783eba7cbb7
  Expr 350069ed8c9e308e7d171878eb06250d
  If 8adb062a80541f4537caeee81d7bc725
  Kind 350069ed8c9e308e7d171878eb06250d
  Label e739a3e6552cb99dfb25d8219b847fb6
  LitV 0126dc7c0aca06604ce1c1866a4ca27b
  Merge 8618c4cff7c45435653614618dd77223
  Module 63b12c7a9614f89d76a5f1c8e3979c8f
  Module d782678268308b8c889017b135bdd9f9
  NumT 539f9e6436bb2f46e0e1ed9aac813b1c
  Pos caef810378ba48ca7966a52d7584d18f
  PrimOp 459db753a665a5d3d985408f034250f5
  Proj c9b17242d24bcebd4dda5844c7db7905
  SDecl d4da484abb8cfac2766f73e28f180df7
  SType 2633b8b7955e013a3831a0582461061f
  SType 350069ed8c9e308e7d171878eb06250d
  Scheme 350069ed8c9e308e7d171878eb06250d
  Star 360a731d5e4cf3a645e5f82bd30238ed
  TmBind 7add3ab09967080e09d768102a5d4bdc
  TmBind 350069ed8c9e308e7d171878eb06250d
  Top 98e3b66dfbd16b59d9fe44f403ad750d
  TopT fa9c823349a4c24a48445d1081f1a548
  TyName 350069ed8c9e308e7d171878eb06250d
import  -/  SEDEL.Util c1534bfc592d5431439a65f47bff8b46
  exports: a4b496c924b84e318819b4bae94d6d7e
  elam 7734d63f56abb72b44df14cc1ddc2275
  elet 339fb1ed0fdebd5716b459b2b46b9975
  evar b2ddeb8e728a2aa666df72cfddc63f44
  mkRecds' 49ad7ae5616fce3262548cd8f93b782a
  mkRecdsT b15b65aa321edd4181439becbbb77336
  tforall c8063ee542e104cfc60908c38e432437
  tvar 2dbd4aa2b55add103905987d5c3da293
import  -/  unbound-generics-0.4.0:Unbound.Generics.LocallyNameless 36704d4dbfb3fb22f46cde363ae796f2
import  -/  unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Name 81d6e7baa0bd0880e550478df477614a
bf09d4c9084e97430dc610a49f932eb5
  $s$fAlternativeParsecT ::
    GHC.Base.Alternative
      (Text.Megaparsec.Internal.ParsecT
         Data.Void.Void [GHC.Types.Char] m)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *.
                  @ (Text.Megaparsec.Internal.ParsecT
                       Data.Void.Void [GHC.Types.Char] m)
                  (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$s$fApplicativeParsecT
                     @ Data.Void.Void
                     @ m)
                  (Text.Megaparsec.Internal.pZero
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$spPlus @ m)
                  (Text.Megaparsec.Internal.$fAlternativeParsecT3
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m
                     Data.Void.$fOrdVoid
                     Text.Megaparsec.Stream.$fStream[])
                    `cast`
                  (forall (a :: <*>_N).
                   <Text.Megaparsec.Internal.ParsecT
                      Data.Void.Void [GHC.Types.Char] m a>_R
                   ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                                 <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <[a]>_R))
                  (Text.Megaparsec.Internal.$fAlternativeParsecT1
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m
                     Data.Void.$fOrdVoid
                     Text.Megaparsec.Stream.$fStream[])
                    `cast`
                  (forall (a :: <*>_N).
                   <Text.Megaparsec.Internal.ParsecT
                      Data.Void.Void [GHC.Types.Char] m a>_R
                   ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                                 <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <[a]>_R)) -}
cfc480f95d8b032dad08565eca667c50
  $s$fAlternativeParsecT1 ::
    Text.Megaparsec.Internal.ParsecT
      Data.Void.Void [GHC.Types.Char] m a
    -> forall b.
       Text.Megaparsec.State.State [GHC.Types.Char]
       -> ([a]
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> m b)
       -> (Text.Megaparsec.Error.ParseError
             [GHC.Types.Char] Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
       -> ([a]
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> m b)
       -> (Text.Megaparsec.Error.ParseError
             [GHC.Types.Char] Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
       -> m b
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U(U,U,U)><L,C(U)><L,U><L,C(U)><L,A>,
     Inline: [2],
     Unfolding: InlineRule (6, True, True)
                (\ @ m :: * -> *
                   @ a
                   (w2 :: Text.Megaparsec.Internal.ParsecT
                            Data.Void.Void [GHC.Types.Char] m a)
                   @ b
                   (w3 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (w4 :: [a]
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> m b)
                   (w5 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (w6 :: [a]
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> m b)
                   (w7 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 Text.Megaparsec.Internal.$w$cmany
                   @ Data.Void.Void
                   @ [GHC.Types.Char]
                   @ m
                   Text.Megaparsec.Stream.$fStream[]
                   @ a
                   w2
                   @ b
                   w3
                   w4
                   w5
                   w6) -}
83da6d84c41e95834a3d27128be3e4c0
  $s$fAlternativeParsecT3 ::
    Text.Megaparsec.Internal.ParsecT
      Data.Void.Void [GHC.Types.Char] m a
    -> forall b.
       Text.Megaparsec.State.State [GHC.Types.Char]
       -> ([a]
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> m b)
       -> (Text.Megaparsec.Error.ParseError
             [GHC.Types.Char] Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
       -> ([a]
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> m b)
       -> (Text.Megaparsec.Error.ParseError
             [GHC.Types.Char] Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
       -> m b
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U><L,C(U)><L,U><L,C(U)><L,U>,
     Inline: [2],
     Unfolding: InlineRule (6, True, False)
                (\ @ m :: * -> *
                   @ a
                   (w2 :: Text.Megaparsec.Internal.ParsecT
                            Data.Void.Void [GHC.Types.Char] m a)
                   @ b
                   (w3 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (w4 :: [a]
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> m b)
                   (w5 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (w6 :: [a]
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> m b)
                   (w7 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 Text.Megaparsec.Internal.$w$csome
                   @ Data.Void.Void
                   @ [GHC.Types.Char]
                   @ m
                   Text.Megaparsec.Stream.$fStream[]
                   @ a
                   w2
                   @ b
                   w3
                   w4
                   w5
                   w6
                   w7) -}
992fab3f10ea78c77c8bc9790e4c658e
  $s$fAlternativeParsecT_$s$fApplicativeParsecT ::
    GHC.Base.Applicative
      (Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e @ m :: * -> *.
                  @ (Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m)
                  (Text.Megaparsec.Internal.$fFunctorParsecT
                     @ e
                     @ [GHC.Types.Char]
                     @ m)
                  (\ @ a ->
                   Text.Megaparsec.Internal.pPure @ a @ e @ [GHC.Types.Char] @ m)
                  (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$spAp @ e @ m)
                  (Text.Megaparsec.Internal.$fAlternativeParsecT2
                     @ [GHC.Types.Char]
                     @ e
                     @ m
                     Text.Megaparsec.Stream.$fStream[])
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                   ->_R <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b>_R
                   ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                                 <e>_N <[GHC.Types.Char]>_N <m>_R <c>_R))
                  (Text.Megaparsec.Internal.$fApplicativeParsecT2
                     @ [GHC.Types.Char]
                     @ e
                     @ m
                     Text.Megaparsec.Stream.$fStream[])
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                   ->_R <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b>_R
                   ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                                 <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R))
                  (Text.Megaparsec.Internal.$fApplicativeParsecT1
                     @ [GHC.Types.Char]
                     @ e
                     @ m
                     Text.Megaparsec.Stream.$fStream[])
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                   ->_R <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b>_R
                   ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                                 <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)) -}
b5a03f624f0489ea3fb25ff8db9ae6ac
  $s$fAlternativeParsecT_$spAp ::
    Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m (a -> b)
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b
  {- Arity: 7,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,U><L,C(U)><L,U><L,C(U)><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   @ b
                   (m37 :: Text.Megaparsec.Internal.ParsecT
                             e [GHC.Types.Char] m (a -> b))
                   (k15 :: Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a)
                   @ b1
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: b
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (cerr :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b1)
                   (eok :: b
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (eerr :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b1) ->
                 m37
                   `cast`
                 (Text.Megaparsec.Internal.N:ParsecT[0]
                      <e>_N <[GHC.Types.Char]>_N <m>_R <a -> b>_R)
                   @ b1
                   s1
                   (\ (x22 :: a -> b)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    k15
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                      @ b1
                      s'
                      (GHC.Base..
                         @ b
                         @ (Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Text.Megaparsec.Internal.Hints
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            -> m b1)
                         @ a
                         cok
                         x22)
                      cerr
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ a
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs
                         (GHC.Base..
                            @ b
                            @ (Text.Megaparsec.State.State [GHC.Types.Char]
                               -> Text.Megaparsec.Internal.Hints
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                               -> m b1)
                            @ a
                            cok
                            x22))
                      (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$swithHints
                         @ e
                         @ m
                         @ b1
                         hs
                         cerr))
                   cerr
                   (\ (x22 :: a -> b)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    k15
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                      @ b1
                      s'
                      (GHC.Base..
                         @ b
                         @ (Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Text.Megaparsec.Internal.Hints
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            -> m b1)
                         @ a
                         cok
                         x22)
                      cerr
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ a
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs
                         (GHC.Base..
                            @ b
                            @ (Text.Megaparsec.State.State [GHC.Types.Char]
                               -> Text.Megaparsec.Internal.Hints
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                               -> m b1)
                            @ a
                            eok
                            x22))
                      (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$swithHints
                         @ e
                         @ m
                         @ b1
                         hs
                         eerr))
                   eerr)
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N) (b :: <*>_N).
                 <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m (a -> b)>_R
                 ->_R <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)) -}
603b7f373338de7d8c9c4aa0ea023616
  $s$fAlternativeParsecT_$spPlus ::
    Text.Megaparsec.Internal.ParsecT
      Data.Void.Void [GHC.Types.Char] m a
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void [GHC.Types.Char] m a
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void [GHC.Types.Char] m a
  {- Arity: 7,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,U><L,C(C1(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ m :: * -> *
                   @ a
                   (m37 :: Text.Megaparsec.Internal.ParsecT
                             Data.Void.Void [GHC.Types.Char] m a)
                   (n2 :: Text.Megaparsec.Internal.ParsecT
                            Data.Void.Void [GHC.Types.Char] m a)
                   @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: a
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (cerr :: Text.Megaparsec.Error.ParseError
                              [GHC.Types.Char] Data.Void.Void
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (eok :: a
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              [GHC.Types.Char] Data.Void.Void
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 m37
                   `cast`
                 (Text.Megaparsec.Internal.N:ParsecT[0]
                      <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                   @ b
                   s1
                   cok
                   cerr
                   eok
                   (\ (err :: Text.Megaparsec.Error.ParseError
                                [GHC.Types.Char] Data.Void.Void)
                      (ms :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                    n2
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                      @ b
                      s1
                      cok
                      (\ (err' :: Text.Megaparsec.Error.ParseError
                                    [GHC.Types.Char] Data.Void.Void)
                         (s' :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                       cerr
                         (let {
                            $j :: GHC.Prim.Int#
                                  -> Text.Megaparsec.Error.ParseError
                                       [GHC.Types.Char] Data.Void.Void
                              <join 1> {- Arity: 1 -}
                            = \ (x# :: GHC.Prim.Int#)[OneShot] ->
                              let {
                                $j1 :: GHC.Prim.Int#
                                       -> Text.Megaparsec.Error.ParseError
                                            [GHC.Types.Char] Data.Void.Void
                                  <join 1> {- Arity: 1 -}
                                = \ (y# :: GHC.Prim.Int#)[OneShot] ->
                                  case GHC.Prim.<# x# y# of lwild {
                                    DEFAULT
                                    -> case GHC.Prim.==# x# y# of lwild1 {
                                         DEFAULT -> err'
                                         1#
                                         -> case err' of wild {
                                              Text.Megaparsec.Error.TrivialError s2 u1 p4
                                              -> case err of wild1 {
                                                   Text.Megaparsec.Error.TrivialError ds u2 p5
                                                   -> Text.Megaparsec.Error.TrivialError
                                                        @ [GHC.Types.Char]
                                                        @ Data.Void.Void
                                                        s2
                                                        (case u1 of wild2 {
                                                           GHC.Maybe.Nothing -> u2
                                                           GHC.Maybe.Just x22
                                                           -> case u2 of wild3 {
                                                                GHC.Maybe.Nothing
                                                                -> GHC.Maybe.Just
                                                                     @ (Text.Megaparsec.Error.ErrorItem
                                                                          (Text.Megaparsec.Stream.Token
                                                                             [GHC.Types.Char]))
                                                                     x22
                                                                GHC.Maybe.Just y
                                                                -> GHC.Maybe.Just
                                                                     @ (Text.Megaparsec.Error.ErrorItem
                                                                          (Text.Megaparsec.Stream.Token
                                                                             [GHC.Types.Char]))
                                                                     (case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                                                                             @ (Text.Megaparsec.Stream.Token
                                                                                  [GHC.Types.Char])
                                                                             GHC.Classes.$fOrdChar
                                                                               `cast`
                                                                             (GHC.Classes.Ord
                                                                                (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                                                                             y
                                                                             x22 of wild4 {
                                                                        GHC.Types.False -> y
                                                                        GHC.Types.True
                                                                        -> x22 }) } })
                                                        (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$sunion1
                                                           p4
                                                           p5)
                                                   Text.Megaparsec.Error.FancyError ds ds1
                                                   -> wild1 }
                                              Text.Megaparsec.Error.FancyError ds ds1
                                              -> case err of wild1 {
                                                   Text.Megaparsec.Error.TrivialError ds2 ds3 ds4
                                                   -> wild
                                                   Text.Megaparsec.Error.FancyError ds2 x22
                                                   -> Text.Megaparsec.Error.FancyError
                                                        @ [GHC.Types.Char]
                                                        @ Data.Void.Void
                                                        ds
                                                        (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$sunion
                                                           ds1
                                                           x22) } } }
                                    1# -> err }
                              } in
                              case err of wild {
                                Text.Megaparsec.Error.TrivialError o ds ds1
                                -> case o of wild1 { GHC.Types.I# y# -> $j1 y# }
                                Text.Megaparsec.Error.FancyError o ds
                                -> case o of wild1 { GHC.Types.I# y# -> $j1 y# } }
                          } in
                          case err' of wild {
                            Text.Megaparsec.Error.TrivialError o ds ds1
                            -> case o of wild1 { GHC.Types.I# x# -> $j x# }
                            Text.Megaparsec.Error.FancyError o ds
                            -> case o of wild1 { GHC.Types.I# x# -> $j x# } })
                         (Text.Megaparsec.Internal.longestMatch @ [GHC.Types.Char] ms s'))
                      (\ (x22 :: a)
                         (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                         (hs :: Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                       eok
                         x22
                         s'
                         (GHC.Base.augment
                            @ (Data.Set.Internal.Set
                                 (Text.Megaparsec.Error.ErrorItem
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                            (\ @ b1
                               (c :: Data.Set.Internal.Set
                                       (Text.Megaparsec.Error.ErrorItem
                                          (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                     -> b1 -> b1)[OneShot]
                               (n3 :: b1)[OneShot] ->
                             case err of wild {
                               Text.Megaparsec.Error.TrivialError errOffset ds ps6
                               -> case s' of wild1 { Text.Megaparsec.State.State ds1 dt3 ds2 ->
                                  case GHC.Classes.eqInt (GHC.Types.I# dt3) errOffset of wild2 {
                                    GHC.Types.False -> n3
                                    GHC.Types.True
                                    -> case ps6 of wild3 {
                                         Data.Set.Internal.Bin dt4 ds4 ds5 ds3 -> c wild3 n3
                                         Data.Set.Internal.Tip -> n3 } } }
                               Text.Megaparsec.Error.FancyError ds ds1 -> n3 })
                            hs
                              `cast`
                            (Text.Megaparsec.Internal.N:Hints[0]
                                 <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                           `cast`
                         (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                   <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)))
                      (\ (err' :: Text.Megaparsec.Error.ParseError
                                    [GHC.Types.Char] Data.Void.Void)
                         (s' :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                       eerr
                         (let {
                            $j :: GHC.Prim.Int#
                                  -> Text.Megaparsec.Error.ParseError
                                       [GHC.Types.Char] Data.Void.Void
                              <join 1> {- Arity: 1 -}
                            = \ (x# :: GHC.Prim.Int#)[OneShot] ->
                              let {
                                $j1 :: GHC.Prim.Int#
                                       -> Text.Megaparsec.Error.ParseError
                                            [GHC.Types.Char] Data.Void.Void
                                  <join 1> {- Arity: 1 -}
                                = \ (y# :: GHC.Prim.Int#)[OneShot] ->
                                  case GHC.Prim.<# x# y# of lwild {
                                    DEFAULT
                                    -> case GHC.Prim.==# x# y# of lwild1 {
                                         DEFAULT -> err'
                                         1#
                                         -> case err' of wild {
                                              Text.Megaparsec.Error.TrivialError s2 u1 p4
                                              -> case err of wild1 {
                                                   Text.Megaparsec.Error.TrivialError ds u2 p5
                                                   -> Text.Megaparsec.Error.TrivialError
                                                        @ [GHC.Types.Char]
                                                        @ Data.Void.Void
                                                        s2
                                                        (case u1 of wild2 {
                                                           GHC.Maybe.Nothing -> u2
                                                           GHC.Maybe.Just x22
                                                           -> case u2 of wild3 {
                                                                GHC.Maybe.Nothing
                                                                -> GHC.Maybe.Just
                                                                     @ (Text.Megaparsec.Error.ErrorItem
                                                                          (Text.Megaparsec.Stream.Token
                                                                             [GHC.Types.Char]))
                                                                     x22
                                                                GHC.Maybe.Just y
                                                                -> GHC.Maybe.Just
                                                                     @ (Text.Megaparsec.Error.ErrorItem
                                                                          (Text.Megaparsec.Stream.Token
                                                                             [GHC.Types.Char]))
                                                                     (case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                                                                             @ (Text.Megaparsec.Stream.Token
                                                                                  [GHC.Types.Char])
                                                                             GHC.Classes.$fOrdChar
                                                                               `cast`
                                                                             (GHC.Classes.Ord
                                                                                (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                                                                             y
                                                                             x22 of wild4 {
                                                                        GHC.Types.False -> y
                                                                        GHC.Types.True
                                                                        -> x22 }) } })
                                                        (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$sunion1
                                                           p4
                                                           p5)
                                                   Text.Megaparsec.Error.FancyError ds ds1
                                                   -> wild1 }
                                              Text.Megaparsec.Error.FancyError ds ds1
                                              -> case err of wild1 {
                                                   Text.Megaparsec.Error.TrivialError ds2 ds3 ds4
                                                   -> wild
                                                   Text.Megaparsec.Error.FancyError ds2 x22
                                                   -> Text.Megaparsec.Error.FancyError
                                                        @ [GHC.Types.Char]
                                                        @ Data.Void.Void
                                                        ds
                                                        (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$sunion
                                                           ds1
                                                           x22) } } }
                                    1# -> err }
                              } in
                              case err of wild {
                                Text.Megaparsec.Error.TrivialError o ds ds1
                                -> case o of wild1 { GHC.Types.I# y# -> $j1 y# }
                                Text.Megaparsec.Error.FancyError o ds
                                -> case o of wild1 { GHC.Types.I# y# -> $j1 y# } }
                          } in
                          case err' of wild {
                            Text.Megaparsec.Error.TrivialError o ds ds1
                            -> case o of wild1 { GHC.Types.I# x# -> $j x# }
                            Text.Megaparsec.Error.FancyError o ds
                            -> case o of wild1 { GHC.Types.I# x# -> $j x# } })
                         (Text.Megaparsec.Internal.longestMatch @ [GHC.Types.Char] ms s'))))
                  `cast`
                (forall (m :: <* -> *>_N) (a :: <*>_N).
                 <Text.Megaparsec.Internal.ParsecT
                    Data.Void.Void [GHC.Types.Char] m a>_R
                 ->_R <Text.Megaparsec.Internal.ParsecT
                         Data.Void.Void [GHC.Types.Char] m a>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <a>_R)) -}
975af2f298f28c0b6c16828dd9fbbe64
  $s$fAlternativeParsecT_$sunion ::
    Data.Set.Internal.Set
      (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
    -> Data.Set.Internal.Set
         (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
    -> Data.Set.Internal.Set
         (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [~] -}
e2097dbdc529df423d30ae131a6a505c
  $s$fAlternativeParsecT_$sunion1 ::
    Data.Set.Internal.Set
      (Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
    -> Data.Set.Internal.Set
         (Text.Megaparsec.Error.ErrorItem
            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
    -> Data.Set.Internal.Set
         (Text.Megaparsec.Error.ErrorItem
            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [~] -}
4f31b8f9ea3e0b81a3a960c8af3ed595
  $s$fAlternativeParsecT_$swithHints ::
    Text.Megaparsec.Internal.Hints
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> (Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
        -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
    -> Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
    -> Text.Megaparsec.State.State [GHC.Types.Char]
    -> m b
  {- Arity: 3, Strictness: <L,U><C(S),1*C1(U)><S,1*U>,
     Inline: (sat-args=3),
     Unfolding: InlineRule (3, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ b
                   (ds :: Text.Megaparsec.Internal.Hints
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (c :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                         -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (e1 :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e) ->
                 case e1 of wild {
                   Text.Megaparsec.Error.TrivialError pos us ps6
                   -> c (Text.Megaparsec.Error.TrivialError
                           @ [GHC.Types.Char]
                           @ e
                           pos
                           us
                           (GHC.Base.foldr
                              @ (Data.Set.Internal.Set
                                   (Text.Megaparsec.Error.ErrorItem
                                      (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                              @ (Data.Set.Internal.Set
                                   (Text.Megaparsec.Error.ErrorItem
                                      (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                 -> Data.Set.Internal.Set
                                      (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                              (\ (ds1 :: Data.Set.Internal.Set
                                           (Text.Megaparsec.Error.ErrorItem
                                              (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                 (ds2 :: Data.Set.Internal.Set
                                           (Text.Megaparsec.Error.ErrorItem
                                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                         -> Data.Set.Internal.Set
                                              (Text.Megaparsec.Error.ErrorItem
                                                 (Text.Megaparsec.Stream.Token
                                                    [GHC.Types.Char])))[OneShot]
                                 (v :: Data.Set.Internal.Set
                                         (Text.Megaparsec.Error.ErrorItem
                                            (Text.Megaparsec.Stream.Token
                                               [GHC.Types.Char])))[OneShot] ->
                               case v of z { DEFAULT ->
                               ds2 (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$sunion1 z ds1) })
                              (GHC.Base.id
                                 @ (Data.Set.Internal.Set
                                      (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                              (GHC.Types.:
                                 @ (Data.Set.Internal.Set
                                      (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                 ps6
                                 ds
                                   `cast`
                                 (Text.Megaparsec.Internal.N:Hints[0]
                                      <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                              (Data.Set.Internal.Tip
                                 @ (Text.Megaparsec.Error.ErrorItem
                                      (Text.Megaparsec.Stream.Token [GHC.Types.Char])))))
                   Text.Megaparsec.Error.FancyError ipv ipv1 -> c wild }) -}
05768270b3c423962530f58a423a183f
  $s$fEqErrorFancy ::
    GHC.Classes.Eq (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                  (Text.Megaparsec.Error.$fEqErrorFancy_$c==
                     @ Data.Void.Void
                     Data.Void.$fEqVoid)
                  SEDEL.Parser.Parser.$s$fEqErrorFancy_$s$fEqErrorFancy_$c/= -}
191e0044635421c914732dbd9cd6f768
  $s$fEqErrorFancy_$s$fEqErrorFancy_$c/= ::
    Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x22 :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                   (y :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                 case Text.Megaparsec.Error.$fEqErrorFancy_$c==
                        @ Data.Void.Void
                        Data.Void.$fEqVoid
                        x22
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
70f62b83aaa39045d6f5954a91dab6e0
  $s$fEqErrorItem ::
    GHC.Classes.Eq
      (Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Text.Megaparsec.Error.ErrorItem
                       (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                  (Text.Megaparsec.Error.$fEqErrorItem_$c==
                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                     GHC.Classes.$fEqChar
                       `cast`
                     (GHC.Classes.Eq (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R)
                  SEDEL.Parser.Parser.$s$fEqErrorItem_$s$fEqErrorItem_$c/= -}
c1f2fd12f3f391668be2b8bf3a113b1b
  $s$fEqErrorItem_$s$fEqErrorItem_$c/= ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x22 :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (y :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                 case Text.Megaparsec.Error.$fEqErrorItem_$c==
                        @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                        GHC.Classes.$fEqChar
                          `cast`
                        (GHC.Classes.Eq (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                        x22
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
8e06671a29df3e0d73090f518f5dc492
  $s$fMonadParsecT ::
    GHC.Base.Monad
      (Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e @ m :: * -> *.
                  @ (Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m)
                  (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$s$fApplicativeParsecT
                     @ e
                     @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecT_$spBind @ e @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecT_$s$fMonadParsecT_$c>>
                     @ e
                     @ m)
                  (\ @ a ->
                   Text.Megaparsec.Internal.pPure @ a @ e @ [GHC.Types.Char] @ m)
                  (Text.Megaparsec.Internal.pFail @ e @ [GHC.Types.Char] @ m) -}
fbae91e921fcd81c40c8abf98fe951b8
  $s$fMonadParsecT_$s$fMonadParsecT_$c>> ::
    Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b
  {- Arity: 7,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,C(C1(C1(U)))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   @ b
                   (m37 :: Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a)
                   (k15 :: Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b)
                   @ b1
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: b
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (cerr :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b1)
                   (eok :: b
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (eerr :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b1) ->
                 m37
                   `cast`
                 (Text.Megaparsec.Internal.N:ParsecT[0]
                      <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                   @ b1
                   s1
                   (\ (x22 :: a)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    k15
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)
                      @ b1
                      s'
                      cok
                      cerr
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ b
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs
                         cok)
                      (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$swithHints
                         @ e
                         @ m
                         @ b1
                         hs
                         cerr))
                   cerr
                   (\ (x22 :: a)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    k15
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)
                      @ b1
                      s'
                      cok
                      cerr
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ b
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs
                         eok)
                      (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$swithHints
                         @ e
                         @ m
                         @ b1
                         hs
                         eerr))
                   eerr)
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N) (b :: <*>_N).
                 <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                 ->_R <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)) -}
1e582ce66f20de7cbcb738491bccab99
  $s$fMonadParsecT_$spBind ::
    Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a
    -> (a -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b)
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b
  {- Arity: 7,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(C1(U))))))><L,U><L,U><L,U><L,C(C1(C1(U)))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   @ b
                   (m37 :: Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a)
                   (k15 :: a
                           -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b)
                   @ b1
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: b
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (cerr :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b1)
                   (eok :: b
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (eerr :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b1) ->
                 m37
                   `cast`
                 (Text.Megaparsec.Internal.N:ParsecT[0]
                      <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                   @ b1
                   s1
                   (\ (x22 :: a)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    (k15 x22)
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)
                      @ b1
                      s'
                      cok
                      cerr
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ b
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs
                         cok)
                      (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$swithHints
                         @ e
                         @ m
                         @ b1
                         hs
                         cerr))
                   cerr
                   (\ (x22 :: a)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    (k15 x22)
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)
                      @ b1
                      s'
                      cok
                      cerr
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ b
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs
                         eok)
                      (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$swithHints
                         @ e
                         @ m
                         @ b1
                         hs
                         eerr))
                   eerr)
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N) (b :: <*>_N).
                 <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                 ->_R <a
                       -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)) -}
2cd2d45e61729e8744a11b013ceee745
  $s$fMonadParsecesParsecT ::
    Text.Megaparsec.Class.MonadParsec
      Data.Void.Void
      [GHC.Types.Char]
      (Text.Megaparsec.Internal.ParsecT
         Data.Void.Void [GHC.Types.Char] m)
  {- Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *.
                  @ Data.Void.Void
                  @ [GHC.Types.Char]
                  @ (Text.Megaparsec.Internal.ParsecT
                       Data.Void.Void [GHC.Types.Char] m)
                  Text.Megaparsec.Stream.$fStream[]
                  (SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$s$fMonadPlusParsecT
                     @ m)
                  (Text.Megaparsec.Internal.pFailure
                     @ [GHC.Types.Char]
                     @ Data.Void.Void
                     @ m)
                  (Text.Megaparsec.Internal.pFancyFailure
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (Text.Megaparsec.Internal.pLabel
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (\ @ a ->
                   Text.Megaparsec.Internal.pLabel
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m
                     @ a
                     (GHC.Types.[] @ GHC.Types.Char))
                  (Text.Megaparsec.Internal.pTry
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (Text.Megaparsec.Internal.pLookAhead
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spNotFollowedBy
                     @ Data.Void.Void
                     @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spWithRecovery
                     @ Data.Void.Void
                     @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spObserving
                     @ Data.Void.Void
                     @ m)
                  (\ @ b
                     (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                     (ds :: ()
                            -> Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Text.Megaparsec.Internal.Hints
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            -> m b)
                     (ds1 :: Text.Megaparsec.Error.ParseError
                               [GHC.Types.Char] Data.Void.Void
                             -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                     (eok :: ()
                             -> Text.Megaparsec.State.State [GHC.Types.Char]
                             -> Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                             -> m b)
                     (eerr :: Text.Megaparsec.Error.ParseError
                                [GHC.Types.Char] Data.Void.Void
                              -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                   case s1 of wild { Text.Megaparsec.State.State input dt3 pst ->
                   let {
                     o :: GHC.Types.Int = GHC.Types.I# dt3
                   } in
                   case input of wild1 {
                     []
                     -> eok
                          GHC.Tuple.()
                          wild
                          (GHC.Types.[]
                             @ (Data.Set.Internal.Set
                                  (Text.Megaparsec.Error.ErrorItem
                                     (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                            `cast`
                          (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                    <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                     : t ts
                     -> eerr
                          (Text.Megaparsec.Error.TrivialError
                             @ [GHC.Types.Char]
                             @ Data.Void.Void
                             o
                             (GHC.Maybe.Just
                                @ (Text.Megaparsec.Error.ErrorItem
                                     (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                (Text.Megaparsec.Error.Tokens
                                   @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                   (Text.Megaparsec.Internal.nes
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                      t `cast`
                                      (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))))))
                             (Data.Set.Internal.$WBin
                                @ (Text.Megaparsec.Error.ErrorItem
                                     (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                (GHC.Types.I# 1#)
                                (Text.Megaparsec.Error.EndOfInput
                                   @ (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                (Data.Set.Internal.Tip
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                (Data.Set.Internal.Tip
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char])))))
                          (Text.Megaparsec.State.$WState @ [GHC.Types.Char] wild1 o pst) } })
                    `cast`
                  (Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                            <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <()>_R))
                  (SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spToken
                     @ Data.Void.Void
                     @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spTokens
                     @ Data.Void.Void
                     @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spTakeWhileP
                     @ Data.Void.Void
                     @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spTakeWhile1P
                     @ Data.Void.Void
                     @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spTakeP
                     @ Data.Void.Void
                     @ m)
                  (\ @ b
                     (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                     (ds :: Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Text.Megaparsec.Internal.Hints
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            -> m b)
                     (ds1 :: Text.Megaparsec.Error.ParseError
                               [GHC.Types.Char] Data.Void.Void
                             -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                     (eok :: Text.Megaparsec.State.State [GHC.Types.Char]
                             -> Text.Megaparsec.State.State [GHC.Types.Char]
                             -> Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                             -> m b)
                     (ds2 :: Text.Megaparsec.Error.ParseError
                               [GHC.Types.Char] Data.Void.Void
                             -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                   eok
                     s1
                     s1
                     (GHC.Types.[]
                        @ (Data.Set.Internal.Set
                             (Text.Megaparsec.Error.ErrorItem
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                       `cast`
                     (Sym (Text.Megaparsec.Internal.N:Hints[0]
                               <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)))
                    `cast`
                  (Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                            <Data.Void.Void>_N
                            <[GHC.Types.Char]>_N
                            <m>_R
                            <Text.Megaparsec.State.State [GHC.Types.Char]>_R))
                  (Text.Megaparsec.Internal.pUpdateParserState
                     @ [GHC.Types.Char]
                     @ Data.Void.Void
                     @ m) -}
3394aaee24891e3da080d83ae58c6f81
  $s$fMonadParsecesParsecT_$s$fMonadPlusParsecT ::
    GHC.Base.MonadPlus
      (Text.Megaparsec.Internal.ParsecT
         Data.Void.Void [GHC.Types.Char] m)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *.
                  @ (Text.Megaparsec.Internal.ParsecT
                       Data.Void.Void [GHC.Types.Char] m)
                  (SEDEL.Parser.Parser.$s$fAlternativeParsecT @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecT @ Data.Void.Void @ m)
                  (Text.Megaparsec.Internal.pZero
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$spPlus @ m) -}
e498cacefec89536a6464589167392d0
  $s$fMonadParsecesParsecT_$spNotFollowedBy ::
    Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m ()
  {- Arity: 6, HasNoCafRefs,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><S(LSL),1*U(U,U,U)><L,A><L,A><L,1*C1(C1(C1(U)))><L,1*C1(C1(U))>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   (p4 :: Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a)
                   @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (ds :: ()
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> m b)
                   (ds1 :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (eok :: ()
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 case s1 of wild { Text.Megaparsec.State.State input dt3 ds2 ->
                 let {
                   o :: GHC.Types.Int = GHC.Types.I# dt3
                 } in
                 let {
                   what :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                   = case input of wild1 {
                       []
                       -> Text.Megaparsec.Error.EndOfInput
                            @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                       : t ts
                       -> Text.Megaparsec.Error.Tokens
                            @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            (GHC.Base.:|
                               @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                               t `cast` (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))
                               (GHC.Types.[] @ (Text.Megaparsec.Stream.Token [GHC.Types.Char]))) }
                 } in
                 p4
                   `cast`
                 (Text.Megaparsec.Internal.N:ParsecT[0]
                      <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                   @ b
                   wild
                   (\ (ds3 :: a)
                      (ds4 :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (ds5 :: Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    eerr
                      (Text.Megaparsec.Error.TrivialError
                         @ [GHC.Types.Char]
                         @ e
                         o
                         (GHC.Maybe.Just
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                            what)
                         (Data.Set.Internal.Tip
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                      wild)
                   (\ (ds3 :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                      (ds4 :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                    eok
                      GHC.Tuple.()
                      wild
                      (GHC.Types.[]
                         @ (Data.Set.Internal.Set
                              (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                        `cast`
                      (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)))
                   (\ (ds3 :: a)
                      (ds4 :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (ds5 :: Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    eerr
                      (Text.Megaparsec.Error.TrivialError
                         @ [GHC.Types.Char]
                         @ e
                         o
                         (GHC.Maybe.Just
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                            what)
                         (Data.Set.Internal.Tip
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                      wild)
                   (\ (ds3 :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                      (ds4 :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                    eok
                      GHC.Tuple.()
                      wild
                      (GHC.Types.[]
                         @ (Data.Set.Internal.Set
                              (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                        `cast`
                      (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))) })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N).
                 <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <()>_R)) -}
f673d4ed00e8bc3aaa0d5a7917c49ea3
  $s$fMonadParsecesParsecT_$spObserving ::
    Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a
    -> Text.Megaparsec.Internal.ParsecT
         e
         [GHC.Types.Char]
         m
         (Data.Either.Either
            (Text.Megaparsec.Error.ParseError [GHC.Types.Char] e) a)
  {- Arity: 6, HasNoCafRefs,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,U><L,C(U)><L,A><L,C(U)><L,A>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   (p4 :: Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a)
                   @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: Data.Either.Either
                             (Text.Megaparsec.Error.ParseError [GHC.Types.Char] e) a
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (eok :: Data.Either.Either
                             (Text.Megaparsec.Error.ParseError [GHC.Types.Char] e) a
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds1 :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 p4
                   `cast`
                 (Text.Megaparsec.Internal.N:ParsecT[0]
                      <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                   @ b
                   s1
                   (\ (x22 :: a) ->
                    cok
                      (Data.Either.Right
                         @ (Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                         @ a
                         x22))
                   (\ (err :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                    cok
                      (Data.Either.Left
                         @ (Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                         @ a
                         err)
                      s'
                      (GHC.Types.[]
                         @ (Data.Set.Internal.Set
                              (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                        `cast`
                      (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)))
                   (\ (x22 :: a) ->
                    eok
                      (Data.Either.Right
                         @ (Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                         @ a
                         x22))
                   (\ (err :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                    eok
                      (Data.Either.Left
                         @ (Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                         @ a
                         err)
                      s'
                      (case err of wild {
                         Text.Megaparsec.Error.TrivialError errOffset ds2 ps6
                         -> case s' of wild1 { Text.Megaparsec.State.State ds3 dt3 ds4 ->
                            case GHC.Classes.eqInt (GHC.Types.I# dt3) errOffset of wild2 {
                              GHC.Types.False
                              -> (GHC.Types.[]
                                    @ (Data.Set.Internal.Set
                                         (Text.Megaparsec.Error.ErrorItem
                                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                   `cast`
                                 (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                           <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                              GHC.Types.True
                              -> case ps6 of wild3 {
                                   Data.Set.Internal.Bin dt4 ds5 ds6 ds7
                                   -> (GHC.Base.build
                                         @ (Data.Set.Internal.Set
                                              (Text.Megaparsec.Error.ErrorItem
                                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                         (\ @ a1
                                            (c :: Data.Set.Internal.Set
                                                    (Text.Megaparsec.Error.ErrorItem
                                                       (Text.Megaparsec.Stream.Token
                                                          [GHC.Types.Char]))
                                                  -> a1 -> a1)[OneShot]
                                            (n2 :: a1)[OneShot] ->
                                          c wild3 n2))
                                        `cast`
                                      (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                                <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                                   Data.Set.Internal.Tip
                                   -> (GHC.Types.[]
                                         @ (Data.Set.Internal.Set
                                              (Text.Megaparsec.Error.ErrorItem
                                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                        `cast`
                                      (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                                <Text.Megaparsec.Stream.Token
                                                   [GHC.Types.Char]>_N)) } } }
                         Text.Megaparsec.Error.FancyError ds2 ds3
                         -> (GHC.Types.[]
                               @ (Data.Set.Internal.Set
                                    (Text.Megaparsec.Error.ErrorItem
                                       (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                              `cast`
                            (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                      <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)) })))
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N).
                 <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N
                               <[GHC.Types.Char]>_N
                               <m>_R
                               <Data.Either.Either
                                  (Text.Megaparsec.Error.ParseError [GHC.Types.Char] e) a>_R)) -}
e9a1a94964d6d5c5f743b7c92c88ec28
  $s$fMonadParsecesParsecT_$spTakeP ::
    GHC.Maybe.Maybe GHC.Base.String
    -> GHC.Types.Int
    -> Text.Megaparsec.Internal.ParsecT
         e
         [GHC.Types.Char]
         m
         (Text.Megaparsec.Stream.Tokens [GHC.Types.Char])
  {- Arity: 7, HasNoCafRefs,
     Strictness: <L,1*U><S(S),1*U(U)><S(LSL),1*U(U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(C1(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   (ml :: GHC.Maybe.Maybe GHC.Base.String)
                   (n2 :: GHC.Types.Int)
                   @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (ds1 :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 case s1 of wild { Text.Megaparsec.State.State input dt3 pst ->
                 let {
                   ps6 :: Data.Set.Internal.Set
                            (Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   = case ml of wild1 {
                       GHC.Maybe.Nothing
                       -> Data.Set.Internal.Tip
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                       GHC.Maybe.Just x22
                       -> case x22 of wild2 {
                            []
                            -> Data.Set.Internal.Tip
                                 @ (Text.Megaparsec.Error.ErrorItem
                                      (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                            : a1 as3
                            -> Data.Set.Internal.$WBin
                                 @ (Text.Megaparsec.Error.ErrorItem
                                      (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                 (GHC.Types.I# 1#)
                                 (Text.Megaparsec.Error.Label
                                    @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                    (GHC.Base.:| @ GHC.Types.Char a1 as3))
                                 (Data.Set.Internal.Tip
                                    @ (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                 (Data.Set.Internal.Tip
                                    @ (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))) } }
                 } in
                 case Text.Megaparsec.Stream.$fStream[]_$ctakeN_ n2 input of wild1 {
                   GHC.Maybe.Nothing
                   -> eerr
                        (Text.Megaparsec.Error.TrivialError
                           @ [GHC.Types.Char]
                           @ e
                           (GHC.Types.I# dt3)
                           (GHC.Maybe.Just
                              @ (Text.Megaparsec.Error.ErrorItem
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              (Text.Megaparsec.Error.EndOfInput
                                 @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                           ps6)
                        wild
                   GHC.Maybe.Just ds2
                   -> case ds2 of wild2 { (,) ts input' ->
                      let {
                        len :: GHC.Types.Int
                        = case GHC.List.$wlenAcc
                                 @ GHC.Types.Char
                                 ts `cast` (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                                 0# of ww2 { DEFAULT ->
                          GHC.Types.I# ww2 }
                      } in
                      case GHC.Classes.neInt len n2 of wild3 {
                        GHC.Types.False
                        -> cok
                             ts
                             (case len of wild4 { GHC.Types.I# y ->
                              Text.Megaparsec.State.$WState
                                @ [GHC.Types.Char]
                                input'
                                (GHC.Types.I# (GHC.Prim.+# dt3 y))
                                pst })
                             (GHC.Types.[]
                                @ (Data.Set.Internal.Set
                                     (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                               `cast`
                             (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                       <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                        GHC.Types.True
                        -> eerr
                             (Text.Megaparsec.Error.TrivialError
                                @ [GHC.Types.Char]
                                @ e
                                (case len of wild4 { GHC.Types.I# y ->
                                 GHC.Types.I# (GHC.Prim.+# dt3 y) })
                                (GHC.Maybe.Just
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                   (Text.Megaparsec.Error.EndOfInput
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                ps6)
                             (Text.Megaparsec.State.$WState
                                @ [GHC.Types.Char]
                                input
                                (GHC.Types.I# dt3)
                                pst) } } } })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Maybe.Maybe GHC.Base.String>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N
                               <[GHC.Types.Char]>_N
                               <m>_R
                               <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]>_R)) -}
57e41c665825f4b6f2d20e9d6780e55b
  $s$fMonadParsecesParsecT_$spTakeWhile1P ::
    GHC.Maybe.Maybe GHC.Base.String
    -> (Text.Megaparsec.Stream.Token [GHC.Types.Char]
        -> GHC.Types.Bool)
    -> Text.Megaparsec.Internal.ParsecT
         e
         [GHC.Types.Char]
         m
         (Text.Megaparsec.Stream.Tokens [GHC.Types.Char])
  {- Arity: 7, HasNoCafRefs,
     Strictness: <L,1*U><L,C(U)><S(SSL),1*U(U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(C1(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   (ml :: GHC.Maybe.Maybe GHC.Base.String)
                   (f2 :: Text.Megaparsec.Stream.Token [GHC.Types.Char]
                          -> GHC.Types.Bool)
                   @ b
                   (ds :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds1 :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (ds2 :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 case ds of wild { Text.Megaparsec.State.State input dt3 pst ->
                 let {
                   o :: GHC.Types.Int = GHC.Types.I# dt3
                 } in
                 let {
                   ds3 :: ([GHC.Types.Char], [GHC.Types.Char])
                   = GHC.List.span
                       @ GHC.Types.Char
                       f2
                         `cast`
                       (Sub (Text.Megaparsec.Stream.D:R:Token[][0])
                        ->_R <GHC.Types.Bool>_R)
                       input
                 } in
                 let {
                   ts :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                   = case ds3
                            `cast`
                          ((,)
                             (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))
                             <[GHC.Types.Char]>_R)_R of wild1 { (,) ts1 input' ->
                     ts1 }
                 } in
                 case ds3
                        `cast`
                      ((,)
                         (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))
                         <[GHC.Types.Char]>_R)_R of wild1 { (,) ts1 input' ->
                 case ts1
                        `cast`
                      (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0])) of wild2 {
                   []
                   -> eerr
                        (Text.Megaparsec.Error.TrivialError
                           @ [GHC.Types.Char]
                           @ e
                           o
                           (GHC.Maybe.Just
                              @ (Text.Megaparsec.Error.ErrorItem
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              (case input of wild3 {
                                 []
                                 -> Text.Megaparsec.Error.EndOfInput
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                 : t ts2
                                 -> Text.Megaparsec.Error.Tokens
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                      (Text.Megaparsec.Internal.nes
                                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                         t `cast`
                                         (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))) }))
                           (case ml of wild3 {
                              GHC.Maybe.Nothing
                              -> Data.Set.Internal.Tip
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              GHC.Maybe.Just x22
                              -> case x22 of wild4 {
                                   []
                                   -> Data.Set.Internal.Tip
                                        @ (Text.Megaparsec.Error.ErrorItem
                                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                   : a1 as3
                                   -> Data.Set.Internal.$WBin
                                        @ (Text.Megaparsec.Error.ErrorItem
                                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                        (GHC.Types.I# 1#)
                                        (Text.Megaparsec.Error.Label
                                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                           (GHC.Base.:| @ GHC.Types.Char a1 as3))
                                        (Data.Set.Internal.Tip
                                           @ (Text.Megaparsec.Error.ErrorItem
                                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                        (Data.Set.Internal.Tip
                                           @ (Text.Megaparsec.Error.ErrorItem
                                                (Text.Megaparsec.Stream.Token
                                                   [GHC.Types.Char]))) } }))
                        (Text.Megaparsec.State.$WState @ [GHC.Types.Char] input o pst)
                   : ds4 ds5
                   -> cok
                        ts
                        (case GHC.List.$wlenAcc
                                @ GHC.Types.Char
                                ts `cast` (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                                0# of ww2 { DEFAULT ->
                         Text.Megaparsec.State.$WState
                           @ [GHC.Types.Char]
                           input'
                           (GHC.Types.I# (GHC.Prim.+# dt3 ww2))
                           pst })
                        (case ml of wild3 {
                           GHC.Maybe.Nothing
                           -> (GHC.Types.[]
                                 @ (Data.Set.Internal.Set
                                      (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                `cast`
                              (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                        <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                           GHC.Maybe.Just x22
                           -> case x22 of wild4 {
                                []
                                -> (GHC.Types.[]
                                      @ (Data.Set.Internal.Set
                                           (Text.Megaparsec.Error.ErrorItem
                                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                     `cast`
                                   (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                             <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                                : a1 as3
                                -> (GHC.Base.build
                                      @ (Data.Set.Internal.Set
                                           (Text.Megaparsec.Error.ErrorItem
                                              (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                      (\ @ a2
                                         (c :: Data.Set.Internal.Set
                                                 (Text.Megaparsec.Error.ErrorItem
                                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                               -> a2 -> a2)[OneShot]
                                         (n2 :: a2)[OneShot] ->
                                       c (Data.Set.Internal.$WBin
                                            @ (Text.Megaparsec.Error.ErrorItem
                                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                            (GHC.Types.I# 1#)
                                            (Text.Megaparsec.Error.Label
                                               @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                               (GHC.Base.:| @ GHC.Types.Char a1 as3))
                                            (Data.Set.Internal.Tip
                                               @ (Text.Megaparsec.Error.ErrorItem
                                                    (Text.Megaparsec.Stream.Token
                                                       [GHC.Types.Char])))
                                            (Data.Set.Internal.Tip
                                               @ (Text.Megaparsec.Error.ErrorItem
                                                    (Text.Megaparsec.Stream.Token
                                                       [GHC.Types.Char]))))
                                         n2))
                                     `cast`
                                   (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                             <Text.Megaparsec.Stream.Token
                                                [GHC.Types.Char]>_N)) } }) } } })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Maybe.Maybe GHC.Base.String>_R
                 ->_R <Text.Megaparsec.Stream.Token [GHC.Types.Char]
                       -> GHC.Types.Bool>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N
                               <[GHC.Types.Char]>_N
                               <m>_R
                               <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]>_R)) -}
bf33770df2a3bf613976722ad7240b4c
  $s$fMonadParsecesParsecT_$spTakeWhileP ::
    GHC.Maybe.Maybe GHC.Base.String
    -> (Text.Megaparsec.Stream.Token [GHC.Types.Char]
        -> GHC.Types.Bool)
    -> Text.Megaparsec.Internal.ParsecT
         e
         [GHC.Types.Char]
         m
         (Text.Megaparsec.Stream.Tokens [GHC.Types.Char])
  {- Arity: 7,
     Strictness: <L,1*U><L,C(U)><S(SSL),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,1*C1(C1(C1(U)))><L,A>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   (ml :: GHC.Maybe.Maybe GHC.Base.String)
                   (f2 :: Text.Megaparsec.Stream.Token [GHC.Types.Char]
                          -> GHC.Types.Bool)
                   @ b
                   (ds :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds1 :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (eok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds2 :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 case ds of wild { Text.Megaparsec.State.State input dt3 pst ->
                 let {
                   hs :: Text.Megaparsec.Internal.Hints
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                   = case ml of wild1 {
                       GHC.Maybe.Nothing
                       -> (GHC.Types.[]
                             @ (Data.Set.Internal.Set
                                  (Text.Megaparsec.Error.ErrorItem
                                     (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                            `cast`
                          (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                    <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                       GHC.Maybe.Just x22
                       -> case x22 of wild2 {
                            []
                            -> (GHC.Types.[]
                                  @ (Data.Set.Internal.Set
                                       (Text.Megaparsec.Error.ErrorItem
                                          (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                 `cast`
                               (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                         <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                            : a1 as3
                            -> (GHC.Base.build
                                  @ (Data.Set.Internal.Set
                                       (Text.Megaparsec.Error.ErrorItem
                                          (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                  (\ @ a2
                                     (c :: Data.Set.Internal.Set
                                             (Text.Megaparsec.Error.ErrorItem
                                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                           -> a2 -> a2)[OneShot]
                                     (n2 :: a2)[OneShot] ->
                                   c (Data.Set.Internal.$WBin
                                        @ (Text.Megaparsec.Error.ErrorItem
                                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                        (GHC.Types.I# 1#)
                                        (Text.Megaparsec.Error.Label
                                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                           (GHC.Base.:| @ GHC.Types.Char a1 as3))
                                        (Data.Set.Internal.Tip
                                           @ (Text.Megaparsec.Error.ErrorItem
                                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                        (Data.Set.Internal.Tip
                                           @ (Text.Megaparsec.Error.ErrorItem
                                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                     n2))
                                 `cast`
                               (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                         <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)) } }
                 } in
                 let {
                   ds3 :: ([GHC.Types.Char], [GHC.Types.Char])
                   = GHC.List.span
                       @ GHC.Types.Char
                       f2
                         `cast`
                       (Sub (Text.Megaparsec.Stream.D:R:Token[][0])
                        ->_R <GHC.Types.Bool>_R)
                       input
                 } in
                 let {
                   ts :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                   = case ds3
                            `cast`
                          ((,)
                             (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))
                             <[GHC.Types.Char]>_R)_R of wild1 { (,) ts1 input' ->
                     ts1 }
                 } in
                 case ds3
                        `cast`
                      ((,)
                         (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))
                         <[GHC.Types.Char]>_R)_R of wild1 { (,) ts1 input' ->
                 case ts1
                        `cast`
                      (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0])) of wild2 {
                   []
                   -> eok
                        ts
                        (case GHC.List.$wlenAcc
                                @ GHC.Types.Char
                                ts `cast` (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                                0# of ww2 { DEFAULT ->
                         Text.Megaparsec.State.$WState
                           @ [GHC.Types.Char]
                           input'
                           (GHC.Types.I# (GHC.Prim.+# dt3 ww2))
                           pst })
                        hs
                   : ds4 ds5
                   -> cok
                        ts
                        (case GHC.List.$wlenAcc
                                @ GHC.Types.Char
                                ts `cast` (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                                0# of ww2 { DEFAULT ->
                         Text.Megaparsec.State.$WState
                           @ [GHC.Types.Char]
                           input'
                           (GHC.Types.I# (GHC.Prim.+# dt3 ww2))
                           pst })
                        hs } } })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Maybe.Maybe GHC.Base.String>_R
                 ->_R <Text.Megaparsec.Stream.Token [GHC.Types.Char]
                       -> GHC.Types.Bool>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N
                               <[GHC.Types.Char]>_N
                               <m>_R
                               <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]>_R)) -}
e382e988b390599951b93550477b73fb
  $s$fMonadParsecesParsecT_$spToken ::
    (Text.Megaparsec.Stream.Token [GHC.Types.Char]
     -> GHC.Maybe.Maybe a)
    -> Data.Set.Internal.Set
         (Text.Megaparsec.Error.ErrorItem
            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a
  {- Arity: 7, HasNoCafRefs,
     Strictness: <L,1*C1(U)><L,U><S(SSL),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(C1(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   (test :: Text.Megaparsec.Stream.Token [GHC.Types.Char]
                            -> GHC.Maybe.Maybe a)
                   (ps6 :: Data.Set.Internal.Set
                             (Text.Megaparsec.Error.ErrorItem
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                   @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: a
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (ds1 :: a
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 case s1 of wild { Text.Megaparsec.State.State input dt3 pst ->
                 let {
                   o :: GHC.Types.Int = GHC.Types.I# dt3
                 } in
                 case input of wild1 {
                   []
                   -> eerr
                        (Text.Megaparsec.Error.TrivialError
                           @ [GHC.Types.Char]
                           @ e
                           o
                           (GHC.Maybe.Just
                              @ (Text.Megaparsec.Error.ErrorItem
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              (Text.Megaparsec.Error.EndOfInput
                                 @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                           ps6)
                        wild
                   : t ts
                   -> case test
                             t `cast`
                             (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))) of wild3 {
                        GHC.Maybe.Nothing
                        -> eerr
                             (Text.Megaparsec.Error.TrivialError
                                @ [GHC.Types.Char]
                                @ e
                                o
                                (GHC.Maybe.Just
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                   (Text.Megaparsec.Error.Tokens
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                      (Text.Megaparsec.Internal.nes
                                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                         t `cast`
                                         (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))))))
                                ps6)
                             (Text.Megaparsec.State.$WState @ [GHC.Types.Char] wild1 o pst)
                        GHC.Maybe.Just x22
                        -> cok
                             x22
                             (Text.Megaparsec.State.$WState
                                @ [GHC.Types.Char]
                                ts
                                (GHC.Types.I# (GHC.Prim.+# dt3 1#))
                                pst)
                             (GHC.Types.[]
                                @ (Data.Set.Internal.Set
                                     (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                               `cast`
                             (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                       <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)) } } })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N).
                 <Text.Megaparsec.Stream.Token [GHC.Types.Char]
                  -> GHC.Maybe.Maybe a>_R
                 ->_R <Data.Set.Internal.Set
                         (Text.Megaparsec.Error.ErrorItem
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)) -}
a3dda35e8fd995518f632a341b13a841
  $s$fMonadParsecesParsecT_$spTokens ::
    (Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
     -> Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
     -> GHC.Types.Bool)
    -> Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
    -> Text.Megaparsec.Internal.ParsecT
         e
         [GHC.Types.Char]
         m
         (Text.Megaparsec.Stream.Tokens [GHC.Types.Char])
  {- Arity: 2, Strictness: <L,C(C1(U))><L,U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   (f2 :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                          -> Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                          -> GHC.Types.Bool)
                   (tts :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char])
                   @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (eok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 case s1 of wild { Text.Megaparsec.State.State input dt3 pst ->
                 let {
                   o :: GHC.Types.Int = GHC.Types.I# dt3
                 } in
                 let {
                   unexpect :: GHC.Types.Int
                               -> Text.Megaparsec.Error.ErrorItem
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                               -> Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                     {- Arity: 2 -}
                   = \ (pos' :: GHC.Types.Int)
                       (u :: Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                     Text.Megaparsec.Error.TrivialError
                       @ [GHC.Types.Char]
                       @ e
                       pos'
                       (GHC.Maybe.Just
                          @ (Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                          u)
                       (Data.Set.Internal.$WBin
                          @ (Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                          (GHC.Types.I# 1#)
                          (Text.Megaparsec.Error.Tokens
                             @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                             (case tts
                                     `cast`
                                   (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]) ; ([Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))])_R) of wild1 {
                                []
                                -> Data.List.NonEmpty.cycle1
                                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                : a1 as3
                                -> GHC.Base.:|
                                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                     a1
                                     as3 }))
                          (Data.Set.Internal.Tip
                             @ (Text.Megaparsec.Error.ErrorItem
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                          (Data.Set.Internal.Tip
                             @ (Text.Megaparsec.Error.ErrorItem
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                 } in
                 let {
                   len :: GHC.Types.Int
                   = case GHC.List.$wlenAcc
                            @ GHC.Types.Char
                            tts `cast` (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                            0# of ww2 { DEFAULT ->
                     GHC.Types.I# ww2 }
                 } in
                 case Text.Megaparsec.Stream.$fStream[]_$ctakeN_
                        len
                        input of wild1 {
                   GHC.Maybe.Nothing
                   -> eerr
                        (unexpect
                           o
                           (Text.Megaparsec.Error.EndOfInput
                              @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                        wild
                   GHC.Maybe.Just ds1
                   -> case ds1 of wild2 { (,) tts' input' ->
                      case f2 tts tts' of wild3 {
                        GHC.Types.False
                        -> eerr
                             (unexpect
                                o
                                (Text.Megaparsec.Error.Tokens
                                   @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                   (case tts'
                                           `cast`
                                         (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]) ; ([Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))])_R) of wild4 {
                                      []
                                      -> Data.List.NonEmpty.cycle1
                                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                      : a1 as3
                                      -> GHC.Base.:|
                                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                           a1
                                           as3 })))
                             (Text.Megaparsec.State.$WState @ [GHC.Types.Char] input o pst)
                        GHC.Types.True
                        -> let {
                             st :: Text.Megaparsec.State.State [GHC.Types.Char]
                             = case len of wild4 { GHC.Types.I# y ->
                               Text.Megaparsec.State.$WState
                                 @ [GHC.Types.Char]
                                 input'
                                 (GHC.Types.I# (GHC.Prim.+# dt3 y))
                                 pst }
                           } in
                           case tts
                                  `cast`
                                (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0])) of wild4 {
                             []
                             -> eok
                                  tts'
                                  st
                                  (GHC.Types.[]
                                     @ (Data.Set.Internal.Set
                                          (Text.Megaparsec.Error.ErrorItem
                                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                    `cast`
                                  (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                            <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                             : ds2 ds3
                             -> cok
                                  tts'
                                  st
                                  (GHC.Types.[]
                                     @ (Data.Set.Internal.Set
                                          (Text.Megaparsec.Error.ErrorItem
                                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                    `cast`
                                  (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                            <Text.Megaparsec.Stream.Token
                                               [GHC.Types.Char]>_N)) } } } } })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N).
                 <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                  -> Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                  -> GHC.Types.Bool>_R
                 ->_R <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N
                               <[GHC.Types.Char]>_N
                               <m>_R
                               <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]>_R)) -}
9712d7b1dcd5d2487182516cb3d77b67
  $s$fMonadParsecesParsecT_$spWithRecovery ::
    (Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
     -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a)
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a
  {- Arity: 7, HasNoCafRefs,
     Strictness: <L,C(C1(C1(C1(C1(C1(U))))))><C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,U><L,U><L,C(C1(U))><L,U><L,C(C1(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   (r :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                         -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a)
                   (p4 :: Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a)
                   @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: a
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (cerr :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (eok :: a
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 p4
                   `cast`
                 (Text.Megaparsec.Internal.N:ParsecT[0]
                      <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                   @ b
                   s1
                   cok
                   (\ (err :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                      (ms :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                    (r err)
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                      @ b
                      ms
                      (\ (x22 :: a)
                         (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                         (ds :: Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                       cok
                         x22
                         s'
                         (GHC.Types.[]
                            @ (Data.Set.Internal.Set
                                 (Text.Megaparsec.Error.ErrorItem
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                           `cast`
                         (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                   <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)))
                      (\ (ds :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                         (ds1 :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                       cerr err ms)
                      (\ (x22 :: a)
                         (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                         (ds :: Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                       eok
                         x22
                         s'
                         (case err of wild {
                            Text.Megaparsec.Error.TrivialError errOffset ds1 ps6
                            -> case s' of wild1 { Text.Megaparsec.State.State ds2 dt3 ds3 ->
                               case GHC.Classes.eqInt (GHC.Types.I# dt3) errOffset of wild2 {
                                 GHC.Types.False
                                 -> (GHC.Types.[]
                                       @ (Data.Set.Internal.Set
                                            (Text.Megaparsec.Error.ErrorItem
                                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                      `cast`
                                    (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                              <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                                 GHC.Types.True
                                 -> case ps6 of wild3 {
                                      Data.Set.Internal.Bin dt4 ds4 ds5 ds6
                                      -> (GHC.Base.build
                                            @ (Data.Set.Internal.Set
                                                 (Text.Megaparsec.Error.ErrorItem
                                                    (Text.Megaparsec.Stream.Token
                                                       [GHC.Types.Char])))
                                            (\ @ a1
                                               (c :: Data.Set.Internal.Set
                                                       (Text.Megaparsec.Error.ErrorItem
                                                          (Text.Megaparsec.Stream.Token
                                                             [GHC.Types.Char]))
                                                     -> a1 -> a1)[OneShot]
                                               (n2 :: a1)[OneShot] ->
                                             c wild3 n2))
                                           `cast`
                                         (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                                   <Text.Megaparsec.Stream.Token
                                                      [GHC.Types.Char]>_N))
                                      Data.Set.Internal.Tip
                                      -> (GHC.Types.[]
                                            @ (Data.Set.Internal.Set
                                                 (Text.Megaparsec.Error.ErrorItem
                                                    (Text.Megaparsec.Stream.Token
                                                       [GHC.Types.Char]))))
                                           `cast`
                                         (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                                   <Text.Megaparsec.Stream.Token
                                                      [GHC.Types.Char]>_N)) } } }
                            Text.Megaparsec.Error.FancyError ds1 ds2
                            -> (GHC.Types.[]
                                  @ (Data.Set.Internal.Set
                                       (Text.Megaparsec.Error.ErrorItem
                                          (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                 `cast`
                               (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                         <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)) }))
                      (\ (ds :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                         (ds1 :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                       cerr err ms))
                   eok
                   (\ (err :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                      (ms :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                    (r err)
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                      @ b
                      ms
                      (\ (x22 :: a)
                         (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                         (ds :: Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                       cok
                         x22
                         s'
                         (case err of wild {
                            Text.Megaparsec.Error.TrivialError errOffset ds1 ps6
                            -> case s' of wild1 { Text.Megaparsec.State.State ds2 dt3 ds3 ->
                               case GHC.Classes.eqInt (GHC.Types.I# dt3) errOffset of wild2 {
                                 GHC.Types.False
                                 -> (GHC.Types.[]
                                       @ (Data.Set.Internal.Set
                                            (Text.Megaparsec.Error.ErrorItem
                                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                      `cast`
                                    (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                              <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                                 GHC.Types.True
                                 -> case ps6 of wild3 {
                                      Data.Set.Internal.Bin dt4 ds4 ds5 ds6
                                      -> (GHC.Base.build
                                            @ (Data.Set.Internal.Set
                                                 (Text.Megaparsec.Error.ErrorItem
                                                    (Text.Megaparsec.Stream.Token
                                                       [GHC.Types.Char])))
                                            (\ @ a1
                                               (c :: Data.Set.Internal.Set
                                                       (Text.Megaparsec.Error.ErrorItem
                                                          (Text.Megaparsec.Stream.Token
                                                             [GHC.Types.Char]))
                                                     -> a1 -> a1)[OneShot]
                                               (n2 :: a1)[OneShot] ->
                                             c wild3 n2))
                                           `cast`
                                         (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                                   <Text.Megaparsec.Stream.Token
                                                      [GHC.Types.Char]>_N))
                                      Data.Set.Internal.Tip
                                      -> (GHC.Types.[]
                                            @ (Data.Set.Internal.Set
                                                 (Text.Megaparsec.Error.ErrorItem
                                                    (Text.Megaparsec.Stream.Token
                                                       [GHC.Types.Char]))))
                                           `cast`
                                         (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                                   <Text.Megaparsec.Stream.Token
                                                      [GHC.Types.Char]>_N)) } } }
                            Text.Megaparsec.Error.FancyError ds1 ds2
                            -> (GHC.Types.[]
                                  @ (Data.Set.Internal.Set
                                       (Text.Megaparsec.Error.ErrorItem
                                          (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                 `cast`
                               (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                         <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)) }))
                      (\ (ds :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                         (ds1 :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                       eerr err ms)
                      (\ (x22 :: a)
                         (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                         (ds :: Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                       eok
                         x22
                         s'
                         (case err of wild {
                            Text.Megaparsec.Error.TrivialError errOffset ds1 ps6
                            -> case s' of wild1 { Text.Megaparsec.State.State ds2 dt3 ds3 ->
                               case GHC.Classes.eqInt (GHC.Types.I# dt3) errOffset of wild2 {
                                 GHC.Types.False
                                 -> (GHC.Types.[]
                                       @ (Data.Set.Internal.Set
                                            (Text.Megaparsec.Error.ErrorItem
                                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                      `cast`
                                    (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                              <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                                 GHC.Types.True
                                 -> case ps6 of wild3 {
                                      Data.Set.Internal.Bin dt4 ds4 ds5 ds6
                                      -> (GHC.Base.build
                                            @ (Data.Set.Internal.Set
                                                 (Text.Megaparsec.Error.ErrorItem
                                                    (Text.Megaparsec.Stream.Token
                                                       [GHC.Types.Char])))
                                            (\ @ a1
                                               (c :: Data.Set.Internal.Set
                                                       (Text.Megaparsec.Error.ErrorItem
                                                          (Text.Megaparsec.Stream.Token
                                                             [GHC.Types.Char]))
                                                     -> a1 -> a1)[OneShot]
                                               (n2 :: a1)[OneShot] ->
                                             c wild3 n2))
                                           `cast`
                                         (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                                   <Text.Megaparsec.Stream.Token
                                                      [GHC.Types.Char]>_N))
                                      Data.Set.Internal.Tip
                                      -> (GHC.Types.[]
                                            @ (Data.Set.Internal.Set
                                                 (Text.Megaparsec.Error.ErrorItem
                                                    (Text.Megaparsec.Stream.Token
                                                       [GHC.Types.Char]))))
                                           `cast`
                                         (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                                   <Text.Megaparsec.Stream.Token
                                                      [GHC.Types.Char]>_N)) } } }
                            Text.Megaparsec.Error.FancyError ds1 ds2
                            -> (GHC.Types.[]
                                  @ (Data.Set.Internal.Set
                                       (Text.Megaparsec.Error.ErrorItem
                                          (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                 `cast`
                               (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                         <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)) }))
                      (\ (ds :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                         (ds1 :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                       eerr err ms)))
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N).
                 <Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                  -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                 ->_R <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)) -}
64978119dcd6c5f8bc0f8e0aaf10eceb
  $s$fOrdErrorFancy ::
    GHC.Classes.Ord (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                  SEDEL.Parser.Parser.$s$fEqErrorFancy
                  (Text.Megaparsec.Error.$fOrdErrorFancy_$ccompare
                     @ Data.Void.Void
                     Data.Void.$fOrdVoid)
                  (Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                     @ Data.Void.Void
                     Data.Void.$fOrdVoid)
                  (\ (a :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                     (b :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                   case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                          @ Data.Void.Void
                          Data.Void.$fOrdVoid
                          b
                          a of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (a :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                     (b :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                   Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                     @ Data.Void.Void
                     Data.Void.$fOrdVoid
                     b
                     a)
                  (\ (a :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                     (b :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                   case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                          @ Data.Void.Void
                          Data.Void.$fOrdVoid
                          a
                          b of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (x22 :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                     (y :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                   case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                          @ Data.Void.Void
                          Data.Void.$fOrdVoid
                          y
                          x22 of wild {
                     GHC.Types.False -> y GHC.Types.True -> x22 })
                  (\ (x22 :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                     (y :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                   case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                          @ Data.Void.Void
                          Data.Void.$fOrdVoid
                          y
                          x22 of wild {
                     GHC.Types.False -> x22 GHC.Types.True -> y }) -}
677ee7cb17ffe89a844b582d21815a66
  $s$fOrdErrorFancy_$c<= ::
    Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                   (b :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                 case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                        @ Data.Void.Void
                        Data.Void.$fOrdVoid
                        b
                        a of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
e709a965c2c7983d7fe83b459d73d7ae
  $s$fOrdErrorFancy_$c>= ::
    Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                   (b :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                 case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                        @ Data.Void.Void
                        Data.Void.$fOrdVoid
                        a
                        b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
e6efd8194217857ed78396eaf46bf16e
  $s$fOrdErrorFancy_$cmax ::
    Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x22 :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                   (y :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                 case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                        @ Data.Void.Void
                        Data.Void.$fOrdVoid
                        y
                        x22 of wild {
                   GHC.Types.False -> y GHC.Types.True -> x22 }) -}
97ae96f1a7827d6181a112932027e55b
  $s$fOrdErrorFancy_$cmin ::
    Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x22 :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                   (y :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                 case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                        @ Data.Void.Void
                        Data.Void.$fOrdVoid
                        y
                        x22 of wild {
                   GHC.Types.False -> x22 GHC.Types.True -> y }) -}
d3d3daf0d3109f4ffecb4496f8b62fce
  $s$fOrdErrorItem ::
    GHC.Classes.Ord
      (Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Text.Megaparsec.Error.ErrorItem
                       (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                  SEDEL.Parser.Parser.$s$fEqErrorItem
                  (Text.Megaparsec.Error.$fOrdErrorItem_$ccompare
                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                     GHC.Classes.$fOrdChar
                       `cast`
                     (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R)
                  (Text.Megaparsec.Error.$fOrdErrorItem_$c<
                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                     GHC.Classes.$fOrdChar
                       `cast`
                     (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R)
                  (\ (a :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                     (b :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                   case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          GHC.Classes.$fOrdChar
                            `cast`
                          (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                          b
                          a of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (a :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                     (b :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                   Text.Megaparsec.Error.$fOrdErrorItem_$c<
                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                     GHC.Classes.$fOrdChar
                       `cast`
                     (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                     b
                     a)
                  (\ (a :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                     (b :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                   case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          GHC.Classes.$fOrdChar
                            `cast`
                          (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                          a
                          b of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (x22 :: Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                     (y :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                   case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          GHC.Classes.$fOrdChar
                            `cast`
                          (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                          y
                          x22 of wild {
                     GHC.Types.False -> y GHC.Types.True -> x22 })
                  (\ (x22 :: Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                     (y :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                   case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          GHC.Classes.$fOrdChar
                            `cast`
                          (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                          y
                          x22 of wild {
                     GHC.Types.False -> x22 GHC.Types.True -> y }) -}
f85ce4bbc531f0a50d2e9afb46d19a7a
  $s$fOrdErrorItem_$c<= ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (b :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                 case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                        @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                        GHC.Classes.$fOrdChar
                          `cast`
                        (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                        b
                        a of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
0ff924c0cecda10cfa2ea11117930f6f
  $s$fOrdErrorItem_$c>= ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (b :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                 case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                        @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                        GHC.Classes.$fOrdChar
                          `cast`
                        (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                        a
                        b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
194d78af3e59c2494dcaa0fd3dbcf610
  $s$fOrdErrorItem_$cmax ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x22 :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (y :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                 case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                        @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                        GHC.Classes.$fOrdChar
                          `cast`
                        (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                        y
                        x22 of wild {
                   GHC.Types.False -> y GHC.Types.True -> x22 }) -}
09418f6dd0df061301c7fe07361da1d9
  $s$fOrdErrorItem_$cmin ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x22 :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (y :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                 case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                        @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                        GHC.Classes.$fOrdChar
                          `cast`
                        (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                        y
                        x22 of wild {
                   GHC.Types.False -> x22 GHC.Types.True -> y }) -}
99fdbc6a11930aa58ab8a4052ea070f0
  $saddPrecLevel ::
    Text.Megaparsec.Internal.ParsecT
      Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity a
    -> [Control.Monad.Combinators.Expr.Operator
          (Text.Megaparsec.Internal.ParsecT
             Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity)
          a]
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity a
  {- Arity: 2, Strictness: <L,C(C1(C1(C1(C1(U)))))><L,1*U> -}
8711477bd43e81a6aeb5251389411b03
  $sinsertR_go3 ::
    GHC.Classes.Ord a1 =>
    a1 -> a1 -> Data.Set.Internal.Set a1 -> Data.Set.Internal.Set a1
  {- Arity: 4,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><L,U><S,1*U><S,1*U> -}
575b124356e95c4470e30bd4b89b14a8
  $sinsert_go3 ::
    GHC.Classes.Ord a1 =>
    a1 -> a1 -> Data.Set.Internal.Set a1 -> Data.Set.Internal.Set a1
  {- Arity: 4,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><L,U><S,1*U><S,1*U> -}
5410fd183b8f98fc79fe9767d549ab22
  $spInfixL ::
    Text.Megaparsec.Internal.ParsecT
      Data.Void.Void
      GHC.Base.String
      Data.Functor.Identity.Identity
      (a -> a -> a)
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity a
    -> a
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity a
  {- Arity: 8,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,U><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Inline: [~] -}
6395756f516a28110762bd42680224b3
  $spInfixR ::
    Text.Megaparsec.Internal.ParsecT
      Data.Void.Void
      GHC.Base.String
      Data.Functor.Identity.Identity
      (a -> a -> a)
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity a
    -> a
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity a
  {- Arity: 8,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,U><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Inline: [~] -}
fba2a1a581011efbe8ac9f990146fabf
  $sskipBlockComment ::
    Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
    -> Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity ()
  {- Arity: 2, Strictness: <L,U><L,U> -}
8c3e71ba18846e0601451d0f8b26e83d
  $swhen1 ::
    Text.Megaparsec.State.State [GHC.Types.Char]
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b)
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><L,A><L,A><C(C(C(S))),1*C1(C1(C1(U)))><L,A>,
     Unfolding: InlineRule (5, True, True)
                (\ @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (ds :: ()
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b)
                   (ds1 :: Text.Megaparsec.Error.ParseError
                             [GHC.Types.Char] Data.Void.Void
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Data.Functor.Identity.Identity b)
                   (eok :: ()
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> Data.Functor.Identity.Identity b)
                   (ds2 :: Text.Megaparsec.Error.ParseError
                             [GHC.Types.Char] Data.Void.Void
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Data.Functor.Identity.Identity b) ->
                 eok
                   GHC.Tuple.()
                   s1
                   (GHC.Types.[]
                      @ (Data.Set.Internal.Set
                           (Text.Megaparsec.Error.ErrorItem
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                     `cast`
                   (Sym (Text.Megaparsec.Internal.N:Hints[0]
                             <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))) -}
be6b667b7bb4edbcaef2526faa0ded3e
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   SEDEL.Parser.Parser.$trModule3
                   SEDEL.Parser.Parser.$trModule1) -}
dc1ce5de5a7e6a3c5ad9e36b0638d341
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Parser.Parser.$trModule2) -}
a042ee096ec763a7f8831a66948ba01c
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SEDEL.Parser.Parser"#) -}
5192296c132e431bc8c3f1353a1a84eb
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Parser.Parser.$trModule4) -}
1321ccafaf4310cf5ceaddb1b78a8998
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ"#) -}
0eba0d36f11d67d3449f08356c261910
  $w$sscientific ::
    [GHC.Types.Char]
    -> GHC.Prim.Int#
    -> Text.Megaparsec.State.PosState [GHC.Types.Char]
    -> (Data.Scientific.Scientific
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <S,U><L,U><L,U><L,C(C1(C1(U)))><L,1*C1(C1(U))>,
     Inline: [2] -}
057e4be1203fe8e71388d15b99ede550
  $w$sskipLineComment ::
    Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
    -> forall b1.
       [GHC.Types.Char]
       -> GHC.Prim.Int#
       -> Text.Megaparsec.State.PosState [GHC.Types.Char]
       -> (()
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b1)
       -> (()
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b1)
       -> (Text.Megaparsec.Error.ParseError
             [GHC.Types.Char] Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Data.Functor.Identity.Identity b1)
       -> Data.Functor.Identity.Identity b1
  {- Arity: 7,
     Strictness: <S,U><L,U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,1*C1(C1(U))>,
     Inline: [2] -}
20ee07a4819c1d4e6ea722022a3b008c
  $w$sspace ::
    Text.Megaparsec.Internal.ParsecT
      Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity ()
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity ()
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity ()
    -> forall b.
       Text.Megaparsec.State.State GHC.Base.String
       -> (()
           -> Text.Megaparsec.State.State GHC.Base.String
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token GHC.Base.String)
           -> Data.Functor.Identity.Identity b)
       -> (Text.Megaparsec.Error.ParseError GHC.Base.String Data.Void.Void
           -> Text.Megaparsec.State.State GHC.Base.String
           -> Data.Functor.Identity.Identity b)
       -> (()
           -> Text.Megaparsec.State.State GHC.Base.String
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token GHC.Base.String)
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 7,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,U(U,U,U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))>,
     Inline: [2] -}
412f0fed4202d05c3263ed0547d7faaa
  $wgo ::
    ([SEDEL.Source.Syntax.SDecl] -> [SEDEL.Source.Syntax.SDecl])
    -> forall b.
       Text.Megaparsec.State.State [GHC.Types.Char]
       -> ([SEDEL.Source.Syntax.SDecl]
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b)
       -> (Text.Megaparsec.Error.ParseError
             [GHC.Types.Char] Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Data.Functor.Identity.Identity b)
       -> ([SEDEL.Source.Syntax.SDecl]
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,C(U)><L,U(U,U,U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))>,
     Inline: [2] -}
5e5111357c90fe0725821c5219544aa8
  $wk ::
    [SEDEL.Source.Syntax.SDecl]
    -> forall b.
       Text.Megaparsec.State.State [GHC.Types.Char]
       -> (SEDEL.Source.Syntax.Module
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b)
       -> (Text.Megaparsec.Error.ParseError
             [GHC.Types.Char] Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Data.Functor.Identity.Identity b)
       -> (SEDEL.Source.Syntax.Module
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,U><L,U(U,U,U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))>,
     Inline: [2] -}
10eb2038326b5a0edf010c8fcb718ea4
  $wlvl ::
    [GHC.Types.Char]
    -> GHC.Prim.Int#
    -> Text.Megaparsec.State.PosState [GHC.Types.Char]
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(C1(U))>,
     Inline: [2],
     Unfolding: (\ @ b
                   (ww :: [GHC.Types.Char])
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: Text.Megaparsec.State.PosState [GHC.Types.Char])
                   (w :: ()
                         -> Text.Megaparsec.State.State [GHC.Types.Char]
                         -> Text.Megaparsec.Internal.Hints
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   []
                   -> w GHC.Tuple.()
                        (Text.Megaparsec.State.State
                           @ [GHC.Types.Char]
                           (GHC.Types.[] @ GHC.Types.Char)
                           ww1
                           ww2)
                        (GHC.Types.[]
                           @ (Data.Set.Internal.Set
                                (Text.Megaparsec.Error.ErrorItem
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                          `cast`
                        (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                  <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                   : t ts
                   -> w1
                        (Text.Megaparsec.Error.TrivialError
                           @ [GHC.Types.Char]
                           @ Data.Void.Void
                           (GHC.Types.I# ww1)
                           (GHC.Maybe.Just
                              @ (Text.Megaparsec.Error.ErrorItem
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              (Text.Megaparsec.Error.Tokens
                                 @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                 (Text.Megaparsec.Internal.nes
                                    @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                    t `cast` (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))))))
                           SEDEL.Parser.Parser.parseModule6)
                        (Text.Megaparsec.State.State @ [GHC.Types.Char] wild ww1 ww2) }) -}
b428990d4e8834faaf9c53131b9cc4a2
  $wprog ::
    Text.Megaparsec.State.State [GHC.Types.Char]
    -> (SEDEL.Source.Syntax.Module
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> (SEDEL.Source.Syntax.Module
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 4,
     Strictness: <L,U(U,U,U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))>,
     Inline: [2],
     Unfolding: (\ @ b1
                   (w :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (w1 :: SEDEL.Source.Syntax.Module
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b1)
                   (w2 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b1)
                   (w3 :: SEDEL.Source.Syntax.Module
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b1) ->
                 SEDEL.Parser.Parser.$wgo
                   (GHC.Base.id @ [SEDEL.Source.Syntax.SDecl])
                   @ b1
                   w
                   (\ (x22 :: [SEDEL.Source.Syntax.SDecl])
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])[OneShot]
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))[OneShot] ->
                    SEDEL.Parser.Parser.$wk
                      x22
                      @ b1
                      s'
                      w1
                      w2
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ SEDEL.Source.Syntax.Module
                         @ [GHC.Types.Char]
                         @ Data.Functor.Identity.Identity
                         @ b1
                         hs
                         w1))
                   w2
                   (\ (x22 :: [SEDEL.Source.Syntax.SDecl])
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])[OneShot]
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))[OneShot] ->
                    SEDEL.Parser.Parser.$wk
                      x22
                      @ b1
                      s'
                      w1
                      w2
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ SEDEL.Source.Syntax.Module
                         @ [GHC.Types.Char]
                         @ Data.Functor.Identity.Identity
                         @ b1
                         hs
                         w3))) -}
5bed25728a675b4e2603a3db2267e6a4
  $wsc ::
    [GHC.Types.Char]
    -> GHC.Prim.Int#
    -> Text.Megaparsec.State.PosState [GHC.Types.Char]
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <S,U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(C1(U))>,
     Inline: [2],
     Unfolding: (\ @ b1
                   (ww :: [GHC.Types.Char])
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: Text.Megaparsec.State.PosState [GHC.Types.Char])
                   (w :: ()
                         -> Text.Megaparsec.State.State [GHC.Types.Char]
                         -> Text.Megaparsec.Internal.Hints
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         -> Data.Functor.Identity.Identity b1)
                   (w1 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b1) ->
                 case GHC.List.$wspan
                        @ GHC.Types.Char
                        GHC.Unicode.isSpace
                        ww of ww3 { (#,#) ww4 ww5 ->
                 case ww4 of wild {
                   []
                   -> w1
                        (Text.Megaparsec.Error.TrivialError
                           @ [GHC.Types.Char]
                           @ Data.Void.Void
                           (GHC.Types.I# ww1)
                           (GHC.Maybe.Just
                              @ (Text.Megaparsec.Error.ErrorItem
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              (case ww of wild1 {
                                 []
                                 -> Text.Megaparsec.Error.EndOfInput
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                 : t ts
                                 -> Text.Megaparsec.Error.Tokens
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                      (Text.Megaparsec.Internal.nes
                                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                         t `cast`
                                         (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))) }))
                           SEDEL.Parser.Parser.parseModule20)
                        (Text.Megaparsec.State.State @ [GHC.Types.Char] ww ww1 ww2)
                   : ds1 ds2
                   -> w GHC.Tuple.()
                        (case GHC.List.$wlenAcc
                                @ GHC.Types.Char
                                wild
                                0# of ww6 { DEFAULT ->
                         Text.Megaparsec.State.State
                           @ [GHC.Types.Char]
                           ww5
                           (GHC.Prim.+# ww1 ww6)
                           ww2 })
                        SEDEL.Parser.Parser.parseModule19
                          `cast`
                        (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                  <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)) } }) -}
beec63f848473aab0fe2fbdbe584efc8
  type Parser =
    Text.Megaparsec.Parsec Data.Void.Void GHC.Base.String :: * -> *
859fecf6da80165842f75b773a664851
  parseModule ::
    GHC.Base.String
    -> Data.Either.Either GHC.Base.String SEDEL.Source.Syntax.Module
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (s :: GHC.Base.String) ->
                 case (Text.Megaparsec.Internal.$fApplicativeParsecT1
                         @ [GHC.Types.Char]
                         @ Data.Void.Void
                         @ Data.Functor.Identity.Identity
                         Text.Megaparsec.Stream.$fStream[]
                         @ SEDEL.Source.Syntax.Module
                         @ ()
                         SEDEL.Parser.Parser.parseModule7
                           `cast`
                         (Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                                   <Data.Void.Void>_N
                                   <[GHC.Types.Char]>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <SEDEL.Source.Syntax.Module>_R))
                         SEDEL.Parser.Parser.parseModule5
                           `cast`
                         (Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                                   <Data.Void.Void>_N
                                   <[GHC.Types.Char]>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <()>_R))
                         @ (Text.Megaparsec.Internal.Reply
                              Data.Void.Void GHC.Base.String SEDEL.Source.Syntax.Module)
                         (Text.Megaparsec.State.State
                            @ GHC.Base.String
                            s
                            0#
                            (Text.Megaparsec.State.PosState
                               @ GHC.Base.String
                               s
                               0#
                               SEDEL.Parser.Parser.parseModule_s2
                               Text.Megaparsec.Pos.defaultTabWidth_a
                                 `cast`
                               (Sym (Text.Megaparsec.Pos.N:Pos[0]))
                               (GHC.Types.[] @ GHC.Types.Char)))
                         SEDEL.Parser.Parser.parseModule4
                           `cast`
                         (<SEDEL.Source.Syntax.Module>_R
                          ->_R <Text.Megaparsec.State.State GHC.Base.String>_R
                          ->_R <Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token GHC.Base.String)>_R
                          ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                        <Text.Megaparsec.Internal.Reply
                                           Data.Void.Void
                                           GHC.Base.String
                                           SEDEL.Source.Syntax.Module>_R))
                         SEDEL.Parser.Parser.parseModule3
                           `cast`
                         (<Text.Megaparsec.Error.ParseError
                             GHC.Base.String Data.Void.Void>_R
                          ->_R <Text.Megaparsec.State.State GHC.Base.String>_R
                          ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                        <Text.Megaparsec.Internal.Reply
                                           Data.Void.Void
                                           GHC.Base.String
                                           SEDEL.Source.Syntax.Module>_R))
                         SEDEL.Parser.Parser.parseModule2
                           `cast`
                         (<SEDEL.Source.Syntax.Module>_R
                          ->_R <Text.Megaparsec.State.State GHC.Base.String>_R
                          ->_R <Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token GHC.Base.String)>_R
                          ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                        <Text.Megaparsec.Internal.Reply
                                           Data.Void.Void
                                           GHC.Base.String
                                           SEDEL.Source.Syntax.Module>_R))
                         SEDEL.Parser.Parser.parseModule1
                           `cast`
                         (<Text.Megaparsec.Error.ParseError
                             GHC.Base.String Data.Void.Void>_R
                          ->_R <Text.Megaparsec.State.State GHC.Base.String>_R
                          ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                        <Text.Megaparsec.Internal.Reply
                                           Data.Void.Void
                                           GHC.Base.String
                                           SEDEL.Source.Syntax.Module>_R)))
                        `cast`
                      (Data.Functor.Identity.N:Identity[0]
                           <Text.Megaparsec.Internal.Reply
                              Data.Void.Void
                              GHC.Base.String
                              SEDEL.Source.Syntax.Module>_R) of wild { Text.Megaparsec.Internal.Reply s' ds result ->
                 case result of wild1 {
                   Text.Megaparsec.Internal.OK x22
                   -> Data.Either.Right
                        @ GHC.Base.String
                        @ SEDEL.Source.Syntax.Module
                        x22
                   Text.Megaparsec.Internal.Error e1
                   -> Data.Either.Left
                        @ GHC.Base.String
                        @ SEDEL.Source.Syntax.Module
                        (Text.Megaparsec.Error.$werrorBundlePretty
                           @ GHC.Base.String
                           @ Data.Void.Void
                           Text.Megaparsec.Stream.$fStream[]
                           Text.Megaparsec.Error.$fShowErrorComponentVoid
                           e1
                           (GHC.Types.[]
                              @ (Text.Megaparsec.Error.ParseError
                                   GHC.Base.String Data.Void.Void))
                           s
                           0#
                           SEDEL.Parser.Parser.parseModule_s2
                           Text.Megaparsec.Pos.defaultTabWidth_a
                             `cast`
                           (Sym (Text.Megaparsec.Pos.N:Pos[0]))
                           (GHC.Types.[] @ GHC.Types.Char)) } }) -}
ecfe4b65d9b745e8ae1d3a645a68e3ef
  parseModule1 ::
    Text.Megaparsec.Error.ParseError GHC.Base.String Data.Void.Void
    -> Text.Megaparsec.State.State GHC.Base.String
    -> Text.Megaparsec.Internal.Reply
         Data.Void.Void GHC.Base.String SEDEL.Source.Syntax.Module
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m,
     Unfolding: (\ (err :: Text.Megaparsec.Error.ParseError
                             GHC.Base.String Data.Void.Void)
                   (s' :: Text.Megaparsec.State.State GHC.Base.String) ->
                 Text.Megaparsec.Internal.Reply
                   @ Data.Void.Void
                   @ GHC.Base.String
                   @ SEDEL.Source.Syntax.Module
                   s'
                   Text.Megaparsec.Internal.Virgin
                   (Text.Megaparsec.Internal.Error
                      @ GHC.Base.String
                      @ Data.Void.Void
                      @ SEDEL.Source.Syntax.Module
                      err)) -}
871a9c5c05a7c9e1ece157dc9a767150
  parseModule10 ::
    Text.Megaparsec.Internal.ParsecT
      Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity ()
  {- Unfolding: (SEDEL.Parser.Parser.$sskipBlockComment
                   SEDEL.Parser.Parser.parseModule13
                     `cast`
                   (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))
                   SEDEL.Parser.Parser.parseModule11
                     `cast`
                   (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))) -}
bba7132763ef21a4b6d54e2bbf200699
  parseModule11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   SEDEL.Parser.Parser.parseModule12) -}
3c668b2aee434e32864d55e58e29b258
  parseModule12 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("-}"#) -}
8d6648172ed36129f4f0128cbdfcaf10
  parseModule13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   SEDEL.Parser.Parser.parseModule14) -}
7c9dcd316765832881c3b89d8fb1cf64
  parseModule14 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("{-"#) -}
737caf8b5c202155dd43cb1824bd6ecd
  parseModule15 ::
    Text.Megaparsec.State.State [GHC.Types.Char]
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <S(LSL),1*U(U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,1*C1(C1(C1(U)))><L,1*C1(C1(U))>,
     Unfolding: (\ @ b1
                   (w :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (w1 :: ()
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b1)
                   (w2 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b1)
                   (w3 :: ()
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b1)
                   (w4 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b1) ->
                 case w of ww { Text.Megaparsec.State.State ww1 ww2 ww3 ->
                 SEDEL.Parser.Parser.$w$sskipLineComment
                   SEDEL.Parser.Parser.parseModule16
                     `cast`
                   (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))
                   @ b1
                   ww1
                   ww2
                   ww3
                   w1
                   w3
                   w4 }) -}
a1ad04462761248bd72b4ce8c884249d
  parseModule16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   SEDEL.Parser.Parser.parseModule17) -}
8e1cdcc8391fb0be5bd12cf9ec43b698
  parseModule17 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("--"#) -}
186b9ee816247b5cb18fa412e909a4ed
  parseModule18 ::
    Text.Megaparsec.State.State [GHC.Types.Char]
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <S(SSL),1*U(U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(C1(U))>,
     Inline: [2],
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   (w :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (w1 :: ()
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b1)
                   (w2 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b1)
                   (w3 :: ()
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b1)
                   (w4 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b1) ->
                 case w of ww { Text.Megaparsec.State.State ww1 ww2 ww3 ->
                 SEDEL.Parser.Parser.$wsc @ b1 ww1 ww2 ww3 w1 w4 }) -}
43992b2ae702217c92519d93182fca35
  parseModule19 ::
    [Data.Set.Internal.Set
       (Text.Megaparsec.Error.ErrorItem
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]))]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Data.Set.Internal.Set
                        (Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                   SEDEL.Parser.Parser.parseModule20
                   (GHC.Types.[]
                      @ (Data.Set.Internal.Set
                           (Text.Megaparsec.Error.ErrorItem
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))) -}
9a45774652c5b188ccc774caf36c3c3f
  parseModule2 ::
    SEDEL.Source.Syntax.Module
    -> Text.Megaparsec.State.State GHC.Base.String
    -> Text.Megaparsec.Internal.Hints
         (Text.Megaparsec.Stream.Token GHC.Base.String)
    -> Text.Megaparsec.Internal.Reply
         Data.Void.Void GHC.Base.String SEDEL.Source.Syntax.Module
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,A>m,
     Unfolding: (\ (a1 :: SEDEL.Source.Syntax.Module)
                   (s' :: Text.Megaparsec.State.State GHC.Base.String)[OneShot]
                   (ds :: Text.Megaparsec.Internal.Hints
                            (Text.Megaparsec.Stream.Token GHC.Base.String))[OneShot] ->
                 Text.Megaparsec.Internal.Reply
                   @ Data.Void.Void
                   @ GHC.Base.String
                   @ SEDEL.Source.Syntax.Module
                   s'
                   Text.Megaparsec.Internal.Virgin
                   (Text.Megaparsec.Internal.OK
                      @ GHC.Base.String
                      @ Data.Void.Void
                      @ SEDEL.Source.Syntax.Module
                      a1)) -}
4450f404c86a94028597e98b4ebc867a
  parseModule20 ::
    Data.Set.Internal.Set
      (Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
  {- Strictness: m1,
     Unfolding: (Data.Set.Internal.Bin
                   @ (Text.Megaparsec.Error.ErrorItem
                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   1#
                   SEDEL.Parser.Parser.parseModule21
                   (Data.Set.Internal.Tip
                      @ (Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                   (Data.Set.Internal.Tip
                      @ (Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])))) -}
b0caf0501b835fb4594177a44b7ee868
  parseModule21 ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
  {- Strictness: m2,
     Unfolding: (Text.Megaparsec.Error.Label
                   @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                   SEDEL.Parser.Parser.parseModule22) -}
ce6d8b30ed8f57a001f9cf5bec2d951f
  parseModule22 :: GHC.Base.NonEmpty GHC.Types.Char
  {- Strictness: m,
     Unfolding: (GHC.Base.:|
                   @ GHC.Types.Char
                   SEDEL.Parser.Parser.parseModule25
                   SEDEL.Parser.Parser.parseModule23) -}
03e526d48f7a1f428898e2a117499f4a
  parseModule23 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   SEDEL.Parser.Parser.parseModule24) -}
0d7bf3bcb2a30538fe1df54f13f957ed
  parseModule24 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("hite space"#) -}
b79a4a1bc7be9dbb09820e814b17fbce
  parseModule25 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'w'#) -}
bfef57959a1f1cf65e279a433c4d583f
  parseModule3 ::
    Text.Megaparsec.Error.ParseError GHC.Base.String Data.Void.Void
    -> Text.Megaparsec.State.State GHC.Base.String
    -> Text.Megaparsec.Internal.Reply
         Data.Void.Void GHC.Base.String SEDEL.Source.Syntax.Module
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m,
     Unfolding: (\ (err :: Text.Megaparsec.Error.ParseError
                             GHC.Base.String Data.Void.Void)
                   (s' :: Text.Megaparsec.State.State GHC.Base.String) ->
                 Text.Megaparsec.Internal.Reply
                   @ Data.Void.Void
                   @ GHC.Base.String
                   @ SEDEL.Source.Syntax.Module
                   s'
                   Text.Megaparsec.Internal.Consumed
                   (Text.Megaparsec.Internal.Error
                      @ GHC.Base.String
                      @ Data.Void.Void
                      @ SEDEL.Source.Syntax.Module
                      err)) -}
15cde05326be05ab9e437dcb0a50aa95
  parseModule4 ::
    SEDEL.Source.Syntax.Module
    -> Text.Megaparsec.State.State GHC.Base.String
    -> Text.Megaparsec.Internal.Hints
         (Text.Megaparsec.Stream.Token GHC.Base.String)
    -> Text.Megaparsec.Internal.Reply
         Data.Void.Void GHC.Base.String SEDEL.Source.Syntax.Module
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,A>m,
     Unfolding: (\ (a1 :: SEDEL.Source.Syntax.Module)
                   (s' :: Text.Megaparsec.State.State GHC.Base.String)[OneShot]
                   (ds :: Text.Megaparsec.Internal.Hints
                            (Text.Megaparsec.Stream.Token GHC.Base.String))[OneShot] ->
                 Text.Megaparsec.Internal.Reply
                   @ Data.Void.Void
                   @ GHC.Base.String
                   @ SEDEL.Source.Syntax.Module
                   s'
                   Text.Megaparsec.Internal.Consumed
                   (Text.Megaparsec.Internal.OK
                      @ GHC.Base.String
                      @ Data.Void.Void
                      @ SEDEL.Source.Syntax.Module
                      a1)) -}
faef75fe8887b8fff2a459f5c509a833
  parseModule5 ::
    Text.Megaparsec.State.State [GHC.Types.Char]
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b)
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(SSL),1*U(1*U,U,U)><L,A><L,A><L,1*C1(C1(C1(U)))><L,1*C1(C1(U))>,
     Inline: [2],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (w1 :: ()
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: ()
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Megaparsec.State.State ww1 ww2 ww3 ->
                 SEDEL.Parser.Parser.$wlvl @ b ww1 ww2 ww3 w3 w4 }) -}
04d8512829d99c4f2ab589626811d38f
  parseModule6 ::
    Data.Set.Internal.Set
      (Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Data.Set.Internal.Bin
                   @ (Text.Megaparsec.Error.ErrorItem
                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   1#
                   (Text.Megaparsec.Error.EndOfInput
                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (Data.Set.Internal.Tip
                      @ (Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                   (Data.Set.Internal.Tip
                      @ (Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])))) -}
66e75ac88d06d6a070baef79a5f4246a
  parseModule7 ::
    Text.Megaparsec.State.State [GHC.Types.Char]
    -> (SEDEL.Source.Syntax.Module
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> (SEDEL.Source.Syntax.Module
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Unfolding: (Text.Megaparsec.Internal.$fApplicativeParsecT2
                   @ [GHC.Types.Char]
                   @ Data.Void.Void
                   @ Data.Functor.Identity.Identity
                   Text.Megaparsec.Stream.$fStream[]
                   @ ()
                   @ SEDEL.Source.Syntax.Module
                   SEDEL.Parser.Parser.parseModule9
                     `cast`
                   (Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                             <Data.Void.Void>_N
                             <GHC.Base.String>_N
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))
                   SEDEL.Parser.Parser.parseModule8
                     `cast`
                   (Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                             <Data.Void.Void>_N
                             <[GHC.Types.Char]>_N
                             <Data.Functor.Identity.Identity>_R
                             <SEDEL.Source.Syntax.Module>_R))) -}
4d6131061eff678cd92f7c33bba8661e
  parseModule8 ::
    Text.Megaparsec.State.State [GHC.Types.Char]
    -> (SEDEL.Source.Syntax.Module
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> (SEDEL.Source.Syntax.Module
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U(U,U,U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,A>,
     Inline: [2],
     Unfolding: InlineRule (5, True, True)
                (\ @ b1
                   (w :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (w1 :: SEDEL.Source.Syntax.Module
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b1)
                   (w2 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b1)
                   (w3 :: SEDEL.Source.Syntax.Module
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b1)
                   (w4 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b1) ->
                 SEDEL.Parser.Parser.$wprog @ b1 w w1 w2 w3) -}
ad394799d525ff122018e4ab5578fc64
  parseModule9 ::
    Text.Megaparsec.State.State GHC.Base.String
    -> (()
        -> Text.Megaparsec.State.State GHC.Base.String
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token GHC.Base.String)
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError GHC.Base.String Data.Void.Void
        -> Text.Megaparsec.State.State GHC.Base.String
        -> Data.Functor.Identity.Identity b)
    -> (()
        -> Text.Megaparsec.State.State GHC.Base.String
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token GHC.Base.String)
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError GHC.Base.String Data.Void.Void
        -> Text.Megaparsec.State.State GHC.Base.String
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,U(U,U,U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,A>,
     Unfolding: (\ @ b
                   (w :: Text.Megaparsec.State.State GHC.Base.String)
                   (w1 :: ()
                          -> Text.Megaparsec.State.State GHC.Base.String
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token GHC.Base.String)
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Megaparsec.Error.ParseError
                            GHC.Base.String Data.Void.Void
                          -> Text.Megaparsec.State.State GHC.Base.String
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: ()
                          -> Text.Megaparsec.State.State GHC.Base.String
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token GHC.Base.String)
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Megaparsec.Error.ParseError
                            GHC.Base.String Data.Void.Void
                          -> Text.Megaparsec.State.State GHC.Base.String
                          -> Data.Functor.Identity.Identity b) ->
                 SEDEL.Parser.Parser.$w$sspace
                   SEDEL.Parser.Parser.parseModule18
                     `cast`
                   (Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                             <Data.Void.Void>_N
                             <[GHC.Types.Char]>_N
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))
                   SEDEL.Parser.Parser.parseModule15
                     `cast`
                   (Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                             <Data.Void.Void>_N
                             <[GHC.Types.Char]>_N
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))
                   SEDEL.Parser.Parser.parseModule10
                   @ b
                   w
                   w1
                   w2
                   w3) -}
66840531204e3c99781e940f520c14f9
  parseModule_s2 :: Text.Megaparsec.Pos.SourcePos
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Text.Megaparsec.Pos.SourcePos
                   (GHC.Types.[] @ GHC.Types.Char)
                   1#
                   1#) -}
"SPEC/SEDEL.Parser.Parser $fAlternativeParsecT @ Void @ [Char] _" [orphan] forall @ m :: *
                                                                                         -> *
                                                                                  (v1 :: Text.Megaparsec.Stream.Stream
                                                                                           [GHC.Types.Char])
                                                                                  (v :: GHC.Classes.Ord
                                                                                          Data.Void.Void)
  Text.Megaparsec.Internal.$fAlternativeParsecT @ Data.Void.Void
                                                @ [GHC.Types.Char]
                                                @ m
                                                v
                                                v1
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT @ m
"SPEC/SEDEL.Parser.Parser $fAlternativeParsecT1 @ Void @ [Char] _" [orphan] [2] forall @ m :: *
                                                                                              -> *
                                                                                       (w1 :: Text.Megaparsec.Stream.Stream
                                                                                                [GHC.Types.Char])
                                                                                       (w :: GHC.Classes.Ord
                                                                                               Data.Void.Void)
  Text.Megaparsec.Internal.$fAlternativeParsecT1 @ Data.Void.Void
                                                 @ [GHC.Types.Char]
                                                 @ m
                                                 w
                                                 w1
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT1 @ m
"SPEC/SEDEL.Parser.Parser $fAlternativeParsecT3 @ Void @ [Char] _" [orphan] [2] forall @ m :: *
                                                                                              -> *
                                                                                       (w1 :: Text.Megaparsec.Stream.Stream
                                                                                                [GHC.Types.Char])
                                                                                       (w :: GHC.Classes.Ord
                                                                                               Data.Void.Void)
  Text.Megaparsec.Internal.$fAlternativeParsecT3 @ Data.Void.Void
                                                 @ [GHC.Types.Char]
                                                 @ m
                                                 w
                                                 w1
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT3 @ m
"SPEC/SEDEL.Parser.Parser $fApplicativeParsecT @ [Char] _ _" [orphan] forall @ e
                                                                             @ m :: * -> *
                                                                             (v :: Text.Megaparsec.Stream.Stream
                                                                                     [GHC.Types.Char])
  Text.Megaparsec.Internal.$fApplicativeParsecT @ [GHC.Types.Char]
                                                @ e
                                                @ m
                                                v
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT_$s$fApplicativeParsecT
      @ e
      @ m
"SPEC/SEDEL.Parser.Parser $fEqErrorFancy @ Void" [orphan] forall (v :: GHC.Classes.Eq
                                                                         Data.Void.Void)
  Text.Megaparsec.Error.$fEqErrorFancy @ Data.Void.Void v
  = SEDEL.Parser.Parser.$s$fEqErrorFancy
"SPEC/SEDEL.Parser.Parser $fEqErrorFancy_$c/= @ Void" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                                 Data.Void.Void)
  Text.Megaparsec.Error.$fEqErrorFancy_$c/= @ Data.Void.Void $dEq
  = SEDEL.Parser.Parser.$s$fEqErrorFancy_$s$fEqErrorFancy_$c/=
"SPEC/SEDEL.Parser.Parser $fEqErrorItem @ (Token [Char])" [orphan] forall (v :: GHC.Classes.Eq
                                                                                  (Text.Megaparsec.Stream.Token
                                                                                     [GHC.Types.Char]))
  Text.Megaparsec.Error.$fEqErrorItem @ (Text.Megaparsec.Stream.Token
                                           [GHC.Types.Char])
                                      v
  = SEDEL.Parser.Parser.$s$fEqErrorItem
"SPEC/SEDEL.Parser.Parser $fEqErrorItem_$c/= @ (Token [Char])" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                                          (Text.Megaparsec.Stream.Token
                                                                                             [GHC.Types.Char]))
  Text.Megaparsec.Error.$fEqErrorItem_$c/= @ (Text.Megaparsec.Stream.Token
                                                [GHC.Types.Char])
                                           $dEq
  = SEDEL.Parser.Parser.$s$fEqErrorItem_$s$fEqErrorItem_$c/=
"SPEC/SEDEL.Parser.Parser $fMonadParsecT @ [Char] _ _" [orphan] forall @ e
                                                                       @ m :: * -> *
                                                                       (v :: Text.Megaparsec.Stream.Stream
                                                                               [GHC.Types.Char])
  Text.Megaparsec.Internal.$fMonadParsecT @ [GHC.Types.Char]
                                          @ e
                                          @ m
                                          v
  = SEDEL.Parser.Parser.$s$fMonadParsecT @ e @ m
"SPEC/SEDEL.Parser.Parser $fMonadParsecT_$c>> @ [Char] _ _" [orphan] forall @ e
                                                                            @ m :: * -> *
                                                                            ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                           [GHC.Types.Char])
  Text.Megaparsec.Internal.$fMonadParsecT_$c>> @ [GHC.Types.Char]
                                               @ e
                                               @ m
                                               $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecT_$s$fMonadParsecT_$c>>
      @ e
      @ m
"SPEC/SEDEL.Parser.Parser $fMonadParsecesParsecT @ Void @ [Char] _" [orphan] forall @ m :: *
                                                                                           -> *
                                                                                    (v1 :: Text.Megaparsec.Stream.Stream
                                                                                             [GHC.Types.Char])
                                                                                    (v :: GHC.Classes.Ord
                                                                                            Data.Void.Void)
  Text.Megaparsec.Internal.$fMonadParsecesParsecT @ Data.Void.Void
                                                  @ [GHC.Types.Char]
                                                  @ m
                                                  v
                                                  v1
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT @ m
"SPEC/SEDEL.Parser.Parser $fMonadPlusParsecT @ Void @ [Char] _" [orphan] forall @ m :: *
                                                                                       -> *
                                                                                (v1 :: Text.Megaparsec.Stream.Stream
                                                                                         [GHC.Types.Char])
                                                                                (v :: GHC.Classes.Ord
                                                                                        Data.Void.Void)
  Text.Megaparsec.Internal.$fMonadPlusParsecT @ Data.Void.Void
                                              @ [GHC.Types.Char]
                                              @ m
                                              v
                                              v1
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$s$fMonadPlusParsecT
      @ m
"SPEC/SEDEL.Parser.Parser $fOrdErrorFancy @ Void" [orphan] forall (v :: GHC.Classes.Ord
                                                                          Data.Void.Void)
  Text.Megaparsec.Error.$fOrdErrorFancy @ Data.Void.Void v
  = SEDEL.Parser.Parser.$s$fOrdErrorFancy
"SPEC/SEDEL.Parser.Parser $fOrdErrorFancy_$c<= @ Void" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                   Data.Void.Void)
  Text.Megaparsec.Error.$fOrdErrorFancy_$c<= @ Data.Void.Void $dOrd
  = SEDEL.Parser.Parser.$s$fOrdErrorFancy_$c<=
"SPEC/SEDEL.Parser.Parser $fOrdErrorFancy_$c>= @ Void" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                   Data.Void.Void)
  Text.Megaparsec.Error.$fOrdErrorFancy_$c>= @ Data.Void.Void $dOrd
  = SEDEL.Parser.Parser.$s$fOrdErrorFancy_$c>=
"SPEC/SEDEL.Parser.Parser $fOrdErrorFancy_$cmax @ Void" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                    Data.Void.Void)
  Text.Megaparsec.Error.$fOrdErrorFancy_$cmax @ Data.Void.Void $dOrd
  = SEDEL.Parser.Parser.$s$fOrdErrorFancy_$cmax
"SPEC/SEDEL.Parser.Parser $fOrdErrorFancy_$cmin @ Void" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                    Data.Void.Void)
  Text.Megaparsec.Error.$fOrdErrorFancy_$cmin @ Data.Void.Void $dOrd
  = SEDEL.Parser.Parser.$s$fOrdErrorFancy_$cmin
"SPEC/SEDEL.Parser.Parser $fOrdErrorItem @ (Token [Char])" [orphan] forall (v :: GHC.Classes.Ord
                                                                                   (Text.Megaparsec.Stream.Token
                                                                                      [GHC.Types.Char]))
  Text.Megaparsec.Error.$fOrdErrorItem @ (Text.Megaparsec.Stream.Token
                                            [GHC.Types.Char])
                                       v
  = SEDEL.Parser.Parser.$s$fOrdErrorItem
"SPEC/SEDEL.Parser.Parser $fOrdErrorItem_$c<= @ (Token [Char])" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                            (Text.Megaparsec.Stream.Token
                                                                                               [GHC.Types.Char]))
  Text.Megaparsec.Error.$fOrdErrorItem_$c<= @ (Text.Megaparsec.Stream.Token
                                                 [GHC.Types.Char])
                                            $dOrd
  = SEDEL.Parser.Parser.$s$fOrdErrorItem_$c<=
"SPEC/SEDEL.Parser.Parser $fOrdErrorItem_$c>= @ (Token [Char])" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                            (Text.Megaparsec.Stream.Token
                                                                                               [GHC.Types.Char]))
  Text.Megaparsec.Error.$fOrdErrorItem_$c>= @ (Text.Megaparsec.Stream.Token
                                                 [GHC.Types.Char])
                                            $dOrd
  = SEDEL.Parser.Parser.$s$fOrdErrorItem_$c>=
"SPEC/SEDEL.Parser.Parser $fOrdErrorItem_$cmax @ (Token [Char])" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                             (Text.Megaparsec.Stream.Token
                                                                                                [GHC.Types.Char]))
  Text.Megaparsec.Error.$fOrdErrorItem_$cmax @ (Text.Megaparsec.Stream.Token
                                                  [GHC.Types.Char])
                                             $dOrd
  = SEDEL.Parser.Parser.$s$fOrdErrorItem_$cmax
"SPEC/SEDEL.Parser.Parser $fOrdErrorItem_$cmin @ (Token [Char])" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                             (Text.Megaparsec.Stream.Token
                                                                                                [GHC.Types.Char]))
  Text.Megaparsec.Error.$fOrdErrorItem_$cmin @ (Text.Megaparsec.Stream.Token
                                                  [GHC.Types.Char])
                                             $dOrd
  = SEDEL.Parser.Parser.$s$fOrdErrorItem_$cmin
"SPEC/SEDEL.Parser.Parser addPrecLevel @ (ParsecT
                                           Void String Identity) _" [orphan] forall @ a
                                                                                                                                      ($dMonadPlus :: GHC.Base.MonadPlus
                                                                                                                                                        (Text.Megaparsec.Internal.ParsecT
                                                                                                                                                           Data.Void.Void
                                                                                                                                                           GHC.Base.String
                                                                                                                                                           Data.Functor.Identity.Identity))
  Control.Monad.Combinators.Expr.addPrecLevel @ (Text.Megaparsec.Internal.ParsecT
                                                   Data.Void.Void
                                                   GHC.Base.String
                                                   Data.Functor.Identity.Identity)
                                              @ a
                                              $dMonadPlus
  = SEDEL.Parser.Parser.$saddPrecLevel @ a
"SPEC/SEDEL.Parser.Parser pAp @ [Char] _ _ _ _" [orphan] forall @ e
                                                                @ m :: * -> *
                                                                @ a
                                                                @ b
                                                                ($dStream :: Text.Megaparsec.Stream.Stream
                                                                               [GHC.Types.Char])
  Text.Megaparsec.Internal.pAp @ [GHC.Types.Char]
                               @ e
                               @ m
                               @ a
                               @ b
                               $dStream
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT_$spAp @ e @ m @ a @ b
"SPEC/SEDEL.Parser.Parser pBind @ [Char] _ _ _ _" [orphan] forall @ e
                                                                  @ m :: * -> *
                                                                  @ a
                                                                  @ b
                                                                  ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                 [GHC.Types.Char])
  Text.Megaparsec.Internal.pBind @ [GHC.Types.Char]
                                 @ e
                                 @ m
                                 @ a
                                 @ b
                                 $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecT_$spBind @ e @ m @ a @ b
"SPEC/SEDEL.Parser.Parser pInfixL @ (ParsecT Void String Identity) _" [orphan] forall @ a
                                                                                      ($dMonadPlus :: GHC.Base.MonadPlus
                                                                                                        (Text.Megaparsec.Internal.ParsecT
                                                                                                           Data.Void.Void
                                                                                                           GHC.Base.String
                                                                                                           Data.Functor.Identity.Identity))
  Control.Monad.Combinators.Expr.pInfixL @ (Text.Megaparsec.Internal.ParsecT
                                              Data.Void.Void
                                              GHC.Base.String
                                              Data.Functor.Identity.Identity)
                                         @ a
                                         $dMonadPlus
  = SEDEL.Parser.Parser.$spInfixL @ a
"SPEC/SEDEL.Parser.Parser pInfixR @ (ParsecT Void String Identity) _" [orphan] forall @ a
                                                                                      ($dMonadPlus :: GHC.Base.MonadPlus
                                                                                                        (Text.Megaparsec.Internal.ParsecT
                                                                                                           Data.Void.Void
                                                                                                           GHC.Base.String
                                                                                                           Data.Functor.Identity.Identity))
  Control.Monad.Combinators.Expr.pInfixR @ (Text.Megaparsec.Internal.ParsecT
                                              Data.Void.Void
                                              GHC.Base.String
                                              Data.Functor.Identity.Identity)
                                         @ a
                                         $dMonadPlus
  = SEDEL.Parser.Parser.$spInfixR @ a
"SPEC/SEDEL.Parser.Parser pNotFollowedBy @ [Char] _ _ _" [orphan] forall @ e
                                                                         @ m :: * -> *
                                                                         @ a
                                                                         ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                        [GHC.Types.Char])
  Text.Megaparsec.Internal.pNotFollowedBy @ [GHC.Types.Char]
                                          @ e
                                          @ m
                                          @ a
                                          $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spNotFollowedBy
      @ e
      @ m
      @ a
"SPEC/SEDEL.Parser.Parser pObserving @ [Char] _ _ _" [orphan] forall @ e
                                                                     @ m :: * -> *
                                                                     @ a
                                                                     ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                    [GHC.Types.Char])
  Text.Megaparsec.Internal.pObserving @ [GHC.Types.Char]
                                      @ e
                                      @ m
                                      @ a
                                      $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spObserving
      @ e
      @ m
      @ a
"SPEC/SEDEL.Parser.Parser pPlus @ Void @ [Char] _ _" [orphan] forall @ m :: *
                                                                            -> *
                                                                     @ a
                                                                     ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                    [GHC.Types.Char])
                                                                     ($dOrd :: GHC.Classes.Ord
                                                                                 Data.Void.Void)
  Text.Megaparsec.Internal.pPlus @ Data.Void.Void
                                 @ [GHC.Types.Char]
                                 @ m
                                 @ a
                                 $dOrd
                                 $dStream
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT_$spPlus @ m @ a
"SPEC/SEDEL.Parser.Parser pTakeP _ @ [Char] _" [orphan] forall @ e
                                                               @ m :: * -> *
                                                               ($dStream :: Text.Megaparsec.Stream.Stream
                                                                              [GHC.Types.Char])
  Text.Megaparsec.Internal.pTakeP @ e @ [GHC.Types.Char] @ m $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spTakeP @ e @ m
"SPEC/SEDEL.Parser.Parser pTakeWhile1P _ @ [Char] _" [orphan] forall @ e
                                                                     @ m :: * -> *
                                                                     ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                    [GHC.Types.Char])
  Text.Megaparsec.Internal.pTakeWhile1P @ e
                                        @ [GHC.Types.Char]
                                        @ m
                                        $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spTakeWhile1P
      @ e
      @ m
"SPEC/SEDEL.Parser.Parser pTakeWhileP _ @ [Char] _" [orphan] forall @ e
                                                                    @ m :: * -> *
                                                                    ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                   [GHC.Types.Char])
  Text.Megaparsec.Internal.pTakeWhileP @ e
                                       @ [GHC.Types.Char]
                                       @ m
                                       $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spTakeWhileP
      @ e
      @ m
"SPEC/SEDEL.Parser.Parser pToken _ @ [Char] _ _" [orphan] forall @ e
                                                                 @ m :: * -> *
                                                                 @ a
                                                                 ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                [GHC.Types.Char])
  Text.Megaparsec.Internal.pToken @ e
                                  @ [GHC.Types.Char]
                                  @ m
                                  @ a
                                  $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spToken @ e @ m @ a
"SPEC/SEDEL.Parser.Parser pTokens _ @ [Char] _" [orphan] forall @ e
                                                                @ m :: * -> *
                                                                ($dStream :: Text.Megaparsec.Stream.Stream
                                                                               [GHC.Types.Char])
  Text.Megaparsec.Internal.pTokens @ e
                                   @ [GHC.Types.Char]
                                   @ m
                                   $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spTokens @ e @ m
"SPEC/SEDEL.Parser.Parser pWithRecovery @ [Char] _ _ _" [orphan] forall @ e
                                                                        @ m :: * -> *
                                                                        @ a
                                                                        ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                       [GHC.Types.Char])
  Text.Megaparsec.Internal.pWithRecovery @ [GHC.Types.Char]
                                         @ e
                                         @ m
                                         @ a
                                         $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spWithRecovery
      @ e
      @ m
      @ a
"SPEC/SEDEL.Parser.Parser skipBlockComment @ Void @ [Char] @ (ParsecT
                                                               Void String Identity)" [orphan] forall ($d~ :: Text.Megaparsec.Stream.Token
                                                                                                                                                                                      [GHC.Types.Char]
                                                                                                                                                                                    Data.Type.Equality.~ GHC.Types.Char)
                                                                                                                                                                            ($dMonadParsec :: Text.Megaparsec.Class.MonadParsec
                                                                                                                                                                                                Data.Void.Void
                                                                                                                                                                                                [GHC.Types.Char]
                                                                                                                                                                                                (Text.Megaparsec.Internal.ParsecT
                                                                                                                                                                                                   Data.Void.Void
                                                                                                                                                                                                   GHC.Base.String
                                                                                                                                                                                                   Data.Functor.Identity.Identity))
  Text.Megaparsec.Char.Lexer.skipBlockComment @ Data.Void.Void
                                              @ [GHC.Types.Char]
                                              @ (Text.Megaparsec.Internal.ParsecT
                                                   Data.Void.Void
                                                   GHC.Base.String
                                                   Data.Functor.Identity.Identity)
                                              $dMonadParsec
                                              $d~
  = SEDEL.Parser.Parser.$sskipBlockComment
"SPEC/SEDEL.Parser.Parser union @ (ErrorFancy Void)" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                 (Text.Megaparsec.Error.ErrorFancy
                                                                                    Data.Void.Void))
  Data.Set.Internal.union @ (Text.Megaparsec.Error.ErrorFancy
                               Data.Void.Void)
                          $dOrd
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT_$sunion
"SPEC/SEDEL.Parser.Parser union @ (ErrorItem (Token [Char]))" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                          (Text.Megaparsec.Error.ErrorItem
                                                                                             (Text.Megaparsec.Stream.Token
                                                                                                [GHC.Types.Char])))
  Data.Set.Internal.union @ (Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                          $dOrd
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT_$sunion1
"SPEC/SEDEL.Parser.Parser withHints @ [Char] _ _ _" [orphan] forall @ e
                                                                    @ m :: * -> *
                                                                    @ b
                                                                    ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                   [GHC.Types.Char])
  Text.Megaparsec.Internal.withHints @ [GHC.Types.Char]
                                     @ e
                                     @ m
                                     @ b
                                     $dStream
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT_$swithHints
      @ e
      @ m
      @ b
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

