
==================== FINAL INTERFACE ====================
2019-03-27 11:20:02.067838 UTC

interface sedel-0.1.0.0-AhY9khA6pZOExbzZW5SwDc:SEDEL.Parser.Parser 8063
  interface hash: 1644ea0dcdfa2648d0862d8c501ff333
  ABI hash: 21e5b1211cf84d44261adc3dc2c27fbd
  export-list hash: db0a5b571d2207b9c8a1686c5bb8040b
  orphan hash: 8dfdcfbb469af6eec55c3cec4b767466
  flag hash: 16a70dcce31f6ef91de5271d59b4cb56
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  SEDEL.Parser.Parser.parseModule
module dependencies: SEDEL.Common SEDEL.Source.Syntax
                     SEDEL.Target.Syntax SEDEL.Util
package dependencies: array-0.5.3.0 async-2.2.1 base-4.12.0.0
                      base-orphans-0.8 bifunctors-5.5.3 binary-0.8.6.0
                      bytestring-0.10.8.2 case-insensitive-1.2.0.11 comonad-5.0.4
                      containers-0.6.0.1 deepseq-1.4.4.0 distributive-0.6
                      exceptions-0.10.0 ghc-boot-th-8.6.3 ghc-prim-0.5.3 hashable-1.2.7.0
                      integer-gmp-1.0.2.0 integer-logarithms-1.0.2.2 megaparsec-7.0.4
                      mtl-2.2.2 parser-combinators-1.0.1 pretty-1.1.3.6
                      prettyprinter-1.2.1 primitive-0.6.4.0 profunctors-5.3
                      protolude-0.2.3 scientific-0.3.6.2 stm-2.5.0.0 tagged-0.8.6
                      template-haskell-2.14.0.0 text-1.2.3.1 transformers-0.5.5.0
                      unbound-generics-0.4.0
orphans: sedel-0.1.0.0-AhY9khA6pZOExbzZW5SwDc:SEDEL.Source.Syntax
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.1:Data.Text.Lazy
         text-1.2.3.1:Data.Text binary-0.8.6.0:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show stm-2.5.0.0:Control.Monad.STM
         transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         bifunctors-5.5.3:Data.Bifunctor.Biff
                         bifunctors-5.5.3:Data.Bifunctor.Clown
                         bifunctors-5.5.3:Data.Bifunctor.Joker
                         bifunctors-5.5.3:Data.Bifunctor.Product
                         bifunctors-5.5.3:Data.Bifunctor.Sum
                         bifunctors-5.5.3:Data.Bifunctor.Tannen
                         containers-0.6.0.1:Data.IntMap.Internal
                         containers-0.6.0.1:Data.IntSet.Internal
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Sequence.Internal
                         containers-0.6.0.1:Data.Set.Internal containers-0.6.0.1:Data.Tree
                         ghc-boot-th-8.6.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.6.3:GHC.LanguageExtensions.Type
                         megaparsec-7.0.4:Text.Megaparsec.Error
                         megaparsec-7.0.4:Text.Megaparsec.Pos
                         megaparsec-7.0.4:Text.Megaparsec.State
                         megaparsec-7.0.4:Text.Megaparsec.Stream
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         prettyprinter-1.2.1:Data.Text.Prettyprint.Doc.Internal
                         primitive-0.6.4.0:Control.Monad.Primitive
                         primitive-0.6.4.0:Data.Primitive.Array
                         sedel-0.1.0.0-AhY9khA6pZOExbzZW5SwDc:SEDEL.Common
                         sedel-0.1.0.0-AhY9khA6pZOExbzZW5SwDc:SEDEL.Source.Syntax
                         sedel-0.1.0.0-AhY9khA6pZOExbzZW5SwDc:SEDEL.Target.Syntax
                         tagged-0.8.6:Data.Tagged
                         template-haskell-2.14.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.1:Data.Text text-1.2.3.1:Data.Text.Lazy
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Bind
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Embed
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Ignore
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Name
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Rebind
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Rec
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Shift
import  -/  base-4.12.0.0:Control.Applicative f4c86ba32601955aaee0c0abccbaeade
import  -/  base-4.12.0.0:Control.Arrow 69c338174663ea24b03d3720d8beceec
import  -/  base-4.12.0.0:Data.Either 946a3435d06773e1dbcad1ba5dc18a2c
import  -/  base-4.12.0.0:Data.Foldable 00188ddf89c975fee76bdfad479443c1
import  -/  base-4.12.0.0:Data.Functor 22aac80fdb6c7b7f60b4aaab86afee64
import  -/  base-4.12.0.0:Data.Maybe 1e8e1362415df45376dffd98f8a47766
import  -/  base-4.12.0.0:Data.Void be49dab333a865813434f4da73ec0f4c
import  -/  base-4.12.0.0:GHC.Base cc906f98291a1b830546e99a96674547
import  -/  base-4.12.0.0:GHC.List 734a72beb76d276fb4a0ba2689a5711f
import  -/  base-4.12.0.0:GHC.Show 4e438f26d903388cc6c2c5d64ed01b98
import  -/  base-4.12.0.0:Prelude 5c01365ec01f83bd405ac01cbb9a8d76
import  -/  megaparsec-7.0.4:Text.Megaparsec b1d8d167d8e2d184f840d7f8cf436244
import  -/  megaparsec-7.0.4:Text.Megaparsec.Char 402ebd4caeb9d2c425df07ec1c885dfd
import  -/  megaparsec-7.0.4:Text.Megaparsec.Char.Lexer 6fa2d936841839921e98fee78df1f8e5
import  -/  megaparsec-7.0.4:Text.Megaparsec.Class 1c814450d61c937971debac96a79da07
import  -/  megaparsec-7.0.4:Text.Megaparsec.Common 9caedca4da95cdf8008be8f91c0e5839
import  -/  megaparsec-7.0.4:Text.Megaparsec.Error c00fdd03998c344baa4a5c8bc868da11
import  -/  megaparsec-7.0.4:Text.Megaparsec.Lexer 6f19e5834a0cdffc2a8fdec0768f2aac
import  -/  parser-combinators-1.0.1:Control.Applicative.Combinators 70d67a1f60f27b2d11938553727ddc47
import  -/  parser-combinators-1.0.1:Control.Monad.Combinators 96f00cb3b58d741f70bc77187e641e82
import  -/  parser-combinators-1.0.1:Control.Monad.Combinators.Expr e01439513ffce752a745749fbf29ccf3
import  -/  scientific-0.3.6.2:Data.Scientific 62c85054f4a7aab32f64fcf46ce53efb
import  -/  SEDEL.Common dd957746dc264eb9e0f081197e6a170a
  exports: 2f8960fc3866b3ed3935cca8fdf4af32
  Add 7b5689630bb805d45c2d9b7c91a94aa7
  Arith ba6e6ee2769ab90fc6f8bfe05c457547
  Comp 95be31892a65ce02162c0359b2fd7836
  Div 9d90e9fa046956310d732e8eb846ddaa
  Equ be009671f59de591c88946764f695cd4
  Gt be31fcc4422ad1046b7cadef42d4a00a
  LAnd 76e1d65d2c4efb84dfc892b6876887fc
  LOr 3d9fb39352f5a35a5a2f3fb33be00346
  Logical 5f88c0dcda3f0bb8a2151f64e886bf39
  Lt d3b4077c262575c1c54e4e55843feca5
  Mul dbcecb52257f0e0de6cdb3f840d576b0
  Neq 2a26dcc2307ec55211eb17750235a9c5
  Sub 10f07d4be3387d45df0fd4398e7b0df1
import  -/  SEDEL.Source.Syntax 2df5c51304ce3d5073c843cca574c67e
  exports: d4d2fd645eff9adcf509b28019caf96b
  And 858cda1fbe6f64a52489f771e0708139
  App 2c964fefc28aabf42ed9dbe40c3accd3
  Arr 22416be279c31386e9cc95e9c9b2de68
  BoolT 9eb5ff7582ee586b5677d133bc3c5a82
  BoolV d7377f24937105ba95ef7593def4f4bf
  BotT e9fc1220c215208a25f3ef509fa1d4c0
  DefDecl 496120e2ede708432a09ee90bbbf5564
  Expr 76520494bd75ab62670e86072668ba13
  If 004baac8f2ab270853994d5c063473ee
  Kind 76520494bd75ab62670e86072668ba13
  Label fc63c6ec9c84d81eb04bc3ecb5e488a0
  LitV bd5053bd7f79e6c004652065acad3370
  Merge bfed41bbda08db4fffae7c43cde3fe30
  Module a47f0c051364b204dc99726dd2bf638b
  Module 7a2313ab6449bd182db161ae191980ad
  NumT adf11e6708e5e8a7ec46f283d84a97ad
  Pos e1abba9e1a944fd21252fe9a5857484c
  PrimOp 75d0f502551fe7e315ae75fc195bd1b1
  Proj 6a5a97deaf11de74c15ccfb48a027d1d
  SDecl 6a20fc9eb35596ae2460813625392c86
  SType a5fd2e9b5e852c36afadad4c1a615a65
  SType 76520494bd75ab62670e86072668ba13
  Scheme 76520494bd75ab62670e86072668ba13
  Star fd95d747935c5574b8df46154b9b35c7
  TmBind 7a84d8e4258307cedac55dc7394971f1
  TmBind 76520494bd75ab62670e86072668ba13
  Top 072bc63b13d03508f9113d1a45bc6153
  TopT 1b95963f14ca91731abc40c7b31bb3cf
  TyName 76520494bd75ab62670e86072668ba13
  TypeBind cc28fa5bde9da9a8ce02c1d05dde235b
  TypeBind 76520494bd75ab62670e86072668ba13
import  -/  SEDEL.Util b3c10612bfd95487b72fc93520437345
  exports: 3deb26de07e49528c70b6f9f7e5d21d6
  elam c63b9f2a7822b309396db11a4804c102
  elet 6886d73ac46ecde14c189190dbc2459b
  evar fb5cd28449c7bf61d6760be3fcc07dad
  mkRecds' f083deea0dd1968ea891861ba66e0bbd
  mkRecdsT 1b4d8bbcba019d8db8a6132784ba9bfa
  tforall 3facec132ad986c8b6858c73f5a216b6
  tvar b859690d5afd464a63318a68f823a7a3
import  -/  unbound-generics-0.4.0:Unbound.Generics.LocallyNameless 36704d4dbfb3fb22f46cde363ae796f2
import  -/  unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Name 81d6e7baa0bd0880e550478df477614a
55550246d7dfc09afe974871f9662ed3
  $s$fAlternativeParsecT ::
    GHC.Base.Alternative
      (Text.Megaparsec.Internal.ParsecT
         Data.Void.Void [GHC.Types.Char] m)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *.
                  @ (Text.Megaparsec.Internal.ParsecT
                       Data.Void.Void [GHC.Types.Char] m)
                  (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$s$fApplicativeParsecT
                     @ Data.Void.Void
                     @ m)
                  (Text.Megaparsec.Internal.pZero
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$spPlus @ m)
                  (Text.Megaparsec.Internal.$fAlternativeParsecT3
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m
                     Data.Void.$fOrdVoid
                     Text.Megaparsec.Stream.$fStream[])
                    `cast`
                  (forall (a :: <*>_N).
                   <Text.Megaparsec.Internal.ParsecT
                      Data.Void.Void [GHC.Types.Char] m a>_R
                   ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                                 <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <[a]>_R))
                  (Text.Megaparsec.Internal.$fAlternativeParsecT1
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m
                     Data.Void.$fOrdVoid
                     Text.Megaparsec.Stream.$fStream[])
                    `cast`
                  (forall (a :: <*>_N).
                   <Text.Megaparsec.Internal.ParsecT
                      Data.Void.Void [GHC.Types.Char] m a>_R
                   ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                                 <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <[a]>_R)) -}
abda69bd49b797dd53ac888dfdf79087
  $s$fAlternativeParsecT1 ::
    Text.Megaparsec.Internal.ParsecT
      Data.Void.Void [GHC.Types.Char] m a
    -> forall b.
       Text.Megaparsec.State.State [GHC.Types.Char]
       -> ([a]
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> m b)
       -> (Text.Megaparsec.Error.ParseError
             [GHC.Types.Char] Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
       -> ([a]
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> m b)
       -> (Text.Megaparsec.Error.ParseError
             [GHC.Types.Char] Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
       -> m b
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U(U,U,U)><L,C(U)><L,U><L,C(U)><L,A>,
     Inline: [2],
     Unfolding: InlineRule (6, True, True)
                (\ @ m :: * -> *
                   @ a
                   (w2 :: Text.Megaparsec.Internal.ParsecT
                            Data.Void.Void [GHC.Types.Char] m a)
                   @ b
                   (w3 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (w4 :: [a]
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> m b)
                   (w5 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (w6 :: [a]
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> m b)
                   (w7 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 Text.Megaparsec.Internal.$w$cmany
                   @ Data.Void.Void
                   @ [GHC.Types.Char]
                   @ m
                   Text.Megaparsec.Stream.$fStream[]
                   @ a
                   w2
                   @ b
                   w3
                   w4
                   w5
                   w6) -}
a6eb601e18b252c4367ec2de74e0d564
  $s$fAlternativeParsecT3 ::
    Text.Megaparsec.Internal.ParsecT
      Data.Void.Void [GHC.Types.Char] m a
    -> forall b.
       Text.Megaparsec.State.State [GHC.Types.Char]
       -> ([a]
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> m b)
       -> (Text.Megaparsec.Error.ParseError
             [GHC.Types.Char] Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
       -> ([a]
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> m b)
       -> (Text.Megaparsec.Error.ParseError
             [GHC.Types.Char] Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
       -> m b
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U><L,C(U)><L,U><L,C(U)><L,U>,
     Inline: [2],
     Unfolding: InlineRule (6, True, False)
                (\ @ m :: * -> *
                   @ a
                   (w2 :: Text.Megaparsec.Internal.ParsecT
                            Data.Void.Void [GHC.Types.Char] m a)
                   @ b
                   (w3 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (w4 :: [a]
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> m b)
                   (w5 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (w6 :: [a]
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> m b)
                   (w7 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 Text.Megaparsec.Internal.$w$csome
                   @ Data.Void.Void
                   @ [GHC.Types.Char]
                   @ m
                   Text.Megaparsec.Stream.$fStream[]
                   @ a
                   w2
                   @ b
                   w3
                   w4
                   w5
                   w6
                   w7) -}
2f95f9f1bf70d1753a7291d837dd95e1
  $s$fAlternativeParsecT_$s$fApplicativeParsecT ::
    GHC.Base.Applicative
      (Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e @ m :: * -> *.
                  @ (Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m)
                  (Text.Megaparsec.Internal.$fFunctorParsecT
                     @ e
                     @ [GHC.Types.Char]
                     @ m)
                  (\ @ a ->
                   Text.Megaparsec.Internal.pPure @ a @ e @ [GHC.Types.Char] @ m)
                  (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$spAp @ e @ m)
                  (Text.Megaparsec.Internal.$fAlternativeParsecT2
                     @ [GHC.Types.Char]
                     @ e
                     @ m
                     Text.Megaparsec.Stream.$fStream[])
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                   ->_R <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b>_R
                   ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                                 <e>_N <[GHC.Types.Char]>_N <m>_R <c>_R))
                  (Text.Megaparsec.Internal.$fApplicativeParsecT2
                     @ [GHC.Types.Char]
                     @ e
                     @ m
                     Text.Megaparsec.Stream.$fStream[])
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                   ->_R <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b>_R
                   ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                                 <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R))
                  (Text.Megaparsec.Internal.$fApplicativeParsecT1
                     @ [GHC.Types.Char]
                     @ e
                     @ m
                     Text.Megaparsec.Stream.$fStream[])
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                   ->_R <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b>_R
                   ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                                 <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)) -}
2b9cad79e49fb146158ff4cab2442def
  $s$fAlternativeParsecT_$spAp ::
    Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m (a -> b)
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b
  {- Arity: 7,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,U><L,C(U)><L,U><L,C(U)><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   @ b
                   (m37 :: Text.Megaparsec.Internal.ParsecT
                             e [GHC.Types.Char] m (a -> b))
                   (k15 :: Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a)
                   @ b1
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: b
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (cerr :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b1)
                   (eok :: b
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (eerr :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b1) ->
                 m37
                   `cast`
                 (Text.Megaparsec.Internal.N:ParsecT[0]
                      <e>_N <[GHC.Types.Char]>_N <m>_R <a -> b>_R)
                   @ b1
                   s1
                   (\ (x22 :: a -> b)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    k15
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                      @ b1
                      s'
                      (GHC.Base..
                         @ b
                         @ (Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Text.Megaparsec.Internal.Hints
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            -> m b1)
                         @ a
                         cok
                         x22)
                      cerr
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ a
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs
                         (GHC.Base..
                            @ b
                            @ (Text.Megaparsec.State.State [GHC.Types.Char]
                               -> Text.Megaparsec.Internal.Hints
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                               -> m b1)
                            @ a
                            cok
                            x22))
                      (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$swithHints
                         @ e
                         @ m
                         @ b1
                         hs
                         cerr))
                   cerr
                   (\ (x22 :: a -> b)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    k15
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                      @ b1
                      s'
                      (GHC.Base..
                         @ b
                         @ (Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Text.Megaparsec.Internal.Hints
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            -> m b1)
                         @ a
                         cok
                         x22)
                      cerr
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ a
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs
                         (GHC.Base..
                            @ b
                            @ (Text.Megaparsec.State.State [GHC.Types.Char]
                               -> Text.Megaparsec.Internal.Hints
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                               -> m b1)
                            @ a
                            eok
                            x22))
                      (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$swithHints
                         @ e
                         @ m
                         @ b1
                         hs
                         eerr))
                   eerr)
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N) (b :: <*>_N).
                 <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m (a -> b)>_R
                 ->_R <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)) -}
d50ef7686b04873d7d5043f8bbcca866
  $s$fAlternativeParsecT_$spPlus ::
    Text.Megaparsec.Internal.ParsecT
      Data.Void.Void [GHC.Types.Char] m a
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void [GHC.Types.Char] m a
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void [GHC.Types.Char] m a
  {- Arity: 7,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,U><L,C(C1(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ m :: * -> *
                   @ a
                   (m37 :: Text.Megaparsec.Internal.ParsecT
                             Data.Void.Void [GHC.Types.Char] m a)
                   (n2 :: Text.Megaparsec.Internal.ParsecT
                            Data.Void.Void [GHC.Types.Char] m a)
                   @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: a
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (cerr :: Text.Megaparsec.Error.ParseError
                              [GHC.Types.Char] Data.Void.Void
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (eok :: a
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              [GHC.Types.Char] Data.Void.Void
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 m37
                   `cast`
                 (Text.Megaparsec.Internal.N:ParsecT[0]
                      <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                   @ b
                   s1
                   cok
                   cerr
                   eok
                   (\ (err :: Text.Megaparsec.Error.ParseError
                                [GHC.Types.Char] Data.Void.Void)
                      (ms :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                    n2
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                      @ b
                      s1
                      cok
                      (\ (err' :: Text.Megaparsec.Error.ParseError
                                    [GHC.Types.Char] Data.Void.Void)
                         (s' :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                       cerr
                         (let {
                            $j :: GHC.Prim.Int#
                                  -> Text.Megaparsec.Error.ParseError
                                       [GHC.Types.Char] Data.Void.Void
                              <join 1> {- Arity: 1 -}
                            = \ (x# :: GHC.Prim.Int#)[OneShot] ->
                              let {
                                $j1 :: GHC.Prim.Int#
                                       -> Text.Megaparsec.Error.ParseError
                                            [GHC.Types.Char] Data.Void.Void
                                  <join 1> {- Arity: 1 -}
                                = \ (y# :: GHC.Prim.Int#)[OneShot] ->
                                  case GHC.Prim.<# x# y# of lwild {
                                    DEFAULT
                                    -> case GHC.Prim.==# x# y# of lwild1 {
                                         DEFAULT -> err'
                                         1#
                                         -> case err' of wild {
                                              Text.Megaparsec.Error.TrivialError s2 u1 p4
                                              -> case err of wild1 {
                                                   Text.Megaparsec.Error.TrivialError ds u2 p5
                                                   -> Text.Megaparsec.Error.TrivialError
                                                        @ [GHC.Types.Char]
                                                        @ Data.Void.Void
                                                        s2
                                                        (case u1 of wild2 {
                                                           GHC.Maybe.Nothing -> u2
                                                           GHC.Maybe.Just x22
                                                           -> case u2 of wild3 {
                                                                GHC.Maybe.Nothing
                                                                -> GHC.Maybe.Just
                                                                     @ (Text.Megaparsec.Error.ErrorItem
                                                                          (Text.Megaparsec.Stream.Token
                                                                             [GHC.Types.Char]))
                                                                     x22
                                                                GHC.Maybe.Just y
                                                                -> GHC.Maybe.Just
                                                                     @ (Text.Megaparsec.Error.ErrorItem
                                                                          (Text.Megaparsec.Stream.Token
                                                                             [GHC.Types.Char]))
                                                                     (case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                                                                             @ (Text.Megaparsec.Stream.Token
                                                                                  [GHC.Types.Char])
                                                                             GHC.Classes.$fOrdChar
                                                                               `cast`
                                                                             (GHC.Classes.Ord
                                                                                (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                                                                             y
                                                                             x22 of wild4 {
                                                                        GHC.Types.False -> y
                                                                        GHC.Types.True
                                                                        -> x22 }) } })
                                                        (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$sunion1
                                                           p4
                                                           p5)
                                                   Text.Megaparsec.Error.FancyError ds ds1
                                                   -> wild1 }
                                              Text.Megaparsec.Error.FancyError ds ds1
                                              -> case err of wild1 {
                                                   Text.Megaparsec.Error.TrivialError ds2 ds3 ds4
                                                   -> wild
                                                   Text.Megaparsec.Error.FancyError ds2 x22
                                                   -> Text.Megaparsec.Error.FancyError
                                                        @ [GHC.Types.Char]
                                                        @ Data.Void.Void
                                                        ds
                                                        (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$sunion
                                                           ds1
                                                           x22) } } }
                                    1# -> err }
                              } in
                              case err of wild {
                                Text.Megaparsec.Error.TrivialError o ds ds1
                                -> case o of wild1 { GHC.Types.I# y# -> $j1 y# }
                                Text.Megaparsec.Error.FancyError o ds
                                -> case o of wild1 { GHC.Types.I# y# -> $j1 y# } }
                          } in
                          case err' of wild {
                            Text.Megaparsec.Error.TrivialError o ds ds1
                            -> case o of wild1 { GHC.Types.I# x# -> $j x# }
                            Text.Megaparsec.Error.FancyError o ds
                            -> case o of wild1 { GHC.Types.I# x# -> $j x# } })
                         (Text.Megaparsec.Internal.longestMatch @ [GHC.Types.Char] ms s'))
                      (\ (x22 :: a)
                         (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                         (hs :: Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                       eok
                         x22
                         s'
                         (GHC.Base.augment
                            @ (Data.Set.Internal.Set
                                 (Text.Megaparsec.Error.ErrorItem
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                            (\ @ b1
                               (c :: Data.Set.Internal.Set
                                       (Text.Megaparsec.Error.ErrorItem
                                          (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                     -> b1 -> b1)[OneShot]
                               (n3 :: b1)[OneShot] ->
                             case err of wild {
                               Text.Megaparsec.Error.TrivialError errOffset ds ps6
                               -> case s' of wild1 { Text.Megaparsec.State.State ds1 dt3 ds2 ->
                                  case GHC.Classes.eqInt (GHC.Types.I# dt3) errOffset of wild2 {
                                    GHC.Types.False -> n3
                                    GHC.Types.True
                                    -> case ps6 of wild3 {
                                         Data.Set.Internal.Bin dt4 ds4 ds5 ds3 -> c wild3 n3
                                         Data.Set.Internal.Tip -> n3 } } }
                               Text.Megaparsec.Error.FancyError ds ds1 -> n3 })
                            hs
                              `cast`
                            (Text.Megaparsec.Internal.N:Hints[0]
                                 <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                           `cast`
                         (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                   <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)))
                      (\ (err' :: Text.Megaparsec.Error.ParseError
                                    [GHC.Types.Char] Data.Void.Void)
                         (s' :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                       eerr
                         (let {
                            $j :: GHC.Prim.Int#
                                  -> Text.Megaparsec.Error.ParseError
                                       [GHC.Types.Char] Data.Void.Void
                              <join 1> {- Arity: 1 -}
                            = \ (x# :: GHC.Prim.Int#)[OneShot] ->
                              let {
                                $j1 :: GHC.Prim.Int#
                                       -> Text.Megaparsec.Error.ParseError
                                            [GHC.Types.Char] Data.Void.Void
                                  <join 1> {- Arity: 1 -}
                                = \ (y# :: GHC.Prim.Int#)[OneShot] ->
                                  case GHC.Prim.<# x# y# of lwild {
                                    DEFAULT
                                    -> case GHC.Prim.==# x# y# of lwild1 {
                                         DEFAULT -> err'
                                         1#
                                         -> case err' of wild {
                                              Text.Megaparsec.Error.TrivialError s2 u1 p4
                                              -> case err of wild1 {
                                                   Text.Megaparsec.Error.TrivialError ds u2 p5
                                                   -> Text.Megaparsec.Error.TrivialError
                                                        @ [GHC.Types.Char]
                                                        @ Data.Void.Void
                                                        s2
                                                        (case u1 of wild2 {
                                                           GHC.Maybe.Nothing -> u2
                                                           GHC.Maybe.Just x22
                                                           -> case u2 of wild3 {
                                                                GHC.Maybe.Nothing
                                                                -> GHC.Maybe.Just
                                                                     @ (Text.Megaparsec.Error.ErrorItem
                                                                          (Text.Megaparsec.Stream.Token
                                                                             [GHC.Types.Char]))
                                                                     x22
                                                                GHC.Maybe.Just y
                                                                -> GHC.Maybe.Just
                                                                     @ (Text.Megaparsec.Error.ErrorItem
                                                                          (Text.Megaparsec.Stream.Token
                                                                             [GHC.Types.Char]))
                                                                     (case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                                                                             @ (Text.Megaparsec.Stream.Token
                                                                                  [GHC.Types.Char])
                                                                             GHC.Classes.$fOrdChar
                                                                               `cast`
                                                                             (GHC.Classes.Ord
                                                                                (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                                                                             y
                                                                             x22 of wild4 {
                                                                        GHC.Types.False -> y
                                                                        GHC.Types.True
                                                                        -> x22 }) } })
                                                        (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$sunion1
                                                           p4
                                                           p5)
                                                   Text.Megaparsec.Error.FancyError ds ds1
                                                   -> wild1 }
                                              Text.Megaparsec.Error.FancyError ds ds1
                                              -> case err of wild1 {
                                                   Text.Megaparsec.Error.TrivialError ds2 ds3 ds4
                                                   -> wild
                                                   Text.Megaparsec.Error.FancyError ds2 x22
                                                   -> Text.Megaparsec.Error.FancyError
                                                        @ [GHC.Types.Char]
                                                        @ Data.Void.Void
                                                        ds
                                                        (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$sunion
                                                           ds1
                                                           x22) } } }
                                    1# -> err }
                              } in
                              case err of wild {
                                Text.Megaparsec.Error.TrivialError o ds ds1
                                -> case o of wild1 { GHC.Types.I# y# -> $j1 y# }
                                Text.Megaparsec.Error.FancyError o ds
                                -> case o of wild1 { GHC.Types.I# y# -> $j1 y# } }
                          } in
                          case err' of wild {
                            Text.Megaparsec.Error.TrivialError o ds ds1
                            -> case o of wild1 { GHC.Types.I# x# -> $j x# }
                            Text.Megaparsec.Error.FancyError o ds
                            -> case o of wild1 { GHC.Types.I# x# -> $j x# } })
                         (Text.Megaparsec.Internal.longestMatch @ [GHC.Types.Char] ms s'))))
                  `cast`
                (forall (m :: <* -> *>_N) (a :: <*>_N).
                 <Text.Megaparsec.Internal.ParsecT
                    Data.Void.Void [GHC.Types.Char] m a>_R
                 ->_R <Text.Megaparsec.Internal.ParsecT
                         Data.Void.Void [GHC.Types.Char] m a>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <a>_R)) -}
4319a44b6558d8e462bab6df6656916c
  $s$fAlternativeParsecT_$sunion ::
    Data.Set.Internal.Set
      (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
    -> Data.Set.Internal.Set
         (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
    -> Data.Set.Internal.Set
         (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [~] -}
fea4bdcc0937aba3ce53b525c7db70d2
  $s$fAlternativeParsecT_$sunion1 ::
    Data.Set.Internal.Set
      (Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
    -> Data.Set.Internal.Set
         (Text.Megaparsec.Error.ErrorItem
            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
    -> Data.Set.Internal.Set
         (Text.Megaparsec.Error.ErrorItem
            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [~] -}
c28e997fed760fb688d2cecfb39ccf52
  $s$fAlternativeParsecT_$swithHints ::
    Text.Megaparsec.Internal.Hints
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> (Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
        -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
    -> Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
    -> Text.Megaparsec.State.State [GHC.Types.Char]
    -> m b
  {- Arity: 3, Strictness: <L,U><C(S),1*C1(U)><S,1*U>,
     Inline: (sat-args=3),
     Unfolding: InlineRule (3, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ b
                   (ds :: Text.Megaparsec.Internal.Hints
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (c :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                         -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (e1 :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e) ->
                 case e1 of wild {
                   Text.Megaparsec.Error.TrivialError pos us ps6
                   -> c (Text.Megaparsec.Error.TrivialError
                           @ [GHC.Types.Char]
                           @ e
                           pos
                           us
                           (GHC.Base.foldr
                              @ (Data.Set.Internal.Set
                                   (Text.Megaparsec.Error.ErrorItem
                                      (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                              @ (Data.Set.Internal.Set
                                   (Text.Megaparsec.Error.ErrorItem
                                      (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                 -> Data.Set.Internal.Set
                                      (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                              (\ (ds1 :: Data.Set.Internal.Set
                                           (Text.Megaparsec.Error.ErrorItem
                                              (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                 (ds2 :: Data.Set.Internal.Set
                                           (Text.Megaparsec.Error.ErrorItem
                                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                         -> Data.Set.Internal.Set
                                              (Text.Megaparsec.Error.ErrorItem
                                                 (Text.Megaparsec.Stream.Token
                                                    [GHC.Types.Char])))[OneShot]
                                 (v :: Data.Set.Internal.Set
                                         (Text.Megaparsec.Error.ErrorItem
                                            (Text.Megaparsec.Stream.Token
                                               [GHC.Types.Char])))[OneShot] ->
                               case v of z { DEFAULT ->
                               ds2 (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$sunion1 z ds1) })
                              (GHC.Base.id
                                 @ (Data.Set.Internal.Set
                                      (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                              (GHC.Types.:
                                 @ (Data.Set.Internal.Set
                                      (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                 ps6
                                 ds
                                   `cast`
                                 (Text.Megaparsec.Internal.N:Hints[0]
                                      <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                              (Data.Set.Internal.Tip
                                 @ (Text.Megaparsec.Error.ErrorItem
                                      (Text.Megaparsec.Stream.Token [GHC.Types.Char])))))
                   Text.Megaparsec.Error.FancyError ipv ipv1 -> c wild }) -}
998fec5bbea66b624305feac50ce6141
  $s$fEqErrorFancy ::
    GHC.Classes.Eq (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                  (Text.Megaparsec.Error.$fEqErrorFancy_$c==
                     @ Data.Void.Void
                     Data.Void.$fEqVoid)
                  SEDEL.Parser.Parser.$s$fEqErrorFancy_$s$fEqErrorFancy_$c/= -}
b2d5df8c6b63d520712944a80390ee9d
  $s$fEqErrorFancy_$s$fEqErrorFancy_$c/= ::
    Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x22 :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                   (y :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                 case Text.Megaparsec.Error.$fEqErrorFancy_$c==
                        @ Data.Void.Void
                        Data.Void.$fEqVoid
                        x22
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
b2033e77390237c9e4cfe2be6f307ff0
  $s$fEqErrorItem ::
    GHC.Classes.Eq
      (Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Text.Megaparsec.Error.ErrorItem
                       (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                  (Text.Megaparsec.Error.$fEqErrorItem_$c==
                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                     GHC.Classes.$fEqChar
                       `cast`
                     (GHC.Classes.Eq (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R)
                  SEDEL.Parser.Parser.$s$fEqErrorItem_$s$fEqErrorItem_$c/= -}
80e4d23b173f0c5ab06d15834a804333
  $s$fEqErrorItem_$s$fEqErrorItem_$c/= ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x22 :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (y :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                 case Text.Megaparsec.Error.$fEqErrorItem_$c==
                        @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                        GHC.Classes.$fEqChar
                          `cast`
                        (GHC.Classes.Eq (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                        x22
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
d0658f1e89efe0f3636a588ef7e1ec02
  $s$fMonadParsecT ::
    GHC.Base.Monad
      (Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e @ m :: * -> *.
                  @ (Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m)
                  (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$s$fApplicativeParsecT
                     @ e
                     @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecT_$spBind @ e @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecT_$s$fMonadParsecT_$c>>
                     @ e
                     @ m)
                  (\ @ a ->
                   Text.Megaparsec.Internal.pPure @ a @ e @ [GHC.Types.Char] @ m)
                  (Text.Megaparsec.Internal.pFail @ e @ [GHC.Types.Char] @ m) -}
ba070664cffa2598ca5ad8d2f3747e2f
  $s$fMonadParsecT_$s$fMonadParsecT_$c>> ::
    Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b
  {- Arity: 7,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,C(C1(C1(U)))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   @ b
                   (m37 :: Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a)
                   (k15 :: Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b)
                   @ b1
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: b
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (cerr :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b1)
                   (eok :: b
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (eerr :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b1) ->
                 m37
                   `cast`
                 (Text.Megaparsec.Internal.N:ParsecT[0]
                      <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                   @ b1
                   s1
                   (\ (x22 :: a)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    k15
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)
                      @ b1
                      s'
                      cok
                      cerr
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ b
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs
                         cok)
                      (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$swithHints
                         @ e
                         @ m
                         @ b1
                         hs
                         cerr))
                   cerr
                   (\ (x22 :: a)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    k15
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)
                      @ b1
                      s'
                      cok
                      cerr
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ b
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs
                         eok)
                      (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$swithHints
                         @ e
                         @ m
                         @ b1
                         hs
                         eerr))
                   eerr)
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N) (b :: <*>_N).
                 <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                 ->_R <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)) -}
6f084aa49a3ce97cf6cfb83dc24300dd
  $s$fMonadParsecT_$spBind ::
    Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a
    -> (a -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b)
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b
  {- Arity: 7,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(C1(U))))))><L,U><L,U><L,U><L,C(C1(C1(U)))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   @ b
                   (m37 :: Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a)
                   (k15 :: a
                           -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b)
                   @ b1
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: b
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (cerr :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b1)
                   (eok :: b
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (eerr :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b1) ->
                 m37
                   `cast`
                 (Text.Megaparsec.Internal.N:ParsecT[0]
                      <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                   @ b1
                   s1
                   (\ (x22 :: a)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    (k15 x22)
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)
                      @ b1
                      s'
                      cok
                      cerr
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ b
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs
                         cok)
                      (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$swithHints
                         @ e
                         @ m
                         @ b1
                         hs
                         cerr))
                   cerr
                   (\ (x22 :: a)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    (k15 x22)
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)
                      @ b1
                      s'
                      cok
                      cerr
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ b
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs
                         eok)
                      (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$swithHints
                         @ e
                         @ m
                         @ b1
                         hs
                         eerr))
                   eerr)
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N) (b :: <*>_N).
                 <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                 ->_R <a
                       -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)) -}
e579cf33b1e59e379484def4590e682a
  $s$fMonadParsecesParsecT ::
    Text.Megaparsec.Class.MonadParsec
      Data.Void.Void
      [GHC.Types.Char]
      (Text.Megaparsec.Internal.ParsecT
         Data.Void.Void [GHC.Types.Char] m)
  {- Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *.
                  @ Data.Void.Void
                  @ [GHC.Types.Char]
                  @ (Text.Megaparsec.Internal.ParsecT
                       Data.Void.Void [GHC.Types.Char] m)
                  Text.Megaparsec.Stream.$fStream[]
                  (SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$s$fMonadPlusParsecT
                     @ m)
                  (Text.Megaparsec.Internal.pFailure
                     @ [GHC.Types.Char]
                     @ Data.Void.Void
                     @ m)
                  (Text.Megaparsec.Internal.pFancyFailure
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (Text.Megaparsec.Internal.pLabel
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (\ @ a ->
                   Text.Megaparsec.Internal.pLabel
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m
                     @ a
                     (GHC.Types.[] @ GHC.Types.Char))
                  (Text.Megaparsec.Internal.pTry
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (Text.Megaparsec.Internal.pLookAhead
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spNotFollowedBy
                     @ Data.Void.Void
                     @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spWithRecovery
                     @ Data.Void.Void
                     @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spObserving
                     @ Data.Void.Void
                     @ m)
                  (\ @ b
                     (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                     (ds :: ()
                            -> Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Text.Megaparsec.Internal.Hints
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            -> m b)
                     (ds1 :: Text.Megaparsec.Error.ParseError
                               [GHC.Types.Char] Data.Void.Void
                             -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                     (eok :: ()
                             -> Text.Megaparsec.State.State [GHC.Types.Char]
                             -> Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                             -> m b)
                     (eerr :: Text.Megaparsec.Error.ParseError
                                [GHC.Types.Char] Data.Void.Void
                              -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                   case s1 of wild { Text.Megaparsec.State.State input dt3 pst ->
                   let {
                     o :: GHC.Types.Int = GHC.Types.I# dt3
                   } in
                   case input of wild1 {
                     []
                     -> eok
                          GHC.Tuple.()
                          wild
                          (GHC.Types.[]
                             @ (Data.Set.Internal.Set
                                  (Text.Megaparsec.Error.ErrorItem
                                     (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                            `cast`
                          (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                    <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                     : t ts
                     -> eerr
                          (Text.Megaparsec.Error.TrivialError
                             @ [GHC.Types.Char]
                             @ Data.Void.Void
                             o
                             (GHC.Maybe.Just
                                @ (Text.Megaparsec.Error.ErrorItem
                                     (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                (Text.Megaparsec.Error.Tokens
                                   @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                   (Text.Megaparsec.Internal.nes
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                      t `cast`
                                      (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))))))
                             (Data.Set.Internal.$WBin
                                @ (Text.Megaparsec.Error.ErrorItem
                                     (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                (GHC.Types.I# 1#)
                                (Text.Megaparsec.Error.EndOfInput
                                   @ (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                (Data.Set.Internal.Tip
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                (Data.Set.Internal.Tip
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char])))))
                          (Text.Megaparsec.State.$WState @ [GHC.Types.Char] wild1 o pst) } })
                    `cast`
                  (Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                            <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <()>_R))
                  (SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spToken
                     @ Data.Void.Void
                     @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spTokens
                     @ Data.Void.Void
                     @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spTakeWhileP
                     @ Data.Void.Void
                     @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spTakeWhile1P
                     @ Data.Void.Void
                     @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spTakeP
                     @ Data.Void.Void
                     @ m)
                  (\ @ b
                     (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                     (ds :: Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Text.Megaparsec.Internal.Hints
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            -> m b)
                     (ds1 :: Text.Megaparsec.Error.ParseError
                               [GHC.Types.Char] Data.Void.Void
                             -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                     (eok :: Text.Megaparsec.State.State [GHC.Types.Char]
                             -> Text.Megaparsec.State.State [GHC.Types.Char]
                             -> Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                             -> m b)
                     (ds2 :: Text.Megaparsec.Error.ParseError
                               [GHC.Types.Char] Data.Void.Void
                             -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                   eok
                     s1
                     s1
                     (GHC.Types.[]
                        @ (Data.Set.Internal.Set
                             (Text.Megaparsec.Error.ErrorItem
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                       `cast`
                     (Sym (Text.Megaparsec.Internal.N:Hints[0]
                               <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)))
                    `cast`
                  (Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                            <Data.Void.Void>_N
                            <[GHC.Types.Char]>_N
                            <m>_R
                            <Text.Megaparsec.State.State [GHC.Types.Char]>_R))
                  (Text.Megaparsec.Internal.pUpdateParserState
                     @ [GHC.Types.Char]
                     @ Data.Void.Void
                     @ m) -}
155cdf73bba13c4258c8b3b8e4a632a9
  $s$fMonadParsecesParsecT_$s$fMonadPlusParsecT ::
    GHC.Base.MonadPlus
      (Text.Megaparsec.Internal.ParsecT
         Data.Void.Void [GHC.Types.Char] m)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *.
                  @ (Text.Megaparsec.Internal.ParsecT
                       Data.Void.Void [GHC.Types.Char] m)
                  (SEDEL.Parser.Parser.$s$fAlternativeParsecT @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecT @ Data.Void.Void @ m)
                  (Text.Megaparsec.Internal.pZero
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$spPlus @ m) -}
76ec4be2c5bb845ca52c92aea322136d
  $s$fMonadParsecesParsecT_$spNotFollowedBy ::
    Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m ()
  {- Arity: 6, HasNoCafRefs,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><S(LSL),1*U(U,U,U)><L,A><L,A><L,1*C1(C1(C1(U)))><L,1*C1(C1(U))>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   (p4 :: Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a)
                   @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (ds :: ()
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> m b)
                   (ds1 :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (eok :: ()
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 case s1 of wild { Text.Megaparsec.State.State input dt3 ds2 ->
                 let {
                   o :: GHC.Types.Int = GHC.Types.I# dt3
                 } in
                 let {
                   what :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                   = case input of wild1 {
                       []
                       -> Text.Megaparsec.Error.EndOfInput
                            @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                       : t ts
                       -> Text.Megaparsec.Error.Tokens
                            @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            (GHC.Base.:|
                               @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                               t `cast` (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))
                               (GHC.Types.[] @ (Text.Megaparsec.Stream.Token [GHC.Types.Char]))) }
                 } in
                 p4
                   `cast`
                 (Text.Megaparsec.Internal.N:ParsecT[0]
                      <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                   @ b
                   wild
                   (\ (ds3 :: a)
                      (ds4 :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (ds5 :: Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    eerr
                      (Text.Megaparsec.Error.TrivialError
                         @ [GHC.Types.Char]
                         @ e
                         o
                         (GHC.Maybe.Just
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                            what)
                         (Data.Set.Internal.Tip
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                      wild)
                   (\ (ds3 :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                      (ds4 :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                    eok
                      GHC.Tuple.()
                      wild
                      (GHC.Types.[]
                         @ (Data.Set.Internal.Set
                              (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                        `cast`
                      (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)))
                   (\ (ds3 :: a)
                      (ds4 :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (ds5 :: Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    eerr
                      (Text.Megaparsec.Error.TrivialError
                         @ [GHC.Types.Char]
                         @ e
                         o
                         (GHC.Maybe.Just
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                            what)
                         (Data.Set.Internal.Tip
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                      wild)
                   (\ (ds3 :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                      (ds4 :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                    eok
                      GHC.Tuple.()
                      wild
                      (GHC.Types.[]
                         @ (Data.Set.Internal.Set
                              (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                        `cast`
                      (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))) })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N).
                 <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <()>_R)) -}
7e1a3be5d1d36007bbd357f7f5fb0f20
  $s$fMonadParsecesParsecT_$spObserving ::
    Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a
    -> Text.Megaparsec.Internal.ParsecT
         e
         [GHC.Types.Char]
         m
         (Data.Either.Either
            (Text.Megaparsec.Error.ParseError [GHC.Types.Char] e) a)
  {- Arity: 6, HasNoCafRefs,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,U><L,C(U)><L,A><L,C(U)><L,A>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   (p4 :: Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a)
                   @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: Data.Either.Either
                             (Text.Megaparsec.Error.ParseError [GHC.Types.Char] e) a
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (eok :: Data.Either.Either
                             (Text.Megaparsec.Error.ParseError [GHC.Types.Char] e) a
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds1 :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 p4
                   `cast`
                 (Text.Megaparsec.Internal.N:ParsecT[0]
                      <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                   @ b
                   s1
                   (\ (x22 :: a) ->
                    cok
                      (Data.Either.Right
                         @ (Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                         @ a
                         x22))
                   (\ (err :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                    cok
                      (Data.Either.Left
                         @ (Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                         @ a
                         err)
                      s'
                      (GHC.Types.[]
                         @ (Data.Set.Internal.Set
                              (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                        `cast`
                      (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)))
                   (\ (x22 :: a) ->
                    eok
                      (Data.Either.Right
                         @ (Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                         @ a
                         x22))
                   (\ (err :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                    eok
                      (Data.Either.Left
                         @ (Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                         @ a
                         err)
                      s'
                      (case err of wild {
                         Text.Megaparsec.Error.TrivialError errOffset ds2 ps6
                         -> case s' of wild1 { Text.Megaparsec.State.State ds3 dt3 ds4 ->
                            case GHC.Classes.eqInt (GHC.Types.I# dt3) errOffset of wild2 {
                              GHC.Types.False
                              -> (GHC.Types.[]
                                    @ (Data.Set.Internal.Set
                                         (Text.Megaparsec.Error.ErrorItem
                                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                   `cast`
                                 (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                           <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                              GHC.Types.True
                              -> case ps6 of wild3 {
                                   Data.Set.Internal.Bin dt4 ds5 ds6 ds7
                                   -> (GHC.Base.build
                                         @ (Data.Set.Internal.Set
                                              (Text.Megaparsec.Error.ErrorItem
                                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                         (\ @ a1
                                            (c :: Data.Set.Internal.Set
                                                    (Text.Megaparsec.Error.ErrorItem
                                                       (Text.Megaparsec.Stream.Token
                                                          [GHC.Types.Char]))
                                                  -> a1 -> a1)[OneShot]
                                            (n2 :: a1)[OneShot] ->
                                          c wild3 n2))
                                        `cast`
                                      (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                                <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                                   Data.Set.Internal.Tip
                                   -> (GHC.Types.[]
                                         @ (Data.Set.Internal.Set
                                              (Text.Megaparsec.Error.ErrorItem
                                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                        `cast`
                                      (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                                <Text.Megaparsec.Stream.Token
                                                   [GHC.Types.Char]>_N)) } } }
                         Text.Megaparsec.Error.FancyError ds2 ds3
                         -> (GHC.Types.[]
                               @ (Data.Set.Internal.Set
                                    (Text.Megaparsec.Error.ErrorItem
                                       (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                              `cast`
                            (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                      <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)) })))
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N).
                 <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N
                               <[GHC.Types.Char]>_N
                               <m>_R
                               <Data.Either.Either
                                  (Text.Megaparsec.Error.ParseError [GHC.Types.Char] e) a>_R)) -}
55478f0623b2c76953ce7edc70ac4277
  $s$fMonadParsecesParsecT_$spTakeP ::
    GHC.Maybe.Maybe GHC.Base.String
    -> GHC.Types.Int
    -> Text.Megaparsec.Internal.ParsecT
         e
         [GHC.Types.Char]
         m
         (Text.Megaparsec.Stream.Tokens [GHC.Types.Char])
  {- Arity: 7, HasNoCafRefs,
     Strictness: <L,1*U><S(S),1*U(U)><S(LSL),1*U(U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(C1(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   (ml :: GHC.Maybe.Maybe GHC.Base.String)
                   (n2 :: GHC.Types.Int)
                   @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (ds1 :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 case s1 of wild { Text.Megaparsec.State.State input dt3 pst ->
                 let {
                   ps6 :: Data.Set.Internal.Set
                            (Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   = case ml of wild1 {
                       GHC.Maybe.Nothing
                       -> Data.Set.Internal.Tip
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                       GHC.Maybe.Just x22
                       -> case x22 of wild2 {
                            []
                            -> Data.Set.Internal.Tip
                                 @ (Text.Megaparsec.Error.ErrorItem
                                      (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                            : a1 as3
                            -> Data.Set.Internal.$WBin
                                 @ (Text.Megaparsec.Error.ErrorItem
                                      (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                 (GHC.Types.I# 1#)
                                 (Text.Megaparsec.Error.Label
                                    @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                    (GHC.Base.:| @ GHC.Types.Char a1 as3))
                                 (Data.Set.Internal.Tip
                                    @ (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                 (Data.Set.Internal.Tip
                                    @ (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))) } }
                 } in
                 case Text.Megaparsec.Stream.$fStream[]_$ctakeN_ n2 input of wild1 {
                   GHC.Maybe.Nothing
                   -> eerr
                        (Text.Megaparsec.Error.TrivialError
                           @ [GHC.Types.Char]
                           @ e
                           (GHC.Types.I# dt3)
                           (GHC.Maybe.Just
                              @ (Text.Megaparsec.Error.ErrorItem
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              (Text.Megaparsec.Error.EndOfInput
                                 @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                           ps6)
                        wild
                   GHC.Maybe.Just ds2
                   -> case ds2 of wild2 { (,) ts input' ->
                      let {
                        len :: GHC.Types.Int
                        = case GHC.List.$wlenAcc
                                 @ GHC.Types.Char
                                 ts `cast` (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                                 0# of ww2 { DEFAULT ->
                          GHC.Types.I# ww2 }
                      } in
                      case GHC.Classes.neInt len n2 of wild3 {
                        GHC.Types.False
                        -> cok
                             ts
                             (case len of wild4 { GHC.Types.I# y ->
                              Text.Megaparsec.State.$WState
                                @ [GHC.Types.Char]
                                input'
                                (GHC.Types.I# (GHC.Prim.+# dt3 y))
                                pst })
                             (GHC.Types.[]
                                @ (Data.Set.Internal.Set
                                     (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                               `cast`
                             (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                       <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                        GHC.Types.True
                        -> eerr
                             (Text.Megaparsec.Error.TrivialError
                                @ [GHC.Types.Char]
                                @ e
                                (case len of wild4 { GHC.Types.I# y ->
                                 GHC.Types.I# (GHC.Prim.+# dt3 y) })
                                (GHC.Maybe.Just
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                   (Text.Megaparsec.Error.EndOfInput
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                ps6)
                             (Text.Megaparsec.State.$WState
                                @ [GHC.Types.Char]
                                input
                                (GHC.Types.I# dt3)
                                pst) } } } })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Maybe.Maybe GHC.Base.String>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N
                               <[GHC.Types.Char]>_N
                               <m>_R
                               <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]>_R)) -}
780dcc8523c2950f41b35818a296aa8a
  $s$fMonadParsecesParsecT_$spTakeWhile1P ::
    GHC.Maybe.Maybe GHC.Base.String
    -> (Text.Megaparsec.Stream.Token [GHC.Types.Char]
        -> GHC.Types.Bool)
    -> Text.Megaparsec.Internal.ParsecT
         e
         [GHC.Types.Char]
         m
         (Text.Megaparsec.Stream.Tokens [GHC.Types.Char])
  {- Arity: 7, HasNoCafRefs,
     Strictness: <L,1*U><L,C(U)><S(SSL),1*U(U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(C1(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   (ml :: GHC.Maybe.Maybe GHC.Base.String)
                   (f2 :: Text.Megaparsec.Stream.Token [GHC.Types.Char]
                          -> GHC.Types.Bool)
                   @ b
                   (ds :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds1 :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (ds2 :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 case ds of wild { Text.Megaparsec.State.State input dt3 pst ->
                 let {
                   o :: GHC.Types.Int = GHC.Types.I# dt3
                 } in
                 let {
                   ds3 :: ([GHC.Types.Char], [GHC.Types.Char])
                   = GHC.List.span
                       @ GHC.Types.Char
                       f2
                         `cast`
                       (Sub (Text.Megaparsec.Stream.D:R:Token[][0])
                        ->_R <GHC.Types.Bool>_R)
                       input
                 } in
                 let {
                   ts :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                   = case ds3
                            `cast`
                          ((,)
                             (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))
                             <[GHC.Types.Char]>_R)_R of wild1 { (,) ts1 input' ->
                     ts1 }
                 } in
                 case ds3
                        `cast`
                      ((,)
                         (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))
                         <[GHC.Types.Char]>_R)_R of wild1 { (,) ts1 input' ->
                 case ts1
                        `cast`
                      (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0])) of wild2 {
                   []
                   -> eerr
                        (Text.Megaparsec.Error.TrivialError
                           @ [GHC.Types.Char]
                           @ e
                           o
                           (GHC.Maybe.Just
                              @ (Text.Megaparsec.Error.ErrorItem
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              (case input of wild3 {
                                 []
                                 -> Text.Megaparsec.Error.EndOfInput
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                 : t ts2
                                 -> Text.Megaparsec.Error.Tokens
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                      (Text.Megaparsec.Internal.nes
                                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                         t `cast`
                                         (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))) }))
                           (case ml of wild3 {
                              GHC.Maybe.Nothing
                              -> Data.Set.Internal.Tip
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              GHC.Maybe.Just x22
                              -> case x22 of wild4 {
                                   []
                                   -> Data.Set.Internal.Tip
                                        @ (Text.Megaparsec.Error.ErrorItem
                                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                   : a1 as3
                                   -> Data.Set.Internal.$WBin
                                        @ (Text.Megaparsec.Error.ErrorItem
                                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                        (GHC.Types.I# 1#)
                                        (Text.Megaparsec.Error.Label
                                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                           (GHC.Base.:| @ GHC.Types.Char a1 as3))
                                        (Data.Set.Internal.Tip
                                           @ (Text.Megaparsec.Error.ErrorItem
                                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                        (Data.Set.Internal.Tip
                                           @ (Text.Megaparsec.Error.ErrorItem
                                                (Text.Megaparsec.Stream.Token
                                                   [GHC.Types.Char]))) } }))
                        (Text.Megaparsec.State.$WState @ [GHC.Types.Char] input o pst)
                   : ds4 ds5
                   -> cok
                        ts
                        (case GHC.List.$wlenAcc
                                @ GHC.Types.Char
                                ts `cast` (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                                0# of ww2 { DEFAULT ->
                         Text.Megaparsec.State.$WState
                           @ [GHC.Types.Char]
                           input'
                           (GHC.Types.I# (GHC.Prim.+# dt3 ww2))
                           pst })
                        (case ml of wild3 {
                           GHC.Maybe.Nothing
                           -> (GHC.Types.[]
                                 @ (Data.Set.Internal.Set
                                      (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                `cast`
                              (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                        <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                           GHC.Maybe.Just x22
                           -> case x22 of wild4 {
                                []
                                -> (GHC.Types.[]
                                      @ (Data.Set.Internal.Set
                                           (Text.Megaparsec.Error.ErrorItem
                                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                     `cast`
                                   (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                             <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                                : a1 as3
                                -> (GHC.Base.build
                                      @ (Data.Set.Internal.Set
                                           (Text.Megaparsec.Error.ErrorItem
                                              (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                      (\ @ a2
                                         (c :: Data.Set.Internal.Set
                                                 (Text.Megaparsec.Error.ErrorItem
                                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                               -> a2 -> a2)[OneShot]
                                         (n2 :: a2)[OneShot] ->
                                       c (Data.Set.Internal.$WBin
                                            @ (Text.Megaparsec.Error.ErrorItem
                                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                            (GHC.Types.I# 1#)
                                            (Text.Megaparsec.Error.Label
                                               @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                               (GHC.Base.:| @ GHC.Types.Char a1 as3))
                                            (Data.Set.Internal.Tip
                                               @ (Text.Megaparsec.Error.ErrorItem
                                                    (Text.Megaparsec.Stream.Token
                                                       [GHC.Types.Char])))
                                            (Data.Set.Internal.Tip
                                               @ (Text.Megaparsec.Error.ErrorItem
                                                    (Text.Megaparsec.Stream.Token
                                                       [GHC.Types.Char]))))
                                         n2))
                                     `cast`
                                   (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                             <Text.Megaparsec.Stream.Token
                                                [GHC.Types.Char]>_N)) } }) } } })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Maybe.Maybe GHC.Base.String>_R
                 ->_R <Text.Megaparsec.Stream.Token [GHC.Types.Char]
                       -> GHC.Types.Bool>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N
                               <[GHC.Types.Char]>_N
                               <m>_R
                               <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]>_R)) -}
79fa54c81fd2a187ee56425d462c5119
  $s$fMonadParsecesParsecT_$spTakeWhileP ::
    GHC.Maybe.Maybe GHC.Base.String
    -> (Text.Megaparsec.Stream.Token [GHC.Types.Char]
        -> GHC.Types.Bool)
    -> Text.Megaparsec.Internal.ParsecT
         e
         [GHC.Types.Char]
         m
         (Text.Megaparsec.Stream.Tokens [GHC.Types.Char])
  {- Arity: 7,
     Strictness: <L,1*U><L,C(U)><S(SSL),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,1*C1(C1(C1(U)))><L,A>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   (ml :: GHC.Maybe.Maybe GHC.Base.String)
                   (f2 :: Text.Megaparsec.Stream.Token [GHC.Types.Char]
                          -> GHC.Types.Bool)
                   @ b
                   (ds :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds1 :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (eok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds2 :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 case ds of wild { Text.Megaparsec.State.State input dt3 pst ->
                 let {
                   hs :: Text.Megaparsec.Internal.Hints
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                   = case ml of wild1 {
                       GHC.Maybe.Nothing
                       -> (GHC.Types.[]
                             @ (Data.Set.Internal.Set
                                  (Text.Megaparsec.Error.ErrorItem
                                     (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                            `cast`
                          (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                    <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                       GHC.Maybe.Just x22
                       -> case x22 of wild2 {
                            []
                            -> (GHC.Types.[]
                                  @ (Data.Set.Internal.Set
                                       (Text.Megaparsec.Error.ErrorItem
                                          (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                 `cast`
                               (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                         <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                            : a1 as3
                            -> (GHC.Base.build
                                  @ (Data.Set.Internal.Set
                                       (Text.Megaparsec.Error.ErrorItem
                                          (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                  (\ @ a2
                                     (c :: Data.Set.Internal.Set
                                             (Text.Megaparsec.Error.ErrorItem
                                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                           -> a2 -> a2)[OneShot]
                                     (n2 :: a2)[OneShot] ->
                                   c (Data.Set.Internal.$WBin
                                        @ (Text.Megaparsec.Error.ErrorItem
                                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                        (GHC.Types.I# 1#)
                                        (Text.Megaparsec.Error.Label
                                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                           (GHC.Base.:| @ GHC.Types.Char a1 as3))
                                        (Data.Set.Internal.Tip
                                           @ (Text.Megaparsec.Error.ErrorItem
                                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                        (Data.Set.Internal.Tip
                                           @ (Text.Megaparsec.Error.ErrorItem
                                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                     n2))
                                 `cast`
                               (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                         <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)) } }
                 } in
                 let {
                   ds3 :: ([GHC.Types.Char], [GHC.Types.Char])
                   = GHC.List.span
                       @ GHC.Types.Char
                       f2
                         `cast`
                       (Sub (Text.Megaparsec.Stream.D:R:Token[][0])
                        ->_R <GHC.Types.Bool>_R)
                       input
                 } in
                 let {
                   ts :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                   = case ds3
                            `cast`
                          ((,)
                             (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))
                             <[GHC.Types.Char]>_R)_R of wild1 { (,) ts1 input' ->
                     ts1 }
                 } in
                 case ds3
                        `cast`
                      ((,)
                         (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))
                         <[GHC.Types.Char]>_R)_R of wild1 { (,) ts1 input' ->
                 case ts1
                        `cast`
                      (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0])) of wild2 {
                   []
                   -> eok
                        ts
                        (case GHC.List.$wlenAcc
                                @ GHC.Types.Char
                                ts `cast` (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                                0# of ww2 { DEFAULT ->
                         Text.Megaparsec.State.$WState
                           @ [GHC.Types.Char]
                           input'
                           (GHC.Types.I# (GHC.Prim.+# dt3 ww2))
                           pst })
                        hs
                   : ds4 ds5
                   -> cok
                        ts
                        (case GHC.List.$wlenAcc
                                @ GHC.Types.Char
                                ts `cast` (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                                0# of ww2 { DEFAULT ->
                         Text.Megaparsec.State.$WState
                           @ [GHC.Types.Char]
                           input'
                           (GHC.Types.I# (GHC.Prim.+# dt3 ww2))
                           pst })
                        hs } } })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Maybe.Maybe GHC.Base.String>_R
                 ->_R <Text.Megaparsec.Stream.Token [GHC.Types.Char]
                       -> GHC.Types.Bool>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N
                               <[GHC.Types.Char]>_N
                               <m>_R
                               <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]>_R)) -}
d4843df9a7c2ece856cfa423319fec49
  $s$fMonadParsecesParsecT_$spToken ::
    (Text.Megaparsec.Stream.Token [GHC.Types.Char]
     -> GHC.Maybe.Maybe a)
    -> Data.Set.Internal.Set
         (Text.Megaparsec.Error.ErrorItem
            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a
  {- Arity: 7, HasNoCafRefs,
     Strictness: <L,1*C1(U)><L,U><S(SSL),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(C1(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   (test :: Text.Megaparsec.Stream.Token [GHC.Types.Char]
                            -> GHC.Maybe.Maybe a)
                   (ps6 :: Data.Set.Internal.Set
                             (Text.Megaparsec.Error.ErrorItem
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                   @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: a
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (ds1 :: a
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 case s1 of wild { Text.Megaparsec.State.State input dt3 pst ->
                 let {
                   o :: GHC.Types.Int = GHC.Types.I# dt3
                 } in
                 case input of wild1 {
                   []
                   -> eerr
                        (Text.Megaparsec.Error.TrivialError
                           @ [GHC.Types.Char]
                           @ e
                           o
                           (GHC.Maybe.Just
                              @ (Text.Megaparsec.Error.ErrorItem
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              (Text.Megaparsec.Error.EndOfInput
                                 @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                           ps6)
                        wild
                   : t ts
                   -> case test
                             t `cast`
                             (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))) of wild3 {
                        GHC.Maybe.Nothing
                        -> eerr
                             (Text.Megaparsec.Error.TrivialError
                                @ [GHC.Types.Char]
                                @ e
                                o
                                (GHC.Maybe.Just
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                   (Text.Megaparsec.Error.Tokens
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                      (Text.Megaparsec.Internal.nes
                                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                         t `cast`
                                         (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))))))
                                ps6)
                             (Text.Megaparsec.State.$WState @ [GHC.Types.Char] wild1 o pst)
                        GHC.Maybe.Just x22
                        -> cok
                             x22
                             (Text.Megaparsec.State.$WState
                                @ [GHC.Types.Char]
                                ts
                                (GHC.Types.I# (GHC.Prim.+# dt3 1#))
                                pst)
                             (GHC.Types.[]
                                @ (Data.Set.Internal.Set
                                     (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                               `cast`
                             (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                       <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)) } } })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N).
                 <Text.Megaparsec.Stream.Token [GHC.Types.Char]
                  -> GHC.Maybe.Maybe a>_R
                 ->_R <Data.Set.Internal.Set
                         (Text.Megaparsec.Error.ErrorItem
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)) -}
d9a41fd74203efd65fa90cf97c3536f9
  $s$fMonadParsecesParsecT_$spTokens ::
    (Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
     -> Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
     -> GHC.Types.Bool)
    -> Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
    -> Text.Megaparsec.Internal.ParsecT
         e
         [GHC.Types.Char]
         m
         (Text.Megaparsec.Stream.Tokens [GHC.Types.Char])
  {- Arity: 2, Strictness: <L,C(C1(U))><L,U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   (f2 :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                          -> Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                          -> GHC.Types.Bool)
                   (tts :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char])
                   @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (eok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 case s1 of wild { Text.Megaparsec.State.State input dt3 pst ->
                 let {
                   o :: GHC.Types.Int = GHC.Types.I# dt3
                 } in
                 let {
                   unexpect :: GHC.Types.Int
                               -> Text.Megaparsec.Error.ErrorItem
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                               -> Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                     {- Arity: 2 -}
                   = \ (pos' :: GHC.Types.Int)
                       (u :: Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                     Text.Megaparsec.Error.TrivialError
                       @ [GHC.Types.Char]
                       @ e
                       pos'
                       (GHC.Maybe.Just
                          @ (Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                          u)
                       (Data.Set.Internal.$WBin
                          @ (Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                          (GHC.Types.I# 1#)
                          (Text.Megaparsec.Error.Tokens
                             @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                             (case tts
                                     `cast`
                                   (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]) ; ([Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))])_R) of wild1 {
                                []
                                -> Data.List.NonEmpty.cycle1
                                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                : a1 as3
                                -> GHC.Base.:|
                                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                     a1
                                     as3 }))
                          (Data.Set.Internal.Tip
                             @ (Text.Megaparsec.Error.ErrorItem
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                          (Data.Set.Internal.Tip
                             @ (Text.Megaparsec.Error.ErrorItem
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                 } in
                 let {
                   len :: GHC.Types.Int
                   = case GHC.List.$wlenAcc
                            @ GHC.Types.Char
                            tts `cast` (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                            0# of ww2 { DEFAULT ->
                     GHC.Types.I# ww2 }
                 } in
                 case Text.Megaparsec.Stream.$fStream[]_$ctakeN_
                        len
                        input of wild1 {
                   GHC.Maybe.Nothing
                   -> eerr
                        (unexpect
                           o
                           (Text.Megaparsec.Error.EndOfInput
                              @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                        wild
                   GHC.Maybe.Just ds1
                   -> case ds1 of wild2 { (,) tts' input' ->
                      case f2 tts tts' of wild3 {
                        GHC.Types.False
                        -> eerr
                             (unexpect
                                o
                                (Text.Megaparsec.Error.Tokens
                                   @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                   (case tts'
                                           `cast`
                                         (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]) ; ([Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))])_R) of wild4 {
                                      []
                                      -> Data.List.NonEmpty.cycle1
                                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                      : a1 as3
                                      -> GHC.Base.:|
                                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                           a1
                                           as3 })))
                             (Text.Megaparsec.State.$WState @ [GHC.Types.Char] input o pst)
                        GHC.Types.True
                        -> let {
                             st :: Text.Megaparsec.State.State [GHC.Types.Char]
                             = case len of wild4 { GHC.Types.I# y ->
                               Text.Megaparsec.State.$WState
                                 @ [GHC.Types.Char]
                                 input'
                                 (GHC.Types.I# (GHC.Prim.+# dt3 y))
                                 pst }
                           } in
                           case tts
                                  `cast`
                                (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0])) of wild4 {
                             []
                             -> eok
                                  tts'
                                  st
                                  (GHC.Types.[]
                                     @ (Data.Set.Internal.Set
                                          (Text.Megaparsec.Error.ErrorItem
                                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                    `cast`
                                  (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                            <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                             : ds2 ds3
                             -> cok
                                  tts'
                                  st
                                  (GHC.Types.[]
                                     @ (Data.Set.Internal.Set
                                          (Text.Megaparsec.Error.ErrorItem
                                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                    `cast`
                                  (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                            <Text.Megaparsec.Stream.Token
                                               [GHC.Types.Char]>_N)) } } } } })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N).
                 <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                  -> Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                  -> GHC.Types.Bool>_R
                 ->_R <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N
                               <[GHC.Types.Char]>_N
                               <m>_R
                               <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]>_R)) -}
4e0ba0b3dc88f48388b2a9add3f6ccb1
  $s$fMonadParsecesParsecT_$spWithRecovery ::
    (Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
     -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a)
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a
  {- Arity: 7, HasNoCafRefs,
     Strictness: <L,C(C1(C1(C1(C1(C1(U))))))><C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,U><L,U><L,C(C1(U))><L,U><L,C(C1(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   (r :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                         -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a)
                   (p4 :: Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a)
                   @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: a
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (cerr :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (eok :: a
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 p4
                   `cast`
                 (Text.Megaparsec.Internal.N:ParsecT[0]
                      <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                   @ b
                   s1
                   cok
                   (\ (err :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                      (ms :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                    (r err)
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                      @ b
                      ms
                      (\ (x22 :: a)
                         (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                         (ds :: Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                       cok
                         x22
                         s'
                         (GHC.Types.[]
                            @ (Data.Set.Internal.Set
                                 (Text.Megaparsec.Error.ErrorItem
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                           `cast`
                         (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                   <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)))
                      (\ (ds :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                         (ds1 :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                       cerr err ms)
                      (\ (x22 :: a)
                         (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                         (ds :: Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                       eok
                         x22
                         s'
                         (case err of wild {
                            Text.Megaparsec.Error.TrivialError errOffset ds1 ps6
                            -> case s' of wild1 { Text.Megaparsec.State.State ds2 dt3 ds3 ->
                               case GHC.Classes.eqInt (GHC.Types.I# dt3) errOffset of wild2 {
                                 GHC.Types.False
                                 -> (GHC.Types.[]
                                       @ (Data.Set.Internal.Set
                                            (Text.Megaparsec.Error.ErrorItem
                                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                      `cast`
                                    (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                              <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                                 GHC.Types.True
                                 -> case ps6 of wild3 {
                                      Data.Set.Internal.Bin dt4 ds4 ds5 ds6
                                      -> (GHC.Base.build
                                            @ (Data.Set.Internal.Set
                                                 (Text.Megaparsec.Error.ErrorItem
                                                    (Text.Megaparsec.Stream.Token
                                                       [GHC.Types.Char])))
                                            (\ @ a1
                                               (c :: Data.Set.Internal.Set
                                                       (Text.Megaparsec.Error.ErrorItem
                                                          (Text.Megaparsec.Stream.Token
                                                             [GHC.Types.Char]))
                                                     -> a1 -> a1)[OneShot]
                                               (n2 :: a1)[OneShot] ->
                                             c wild3 n2))
                                           `cast`
                                         (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                                   <Text.Megaparsec.Stream.Token
                                                      [GHC.Types.Char]>_N))
                                      Data.Set.Internal.Tip
                                      -> (GHC.Types.[]
                                            @ (Data.Set.Internal.Set
                                                 (Text.Megaparsec.Error.ErrorItem
                                                    (Text.Megaparsec.Stream.Token
                                                       [GHC.Types.Char]))))
                                           `cast`
                                         (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                                   <Text.Megaparsec.Stream.Token
                                                      [GHC.Types.Char]>_N)) } } }
                            Text.Megaparsec.Error.FancyError ds1 ds2
                            -> (GHC.Types.[]
                                  @ (Data.Set.Internal.Set
                                       (Text.Megaparsec.Error.ErrorItem
                                          (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                 `cast`
                               (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                         <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)) }))
                      (\ (ds :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                         (ds1 :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                       cerr err ms))
                   eok
                   (\ (err :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                      (ms :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                    (r err)
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                      @ b
                      ms
                      (\ (x22 :: a)
                         (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                         (ds :: Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                       cok
                         x22
                         s'
                         (case err of wild {
                            Text.Megaparsec.Error.TrivialError errOffset ds1 ps6
                            -> case s' of wild1 { Text.Megaparsec.State.State ds2 dt3 ds3 ->
                               case GHC.Classes.eqInt (GHC.Types.I# dt3) errOffset of wild2 {
                                 GHC.Types.False
                                 -> (GHC.Types.[]
                                       @ (Data.Set.Internal.Set
                                            (Text.Megaparsec.Error.ErrorItem
                                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                      `cast`
                                    (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                              <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                                 GHC.Types.True
                                 -> case ps6 of wild3 {
                                      Data.Set.Internal.Bin dt4 ds4 ds5 ds6
                                      -> (GHC.Base.build
                                            @ (Data.Set.Internal.Set
                                                 (Text.Megaparsec.Error.ErrorItem
                                                    (Text.Megaparsec.Stream.Token
                                                       [GHC.Types.Char])))
                                            (\ @ a1
                                               (c :: Data.Set.Internal.Set
                                                       (Text.Megaparsec.Error.ErrorItem
                                                          (Text.Megaparsec.Stream.Token
                                                             [GHC.Types.Char]))
                                                     -> a1 -> a1)[OneShot]
                                               (n2 :: a1)[OneShot] ->
                                             c wild3 n2))
                                           `cast`
                                         (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                                   <Text.Megaparsec.Stream.Token
                                                      [GHC.Types.Char]>_N))
                                      Data.Set.Internal.Tip
                                      -> (GHC.Types.[]
                                            @ (Data.Set.Internal.Set
                                                 (Text.Megaparsec.Error.ErrorItem
                                                    (Text.Megaparsec.Stream.Token
                                                       [GHC.Types.Char]))))
                                           `cast`
                                         (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                                   <Text.Megaparsec.Stream.Token
                                                      [GHC.Types.Char]>_N)) } } }
                            Text.Megaparsec.Error.FancyError ds1 ds2
                            -> (GHC.Types.[]
                                  @ (Data.Set.Internal.Set
                                       (Text.Megaparsec.Error.ErrorItem
                                          (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                 `cast`
                               (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                         <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)) }))
                      (\ (ds :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                         (ds1 :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                       eerr err ms)
                      (\ (x22 :: a)
                         (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                         (ds :: Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                       eok
                         x22
                         s'
                         (case err of wild {
                            Text.Megaparsec.Error.TrivialError errOffset ds1 ps6
                            -> case s' of wild1 { Text.Megaparsec.State.State ds2 dt3 ds3 ->
                               case GHC.Classes.eqInt (GHC.Types.I# dt3) errOffset of wild2 {
                                 GHC.Types.False
                                 -> (GHC.Types.[]
                                       @ (Data.Set.Internal.Set
                                            (Text.Megaparsec.Error.ErrorItem
                                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                      `cast`
                                    (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                              <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                                 GHC.Types.True
                                 -> case ps6 of wild3 {
                                      Data.Set.Internal.Bin dt4 ds4 ds5 ds6
                                      -> (GHC.Base.build
                                            @ (Data.Set.Internal.Set
                                                 (Text.Megaparsec.Error.ErrorItem
                                                    (Text.Megaparsec.Stream.Token
                                                       [GHC.Types.Char])))
                                            (\ @ a1
                                               (c :: Data.Set.Internal.Set
                                                       (Text.Megaparsec.Error.ErrorItem
                                                          (Text.Megaparsec.Stream.Token
                                                             [GHC.Types.Char]))
                                                     -> a1 -> a1)[OneShot]
                                               (n2 :: a1)[OneShot] ->
                                             c wild3 n2))
                                           `cast`
                                         (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                                   <Text.Megaparsec.Stream.Token
                                                      [GHC.Types.Char]>_N))
                                      Data.Set.Internal.Tip
                                      -> (GHC.Types.[]
                                            @ (Data.Set.Internal.Set
                                                 (Text.Megaparsec.Error.ErrorItem
                                                    (Text.Megaparsec.Stream.Token
                                                       [GHC.Types.Char]))))
                                           `cast`
                                         (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                                   <Text.Megaparsec.Stream.Token
                                                      [GHC.Types.Char]>_N)) } } }
                            Text.Megaparsec.Error.FancyError ds1 ds2
                            -> (GHC.Types.[]
                                  @ (Data.Set.Internal.Set
                                       (Text.Megaparsec.Error.ErrorItem
                                          (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                 `cast`
                               (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                         <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)) }))
                      (\ (ds :: Text.Megaparsec.Error.ParseError [GHC.Types.Char] e)
                         (ds1 :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                       eerr err ms)))
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N).
                 <Text.Megaparsec.Error.ParseError [GHC.Types.Char] e
                  -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                 ->_R <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)) -}
72b24f47e5d69ce6184b6d4e1a293423
  $s$fOrdErrorFancy ::
    GHC.Classes.Ord (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                  SEDEL.Parser.Parser.$s$fEqErrorFancy
                  (Text.Megaparsec.Error.$fOrdErrorFancy_$ccompare
                     @ Data.Void.Void
                     Data.Void.$fOrdVoid)
                  (Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                     @ Data.Void.Void
                     Data.Void.$fOrdVoid)
                  (\ (a :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                     (b :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                   case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                          @ Data.Void.Void
                          Data.Void.$fOrdVoid
                          b
                          a of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (a :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                     (b :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                   Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                     @ Data.Void.Void
                     Data.Void.$fOrdVoid
                     b
                     a)
                  (\ (a :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                     (b :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                   case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                          @ Data.Void.Void
                          Data.Void.$fOrdVoid
                          a
                          b of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (x22 :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                     (y :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                   case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                          @ Data.Void.Void
                          Data.Void.$fOrdVoid
                          y
                          x22 of wild {
                     GHC.Types.False -> y GHC.Types.True -> x22 })
                  (\ (x22 :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                     (y :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                   case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                          @ Data.Void.Void
                          Data.Void.$fOrdVoid
                          y
                          x22 of wild {
                     GHC.Types.False -> x22 GHC.Types.True -> y }) -}
4c89d504812ad799f151feb638143267
  $s$fOrdErrorFancy_$c<= ::
    Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                   (b :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                 case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                        @ Data.Void.Void
                        Data.Void.$fOrdVoid
                        b
                        a of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
2d3dfcdfb321615d66cf03ffb846737a
  $s$fOrdErrorFancy_$c>= ::
    Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                   (b :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                 case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                        @ Data.Void.Void
                        Data.Void.$fOrdVoid
                        a
                        b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
a6ac37daf221688068be17cd3bb894d8
  $s$fOrdErrorFancy_$cmax ::
    Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x22 :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                   (y :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                 case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                        @ Data.Void.Void
                        Data.Void.$fOrdVoid
                        y
                        x22 of wild {
                   GHC.Types.False -> y GHC.Types.True -> x22 }) -}
5eaa27821db1234f60b9516aa3650e39
  $s$fOrdErrorFancy_$cmin ::
    Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x22 :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                   (y :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                 case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                        @ Data.Void.Void
                        Data.Void.$fOrdVoid
                        y
                        x22 of wild {
                   GHC.Types.False -> x22 GHC.Types.True -> y }) -}
769ba9ac900a8905c79c8421a7db0a0e
  $s$fOrdErrorItem ::
    GHC.Classes.Ord
      (Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Text.Megaparsec.Error.ErrorItem
                       (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                  SEDEL.Parser.Parser.$s$fEqErrorItem
                  (Text.Megaparsec.Error.$fOrdErrorItem_$ccompare
                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                     GHC.Classes.$fOrdChar
                       `cast`
                     (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R)
                  (Text.Megaparsec.Error.$fOrdErrorItem_$c<
                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                     GHC.Classes.$fOrdChar
                       `cast`
                     (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R)
                  (\ (a :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                     (b :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                   case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          GHC.Classes.$fOrdChar
                            `cast`
                          (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                          b
                          a of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (a :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                     (b :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                   Text.Megaparsec.Error.$fOrdErrorItem_$c<
                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                     GHC.Classes.$fOrdChar
                       `cast`
                     (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                     b
                     a)
                  (\ (a :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                     (b :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                   case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          GHC.Classes.$fOrdChar
                            `cast`
                          (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                          a
                          b of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (x22 :: Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                     (y :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                   case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          GHC.Classes.$fOrdChar
                            `cast`
                          (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                          y
                          x22 of wild {
                     GHC.Types.False -> y GHC.Types.True -> x22 })
                  (\ (x22 :: Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                     (y :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                   case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          GHC.Classes.$fOrdChar
                            `cast`
                          (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                          y
                          x22 of wild {
                     GHC.Types.False -> x22 GHC.Types.True -> y }) -}
be242c9a75dd1c7ac8d1db7a75109ddf
  $s$fOrdErrorItem_$c<= ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (b :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                 case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                        @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                        GHC.Classes.$fOrdChar
                          `cast`
                        (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                        b
                        a of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
3a8f2c5513606f765ffc6bac1989560b
  $s$fOrdErrorItem_$c>= ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (b :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                 case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                        @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                        GHC.Classes.$fOrdChar
                          `cast`
                        (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                        a
                        b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
1322724583ecd0d2773266ba31c25f08
  $s$fOrdErrorItem_$cmax ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x22 :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (y :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                 case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                        @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                        GHC.Classes.$fOrdChar
                          `cast`
                        (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                        y
                        x22 of wild {
                   GHC.Types.False -> y GHC.Types.True -> x22 }) -}
d758aa4d69f99983aab378d4934bc15b
  $s$fOrdErrorItem_$cmin ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x22 :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (y :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                 case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                        @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                        GHC.Classes.$fOrdChar
                          `cast`
                        (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                        y
                        x22 of wild {
                   GHC.Types.False -> x22 GHC.Types.True -> y }) -}
88b86309944e4e8fc6c66f1820f8ad41
  $saddPrecLevel ::
    Text.Megaparsec.Internal.ParsecT
      Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity a
    -> [Control.Monad.Combinators.Expr.Operator
          (Text.Megaparsec.Internal.ParsecT
             Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity)
          a]
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity a
  {- Arity: 2, Strictness: <L,C(C1(C1(C1(C1(U)))))><L,1*U> -}
8ec1e6026a3739042810dfd5e101b890
  $sinsertR_go3 ::
    GHC.Classes.Ord a1 =>
    a1 -> a1 -> Data.Set.Internal.Set a1 -> Data.Set.Internal.Set a1
  {- Arity: 4,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><L,U><S,1*U><S,1*U> -}
fddb67bfa80a47e6db204b39e4d8c0a8
  $sinsert_go3 ::
    GHC.Classes.Ord a1 =>
    a1 -> a1 -> Data.Set.Internal.Set a1 -> Data.Set.Internal.Set a1
  {- Arity: 4,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><L,U><S,1*U><S,1*U> -}
115ae3082dcba3456b426bfc1752d543
  $spInfixL ::
    Text.Megaparsec.Internal.ParsecT
      Data.Void.Void
      GHC.Base.String
      Data.Functor.Identity.Identity
      (a -> a -> a)
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity a
    -> a
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity a
  {- Arity: 8,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,U><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Inline: [~] -}
f90c26722d429048cc536f025c7740d2
  $spInfixR ::
    Text.Megaparsec.Internal.ParsecT
      Data.Void.Void
      GHC.Base.String
      Data.Functor.Identity.Identity
      (a -> a -> a)
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity a
    -> a
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity a
  {- Arity: 8,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,U><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Inline: [~] -}
64b79f2e280156acd9cf32847e0597d3
  $sskipBlockComment ::
    Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
    -> Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity ()
  {- Arity: 2, Strictness: <L,U><L,U> -}
4a8669d63fabf0e2c2f7bbad3f9dbbb3
  $swhen1 ::
    Text.Megaparsec.State.State [GHC.Types.Char]
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b)
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><L,A><L,A><C(C(C(S))),1*C1(C1(C1(U)))><L,A>,
     Unfolding: InlineRule (5, True, True)
                (\ @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (ds :: ()
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b)
                   (ds1 :: Text.Megaparsec.Error.ParseError
                             [GHC.Types.Char] Data.Void.Void
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Data.Functor.Identity.Identity b)
                   (eok :: ()
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> Data.Functor.Identity.Identity b)
                   (ds2 :: Text.Megaparsec.Error.ParseError
                             [GHC.Types.Char] Data.Void.Void
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Data.Functor.Identity.Identity b) ->
                 eok
                   GHC.Tuple.()
                   s1
                   (GHC.Types.[]
                      @ (Data.Set.Internal.Set
                           (Text.Megaparsec.Error.ErrorItem
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                     `cast`
                   (Sym (Text.Megaparsec.Internal.N:Hints[0]
                             <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))) -}
e194d9ecd698117bca4862ec892fa8b5
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   SEDEL.Parser.Parser.$trModule3
                   SEDEL.Parser.Parser.$trModule1) -}
7be98f02e3c451d1a67c5ab57e6cec7b
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Parser.Parser.$trModule2) -}
895b075c102978380423ded067f6ecf2
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SEDEL.Parser.Parser"#) -}
ae2b5f93cc1160ec146e31fb55a3936c
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Parser.Parser.$trModule4) -}
f39acfff653b4c2185ed9a963cb4844f
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("sedel-0.1.0.0-AhY9khA6pZOExbzZW5SwDc"#) -}
7fd0fb868a7689001aba2982c51cf49f
  $w$sscientific ::
    [GHC.Types.Char]
    -> GHC.Prim.Int#
    -> Text.Megaparsec.State.PosState [GHC.Types.Char]
    -> (Data.Scientific.Scientific
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <S,U><L,U><L,U><L,C(C1(C1(U)))><L,1*C1(C1(U))>,
     Inline: [2] -}
e1191e070075e5d136c82e978e426ad4
  $w$sskipLineComment ::
    Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
    -> forall b1.
       [GHC.Types.Char]
       -> GHC.Prim.Int#
       -> Text.Megaparsec.State.PosState [GHC.Types.Char]
       -> (()
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b1)
       -> (()
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b1)
       -> (Text.Megaparsec.Error.ParseError
             [GHC.Types.Char] Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Data.Functor.Identity.Identity b1)
       -> Data.Functor.Identity.Identity b1
  {- Arity: 7,
     Strictness: <S,U><L,U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,1*C1(C1(U))>,
     Inline: [2] -}
4ea7f01e9921b92e5f50fd812ddc4dc4
  $w$sspace ::
    Text.Megaparsec.Internal.ParsecT
      Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity ()
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity ()
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity ()
    -> forall b.
       Text.Megaparsec.State.State GHC.Base.String
       -> (()
           -> Text.Megaparsec.State.State GHC.Base.String
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token GHC.Base.String)
           -> Data.Functor.Identity.Identity b)
       -> (Text.Megaparsec.Error.ParseError GHC.Base.String Data.Void.Void
           -> Text.Megaparsec.State.State GHC.Base.String
           -> Data.Functor.Identity.Identity b)
       -> (()
           -> Text.Megaparsec.State.State GHC.Base.String
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token GHC.Base.String)
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 7,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,U(U,U,U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))>,
     Inline: [2] -}
d301870d92f70a4b11e5ee1f13972318
  $wgo ::
    ([SEDEL.Source.Syntax.SDecl] -> [SEDEL.Source.Syntax.SDecl])
    -> forall b.
       Text.Megaparsec.State.State [GHC.Types.Char]
       -> ([SEDEL.Source.Syntax.SDecl]
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b)
       -> (Text.Megaparsec.Error.ParseError
             [GHC.Types.Char] Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Data.Functor.Identity.Identity b)
       -> ([SEDEL.Source.Syntax.SDecl]
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,C(U)><L,U(U,U,U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))>,
     Inline: [2] -}
7f9c361b0cc1b899cab641fe0452ca88
  $wk ::
    [SEDEL.Source.Syntax.SDecl]
    -> forall b.
       Text.Megaparsec.State.State [GHC.Types.Char]
       -> (SEDEL.Source.Syntax.Module
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b)
       -> (Text.Megaparsec.Error.ParseError
             [GHC.Types.Char] Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Data.Functor.Identity.Identity b)
       -> (SEDEL.Source.Syntax.Module
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,U><L,U(U,U,U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))>,
     Inline: [2] -}
624b27dd745fd79e25375a52e08a0cf4
  $wlvl ::
    [GHC.Types.Char]
    -> GHC.Prim.Int#
    -> Text.Megaparsec.State.PosState [GHC.Types.Char]
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(C1(U))>,
     Inline: [2],
     Unfolding: (\ @ b
                   (ww :: [GHC.Types.Char])
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: Text.Megaparsec.State.PosState [GHC.Types.Char])
                   (w :: ()
                         -> Text.Megaparsec.State.State [GHC.Types.Char]
                         -> Text.Megaparsec.Internal.Hints
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   []
                   -> w GHC.Tuple.()
                        (Text.Megaparsec.State.State
                           @ [GHC.Types.Char]
                           (GHC.Types.[] @ GHC.Types.Char)
                           ww1
                           ww2)
                        (GHC.Types.[]
                           @ (Data.Set.Internal.Set
                                (Text.Megaparsec.Error.ErrorItem
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                          `cast`
                        (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                  <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                   : t ts
                   -> w1
                        (Text.Megaparsec.Error.TrivialError
                           @ [GHC.Types.Char]
                           @ Data.Void.Void
                           (GHC.Types.I# ww1)
                           (GHC.Maybe.Just
                              @ (Text.Megaparsec.Error.ErrorItem
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              (Text.Megaparsec.Error.Tokens
                                 @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                 (Text.Megaparsec.Internal.nes
                                    @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                    t `cast` (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))))))
                           SEDEL.Parser.Parser.parseModule6)
                        (Text.Megaparsec.State.State @ [GHC.Types.Char] wild ww1 ww2) }) -}
7c0cd9f60268c075f78cc988f3e87186
  $wprog ::
    Text.Megaparsec.State.State [GHC.Types.Char]
    -> (SEDEL.Source.Syntax.Module
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> (SEDEL.Source.Syntax.Module
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 4,
     Strictness: <L,U(U,U,U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))>,
     Inline: [2],
     Unfolding: (\ @ b1
                   (w :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (w1 :: SEDEL.Source.Syntax.Module
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b1)
                   (w2 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b1)
                   (w3 :: SEDEL.Source.Syntax.Module
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b1) ->
                 SEDEL.Parser.Parser.$wgo
                   (GHC.Base.id @ [SEDEL.Source.Syntax.SDecl])
                   @ b1
                   w
                   (\ (x22 :: [SEDEL.Source.Syntax.SDecl])
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])[OneShot]
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))[OneShot] ->
                    SEDEL.Parser.Parser.$wk
                      x22
                      @ b1
                      s'
                      w1
                      w2
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ SEDEL.Source.Syntax.Module
                         @ [GHC.Types.Char]
                         @ Data.Functor.Identity.Identity
                         @ b1
                         hs
                         w1))
                   w2
                   (\ (x22 :: [SEDEL.Source.Syntax.SDecl])
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])[OneShot]
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))[OneShot] ->
                    SEDEL.Parser.Parser.$wk
                      x22
                      @ b1
                      s'
                      w1
                      w2
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ SEDEL.Source.Syntax.Module
                         @ [GHC.Types.Char]
                         @ Data.Functor.Identity.Identity
                         @ b1
                         hs
                         w3))) -}
430422d62663a990c7a5f87e328d2c37
  $wsc ::
    [GHC.Types.Char]
    -> GHC.Prim.Int#
    -> Text.Megaparsec.State.PosState [GHC.Types.Char]
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <S,U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(C1(U))>,
     Inline: [2],
     Unfolding: (\ @ b1
                   (ww :: [GHC.Types.Char])
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: Text.Megaparsec.State.PosState [GHC.Types.Char])
                   (w :: ()
                         -> Text.Megaparsec.State.State [GHC.Types.Char]
                         -> Text.Megaparsec.Internal.Hints
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         -> Data.Functor.Identity.Identity b1)
                   (w1 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b1) ->
                 case GHC.List.$wspan
                        @ GHC.Types.Char
                        GHC.Unicode.isSpace
                        ww of ww3 { (#,#) ww4 ww5 ->
                 case ww4 of wild {
                   []
                   -> w1
                        (Text.Megaparsec.Error.TrivialError
                           @ [GHC.Types.Char]
                           @ Data.Void.Void
                           (GHC.Types.I# ww1)
                           (GHC.Maybe.Just
                              @ (Text.Megaparsec.Error.ErrorItem
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              (case ww of wild1 {
                                 []
                                 -> Text.Megaparsec.Error.EndOfInput
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                 : t ts
                                 -> Text.Megaparsec.Error.Tokens
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                      (Text.Megaparsec.Internal.nes
                                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                         t `cast`
                                         (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))) }))
                           SEDEL.Parser.Parser.parseModule20)
                        (Text.Megaparsec.State.State @ [GHC.Types.Char] ww ww1 ww2)
                   : ds1 ds2
                   -> w GHC.Tuple.()
                        (case GHC.List.$wlenAcc
                                @ GHC.Types.Char
                                wild
                                0# of ww6 { DEFAULT ->
                         Text.Megaparsec.State.State
                           @ [GHC.Types.Char]
                           ww5
                           (GHC.Prim.+# ww1 ww6)
                           ww2 })
                        SEDEL.Parser.Parser.parseModule19
                          `cast`
                        (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                  <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)) } }) -}
d3f243cd56cd5fb56aff9a99bb830c0b
  type Parser =
    Text.Megaparsec.Parsec Data.Void.Void GHC.Base.String :: * -> *
a558d1972ddbb4f92fbe0b8bcac98046
  parseModule ::
    GHC.Base.String
    -> Data.Either.Either GHC.Base.String SEDEL.Source.Syntax.Module
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (s :: GHC.Base.String) ->
                 case (Text.Megaparsec.Internal.$fApplicativeParsecT1
                         @ [GHC.Types.Char]
                         @ Data.Void.Void
                         @ Data.Functor.Identity.Identity
                         Text.Megaparsec.Stream.$fStream[]
                         @ SEDEL.Source.Syntax.Module
                         @ ()
                         SEDEL.Parser.Parser.parseModule7
                           `cast`
                         (Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                                   <Data.Void.Void>_N
                                   <[GHC.Types.Char]>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <SEDEL.Source.Syntax.Module>_R))
                         SEDEL.Parser.Parser.parseModule5
                           `cast`
                         (Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                                   <Data.Void.Void>_N
                                   <[GHC.Types.Char]>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <()>_R))
                         @ (Text.Megaparsec.Internal.Reply
                              Data.Void.Void GHC.Base.String SEDEL.Source.Syntax.Module)
                         (Text.Megaparsec.State.State
                            @ GHC.Base.String
                            s
                            0#
                            (Text.Megaparsec.State.PosState
                               @ GHC.Base.String
                               s
                               0#
                               SEDEL.Parser.Parser.parseModule_s2
                               Text.Megaparsec.Pos.defaultTabWidth_a
                                 `cast`
                               (Sym (Text.Megaparsec.Pos.N:Pos[0]))
                               (GHC.Types.[] @ GHC.Types.Char)))
                         SEDEL.Parser.Parser.parseModule4
                           `cast`
                         (<SEDEL.Source.Syntax.Module>_R
                          ->_R <Text.Megaparsec.State.State GHC.Base.String>_R
                          ->_R <Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token GHC.Base.String)>_R
                          ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                        <Text.Megaparsec.Internal.Reply
                                           Data.Void.Void
                                           GHC.Base.String
                                           SEDEL.Source.Syntax.Module>_R))
                         SEDEL.Parser.Parser.parseModule3
                           `cast`
                         (<Text.Megaparsec.Error.ParseError
                             GHC.Base.String Data.Void.Void>_R
                          ->_R <Text.Megaparsec.State.State GHC.Base.String>_R
                          ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                        <Text.Megaparsec.Internal.Reply
                                           Data.Void.Void
                                           GHC.Base.String
                                           SEDEL.Source.Syntax.Module>_R))
                         SEDEL.Parser.Parser.parseModule2
                           `cast`
                         (<SEDEL.Source.Syntax.Module>_R
                          ->_R <Text.Megaparsec.State.State GHC.Base.String>_R
                          ->_R <Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token GHC.Base.String)>_R
                          ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                        <Text.Megaparsec.Internal.Reply
                                           Data.Void.Void
                                           GHC.Base.String
                                           SEDEL.Source.Syntax.Module>_R))
                         SEDEL.Parser.Parser.parseModule1
                           `cast`
                         (<Text.Megaparsec.Error.ParseError
                             GHC.Base.String Data.Void.Void>_R
                          ->_R <Text.Megaparsec.State.State GHC.Base.String>_R
                          ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                        <Text.Megaparsec.Internal.Reply
                                           Data.Void.Void
                                           GHC.Base.String
                                           SEDEL.Source.Syntax.Module>_R)))
                        `cast`
                      (Data.Functor.Identity.N:Identity[0]
                           <Text.Megaparsec.Internal.Reply
                              Data.Void.Void
                              GHC.Base.String
                              SEDEL.Source.Syntax.Module>_R) of wild { Text.Megaparsec.Internal.Reply s' ds result ->
                 case result of wild1 {
                   Text.Megaparsec.Internal.OK x22
                   -> Data.Either.Right
                        @ GHC.Base.String
                        @ SEDEL.Source.Syntax.Module
                        x22
                   Text.Megaparsec.Internal.Error e1
                   -> Data.Either.Left
                        @ GHC.Base.String
                        @ SEDEL.Source.Syntax.Module
                        (Text.Megaparsec.Error.$werrorBundlePretty
                           @ GHC.Base.String
                           @ Data.Void.Void
                           Text.Megaparsec.Stream.$fStream[]
                           Text.Megaparsec.Error.$fShowErrorComponentVoid
                           e1
                           (GHC.Types.[]
                              @ (Text.Megaparsec.Error.ParseError
                                   GHC.Base.String Data.Void.Void))
                           s
                           0#
                           SEDEL.Parser.Parser.parseModule_s2
                           Text.Megaparsec.Pos.defaultTabWidth_a
                             `cast`
                           (Sym (Text.Megaparsec.Pos.N:Pos[0]))
                           (GHC.Types.[] @ GHC.Types.Char)) } }) -}
c76b17694ed72c8a704d969137dd5e9a
  parseModule1 ::
    Text.Megaparsec.Error.ParseError GHC.Base.String Data.Void.Void
    -> Text.Megaparsec.State.State GHC.Base.String
    -> Text.Megaparsec.Internal.Reply
         Data.Void.Void GHC.Base.String SEDEL.Source.Syntax.Module
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m,
     Unfolding: (\ (err :: Text.Megaparsec.Error.ParseError
                             GHC.Base.String Data.Void.Void)
                   (s' :: Text.Megaparsec.State.State GHC.Base.String) ->
                 Text.Megaparsec.Internal.Reply
                   @ Data.Void.Void
                   @ GHC.Base.String
                   @ SEDEL.Source.Syntax.Module
                   s'
                   Text.Megaparsec.Internal.Virgin
                   (Text.Megaparsec.Internal.Error
                      @ GHC.Base.String
                      @ Data.Void.Void
                      @ SEDEL.Source.Syntax.Module
                      err)) -}
e52d6bd3adbac7eff04ced073aacf98a
  parseModule10 ::
    Text.Megaparsec.Internal.ParsecT
      Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity ()
  {- Unfolding: (SEDEL.Parser.Parser.$sskipBlockComment
                   SEDEL.Parser.Parser.parseModule13
                     `cast`
                   (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))
                   SEDEL.Parser.Parser.parseModule11
                     `cast`
                   (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))) -}
7c229ac3f040ba702eda6beceb75d5ab
  parseModule11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   SEDEL.Parser.Parser.parseModule12) -}
018d1495d0feb22b87fa042a6f1acde4
  parseModule12 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("-}"#) -}
5cbe19917d72e7b175b336696491e553
  parseModule13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   SEDEL.Parser.Parser.parseModule14) -}
74400d22bd7642dd6cc111b8983bc000
  parseModule14 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("{-"#) -}
5d3afe9e92f6bb1e4b068deda70230fd
  parseModule15 ::
    Text.Megaparsec.State.State [GHC.Types.Char]
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <S(LSL),1*U(U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,1*C1(C1(C1(U)))><L,1*C1(C1(U))>,
     Unfolding: (\ @ b1
                   (w :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (w1 :: ()
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b1)
                   (w2 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b1)
                   (w3 :: ()
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b1)
                   (w4 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b1) ->
                 case w of ww { Text.Megaparsec.State.State ww1 ww2 ww3 ->
                 SEDEL.Parser.Parser.$w$sskipLineComment
                   SEDEL.Parser.Parser.parseModule16
                     `cast`
                   (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))
                   @ b1
                   ww1
                   ww2
                   ww3
                   w1
                   w3
                   w4 }) -}
16f942885be7aa2f0ee515b82150304d
  parseModule16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   SEDEL.Parser.Parser.parseModule17) -}
aea025ea2b3137e6a6c689deaf6c3837
  parseModule17 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("--"#) -}
eedca340096486ac87758668317f810c
  parseModule18 ::
    Text.Megaparsec.State.State [GHC.Types.Char]
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <S(SSL),1*U(U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(C1(U))>,
     Inline: [2],
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   (w :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (w1 :: ()
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b1)
                   (w2 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b1)
                   (w3 :: ()
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b1)
                   (w4 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b1) ->
                 case w of ww { Text.Megaparsec.State.State ww1 ww2 ww3 ->
                 SEDEL.Parser.Parser.$wsc @ b1 ww1 ww2 ww3 w1 w4 }) -}
a5439d91d734e99dee37de4f5d79f8bf
  parseModule19 ::
    [Data.Set.Internal.Set
       (Text.Megaparsec.Error.ErrorItem
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]))]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Data.Set.Internal.Set
                        (Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                   SEDEL.Parser.Parser.parseModule20
                   (GHC.Types.[]
                      @ (Data.Set.Internal.Set
                           (Text.Megaparsec.Error.ErrorItem
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))) -}
98c124ff09938ce30ff88497c2c2bb9e
  parseModule2 ::
    SEDEL.Source.Syntax.Module
    -> Text.Megaparsec.State.State GHC.Base.String
    -> Text.Megaparsec.Internal.Hints
         (Text.Megaparsec.Stream.Token GHC.Base.String)
    -> Text.Megaparsec.Internal.Reply
         Data.Void.Void GHC.Base.String SEDEL.Source.Syntax.Module
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,A>m,
     Unfolding: (\ (a1 :: SEDEL.Source.Syntax.Module)
                   (s' :: Text.Megaparsec.State.State GHC.Base.String)[OneShot]
                   (ds :: Text.Megaparsec.Internal.Hints
                            (Text.Megaparsec.Stream.Token GHC.Base.String))[OneShot] ->
                 Text.Megaparsec.Internal.Reply
                   @ Data.Void.Void
                   @ GHC.Base.String
                   @ SEDEL.Source.Syntax.Module
                   s'
                   Text.Megaparsec.Internal.Virgin
                   (Text.Megaparsec.Internal.OK
                      @ GHC.Base.String
                      @ Data.Void.Void
                      @ SEDEL.Source.Syntax.Module
                      a1)) -}
06d92d697997bf99ea08e7c2d8078da0
  parseModule20 ::
    Data.Set.Internal.Set
      (Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
  {- Strictness: m1,
     Unfolding: (Data.Set.Internal.Bin
                   @ (Text.Megaparsec.Error.ErrorItem
                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   1#
                   SEDEL.Parser.Parser.parseModule21
                   (Data.Set.Internal.Tip
                      @ (Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                   (Data.Set.Internal.Tip
                      @ (Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])))) -}
4341b636138898230cd10be6a1fa7151
  parseModule21 ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
  {- Strictness: m2,
     Unfolding: (Text.Megaparsec.Error.Label
                   @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                   SEDEL.Parser.Parser.parseModule22) -}
be671540b6582e3a846060001bba8dcb
  parseModule22 :: GHC.Base.NonEmpty GHC.Types.Char
  {- Strictness: m,
     Unfolding: (GHC.Base.:|
                   @ GHC.Types.Char
                   SEDEL.Parser.Parser.parseModule25
                   SEDEL.Parser.Parser.parseModule23) -}
52740d59b833f0b5269666df93cd6f37
  parseModule23 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   SEDEL.Parser.Parser.parseModule24) -}
413a649df8caf6b0609fe396ad855d0a
  parseModule24 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("hite space"#) -}
b26c957c422a698ba22881591f0411b8
  parseModule25 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'w'#) -}
b710bd47c3b83a7928336f85cc30299c
  parseModule3 ::
    Text.Megaparsec.Error.ParseError GHC.Base.String Data.Void.Void
    -> Text.Megaparsec.State.State GHC.Base.String
    -> Text.Megaparsec.Internal.Reply
         Data.Void.Void GHC.Base.String SEDEL.Source.Syntax.Module
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m,
     Unfolding: (\ (err :: Text.Megaparsec.Error.ParseError
                             GHC.Base.String Data.Void.Void)
                   (s' :: Text.Megaparsec.State.State GHC.Base.String) ->
                 Text.Megaparsec.Internal.Reply
                   @ Data.Void.Void
                   @ GHC.Base.String
                   @ SEDEL.Source.Syntax.Module
                   s'
                   Text.Megaparsec.Internal.Consumed
                   (Text.Megaparsec.Internal.Error
                      @ GHC.Base.String
                      @ Data.Void.Void
                      @ SEDEL.Source.Syntax.Module
                      err)) -}
337ce085a869bb09a3a599f934bdebf1
  parseModule4 ::
    SEDEL.Source.Syntax.Module
    -> Text.Megaparsec.State.State GHC.Base.String
    -> Text.Megaparsec.Internal.Hints
         (Text.Megaparsec.Stream.Token GHC.Base.String)
    -> Text.Megaparsec.Internal.Reply
         Data.Void.Void GHC.Base.String SEDEL.Source.Syntax.Module
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,A>m,
     Unfolding: (\ (a1 :: SEDEL.Source.Syntax.Module)
                   (s' :: Text.Megaparsec.State.State GHC.Base.String)[OneShot]
                   (ds :: Text.Megaparsec.Internal.Hints
                            (Text.Megaparsec.Stream.Token GHC.Base.String))[OneShot] ->
                 Text.Megaparsec.Internal.Reply
                   @ Data.Void.Void
                   @ GHC.Base.String
                   @ SEDEL.Source.Syntax.Module
                   s'
                   Text.Megaparsec.Internal.Consumed
                   (Text.Megaparsec.Internal.OK
                      @ GHC.Base.String
                      @ Data.Void.Void
                      @ SEDEL.Source.Syntax.Module
                      a1)) -}
c0f73a2416f0bd96e1e9606265dd55df
  parseModule5 ::
    Text.Megaparsec.State.State [GHC.Types.Char]
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b)
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(SSL),1*U(1*U,U,U)><L,A><L,A><L,1*C1(C1(C1(U)))><L,1*C1(C1(U))>,
     Inline: [2],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (w1 :: ()
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: ()
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Megaparsec.State.State ww1 ww2 ww3 ->
                 SEDEL.Parser.Parser.$wlvl @ b ww1 ww2 ww3 w3 w4 }) -}
afb4289efd38d6c6a3d128f2e895b532
  parseModule6 ::
    Data.Set.Internal.Set
      (Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Data.Set.Internal.Bin
                   @ (Text.Megaparsec.Error.ErrorItem
                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   1#
                   (Text.Megaparsec.Error.EndOfInput
                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (Data.Set.Internal.Tip
                      @ (Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                   (Data.Set.Internal.Tip
                      @ (Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])))) -}
34373580547281579dcba6c37181c2ee
  parseModule7 ::
    Text.Megaparsec.State.State [GHC.Types.Char]
    -> (SEDEL.Source.Syntax.Module
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> (SEDEL.Source.Syntax.Module
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Unfolding: (Text.Megaparsec.Internal.$fApplicativeParsecT2
                   @ [GHC.Types.Char]
                   @ Data.Void.Void
                   @ Data.Functor.Identity.Identity
                   Text.Megaparsec.Stream.$fStream[]
                   @ ()
                   @ SEDEL.Source.Syntax.Module
                   SEDEL.Parser.Parser.parseModule9
                     `cast`
                   (Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                             <Data.Void.Void>_N
                             <GHC.Base.String>_N
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))
                   SEDEL.Parser.Parser.parseModule8
                     `cast`
                   (Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                             <Data.Void.Void>_N
                             <[GHC.Types.Char]>_N
                             <Data.Functor.Identity.Identity>_R
                             <SEDEL.Source.Syntax.Module>_R))) -}
d45258f8a817aeb405b5f3495a08f7e9
  parseModule8 ::
    Text.Megaparsec.State.State [GHC.Types.Char]
    -> (SEDEL.Source.Syntax.Module
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> (SEDEL.Source.Syntax.Module
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          [GHC.Types.Char] Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U(U,U,U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,A>,
     Inline: [2],
     Unfolding: InlineRule (5, True, True)
                (\ @ b1
                   (w :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (w1 :: SEDEL.Source.Syntax.Module
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b1)
                   (w2 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b1)
                   (w3 :: SEDEL.Source.Syntax.Module
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b1)
                   (w4 :: Text.Megaparsec.Error.ParseError
                            [GHC.Types.Char] Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b1) ->
                 SEDEL.Parser.Parser.$wprog @ b1 w w1 w2 w3) -}
715c79f158fbf54366a327663cb11253
  parseModule9 ::
    Text.Megaparsec.State.State GHC.Base.String
    -> (()
        -> Text.Megaparsec.State.State GHC.Base.String
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token GHC.Base.String)
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError GHC.Base.String Data.Void.Void
        -> Text.Megaparsec.State.State GHC.Base.String
        -> Data.Functor.Identity.Identity b)
    -> (()
        -> Text.Megaparsec.State.State GHC.Base.String
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token GHC.Base.String)
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError GHC.Base.String Data.Void.Void
        -> Text.Megaparsec.State.State GHC.Base.String
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,U(U,U,U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,A>,
     Unfolding: (\ @ b
                   (w :: Text.Megaparsec.State.State GHC.Base.String)
                   (w1 :: ()
                          -> Text.Megaparsec.State.State GHC.Base.String
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token GHC.Base.String)
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Megaparsec.Error.ParseError
                            GHC.Base.String Data.Void.Void
                          -> Text.Megaparsec.State.State GHC.Base.String
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: ()
                          -> Text.Megaparsec.State.State GHC.Base.String
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token GHC.Base.String)
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Megaparsec.Error.ParseError
                            GHC.Base.String Data.Void.Void
                          -> Text.Megaparsec.State.State GHC.Base.String
                          -> Data.Functor.Identity.Identity b) ->
                 SEDEL.Parser.Parser.$w$sspace
                   SEDEL.Parser.Parser.parseModule18
                     `cast`
                   (Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                             <Data.Void.Void>_N
                             <[GHC.Types.Char]>_N
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))
                   SEDEL.Parser.Parser.parseModule15
                     `cast`
                   (Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                             <Data.Void.Void>_N
                             <[GHC.Types.Char]>_N
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))
                   SEDEL.Parser.Parser.parseModule10
                   @ b
                   w
                   w1
                   w2
                   w3) -}
de5d1704c881e19bab1b3a3cf9a032e3
  parseModule_s2 :: Text.Megaparsec.Pos.SourcePos
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Text.Megaparsec.Pos.SourcePos
                   (GHC.Types.[] @ GHC.Types.Char)
                   1#
                   1#) -}
"SPEC/SEDEL.Parser.Parser $fAlternativeParsecT @ Void @ [Char] _" [orphan] forall @ m :: *
                                                                                         -> *
                                                                                  (v1 :: Text.Megaparsec.Stream.Stream
                                                                                           [GHC.Types.Char])
                                                                                  (v :: GHC.Classes.Ord
                                                                                          Data.Void.Void)
  Text.Megaparsec.Internal.$fAlternativeParsecT @ Data.Void.Void
                                                @ [GHC.Types.Char]
                                                @ m
                                                v
                                                v1
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT @ m
"SPEC/SEDEL.Parser.Parser $fAlternativeParsecT1 @ Void @ [Char] _" [orphan] [2] forall @ m :: *
                                                                                              -> *
                                                                                       (w1 :: Text.Megaparsec.Stream.Stream
                                                                                                [GHC.Types.Char])
                                                                                       (w :: GHC.Classes.Ord
                                                                                               Data.Void.Void)
  Text.Megaparsec.Internal.$fAlternativeParsecT1 @ Data.Void.Void
                                                 @ [GHC.Types.Char]
                                                 @ m
                                                 w
                                                 w1
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT1 @ m
"SPEC/SEDEL.Parser.Parser $fAlternativeParsecT3 @ Void @ [Char] _" [orphan] [2] forall @ m :: *
                                                                                              -> *
                                                                                       (w1 :: Text.Megaparsec.Stream.Stream
                                                                                                [GHC.Types.Char])
                                                                                       (w :: GHC.Classes.Ord
                                                                                               Data.Void.Void)
  Text.Megaparsec.Internal.$fAlternativeParsecT3 @ Data.Void.Void
                                                 @ [GHC.Types.Char]
                                                 @ m
                                                 w
                                                 w1
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT3 @ m
"SPEC/SEDEL.Parser.Parser $fApplicativeParsecT @ [Char] _ _" [orphan] forall @ e
                                                                             @ m :: * -> *
                                                                             (v :: Text.Megaparsec.Stream.Stream
                                                                                     [GHC.Types.Char])
  Text.Megaparsec.Internal.$fApplicativeParsecT @ [GHC.Types.Char]
                                                @ e
                                                @ m
                                                v
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT_$s$fApplicativeParsecT
      @ e
      @ m
"SPEC/SEDEL.Parser.Parser $fEqErrorFancy @ Void" [orphan] forall (v :: GHC.Classes.Eq
                                                                         Data.Void.Void)
  Text.Megaparsec.Error.$fEqErrorFancy @ Data.Void.Void v
  = SEDEL.Parser.Parser.$s$fEqErrorFancy
"SPEC/SEDEL.Parser.Parser $fEqErrorFancy_$c/= @ Void" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                                 Data.Void.Void)
  Text.Megaparsec.Error.$fEqErrorFancy_$c/= @ Data.Void.Void $dEq
  = SEDEL.Parser.Parser.$s$fEqErrorFancy_$s$fEqErrorFancy_$c/=
"SPEC/SEDEL.Parser.Parser $fEqErrorItem @ (Token [Char])" [orphan] forall (v :: GHC.Classes.Eq
                                                                                  (Text.Megaparsec.Stream.Token
                                                                                     [GHC.Types.Char]))
  Text.Megaparsec.Error.$fEqErrorItem @ (Text.Megaparsec.Stream.Token
                                           [GHC.Types.Char])
                                      v
  = SEDEL.Parser.Parser.$s$fEqErrorItem
"SPEC/SEDEL.Parser.Parser $fEqErrorItem_$c/= @ (Token [Char])" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                                          (Text.Megaparsec.Stream.Token
                                                                                             [GHC.Types.Char]))
  Text.Megaparsec.Error.$fEqErrorItem_$c/= @ (Text.Megaparsec.Stream.Token
                                                [GHC.Types.Char])
                                           $dEq
  = SEDEL.Parser.Parser.$s$fEqErrorItem_$s$fEqErrorItem_$c/=
"SPEC/SEDEL.Parser.Parser $fMonadParsecT @ [Char] _ _" [orphan] forall @ e
                                                                       @ m :: * -> *
                                                                       (v :: Text.Megaparsec.Stream.Stream
                                                                               [GHC.Types.Char])
  Text.Megaparsec.Internal.$fMonadParsecT @ [GHC.Types.Char]
                                          @ e
                                          @ m
                                          v
  = SEDEL.Parser.Parser.$s$fMonadParsecT @ e @ m
"SPEC/SEDEL.Parser.Parser $fMonadParsecT_$c>> @ [Char] _ _" [orphan] forall @ e
                                                                            @ m :: * -> *
                                                                            ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                           [GHC.Types.Char])
  Text.Megaparsec.Internal.$fMonadParsecT_$c>> @ [GHC.Types.Char]
                                               @ e
                                               @ m
                                               $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecT_$s$fMonadParsecT_$c>>
      @ e
      @ m
"SPEC/SEDEL.Parser.Parser $fMonadParsecesParsecT @ Void @ [Char] _" [orphan] forall @ m :: *
                                                                                           -> *
                                                                                    (v1 :: Text.Megaparsec.Stream.Stream
                                                                                             [GHC.Types.Char])
                                                                                    (v :: GHC.Classes.Ord
                                                                                            Data.Void.Void)
  Text.Megaparsec.Internal.$fMonadParsecesParsecT @ Data.Void.Void
                                                  @ [GHC.Types.Char]
                                                  @ m
                                                  v
                                                  v1
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT @ m
"SPEC/SEDEL.Parser.Parser $fMonadPlusParsecT @ Void @ [Char] _" [orphan] forall @ m :: *
                                                                                       -> *
                                                                                (v1 :: Text.Megaparsec.Stream.Stream
                                                                                         [GHC.Types.Char])
                                                                                (v :: GHC.Classes.Ord
                                                                                        Data.Void.Void)
  Text.Megaparsec.Internal.$fMonadPlusParsecT @ Data.Void.Void
                                              @ [GHC.Types.Char]
                                              @ m
                                              v
                                              v1
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$s$fMonadPlusParsecT
      @ m
"SPEC/SEDEL.Parser.Parser $fOrdErrorFancy @ Void" [orphan] forall (v :: GHC.Classes.Ord
                                                                          Data.Void.Void)
  Text.Megaparsec.Error.$fOrdErrorFancy @ Data.Void.Void v
  = SEDEL.Parser.Parser.$s$fOrdErrorFancy
"SPEC/SEDEL.Parser.Parser $fOrdErrorFancy_$c<= @ Void" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                   Data.Void.Void)
  Text.Megaparsec.Error.$fOrdErrorFancy_$c<= @ Data.Void.Void $dOrd
  = SEDEL.Parser.Parser.$s$fOrdErrorFancy_$c<=
"SPEC/SEDEL.Parser.Parser $fOrdErrorFancy_$c>= @ Void" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                   Data.Void.Void)
  Text.Megaparsec.Error.$fOrdErrorFancy_$c>= @ Data.Void.Void $dOrd
  = SEDEL.Parser.Parser.$s$fOrdErrorFancy_$c>=
"SPEC/SEDEL.Parser.Parser $fOrdErrorFancy_$cmax @ Void" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                    Data.Void.Void)
  Text.Megaparsec.Error.$fOrdErrorFancy_$cmax @ Data.Void.Void $dOrd
  = SEDEL.Parser.Parser.$s$fOrdErrorFancy_$cmax
"SPEC/SEDEL.Parser.Parser $fOrdErrorFancy_$cmin @ Void" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                    Data.Void.Void)
  Text.Megaparsec.Error.$fOrdErrorFancy_$cmin @ Data.Void.Void $dOrd
  = SEDEL.Parser.Parser.$s$fOrdErrorFancy_$cmin
"SPEC/SEDEL.Parser.Parser $fOrdErrorItem @ (Token [Char])" [orphan] forall (v :: GHC.Classes.Ord
                                                                                   (Text.Megaparsec.Stream.Token
                                                                                      [GHC.Types.Char]))
  Text.Megaparsec.Error.$fOrdErrorItem @ (Text.Megaparsec.Stream.Token
                                            [GHC.Types.Char])
                                       v
  = SEDEL.Parser.Parser.$s$fOrdErrorItem
"SPEC/SEDEL.Parser.Parser $fOrdErrorItem_$c<= @ (Token [Char])" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                            (Text.Megaparsec.Stream.Token
                                                                                               [GHC.Types.Char]))
  Text.Megaparsec.Error.$fOrdErrorItem_$c<= @ (Text.Megaparsec.Stream.Token
                                                 [GHC.Types.Char])
                                            $dOrd
  = SEDEL.Parser.Parser.$s$fOrdErrorItem_$c<=
"SPEC/SEDEL.Parser.Parser $fOrdErrorItem_$c>= @ (Token [Char])" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                            (Text.Megaparsec.Stream.Token
                                                                                               [GHC.Types.Char]))
  Text.Megaparsec.Error.$fOrdErrorItem_$c>= @ (Text.Megaparsec.Stream.Token
                                                 [GHC.Types.Char])
                                            $dOrd
  = SEDEL.Parser.Parser.$s$fOrdErrorItem_$c>=
"SPEC/SEDEL.Parser.Parser $fOrdErrorItem_$cmax @ (Token [Char])" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                             (Text.Megaparsec.Stream.Token
                                                                                                [GHC.Types.Char]))
  Text.Megaparsec.Error.$fOrdErrorItem_$cmax @ (Text.Megaparsec.Stream.Token
                                                  [GHC.Types.Char])
                                             $dOrd
  = SEDEL.Parser.Parser.$s$fOrdErrorItem_$cmax
"SPEC/SEDEL.Parser.Parser $fOrdErrorItem_$cmin @ (Token [Char])" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                             (Text.Megaparsec.Stream.Token
                                                                                                [GHC.Types.Char]))
  Text.Megaparsec.Error.$fOrdErrorItem_$cmin @ (Text.Megaparsec.Stream.Token
                                                  [GHC.Types.Char])
                                             $dOrd
  = SEDEL.Parser.Parser.$s$fOrdErrorItem_$cmin
"SPEC/SEDEL.Parser.Parser addPrecLevel @ (ParsecT
                                           Void String Identity) _" [orphan] forall @ a
                                                                                                                                      ($dMonadPlus :: GHC.Base.MonadPlus
                                                                                                                                                        (Text.Megaparsec.Internal.ParsecT
                                                                                                                                                           Data.Void.Void
                                                                                                                                                           GHC.Base.String
                                                                                                                                                           Data.Functor.Identity.Identity))
  Control.Monad.Combinators.Expr.addPrecLevel @ (Text.Megaparsec.Internal.ParsecT
                                                   Data.Void.Void
                                                   GHC.Base.String
                                                   Data.Functor.Identity.Identity)
                                              @ a
                                              $dMonadPlus
  = SEDEL.Parser.Parser.$saddPrecLevel @ a
"SPEC/SEDEL.Parser.Parser pAp @ [Char] _ _ _ _" [orphan] forall @ e
                                                                @ m :: * -> *
                                                                @ a
                                                                @ b
                                                                ($dStream :: Text.Megaparsec.Stream.Stream
                                                                               [GHC.Types.Char])
  Text.Megaparsec.Internal.pAp @ [GHC.Types.Char]
                               @ e
                               @ m
                               @ a
                               @ b
                               $dStream
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT_$spAp @ e @ m @ a @ b
"SPEC/SEDEL.Parser.Parser pBind @ [Char] _ _ _ _" [orphan] forall @ e
                                                                  @ m :: * -> *
                                                                  @ a
                                                                  @ b
                                                                  ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                 [GHC.Types.Char])
  Text.Megaparsec.Internal.pBind @ [GHC.Types.Char]
                                 @ e
                                 @ m
                                 @ a
                                 @ b
                                 $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecT_$spBind @ e @ m @ a @ b
"SPEC/SEDEL.Parser.Parser pInfixL @ (ParsecT Void String Identity) _" [orphan] forall @ a
                                                                                      ($dMonadPlus :: GHC.Base.MonadPlus
                                                                                                        (Text.Megaparsec.Internal.ParsecT
                                                                                                           Data.Void.Void
                                                                                                           GHC.Base.String
                                                                                                           Data.Functor.Identity.Identity))
  Control.Monad.Combinators.Expr.pInfixL @ (Text.Megaparsec.Internal.ParsecT
                                              Data.Void.Void
                                              GHC.Base.String
                                              Data.Functor.Identity.Identity)
                                         @ a
                                         $dMonadPlus
  = SEDEL.Parser.Parser.$spInfixL @ a
"SPEC/SEDEL.Parser.Parser pInfixR @ (ParsecT Void String Identity) _" [orphan] forall @ a
                                                                                      ($dMonadPlus :: GHC.Base.MonadPlus
                                                                                                        (Text.Megaparsec.Internal.ParsecT
                                                                                                           Data.Void.Void
                                                                                                           GHC.Base.String
                                                                                                           Data.Functor.Identity.Identity))
  Control.Monad.Combinators.Expr.pInfixR @ (Text.Megaparsec.Internal.ParsecT
                                              Data.Void.Void
                                              GHC.Base.String
                                              Data.Functor.Identity.Identity)
                                         @ a
                                         $dMonadPlus
  = SEDEL.Parser.Parser.$spInfixR @ a
"SPEC/SEDEL.Parser.Parser pNotFollowedBy @ [Char] _ _ _" [orphan] forall @ e
                                                                         @ m :: * -> *
                                                                         @ a
                                                                         ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                        [GHC.Types.Char])
  Text.Megaparsec.Internal.pNotFollowedBy @ [GHC.Types.Char]
                                          @ e
                                          @ m
                                          @ a
                                          $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spNotFollowedBy
      @ e
      @ m
      @ a
"SPEC/SEDEL.Parser.Parser pObserving @ [Char] _ _ _" [orphan] forall @ e
                                                                     @ m :: * -> *
                                                                     @ a
                                                                     ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                    [GHC.Types.Char])
  Text.Megaparsec.Internal.pObserving @ [GHC.Types.Char]
                                      @ e
                                      @ m
                                      @ a
                                      $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spObserving
      @ e
      @ m
      @ a
"SPEC/SEDEL.Parser.Parser pPlus @ Void @ [Char] _ _" [orphan] forall @ m :: *
                                                                            -> *
                                                                     @ a
                                                                     ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                    [GHC.Types.Char])
                                                                     ($dOrd :: GHC.Classes.Ord
                                                                                 Data.Void.Void)
  Text.Megaparsec.Internal.pPlus @ Data.Void.Void
                                 @ [GHC.Types.Char]
                                 @ m
                                 @ a
                                 $dOrd
                                 $dStream
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT_$spPlus @ m @ a
"SPEC/SEDEL.Parser.Parser pTakeP _ @ [Char] _" [orphan] forall @ e
                                                               @ m :: * -> *
                                                               ($dStream :: Text.Megaparsec.Stream.Stream
                                                                              [GHC.Types.Char])
  Text.Megaparsec.Internal.pTakeP @ e @ [GHC.Types.Char] @ m $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spTakeP @ e @ m
"SPEC/SEDEL.Parser.Parser pTakeWhile1P _ @ [Char] _" [orphan] forall @ e
                                                                     @ m :: * -> *
                                                                     ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                    [GHC.Types.Char])
  Text.Megaparsec.Internal.pTakeWhile1P @ e
                                        @ [GHC.Types.Char]
                                        @ m
                                        $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spTakeWhile1P
      @ e
      @ m
"SPEC/SEDEL.Parser.Parser pTakeWhileP _ @ [Char] _" [orphan] forall @ e
                                                                    @ m :: * -> *
                                                                    ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                   [GHC.Types.Char])
  Text.Megaparsec.Internal.pTakeWhileP @ e
                                       @ [GHC.Types.Char]
                                       @ m
                                       $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spTakeWhileP
      @ e
      @ m
"SPEC/SEDEL.Parser.Parser pToken _ @ [Char] _ _" [orphan] forall @ e
                                                                 @ m :: * -> *
                                                                 @ a
                                                                 ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                [GHC.Types.Char])
  Text.Megaparsec.Internal.pToken @ e
                                  @ [GHC.Types.Char]
                                  @ m
                                  @ a
                                  $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spToken @ e @ m @ a
"SPEC/SEDEL.Parser.Parser pTokens _ @ [Char] _" [orphan] forall @ e
                                                                @ m :: * -> *
                                                                ($dStream :: Text.Megaparsec.Stream.Stream
                                                                               [GHC.Types.Char])
  Text.Megaparsec.Internal.pTokens @ e
                                   @ [GHC.Types.Char]
                                   @ m
                                   $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spTokens @ e @ m
"SPEC/SEDEL.Parser.Parser pWithRecovery @ [Char] _ _ _" [orphan] forall @ e
                                                                        @ m :: * -> *
                                                                        @ a
                                                                        ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                       [GHC.Types.Char])
  Text.Megaparsec.Internal.pWithRecovery @ [GHC.Types.Char]
                                         @ e
                                         @ m
                                         @ a
                                         $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spWithRecovery
      @ e
      @ m
      @ a
"SPEC/SEDEL.Parser.Parser skipBlockComment @ Void @ [Char] @ (ParsecT
                                                               Void String Identity)" [orphan] forall ($d~ :: Text.Megaparsec.Stream.Token
                                                                                                                                                                                      [GHC.Types.Char]
                                                                                                                                                                                    Data.Type.Equality.~ GHC.Types.Char)
                                                                                                                                                                            ($dMonadParsec :: Text.Megaparsec.Class.MonadParsec
                                                                                                                                                                                                Data.Void.Void
                                                                                                                                                                                                [GHC.Types.Char]
                                                                                                                                                                                                (Text.Megaparsec.Internal.ParsecT
                                                                                                                                                                                                   Data.Void.Void
                                                                                                                                                                                                   GHC.Base.String
                                                                                                                                                                                                   Data.Functor.Identity.Identity))
  Text.Megaparsec.Char.Lexer.skipBlockComment @ Data.Void.Void
                                              @ [GHC.Types.Char]
                                              @ (Text.Megaparsec.Internal.ParsecT
                                                   Data.Void.Void
                                                   GHC.Base.String
                                                   Data.Functor.Identity.Identity)
                                              $dMonadParsec
                                              $d~
  = SEDEL.Parser.Parser.$sskipBlockComment
"SPEC/SEDEL.Parser.Parser union @ (ErrorFancy Void)" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                 (Text.Megaparsec.Error.ErrorFancy
                                                                                    Data.Void.Void))
  Data.Set.Internal.union @ (Text.Megaparsec.Error.ErrorFancy
                               Data.Void.Void)
                          $dOrd
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT_$sunion
"SPEC/SEDEL.Parser.Parser union @ (ErrorItem (Token [Char]))" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                          (Text.Megaparsec.Error.ErrorItem
                                                                                             (Text.Megaparsec.Stream.Token
                                                                                                [GHC.Types.Char])))
  Data.Set.Internal.union @ (Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                          $dOrd
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT_$sunion1
"SPEC/SEDEL.Parser.Parser withHints @ [Char] _ _ _" [orphan] forall @ e
                                                                    @ m :: * -> *
                                                                    @ b
                                                                    ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                   [GHC.Types.Char])
  Text.Megaparsec.Internal.withHints @ [GHC.Types.Char]
                                     @ e
                                     @ m
                                     @ b
                                     $dStream
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT_$swithHints
      @ e
      @ m
      @ b
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

