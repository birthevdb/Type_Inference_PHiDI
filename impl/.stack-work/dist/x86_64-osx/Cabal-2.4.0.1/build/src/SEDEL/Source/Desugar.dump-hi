
==================== FINAL INTERFACE ====================
2019-08-12 12:24:19.225072 UTC

interface sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.Source.Desugar 8063
  interface hash: b8328ead3b99de6ea25e3600f49381bc
  ABI hash: 20ed66810c076b1d7e17421ae8bfcfeb
  export-list hash: d7d075316e2e64861442d904030d79b9
  orphan hash: c23520b1a91e6c2b037306e658a55e3f
  flag hash: 382277a91afac9cbee37a74a49298e8d
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  SEDEL.Source.Desugar.desugar
  SEDEL.Source.Desugar.desugarExpr
  SEDEL.Source.Desugar.desugarTmBind
  SEDEL.Source.Desugar.expandType
  SEDEL.Source.Desugar.normalizeTmDecl
module dependencies: SEDEL.Common SEDEL.Environment
                     SEDEL.Intermediate.Syntax SEDEL.PrettyPrint SEDEL.Source.Syntax
package dependencies: array-0.5.3.0 async-2.2.1 base-4.12.0.0
                      base-orphans-0.8 bifunctors-5.5.3 binary-0.8.6.0
                      bytestring-0.10.8.2 comonad-5.0.4 containers-0.6.0.1
                      deepseq-1.4.4.0 distributive-0.6 exceptions-0.10.0
                      ghc-boot-th-8.6.3 ghc-prim-0.5.3 hashable-1.2.7.0
                      integer-gmp-1.0.2.0 megaparsec-7.0.4 mtl-2.2.2
                      parser-combinators-1.0.1 pretty-1.1.3.6 prettyprinter-1.2.1
                      profunctors-5.3 protolude-0.2.3 stm-2.5.0.0 tagged-0.8.6
                      template-haskell-2.14.0.0 text-1.2.3.1 transformers-0.5.5.0
                      unbound-generics-0.4.0
orphans: sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.PrettyPrint
         sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.Intermediate.Syntax
         sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.Source.Syntax
         transformers-0.5.5.0:Control.Monad.Trans.Error
         stm-2.5.0.0:Control.Monad.STM
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.1:Data.Text.Lazy
         text-1.2.3.1:Data.Text binary-0.8.6.0:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show base-4.12.0.0:GHC.Float
         base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         bifunctors-5.5.3:Data.Bifunctor.Biff
                         bifunctors-5.5.3:Data.Bifunctor.Clown
                         bifunctors-5.5.3:Data.Bifunctor.Joker
                         bifunctors-5.5.3:Data.Bifunctor.Product
                         bifunctors-5.5.3:Data.Bifunctor.Sum
                         bifunctors-5.5.3:Data.Bifunctor.Tannen
                         containers-0.6.0.1:Data.IntMap.Internal
                         containers-0.6.0.1:Data.IntSet.Internal
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Sequence.Internal
                         containers-0.6.0.1:Data.Set.Internal containers-0.6.0.1:Data.Tree
                         ghc-boot-th-8.6.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.6.3:GHC.LanguageExtensions.Type
                         megaparsec-7.0.4:Text.Megaparsec.Error
                         megaparsec-7.0.4:Text.Megaparsec.Pos
                         megaparsec-7.0.4:Text.Megaparsec.State
                         megaparsec-7.0.4:Text.Megaparsec.Stream
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         prettyprinter-1.2.1:Data.Text.Prettyprint.Doc.Internal
                         sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.Common
                         sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.Intermediate.Syntax
                         sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.Source.Syntax
                         tagged-0.8.6:Data.Tagged
                         template-haskell-2.14.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.1:Data.Text text-1.2.3.1:Data.Text.Lazy
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Bind
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Embed
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Ignore
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Name
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Rebind
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Rec
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Shift
import  -/  base-4.12.0.0:Data.Foldable 00188ddf89c975fee76bdfad479443c1
import  -/  base-4.12.0.0:Data.Maybe 1e8e1362415df45376dffd98f8a47766
import  -/  base-4.12.0.0:GHC.Base cc906f98291a1b830546e99a96674547
import  -/  protolude-0.2.3:Protolude f69a0445642f255f4ede68732259560a
import  -/  SEDEL.Environment d8bc650b7b97515a31f95e90c47efbdd
  exports: ee616ba5663dcc7668ccee4c280f41a3
  SCtx a8e6987da1cb24e3d3606dff7a039d9c
  lookupTVarSynMaybe c90bf5afd5a52b7bd41e9b4aa96ed766
import  -/  SEDEL.Source.Syntax ec83a0da1c10765115fe4a9f09c754b0
  exports: 9689242b0decab272007a11f45b72d7d
  And 0283b9e7440c4a3e47a1281e02970dde
  App c363422f50778c82e96747329eb9877e
  Arr df83e91aec2f80dc9d042375099bb771
  BoolT 21df8d7d01d510390fe4d585a4a596cd
  BotT 77bd90a3bcfd29395ef1007b8a6a4ee6
  DForall 0b90eb4f4665e714927dfbf10c3a2bda
  DRec' 7cbb27fc4ed6a9f26ea9ac20bbfb9298
  DefDecl 0bcb0cf0edd018dbef851783eba7cbb7
  Expr 350069ed8c9e308e7d171878eb06250d
  If 8adb062a80541f4537caeee81d7bc725
  Lam 63512428e48d94b955997c9b670e149e
  Let 01c008f6cf31bc0acec7ee6debf6c39a
  Merge 8618c4cff7c45435653614618dd77223
  NumT 539f9e6436bb2f46e0e1ed9aac813b1c
  Pos caef810378ba48ca7966a52d7584d18f
  PrimOp 459db753a665a5d3d985408f034250f5
  Proj c9b17242d24bcebd4dda5844c7db7905
  RawName dd597ebe4002c588443d0e6bcbc3e158
  Rec f54127b91625470e365ba58cc88fab42
  SDecl d4da484abb8cfac2766f73e28f180df7
  SRecT 4b07dd6d7293a4e5e53901cef6634094
  SType 2633b8b7955e013a3831a0582461061f
  SType 350069ed8c9e308e7d171878eb06250d
  Scheme 350069ed8c9e308e7d171878eb06250d
  TVar 2d4c55a015b709b4614fff76215f0c95
  TmBind 350069ed8c9e308e7d171878eb06250d
  TmName 350069ed8c9e308e7d171878eb06250d
  TopT fa9c823349a4c24a48445d1081f1a548
  TyName 350069ed8c9e308e7d171878eb06250d
  bindName 350069ed8c9e308e7d171878eb06250d
  bindParams 350069ed8c9e308e7d171878eb06250d
  bindRhs 350069ed8c9e308e7d171878eb06250d
  bindRhsTyAscription 350069ed8c9e308e7d171878eb06250d
  bindTyParams 350069ed8c9e308e7d171878eb06250d
import  -/  unbound-generics-0.4.0:Unbound.Generics.LocallyNameless 36704d4dbfb3fb22f46cde363ae796f2
import  -/  unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Embed f74cff3aea20e9a2f5e6bfc539a9689b
import  -/  unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Fresh e0f8d49fe8e0f78dfcabb34436892778
import  -/  unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Operations d0c219408974b95413509bf76023577c
3a17e079f90e562748dbe07d95b0791e
  $s$fAlpha(,)_$s$fAlphaEmbed ::
    Unbound.Generics.LocallyNameless.Alpha.Alpha
      (Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType)
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Embed.Embed
                       SEDEL.Source.Syntax.SType)
                  SEDEL.Source.Desugar.$s$fAlpha(,)_$s$fShowEmbed
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType)
                     (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Source.Syntax.SType) ->
                   SEDEL.Source.Syntax.$fAlphaSType_$caeq'
                     (case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                      Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                        Unbound.Generics.LocallyNameless.Alpha.Term
                        ds3 })
                     ds
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Source.Syntax.SType>_R)
                     ds1
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Source.Syntax.SType>_R))
                  (Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cfvAny'
                     @ SEDEL.Source.Syntax.SType
                     SEDEL.Source.Syntax.$fAlphaSType)
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (b :: Unbound.Generics.LocallyNameless.Alpha.NamePatFind)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed6
                          @ SEDEL.Source.Syntax.SType
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> (SEDEL.Source.Syntax.$fAlphaSType_$cclose
                           (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                              Unbound.Generics.LocallyNameless.Alpha.Term
                              ds2)
                           b
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R))
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <SEDEL.Source.Syntax.SType>_R)) } })
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (b :: Unbound.Generics.LocallyNameless.Alpha.NthPatFind)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed5
                          @ SEDEL.Source.Syntax.SType
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> (SEDEL.Source.Syntax.$fAlphaSType_$copen
                           (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                              Unbound.Generics.LocallyNameless.Alpha.Term
                              ds2)
                           b
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R))
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <SEDEL.Source.Syntax.SType>_R)) } })
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   case (SEDEL.Source.Syntax.$fAlphaSType_$cisTerm
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R))
                          `cast`
                        (Data.Semigroup.Internal.N:All[0]) of wild {
                     GHC.Types.False
                     -> (GHC.Maybe.Nothing
                           @ [Unbound.Generics.LocallyNameless.Name.AnyName])
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                  <Unbound.Generics.LocallyNameless.Name.AnyName>_R))
                     GHC.Types.True
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed4
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                  <Unbound.Generics.LocallyNameless.Name.AnyName>_R)) })
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   GHC.Types.False)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      SEDEL.Source.Syntax.SType>_R
                   ->_R Sym (Data.Semigroup.Internal.N:All[0]))
                  SEDEL.Source.Syntax.$fAlphaSType_$cisTerm
                    `cast`
                  (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                            <SEDEL.Source.Syntax.SType>_R)
                   ->_R Data.Semigroup.Internal.N:All[0])
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   Data.Either.Left
                     @ GHC.Integer.Type.Integer
                     @ Unbound.Generics.LocallyNameless.Name.AnyName)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      SEDEL.Source.Syntax.SType>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Alpha.N:NthPatFind[0]))
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   Unbound.Generics.LocallyNameless.Alpha.$fAlpha()2)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      SEDEL.Source.Syntax.SType>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Alpha.N:NamePatFind[0]))
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (perm :: Unbound.Generics.PermM.Perm
                                Unbound.Generics.LocallyNameless.Name.AnyName)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term -> ds
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> (SEDEL.Source.Syntax.$fAlphaScheme_$cswaps'
                           (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                              Unbound.Generics.LocallyNameless.Alpha.Term
                              ds2)
                           perm
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R))
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <SEDEL.Source.Syntax.SType>_R)) } })
                  (\ @ m :: * -> *
                     @ b
                     ($dLFresh :: Unbound.Generics.LocallyNameless.LFresh.LFresh m) ->
                   Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed2
                     @ b
                     @ m
                     @ SEDEL.Source.Syntax.SType)
                  (\ @ m :: * -> *
                     ($dFresh :: Unbound.Generics.LocallyNameless.Fresh.Fresh m)
                     (eta :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (eta1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                                SEDEL.Source.Syntax.SType) ->
                   case eta of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed1
                          @ SEDEL.Source.Syntax.SType
                          @ m
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> GHC.Base.return
                          @ m
                          (Unbound.Generics.LocallyNameless.Fresh.$p1Fresh @ m $dFresh)
                          @ (Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Source.Syntax.SType,
                             Unbound.Generics.PermM.Perm
                               Unbound.Generics.LocallyNameless.Name.AnyName)
                          (eta1,
                           (Data.Map.Internal.Tip
                              @ Unbound.Generics.LocallyNameless.Name.AnyName
                              @ Unbound.Generics.LocallyNameless.Name.AnyName)
                             `cast`
                           (Sym (Unbound.Generics.PermM.N:Perm[0]
                                     <Unbound.Generics.LocallyNameless.Name.AnyName>_N))) } })
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType)
                     (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Source.Syntax.SType) ->
                   SEDEL.Source.Syntax.$fAlphaSType_$cacompare'
                     (case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                      Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                        Unbound.Generics.LocallyNameless.Alpha.Term
                        ds3 })
                     ds
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Source.Syntax.SType>_R)
                     ds1
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Source.Syntax.SType>_R)) -}
62e97544b8021f4b73ce47c5f2de0bde
  $s$fAlpha(,)_$s$fShowEmbed ::
    GHC.Show.Show
      (Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Embed.Embed
                       SEDEL.Source.Syntax.SType)
                  (Unbound.Generics.LocallyNameless.Embed.$fShowEmbed_$cshowsPrec
                     @ SEDEL.Source.Syntax.SType
                     SEDEL.Source.Syntax.$fShowSType)
                  (\ (x :: Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Source.Syntax.SType) ->
                   GHC.CString.unpackAppendCString#
                     Unbound.Generics.LocallyNameless.Embed.$fShowEmbed3
                     (SEDEL.Source.Syntax.$fShowSType_$cshowsPrec
                        Unbound.Generics.LocallyNameless.Embed.$fShowEmbed2
                        x `cast`
                        (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                             <SEDEL.Source.Syntax.SType>_R)
                        Unbound.Generics.LocallyNameless.Embed.$fShowEmbed4))
                  (Unbound.Generics.LocallyNameless.Embed.$fShowEmbed_$cshowList
                     @ SEDEL.Source.Syntax.SType
                     SEDEL.Source.Syntax.$fShowSType) -}
d1035c943f299c87a7737917cb6ad0ec
  $s$fAlphaEmbed_$cacompare' ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
    -> GHC.Types.Ordering
  {- Arity: 3, Strictness: <L,1*U(A,U)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType)
                   (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Source.Syntax.SType) ->
                 SEDEL.Source.Syntax.$fAlphaSType_$cacompare'
                   (case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                      Unbound.Generics.LocallyNameless.Alpha.Term
                      ds3 })
                   ds
                     `cast`
                   (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                        <SEDEL.Source.Syntax.SType>_R)
                   ds1
                     `cast`
                   (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                        <SEDEL.Source.Syntax.SType>_R)) -}
a77a8fdf4f9e6f95416d05a46fabd761
  $s$fAlphaEmbed_$caeq' ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
    -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,1*H><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType)
                   (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Source.Syntax.SType) ->
                 SEDEL.Source.Syntax.$fAlphaSType_$caeq'
                   (case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                      Unbound.Generics.LocallyNameless.Alpha.Term
                      ds3 })
                   ds
                     `cast`
                   (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                        <SEDEL.Source.Syntax.SType>_R)
                   ds1
                     `cast`
                   (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                        <SEDEL.Source.Syntax.SType>_R)) -}
1dc5724f51848ecf3c3ec8c471e2caca
  $s$fAlphaEmbed_$cclose ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Alpha.NamePatFind
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
  {- Arity: 3, Strictness: <S(SS),1*U(U,U)><L,C(U)><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (b :: Unbound.Generics.LocallyNameless.Alpha.NamePatFind)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType) ->
                 case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                 case ds1 of wild1 {
                   Unbound.Generics.LocallyNameless.Alpha.Term
                   -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed6
                        @ SEDEL.Source.Syntax.SType
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> (SEDEL.Source.Syntax.$fAlphaSType_$cclose
                         (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                            Unbound.Generics.LocallyNameless.Alpha.Term
                            ds2)
                         b
                         ds
                           `cast`
                         (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                              <SEDEL.Source.Syntax.SType>_R))
                        `cast`
                      (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R)) } }) -}
820526996fa7d74c1d26cf9dfee9905e
  $s$fAlphaEmbed_$cfreshen' ::
    Unbound.Generics.LocallyNameless.Fresh.Fresh m =>
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
    -> m (Unbound.Generics.LocallyNameless.Embed.Embed
            SEDEL.Source.Syntax.SType,
          Unbound.Generics.PermM.Perm
            Unbound.Generics.LocallyNameless.Name.AnyName)
  {- Arity: 3,
     Strictness: <S(S(LLLC(S)L)L),1*U(1*U(A,A,A,1*C1(U),A),A)><S(SL),1*U(U,A)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   ($dFresh :: Unbound.Generics.LocallyNameless.Fresh.Fresh m)
                   (eta :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (eta1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                 case eta of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                 case ds1 of wild1 {
                   Unbound.Generics.LocallyNameless.Alpha.Term
                   -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed1
                        @ SEDEL.Source.Syntax.SType
                        @ m
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> GHC.Base.return
                        @ m
                        (Unbound.Generics.LocallyNameless.Fresh.$p1Fresh @ m $dFresh)
                        @ (Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Source.Syntax.SType,
                           Unbound.Generics.PermM.Perm
                             Unbound.Generics.LocallyNameless.Name.AnyName)
                        (eta1,
                         (Data.Map.Internal.Tip
                            @ Unbound.Generics.LocallyNameless.Name.AnyName
                            @ Unbound.Generics.LocallyNameless.Name.AnyName)
                           `cast`
                         (Sym (Unbound.Generics.PermM.N:Perm[0]
                                   <Unbound.Generics.LocallyNameless.Name.AnyName>_N))) } }) -}
1d17d27c0025d76d8f4820f12bd842ef
  $s$fAlphaEmbed_$cisPat ::
    Unbound.Generics.LocallyNameless.Embed.Embed
      SEDEL.Source.Syntax.SType
    -> Unbound.Generics.LocallyNameless.Alpha.DisjointSet
         Unbound.Generics.LocallyNameless.Name.AnyName
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType) ->
                 case (SEDEL.Source.Syntax.$fAlphaSType_$cisTerm
                         ds
                           `cast`
                         (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                              <SEDEL.Source.Syntax.SType>_R))
                        `cast`
                      (Data.Semigroup.Internal.N:All[0]) of wild {
                   GHC.Types.False
                   -> (GHC.Maybe.Nothing
                         @ [Unbound.Generics.LocallyNameless.Name.AnyName])
                        `cast`
                      (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                <Unbound.Generics.LocallyNameless.Name.AnyName>_R))
                   GHC.Types.True
                   -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed4
                        `cast`
                      (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                <Unbound.Generics.LocallyNameless.Name.AnyName>_R)) }) -}
876ba422ead5cac62b4316dbd0993490
  $s$fAlphaEmbed_$copen ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Alpha.NthPatFind
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
  {- Arity: 3, Strictness: <S(SS),1*U(U,U)><L,C(U)><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (b :: Unbound.Generics.LocallyNameless.Alpha.NthPatFind)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType) ->
                 case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                 case ds1 of wild1 {
                   Unbound.Generics.LocallyNameless.Alpha.Term
                   -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed5
                        @ SEDEL.Source.Syntax.SType
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> (SEDEL.Source.Syntax.$fAlphaSType_$copen
                         (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                            Unbound.Generics.LocallyNameless.Alpha.Term
                            ds2)
                         b
                         ds
                           `cast`
                         (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                              <SEDEL.Source.Syntax.SType>_R))
                        `cast`
                      (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R)) } }) -}
a37ab77f2331be6f72c256bb7e19b495
  $s$fAlphaEmbed_$cswaps' ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.PermM.Perm
         Unbound.Generics.LocallyNameless.Name.AnyName
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
  {- Arity: 3, Strictness: <S(SL),1*U(U,A)><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (perm :: Unbound.Generics.PermM.Perm
                              Unbound.Generics.LocallyNameless.Name.AnyName)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType) ->
                 case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                 case ds1 of wild1 {
                   Unbound.Generics.LocallyNameless.Alpha.Term -> ds
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> (SEDEL.Source.Syntax.$fAlphaScheme_$cswaps'
                         (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                            Unbound.Generics.LocallyNameless.Alpha.Term
                            ds2)
                         perm
                         ds
                           `cast`
                         (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                              <SEDEL.Source.Syntax.SType>_R))
                        `cast`
                      (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R)) } }) -}
45848d7f14f60c533e0a396a6c60aef7
  $s$fApplicativeFreshMT ::
    GHC.Base.Applicative
      (Unbound.Generics.LocallyNameless.Fresh.FreshMT
         Data.Functor.Identity.Identity)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Fresh.FreshMT
                       Data.Functor.Identity.Identity)
                  SEDEL.Source.Desugar.$s$fApplicativeFreshMT_$s$fFunctorFreshMT
                  (\ @ a (eta :: a) (eta1 :: GHC.Integer.Type.Integer) ->
                   (eta, eta1))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R (<GHC.Integer.Type.Integer>_R
                         ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                       <(a,
                                         GHC.Integer.Type.Integer)>_R)) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                    <GHC.Integer.Type.Integer>_N
                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                    <a>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Data.Functor.Identity.Identity>_N <a>_N))
                  (Unbound.Generics.LocallyNameless.Fresh.$fApplicativeFreshMT4
                     @ Data.Functor.Identity.Identity
                     Data.Functor.Identity.$fMonadIdentity)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Data.Functor.Identity.Identity>_N <a
                                                                                                                 -> b>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Data.Functor.Identity.Identity>_N <a>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Data.Functor.Identity.Identity>_R
                                 <b>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Data.Functor.Identity.Identity>_N <b>_N)
                  (\ @ a
                     @ b
                     @ c
                     (eta :: a -> b -> c)
                     (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer Data.Functor.Identity.Identity a)
                     (eta2 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer Data.Functor.Identity.Identity b)
                     (eta3 :: GHC.Integer.Type.Integer) ->
                   Control.Monad.Trans.State.Lazy.$w$cliftA2
                     @ Data.Functor.Identity.Identity
                     @ GHC.Integer.Type.Integer
                     Data.Functor.Identity.$fFunctorIdentity
                     Data.Functor.Identity.$fMonadIdentity_$c>>=
                     Data.Functor.Identity.$fApplicativeIdentity3
                       `cast`
                     (forall (a1 :: <*>_N).
                      <a1>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <a1>_R))
                     @ a
                     @ b
                     @ c
                     eta
                     eta1
                     eta2
                     eta3)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Data.Functor.Identity.Identity>_N <a>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Data.Functor.Identity.Identity>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Data.Functor.Identity.Identity>_R
                                 <c>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Data.Functor.Identity.Identity>_N <c>_N)
                  (\ @ a
                     @ b
                     (eta :: Control.Monad.Trans.State.Lazy.StateT
                               GHC.Integer.Type.Integer Data.Functor.Identity.Identity a)
                     (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer Data.Functor.Identity.Identity b)
                     (eta2 :: GHC.Integer.Type.Integer) ->
                   eta1
                     `cast`
                   (Control.Monad.Trans.State.Lazy.N:StateT[0]
                        <GHC.Integer.Type.Integer>_N
                        <Data.Functor.Identity.Identity>_R
                        <b>_N)
                     (case (eta
                              `cast`
                            (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Data.Functor.Identity.Identity>_R
                                 <a>_N)
                              eta2)
                             `cast`
                           (Data.Functor.Identity.N:Identity[0]
                                <(a, GHC.Integer.Type.Integer)>_R) of wild { (,) a1 s' ->
                      s' }))
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Data.Functor.Identity.Identity>_N <a>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Data.Functor.Identity.Identity>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Data.Functor.Identity.Identity>_R
                                 <b>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Data.Functor.Identity.Identity>_N <b>_N)
                  (\ @ a
                     @ b
                     (eta :: Control.Monad.Trans.State.Lazy.StateT
                               GHC.Integer.Type.Integer Data.Functor.Identity.Identity a)
                     (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer Data.Functor.Identity.Identity b)
                     (eta2 :: GHC.Integer.Type.Integer) ->
                   Control.Monad.Trans.State.Lazy.$w$cliftA2
                     @ Data.Functor.Identity.Identity
                     @ GHC.Integer.Type.Integer
                     Data.Functor.Identity.$fFunctorIdentity
                     Data.Functor.Identity.$fMonadIdentity_$c>>=
                     Data.Functor.Identity.$fApplicativeIdentity3
                       `cast`
                     (forall (a1 :: <*>_N).
                      <a1>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <a1>_R))
                     @ a
                     @ b
                     @ a
                     (GHC.Base.const @ a @ b)
                     eta
                     eta1
                     eta2)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Data.Functor.Identity.Identity>_N <a>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Data.Functor.Identity.Identity>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Data.Functor.Identity.Identity>_R
                                 <a>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Data.Functor.Identity.Identity>_N <a>_N) -}
50986dc72852c1708f32918277f5dbb6
  $s$fApplicativeFreshMT2 ::
    Control.Monad.Trans.State.Lazy.StateT
      GHC.Integer.Type.Integer Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.State.Lazy.StateT
         GHC.Integer.Type.Integer Data.Functor.Identity.Identity b
    -> GHC.Integer.Type.Integer
    -> Data.Functor.Identity.Identity (b, GHC.Integer.Type.Integer)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U(A,1*U))><C(S),1*C1(U(U,U))><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (eta :: Control.Monad.Trans.State.Lazy.StateT
                             GHC.Integer.Type.Integer Data.Functor.Identity.Identity a)
                   (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                              GHC.Integer.Type.Integer Data.Functor.Identity.Identity b)
                   (eta2 :: GHC.Integer.Type.Integer) ->
                 eta1
                   `cast`
                 (Control.Monad.Trans.State.Lazy.N:StateT[0]
                      <GHC.Integer.Type.Integer>_N
                      <Data.Functor.Identity.Identity>_R
                      <b>_N)
                   (case (eta
                            `cast`
                          (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <GHC.Integer.Type.Integer>_N
                               <Data.Functor.Identity.Identity>_R
                               <a>_N)
                            eta2)
                           `cast`
                         (Data.Functor.Identity.N:Identity[0]
                              <(a, GHC.Integer.Type.Integer)>_R) of wild { (,) a1 s' ->
                    s' })) -}
bff920677b1854af0be3e81d6607060b
  $s$fApplicativeFreshMT_$s$fFunctorFreshMT ::
    GHC.Base.Functor
      (Unbound.Generics.LocallyNameless.Fresh.FreshMT
         Data.Functor.Identity.Identity)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Fresh.FreshMT
                       Data.Functor.Identity.Identity)
                  (SEDEL.Source.Desugar.$s$fApplicativeFreshMT_$s$fFunctorStateT_$cfmap
                     @ GHC.Integer.Type.Integer)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a -> b>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Data.Functor.Identity.Identity>_N <a>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Data.Functor.Identity.Identity>_N <b>_N)
                  (\ @ a
                     @ b
                     (x :: a)
                     (eta :: Control.Monad.Trans.State.Lazy.StateT
                               GHC.Integer.Type.Integer Data.Functor.Identity.Identity b)
                     (eta1 :: GHC.Integer.Type.Integer) ->
                   (x,
                    case (eta
                            `cast`
                          (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <GHC.Integer.Type.Integer>_N
                               <Data.Functor.Identity.Identity>_R
                               <b>_N)
                            eta1)
                           `cast`
                         (Data.Functor.Identity.N:Identity[0]
                              <(b, GHC.Integer.Type.Integer)>_R) of wild { (,) a1 s' ->
                    s' }))
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Data.Functor.Identity.Identity>_N <b>_N
                   ->_R (<GHC.Integer.Type.Integer>_R
                         ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                       <(a,
                                         GHC.Integer.Type.Integer)>_R)) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                    <GHC.Integer.Type.Integer>_N
                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                    <a>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Data.Functor.Identity.Identity>_N <a>_N)) -}
507ce32a66712f28813681062648913b
  $s$fApplicativeFreshMT_$s$fFunctorStateT_$cfmap ::
    (a -> b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U)><L,1*C1(U(1*U,1*U))><L,U>m,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (f :: a -> b)
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s Data.Functor.Identity.Identity a)
                   (s1 :: s) ->
                 let {
                   ds :: Data.Functor.Identity.Identity (a, s)
                   = m1
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N <Data.Functor.Identity.Identity>_R <a>_N)
                       s1
                 } in
                 (f (case ds
                            `cast`
                          (Data.Functor.Identity.N:Identity[0]
                               <(a, s)>_R) of wild { (,) a1 s' ->
                     a1 }),
                  case ds
                         `cast`
                       (Data.Functor.Identity.N:Identity[0]
                            <(a, s)>_R) of wild { (,) a1 s' ->
                  s' })
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0] <(b, s)>_R)))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s Data.Functor.Identity.Identity a>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <Data.Functor.Identity.Identity>_R <b>_N)) -}
d406487556260ce502a4802066c4474d
  $s$fFreshFreshMT ::
    Unbound.Generics.LocallyNameless.Fresh.Fresh
      (Unbound.Generics.LocallyNameless.Fresh.FreshMT
         Data.Functor.Identity.Identity)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Fresh.FreshMT
                       Data.Functor.Identity.Identity)
                  SEDEL.Source.Desugar.$s$fFreshFreshMT_$s$fMonadFreshMT
                  (Unbound.Generics.LocallyNameless.Fresh.$fFreshFreshMT1
                     @ Data.Functor.Identity.Identity
                     Data.Functor.Identity.$fMonadIdentity)
                    `cast`
                  (forall (a :: <*>_N).
                   <Unbound.Generics.LocallyNameless.Name.Name a>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Data.Functor.Identity.Identity>_R
                                 <Unbound.Generics.LocallyNameless.Name.Name
                                    a>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Data.Functor.Identity.Identity>_N <Unbound.Generics.LocallyNameless.Name.Name
                                                                                                                                            a>_N) -}
0e09224bcf2a7bffae9e12c2699e9495
  $s$fFreshFreshMT1 ::
    Unbound.Generics.LocallyNameless.Name.Name a
    -> GHC.Integer.Type.Integer
    -> Data.Functor.Identity.Identity
         (Unbound.Generics.LocallyNameless.Name.Name a,
          GHC.Integer.Type.Integer)
  {- Arity: 2, Strictness: <S,1*U><L,U>m, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w1 :: Unbound.Generics.LocallyNameless.Name.Name a)
                   (w2 :: GHC.Integer.Type.Integer) ->
                 case w1 of wild {
                   Unbound.Generics.LocallyNameless.Name.Fn s ds
                   -> (case w2 of dt { DEFAULT ->
                       Unbound.Generics.LocallyNameless.Name.Fn @ a s dt },
                       GHC.Integer.Type.plusInteger
                         w2
                         Unbound.Generics.LocallyNameless.Fresh.$fFreshFreshMT2)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(Unbound.Generics.LocallyNameless.Name.Name a,
                                  GHC.Integer.Type.Integer)>_R))
                   Unbound.Generics.LocallyNameless.Name.Bn ds ds1
                   -> (wild, w2)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(Unbound.Generics.LocallyNameless.Name.Name a,
                                  GHC.Integer.Type.Integer)>_R)) }) -}
87fa212bd3d1bd3f36a4c9ee45e4425c
  $s$fFreshFreshMT_$s$fMonadFreshMT ::
    GHC.Base.Monad
      (Unbound.Generics.LocallyNameless.Fresh.FreshMT
         Data.Functor.Identity.Identity)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Fresh.FreshMT
                       Data.Functor.Identity.Identity)
                  SEDEL.Source.Desugar.$s$fApplicativeFreshMT
                  (SEDEL.Source.Desugar.$s$fFreshFreshMT_$s$fMonadStateT_$c>>=
                     @ GHC.Integer.Type.Integer)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Data.Functor.Identity.Identity>_N <a>_N
                   ->_R (<a>_R
                         ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Data.Functor.Identity.Identity>_N <b>_N)
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Data.Functor.Identity.Identity>_N <b>_N)
                  (SEDEL.Source.Desugar.$s$fFreshFreshMT_$s$fMonadStateT_$c>>
                     @ GHC.Integer.Type.Integer)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Data.Functor.Identity.Identity>_N <a>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Data.Functor.Identity.Identity>_N <b>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Data.Functor.Identity.Identity>_N <b>_N)
                  (\ @ a (eta :: a) (eta1 :: GHC.Integer.Type.Integer) ->
                   (eta, eta1))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R (<GHC.Integer.Type.Integer>_R
                         ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                       <(a,
                                         GHC.Integer.Type.Integer)>_R)) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                    <GHC.Integer.Type.Integer>_N
                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                    <a>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Data.Functor.Identity.Identity>_N <a>_N))
                  (SEDEL.Source.Desugar.$s$fFreshFreshMT_$s$fMonadStateT_$cfail
                     @ GHC.Integer.Type.Integer)
                    `cast`
                  (forall (a :: <*>_N).
                   <[GHC.Types.Char]>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Data.Functor.Identity.Identity>_N <a>_N) -}
a69155b82ab996157615967c4a083e96
  $s$fFreshFreshMT_$s$fMonadStateT_$c>> ::
    Control.Monad.Trans.State.Lazy.StateT
      s Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity b
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U(A,1*U))><C(S),1*C1(U(U,U))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s Data.Functor.Identity.Identity a)
                   (k :: Control.Monad.Trans.State.Lazy.StateT
                           s Data.Functor.Identity.Identity b)
                   (s1 :: s) ->
                 k `cast`
                 (Control.Monad.Trans.State.Lazy.N:StateT[0]
                      <s>_N <Data.Functor.Identity.Identity>_R <b>_N)
                   (case (m1
                            `cast`
                          (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <Data.Functor.Identity.Identity>_R <a>_N)
                            s1)
                           `cast`
                         (Data.Functor.Identity.N:Identity[0]
                              <(a, s)>_R) of wild { (,) a1 s' ->
                    s' }))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s Data.Functor.Identity.Identity a>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s Data.Functor.Identity.Identity b>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <Data.Functor.Identity.Identity>_R <b>_N)) -}
29941e2a9bcd8980c186818ce50354a0
  $s$fFreshFreshMT_$s$fMonadStateT_$c>>= ::
    Control.Monad.Trans.State.Lazy.StateT
      s Data.Functor.Identity.Identity a
    -> (a
        -> Control.Monad.Trans.State.Lazy.StateT
             s Data.Functor.Identity.Identity b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U(1*U,1*U))><C(C(S)),1*C1(C1(U(U,U)))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s Data.Functor.Identity.Identity a)
                   (k :: a
                         -> Control.Monad.Trans.State.Lazy.StateT
                              s Data.Functor.Identity.Identity b)
                   (s1 :: s) ->
                 let {
                   ds :: Data.Functor.Identity.Identity (a, s)
                   = m1
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N <Data.Functor.Identity.Identity>_R <a>_N)
                       s1
                 } in
                 (k (case ds
                            `cast`
                          (Data.Functor.Identity.N:Identity[0]
                               <(a, s)>_R) of wild { (,) a1 s' ->
                     a1 }))
                   `cast`
                 (Control.Monad.Trans.State.Lazy.N:StateT[0]
                      <s>_N <Data.Functor.Identity.Identity>_R <b>_N)
                   (case ds
                           `cast`
                         (Data.Functor.Identity.N:Identity[0]
                              <(a, s)>_R) of wild { (,) a1 s' ->
                    s' }))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s Data.Functor.Identity.Identity a>_R
                 ->_R <a
                       -> Control.Monad.Trans.State.Lazy.StateT
                            s Data.Functor.Identity.Identity b>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <Data.Functor.Identity.Identity>_R <b>_N)) -}
b3f5c9b4a4e1710a73c69a0a86bae915
  $s$fFreshFreshMT_$s$fMonadStateT_$cfail ::
    GHC.Base.String
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity a
  {- Arity: 2, Strictness: <B,U><B,A>x, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ s @ a (str :: GHC.Base.String) (ds :: s) ->
                 GHC.Err.errorWithoutStackTrace
                   @ 'GHC.Types.LiftedRep
                   @ (Data.Functor.Identity.Identity (a, s))
                   str)
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <GHC.Base.String>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <Data.Functor.Identity.Identity>_R <a>_N)) -}
09832da82389f4ae53410f6587bcbf37
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   SEDEL.Source.Desugar.$trModule3
                   SEDEL.Source.Desugar.$trModule1) -}
68b94e8e21671c1c5ca5e972277c7556
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Desugar.$trModule2) -}
2e3c9e7418a6557cf53b35e0871c48dd
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SEDEL.Source.Desugar"#) -}
0f561b070ac635aab4a3960c4d5870e5
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Desugar.$trModule4) -}
66d1c59db429e878457c9c5891c72116
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ"#) -}
d7e58a470c52bd97c3db5a2f0d0b54c8
  $w$sgo ::
    SEDEL.Source.Syntax.Expr
    -> GHC.Integer.Type.Integer
    -> (# SEDEL.Source.Syntax.Expr, GHC.Integer.Type.Integer #)
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [2] -}
de0fecb50bc3064e5a55642aeb613365
  $wgo ::
    SEDEL.Environment.SCtx
    -> SEDEL.Source.Syntax.Scheme
    -> GHC.Integer.Type.Integer
    -> (# SEDEL.Source.Syntax.Scheme, GHC.Integer.Type.Integer #)
  {- Arity: 3, Strictness: <L,U(A,U,A,A)><S,1*U><L,U>, Inline: [2] -}
6c85ba27e79e32700ccf357c64c19a22
  $wnormalizeTmDecl ::
    SEDEL.Source.Syntax.TmBind
    -> (# SEDEL.Source.Syntax.RawName, SEDEL.Source.Syntax.Expr #)
  {- Arity: 1, Strictness: <L,U(1*U,A,1*U,U,A,A)>, Inline: [2],
     Unfolding: (\ (w :: SEDEL.Source.Syntax.TmBind) ->
                 (# SEDEL.Source.Syntax.bindName w,
                    case w of wild { SEDEL.Source.Syntax.TmBind ds1 ds2 ds3 ds4 ds5 ds6 ->
                    letrec {
                      go :: [(SEDEL.Source.Syntax.TmName,
                              GHC.Maybe.Maybe SEDEL.Source.Syntax.Scheme)]
                            -> SEDEL.Source.Syntax.Expr
                        {- Arity: 1, Strictness: <S,1*U> -}
                      = \ (ds :: [(SEDEL.Source.Syntax.TmName,
                                   GHC.Maybe.Maybe SEDEL.Source.Syntax.Scheme)]) ->
                        case ds of wild1 {
                          [] -> ds4
                          : y ys
                          -> case y of wild2 { (,) n t ->
                             SEDEL.Source.Syntax.Lam
                               (Unbound.Generics.LocallyNameless.Bind.B
                                  @ SEDEL.Source.Syntax.TmName
                                  @ SEDEL.Source.Syntax.Expr
                                  n
                                  (SEDEL.Source.Syntax.$fAlphaExpr_$cclose
                                     Unbound.Generics.LocallyNameless.Alpha.initialCtx
                                     (Unbound.Generics.LocallyNameless.Alpha.$fAlphaName4
                                        @ SEDEL.Source.Syntax.Expr
                                        SEDEL.Source.Syntax.$fAlphaExpr1
                                          `cast`
                                        (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <SEDEL.Source.Syntax.Expr>_N)
                                        n)
                                       `cast`
                                     (Sym (Unbound.Generics.LocallyNameless.Alpha.N:NamePatFind[0]))
                                     (go ys))) } }
                    } in
                    go ds3 } #)) -}
0ec723830c20140bfa5a32cf0eb00b4c
  desugar ::
    [SEDEL.Source.Syntax.SDecl] -> [SEDEL.Source.Syntax.SDecl]
  {- Arity: 1,
     Unfolding: (GHC.Base.map
                   @ SEDEL.Source.Syntax.SDecl
                   @ SEDEL.Source.Syntax.SDecl
                   SEDEL.Source.Desugar.desugar1) -}
3ea93c95a251469f32b265d5ea1c5474
  desugar1 :: SEDEL.Source.Syntax.SDecl -> SEDEL.Source.Syntax.SDecl
  {- Arity: 1, Strictness: <S,1*U(1*U(U,U,U,1*U,U,U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: SEDEL.Source.Syntax.SDecl) ->
                 case ds of wild { SEDEL.Source.Syntax.DefDecl decl ->
                 SEDEL.Source.Syntax.DefDecl
                   (SEDEL.Source.Desugar.desugarTmBind decl) }) -}
98921ab5c7b9535bca5afdb3abb46698
  desugarExpr :: SEDEL.Source.Syntax.Expr -> SEDEL.Source.Syntax.Expr
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                SEDEL.Source.Desugar.desugarTmBind1
                  `cast`
                (<SEDEL.Source.Syntax.Expr>_R
                 ->_R Data.Functor.Identity.N:Identity[0]
                          <SEDEL.Source.Syntax.Expr>_R) -}
2f2fb11a9b8335a13868ab316498b2e9
  desugarTmBind ::
    SEDEL.Source.Syntax.TmBind -> SEDEL.Source.Syntax.TmBind
  {- Arity: 1, Strictness: <S,1*U(U,U,U,1*U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (b :: SEDEL.Source.Syntax.TmBind) ->
                 case b of wild { SEDEL.Source.Syntax.TmBind ds ds1 ds2 ds3 ds4 ds5 ->
                 SEDEL.Source.Syntax.TmBind
                   ds
                   ds1
                   ds2
                   (SEDEL.Source.Desugar.desugarTmBind1 ds3)
                     `cast`
                   (Data.Functor.Identity.N:Identity[0] <SEDEL.Source.Syntax.Expr>_R)
                   ds4
                   ds5 }) -}
8b16181712b04ece68a66c84f789bc69
  desugarTmBind1 ::
    SEDEL.Source.Syntax.Expr
    -> Data.Functor.Identity.Identity SEDEL.Source.Syntax.Expr
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: SEDEL.Source.Syntax.Expr) ->
                 case (SEDEL.Source.Desugar.desugarTmBind2
                         x
                         Unbound.Generics.LocallyNameless.Fresh.runFreshM1)
                        `cast`
                      (Data.Functor.Identity.N:Identity[0]
                           <(SEDEL.Source.Syntax.Expr,
                             GHC.Integer.Type.Integer)>_R) of wild { (,) a1 ds1 ->
                 a1
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <SEDEL.Source.Syntax.Expr>_R)) }) -}
1e2f911a03b72729035aaee6460a7597
  desugarTmBind2 ::
    SEDEL.Source.Syntax.Expr
    -> GHC.Integer.Type.Integer
    -> Data.Functor.Identity.Identity
         (SEDEL.Source.Syntax.Expr, GHC.Integer.Type.Integer)
  {- Arity: 2, Strictness: <S,1*U><L,U>m, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: SEDEL.Source.Syntax.Expr)
                   (w1 :: GHC.Integer.Type.Integer) ->
                 case SEDEL.Source.Desugar.$w$sgo w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(SEDEL.Source.Syntax.Expr, GHC.Integer.Type.Integer)>_R)) }) -}
1eec797ae820324c607a986205bff557
  expandType ::
    SEDEL.Environment.SCtx
    -> SEDEL.Source.Syntax.Scheme -> SEDEL.Source.Syntax.Scheme
  {- Arity: 2, Strictness: <L,U(A,U,A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ctx :: SEDEL.Environment.SCtx)
                   (ty :: SEDEL.Source.Syntax.Scheme) ->
                 case (SEDEL.Source.Desugar.expandType1
                         ctx
                         ty
                         Unbound.Generics.LocallyNameless.Fresh.runFreshM1)
                        `cast`
                      (Data.Functor.Identity.N:Identity[0]
                           <(SEDEL.Source.Syntax.Scheme,
                             GHC.Integer.Type.Integer)>_R) of wild { (,) a1 ds1 ->
                 a1 }) -}
4194a52904bc35c536fe37ada743103e
  expandType1 ::
    SEDEL.Environment.SCtx
    -> SEDEL.Source.Syntax.Scheme
    -> GHC.Integer.Type.Integer
    -> Data.Functor.Identity.Identity
         (SEDEL.Source.Syntax.Scheme, GHC.Integer.Type.Integer)
  {- Arity: 3, Strictness: <L,U(A,U,A,A)><S,1*U><L,U>m, Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: SEDEL.Environment.SCtx)
                   (w1 :: SEDEL.Source.Syntax.Scheme)
                   (w2 :: GHC.Integer.Type.Integer) ->
                 case SEDEL.Source.Desugar.$wgo w w1 w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(SEDEL.Source.Syntax.Scheme, GHC.Integer.Type.Integer)>_R)) }) -}
9aca1e59ca48302d41c3a955f0d2657e
  normalizeTmDecl ::
    SEDEL.Source.Syntax.TmBind
    -> (SEDEL.Source.Syntax.RawName, SEDEL.Source.Syntax.Expr)
  {- Arity: 1, Strictness: <L,U(U,A,U,U,A,A)>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: SEDEL.Source.Syntax.TmBind) ->
                 case SEDEL.Source.Desugar.$wnormalizeTmDecl
                        w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
"SPEC/SEDEL.Source.Desugar $fAlphaEmbed @ SType" [orphan] forall (v :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                         SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed @ SEDEL.Source.Syntax.SType
                                                      v
  = SEDEL.Source.Desugar.$s$fAlpha(,)_$s$fAlphaEmbed
"SPEC/SEDEL.Source.Desugar $fAlphaEmbed_$cacompare' @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                           SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cacompare' @ SEDEL.Source.Syntax.SType
                                                                  $dAlpha
  = SEDEL.Source.Desugar.$s$fAlphaEmbed_$cacompare'
"SPEC/SEDEL.Source.Desugar $fAlphaEmbed_$caeq' @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                      SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$caeq' @ SEDEL.Source.Syntax.SType
                                                             $dAlpha
  = SEDEL.Source.Desugar.$s$fAlphaEmbed_$caeq'
"SPEC/SEDEL.Source.Desugar $fAlphaEmbed_$cclose @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                       SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cclose @ SEDEL.Source.Syntax.SType
                                                              $dAlpha
  = SEDEL.Source.Desugar.$s$fAlphaEmbed_$cclose
"SPEC/SEDEL.Source.Desugar $fAlphaEmbed_$cfreshen' @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                          SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cfreshen' @ SEDEL.Source.Syntax.SType
                                                                 $dAlpha
  = SEDEL.Source.Desugar.$s$fAlphaEmbed_$cfreshen'
"SPEC/SEDEL.Source.Desugar $fAlphaEmbed_$cisPat @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                       SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cisPat @ SEDEL.Source.Syntax.SType
                                                              $dAlpha
  = SEDEL.Source.Desugar.$s$fAlphaEmbed_$cisPat
"SPEC/SEDEL.Source.Desugar $fAlphaEmbed_$copen @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                      SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$copen @ SEDEL.Source.Syntax.SType
                                                             $dAlpha
  = SEDEL.Source.Desugar.$s$fAlphaEmbed_$copen
"SPEC/SEDEL.Source.Desugar $fAlphaEmbed_$cswaps' @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                        SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cswaps' @ SEDEL.Source.Syntax.SType
                                                               $dAlpha
  = SEDEL.Source.Desugar.$s$fAlphaEmbed_$cswaps'
"SPEC/SEDEL.Source.Desugar $fApplicativeFreshMT @ Identity" [orphan] forall (v :: GHC.Base.Monad
                                                                                    Data.Functor.Identity.Identity)
  Unbound.Generics.LocallyNameless.Fresh.$fApplicativeFreshMT @ Data.Functor.Identity.Identity
                                                              v
  = SEDEL.Source.Desugar.$s$fApplicativeFreshMT
"SPEC/SEDEL.Source.Desugar $fApplicativeFreshMT2 @ Identity" [orphan] forall ($dMonad :: GHC.Base.Monad
                                                                                           Data.Functor.Identity.Identity)
  Unbound.Generics.LocallyNameless.Fresh.$fApplicativeFreshMT2 @ Data.Functor.Identity.Identity
                                                               $dMonad
  = SEDEL.Source.Desugar.$s$fApplicativeFreshMT2
"SPEC/SEDEL.Source.Desugar $fFreshFreshMT @ Identity" [orphan] forall (v :: GHC.Base.Monad
                                                                              Data.Functor.Identity.Identity)
  Unbound.Generics.LocallyNameless.Fresh.$fFreshFreshMT @ Data.Functor.Identity.Identity
                                                        v
  = SEDEL.Source.Desugar.$s$fFreshFreshMT
"SPEC/SEDEL.Source.Desugar $fFreshFreshMT1 @ Identity" [orphan] [2] forall (w :: GHC.Base.Monad
                                                                                   Data.Functor.Identity.Identity)
  Unbound.Generics.LocallyNameless.Fresh.$fFreshFreshMT1 @ Data.Functor.Identity.Identity
                                                         w
  = SEDEL.Source.Desugar.$s$fFreshFreshMT1
"SPEC/SEDEL.Source.Desugar $fFunctorFreshMT @ Identity" [orphan] forall (v :: GHC.Base.Functor
                                                                                Data.Functor.Identity.Identity)
  Unbound.Generics.LocallyNameless.Fresh.$fFunctorFreshMT @ Data.Functor.Identity.Identity
                                                          v
  = SEDEL.Source.Desugar.$s$fApplicativeFreshMT_$s$fFunctorFreshMT
"SPEC/SEDEL.Source.Desugar $fFunctorStateT_$cfmap @ Identity _" [orphan] forall @ s
                                                                                ($dFunctor :: GHC.Base.Functor
                                                                                                Data.Functor.Identity.Identity)
  Control.Monad.Trans.State.Lazy.$fFunctorStateT_$cfmap @ Data.Functor.Identity.Identity
                                                        @ s
                                                        $dFunctor
  = SEDEL.Source.Desugar.$s$fApplicativeFreshMT_$s$fFunctorStateT_$cfmap
      @ s
"SPEC/SEDEL.Source.Desugar $fMonadFreshMT @ Identity" [orphan] forall (v :: GHC.Base.Monad
                                                                              Data.Functor.Identity.Identity)
  Unbound.Generics.LocallyNameless.Fresh.$fMonadFreshMT @ Data.Functor.Identity.Identity
                                                        v
  = SEDEL.Source.Desugar.$s$fFreshFreshMT_$s$fMonadFreshMT
"SPEC/SEDEL.Source.Desugar $fMonadStateT_$c>> @ Identity _" [orphan] forall @ s
                                                                            ($dMonad :: GHC.Base.Monad
                                                                                          Data.Functor.Identity.Identity)
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>> @ Data.Functor.Identity.Identity
                                                    @ s
                                                    $dMonad
  = SEDEL.Source.Desugar.$s$fFreshFreshMT_$s$fMonadStateT_$c>> @ s
"SPEC/SEDEL.Source.Desugar $fMonadStateT_$c>>= @ Identity _" [orphan] forall @ s
                                                                             ($dMonad :: GHC.Base.Monad
                                                                                           Data.Functor.Identity.Identity)
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>>= @ Data.Functor.Identity.Identity
                                                     @ s
                                                     $dMonad
  = SEDEL.Source.Desugar.$s$fFreshFreshMT_$s$fMonadStateT_$c>>= @ s
"SPEC/SEDEL.Source.Desugar $fMonadStateT_$cfail @ Identity _" [orphan] forall @ s
                                                                              ($dMonad :: GHC.Base.Monad
                                                                                            Data.Functor.Identity.Identity)
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$cfail @ Data.Functor.Identity.Identity
                                                      @ s
                                                      $dMonad
  = SEDEL.Source.Desugar.$s$fFreshFreshMT_$s$fMonadStateT_$cfail @ s
"SPEC/SEDEL.Source.Desugar $fShowEmbed @ SType" [orphan] forall (v :: GHC.Show.Show
                                                                        SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fShowEmbed @ SEDEL.Source.Syntax.SType
                                                     v
  = SEDEL.Source.Desugar.$s$fAlpha(,)_$s$fShowEmbed
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

