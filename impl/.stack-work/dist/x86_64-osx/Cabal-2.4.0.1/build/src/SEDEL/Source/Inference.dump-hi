
==================== FINAL INTERFACE ====================
2019-04-01 09:34:48.358491 UTC

interface sedel-0.1.0.0-AhY9khA6pZOExbzZW5SwDc:SEDEL.Source.Inference 8063
  interface hash: 82454f2b3756b5f54483300e0300ed58
  ABI hash: 707d2c085848cc300a8df3a26af98c21
  export-list hash: 43774e5dacf85e4cda6aa9b964bc2098
  orphan hash: 4d0c663a8fe3ed41486628af84e256fa
  flag hash: 5455c992fe6bc042952aad8f14bafb4c
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  SEDEL.Source.Inference.tcModule
module dependencies: SEDEL.Common SEDEL.Environment
                     SEDEL.PrettyPrint SEDEL.Source.Desugar SEDEL.Source.Syntax
                     SEDEL.Target.Syntax SEDEL.Util
package dependencies: array-0.5.3.0 async-2.2.1 base-4.12.0.0
                      base-orphans-0.8 bifunctors-5.5.3 binary-0.8.6.0
                      bytestring-0.10.8.2 comonad-5.0.4 containers-0.6.0.1
                      deepseq-1.4.4.0 distributive-0.6 exceptions-0.10.0
                      ghc-boot-th-8.6.3 ghc-prim-0.5.3 hashable-1.2.7.0
                      integer-gmp-1.0.2.0 megaparsec-7.0.4 mtl-2.2.2
                      parser-combinators-1.0.1 pretty-1.1.3.6 prettyprinter-1.2.1
                      profunctors-5.3 protolude-0.2.3 stm-2.5.0.0 tagged-0.8.6
                      template-haskell-2.14.0.0 text-1.2.3.1 transformers-0.5.5.0
                      unbound-generics-0.4.0
orphans: sedel-0.1.0.0-AhY9khA6pZOExbzZW5SwDc:SEDEL.PrettyPrint
         sedel-0.1.0.0-AhY9khA6pZOExbzZW5SwDc:SEDEL.Source.Syntax
         transformers-0.5.5.0:Control.Monad.Trans.Error
         stm-2.5.0.0:Control.Monad.STM
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.1:Data.Text.Lazy
         text-1.2.3.1:Data.Text binary-0.8.6.0:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show base-4.12.0.0:GHC.Float
         base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         bifunctors-5.5.3:Data.Bifunctor.Biff
                         bifunctors-5.5.3:Data.Bifunctor.Clown
                         bifunctors-5.5.3:Data.Bifunctor.Joker
                         bifunctors-5.5.3:Data.Bifunctor.Product
                         bifunctors-5.5.3:Data.Bifunctor.Sum
                         bifunctors-5.5.3:Data.Bifunctor.Tannen
                         containers-0.6.0.1:Data.IntMap.Internal
                         containers-0.6.0.1:Data.IntSet.Internal
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Sequence.Internal
                         containers-0.6.0.1:Data.Set.Internal containers-0.6.0.1:Data.Tree
                         ghc-boot-th-8.6.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.6.3:GHC.LanguageExtensions.Type
                         megaparsec-7.0.4:Text.Megaparsec.Error
                         megaparsec-7.0.4:Text.Megaparsec.Pos
                         megaparsec-7.0.4:Text.Megaparsec.State
                         megaparsec-7.0.4:Text.Megaparsec.Stream
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         prettyprinter-1.2.1:Data.Text.Prettyprint.Doc.Internal
                         sedel-0.1.0.0-AhY9khA6pZOExbzZW5SwDc:SEDEL.Common
                         sedel-0.1.0.0-AhY9khA6pZOExbzZW5SwDc:SEDEL.Source.Syntax
                         sedel-0.1.0.0-AhY9khA6pZOExbzZW5SwDc:SEDEL.Target.Syntax
                         tagged-0.8.6:Data.Tagged
                         template-haskell-2.14.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.1:Data.Text text-1.2.3.1:Data.Text.Lazy
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Bind
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Embed
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Ignore
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Name
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Rebind
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Rec
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Shift
import  -/  base-4.12.0.0:Data.Bifunctor 5b0364c19dacbd8c7945623465593ba3
import  -/  base-4.12.0.0:Data.Functor 22aac80fdb6c7b7f60b4aaab86afee64
import  -/  base-4.12.0.0:Data.Tuple c92a835d04b6c075a7031d4e28e53c71
import  -/  base-4.12.0.0:GHC.Base cc906f98291a1b830546e99a96674547
import  -/  ghc-prim-0.5.3:GHC.Classes e0d9c979f6368701f34fa421754d2cce
import  -/  prettyprinter-1.2.1:Data.Text.Prettyprint.Doc 37bebc045f3a0cb8e8977c181970ecaf
import  -/  prettyprinter-1.2.1:Data.Text.Prettyprint.Doc.Internal 12d379fe6b8bbcab8bffc2d86df0e72f
import  -/  protolude-0.2.3:Protolude f69a0445642f255f4ede68732259560a
import  -/  SEDEL.Environment ed88f2a0dd8c2a9eca4b994034abfc4f
  exports: e9e749407a9acf1de6b985e3dfe9ebfc
  TcMonad aede03bd985ed5eab6fd8583336c24df
  errThrow d4f105c5e1c946ff4538058aeb6593c9
  extendSourceLocation e582cf69eee35e5762f4b31e059a547a
  extendVarCtx f0ffddad7ec280792a4e23a18fb465ce
  getFreshUni 316ea113a52b1a9c69aaf9779803a133
  localCtx 90f5012859d4b472b3bea1c204d6226b
  lookupTmDef 691165d2eeacc0ad8d33b633f7809d72
  lookupVarTy 1fc33344367135de0a883f5f0120965a
import  -/  SEDEL.PrettyPrint f1989f434297afaffeb0400ac83369d8
  exports: fc8e469d5c6860b5918a12f67da268d9
  DD a2030736901739b48440eac37c3a5235
  DS 89dd69ac33df628ab327eb3e7250620a
import  -/  SEDEL.Source.Desugar 87453ac21760408db5fa9aada47619ea
  exports: bdb0b33881432c72ca9d571a98eb3419
  desugar a8076c309111dc9b3f970ae315c86de8
  desugarTmBind a5dce0a809ac52d65ca8d939f606aadf
  normalizeTmDecl aa59f6fa4972287f160738550f4bb102
import  -/  SEDEL.Source.Syntax 2df5c51304ce3d5073c843cca574c67e
  exports: d4d2fd645eff9adcf509b28019caf96b
  And 858cda1fbe6f64a52489f771e0708139
  App 2c964fefc28aabf42ed9dbe40c3accd3
  Arr 22416be279c31386e9cc95e9c9b2de68
  BoolT 9eb5ff7582ee586b5677d133bc3c5a82
  BoolV d7377f24937105ba95ef7593def4f4bf
  BotT e9fc1220c215208a25f3ef509fa1d4c0
  DForall 3b7d6b5afb57e716755254c1449edcb0
  DRec 67d90dc5830827b93ce062be4b2fee0f
  DefDecl 496120e2ede708432a09ee90bbbf5564
  Expr 76520494bd75ab62670e86072668ba13
  Join a4919cbd9c43f86a7e132f12d2cdc38f
  Label fc63c6ec9c84d81eb04bc3ecb5e488a0
  Lam 89716123ec809e2cc8bdc155ae4f4668
  Let eef6e727cd3f41679ad959a78238d920
  LitV bd5053bd7f79e6c004652065acad3370
  Meet b52f57d57eb5f073ea5cb7b7cef99237
  Merge bfed41bbda08db4fffae7c43cde3fe30
  Module 7a2313ab6449bd182db161ae191980ad
  NumT adf11e6708e5e8a7ec46f283d84a97ad
  Pos e1abba9e1a944fd21252fe9a5857484c
  Proj 6a5a97deaf11de74c15ccfb48a027d1d
  SDecl 6a20fc9eb35596ae2460813625392c86
  SRecT 9b864ff12762d70109c77b1f5eea4c3a
  SType a5fd2e9b5e852c36afadad4c1a615a65
  SType 76520494bd75ab62670e86072668ba13
  Scheme 76520494bd75ab62670e86072668ba13
  TUni 9eb22e5d95f0de04502f16ea4eb97bf9
  TVar 3e45bba34d2b60ad4b6a831b8a2e52f8
  TmBind 76520494bd75ab62670e86072668ba13
  TmName 76520494bd75ab62670e86072668ba13
  Top 072bc63b13d03508f9113d1a45bc6153
  TopT 1b95963f14ca91731abc40c7b31bb3cf
  TyName 76520494bd75ab62670e86072668ba13
  Var 6d082d2f0a5af10d8ab316bafa598eed
  mainExpr 7a2313ab6449bd182db161ae191980ad
  moduleEntries 7a2313ab6449bd182db161ae191980ad
import  -/  SEDEL.Target.Syntax 2589141e2792ef4fd114aa83be20e48d
  exports: b36744e56246d62dcae7b00d023dfc0b
  UApp 719a706229ae3c802cf6c86cb22237ec
  UBoolV 5954c5bc63f985d11a93ad131f6f73c6
  UExpr e143c1a7574a05400d7144cf1b16fbbb
  ULam 8c4c86bcc2abe90c16c3fa849f7fdf12
  ULitV fe225ea27707f771720586ed0af72607
  UName e143c1a7574a05400d7144cf1b16fbbb
  UPair cece624353823557d79018d11c09a41b
  UUnit dfd44aa113b0d584cdd6e71d429baf45
  UVar 9b01596724234c0181c1c174186fd745
  elet b9d585153492f98704d2958f15b2982f
import  -/  SEDEL.Util 852fd4a639e7732ead5b4498cf00b60a
  exports: 3deb26de07e49528c70b6f9f7e5d21d6
  translType 6fa5b16cfceb5a2dd039239934103b7c
  translate d0b236b1da26ed7519e9598588769645
import  -/  unbound-generics-0.4.0:Unbound.Generics.LocallyNameless 36704d4dbfb3fb22f46cde363ae796f2
import  -/  unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Embed f74cff3aea20e9a2f5e6bfc539a9689b
import  -/  unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Fresh e0f8d49fe8e0f78dfcabb34436892778
import  -/  unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Name 81d6e7baa0bd0880e550478df477614a
import  -/  unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Operations d0c219408974b95413509bf76023577c
259917dc6d2111ba32978e2618a0f207
  $s$fAlpha(,)_$s$fAlphaEmbed ::
    Unbound.Generics.LocallyNameless.Alpha.Alpha
      (Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.Scheme)
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Embed.Embed
                       SEDEL.Source.Syntax.Scheme)
                  SEDEL.Source.Inference.$s$fAlpha(,)_$s$fShowEmbed
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.Scheme)
                     (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Source.Syntax.Scheme) ->
                   SEDEL.Source.Syntax.$fAlphaScheme_$caeq'
                     (case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                      Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                        Unbound.Generics.LocallyNameless.Alpha.Term
                        ds3 })
                     ds
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Source.Syntax.Scheme>_R)
                     ds1
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Source.Syntax.Scheme>_R))
                  (Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cfvAny'
                     @ SEDEL.Source.Syntax.Scheme
                     SEDEL.Source.Syntax.$fAlphaScheme)
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (b :: Unbound.Generics.LocallyNameless.Alpha.NamePatFind)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.Scheme) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed6
                          @ SEDEL.Source.Syntax.Scheme
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> (SEDEL.Source.Syntax.$fAlphaScheme_$cclose
                           (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                              Unbound.Generics.LocallyNameless.Alpha.Term
                              ds2)
                           b
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.Scheme>_R))
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <SEDEL.Source.Syntax.Scheme>_R)) } })
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (b :: Unbound.Generics.LocallyNameless.Alpha.NthPatFind)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.Scheme) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed5
                          @ SEDEL.Source.Syntax.Scheme
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> (SEDEL.Source.Syntax.$fAlphaScheme_$copen
                           (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                              Unbound.Generics.LocallyNameless.Alpha.Term
                              ds2)
                           b
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.Scheme>_R))
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <SEDEL.Source.Syntax.Scheme>_R)) } })
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.Scheme) ->
                   case (SEDEL.Source.Syntax.$fAlphaScheme_$cisTerm
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.Scheme>_R))
                          `cast`
                        (Data.Semigroup.Internal.N:All[0]) of wild {
                     GHC.Types.False
                     -> (GHC.Maybe.Nothing
                           @ [Unbound.Generics.LocallyNameless.Name.AnyName])
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                  <Unbound.Generics.LocallyNameless.Name.AnyName>_R))
                     GHC.Types.True
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed4
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                  <Unbound.Generics.LocallyNameless.Name.AnyName>_R)) })
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.Scheme) ->
                   GHC.Types.False)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      SEDEL.Source.Syntax.Scheme>_R
                   ->_R Sym (Data.Semigroup.Internal.N:All[0]))
                  SEDEL.Source.Syntax.$fAlphaScheme_$cisTerm
                    `cast`
                  (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                            <SEDEL.Source.Syntax.Scheme>_R)
                   ->_R Data.Semigroup.Internal.N:All[0])
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.Scheme) ->
                   Data.Either.Left
                     @ GHC.Integer.Type.Integer
                     @ Unbound.Generics.LocallyNameless.Name.AnyName)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      SEDEL.Source.Syntax.Scheme>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Alpha.N:NthPatFind[0]))
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.Scheme) ->
                   Unbound.Generics.LocallyNameless.Alpha.$fAlpha()2)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      SEDEL.Source.Syntax.Scheme>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Alpha.N:NamePatFind[0]))
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (perm :: Unbound.Generics.PermM.Perm
                                Unbound.Generics.LocallyNameless.Name.AnyName)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.Scheme) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term -> ds
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> (SEDEL.Source.Syntax.$fAlphaExpr_$cswaps'
                           (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                              Unbound.Generics.LocallyNameless.Alpha.Term
                              ds2)
                           perm
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.Scheme>_R))
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <SEDEL.Source.Syntax.Scheme>_R)) } })
                  (\ @ m :: * -> *
                     @ b
                     ($dLFresh :: Unbound.Generics.LocallyNameless.LFresh.LFresh m) ->
                   Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed2
                     @ b
                     @ m
                     @ SEDEL.Source.Syntax.Scheme)
                  (\ @ m :: * -> *
                     ($dFresh :: Unbound.Generics.LocallyNameless.Fresh.Fresh m)
                     (eta1 :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (eta2 :: Unbound.Generics.LocallyNameless.Embed.Embed
                                SEDEL.Source.Syntax.Scheme) ->
                   case eta1 of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed1
                          @ SEDEL.Source.Syntax.Scheme
                          @ m
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> GHC.Base.return
                          @ m
                          (Unbound.Generics.LocallyNameless.Fresh.$p1Fresh @ m $dFresh)
                          @ (Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Source.Syntax.Scheme,
                             Unbound.Generics.PermM.Perm
                               Unbound.Generics.LocallyNameless.Name.AnyName)
                          (eta2,
                           (Data.Map.Internal.Tip
                              @ Unbound.Generics.LocallyNameless.Name.AnyName
                              @ Unbound.Generics.LocallyNameless.Name.AnyName)
                             `cast`
                           (Sym (Unbound.Generics.PermM.N:Perm[0]
                                     <Unbound.Generics.LocallyNameless.Name.AnyName>_N))) } })
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.Scheme)
                     (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Source.Syntax.Scheme) ->
                   SEDEL.Source.Syntax.$fAlphaScheme_$cacompare'
                     (case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                      Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                        Unbound.Generics.LocallyNameless.Alpha.Term
                        ds3 })
                     ds
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Source.Syntax.Scheme>_R)
                     ds1
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Source.Syntax.Scheme>_R)) -}
83f30b362e9f8b8bd932ce60e15f6898
  $s$fAlpha(,)_$s$fShowEmbed ::
    GHC.Show.Show
      (Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.Scheme)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Embed.Embed
                       SEDEL.Source.Syntax.Scheme)
                  (Unbound.Generics.LocallyNameless.Embed.$fShowEmbed_$cshowsPrec
                     @ SEDEL.Source.Syntax.Scheme
                     SEDEL.Source.Syntax.$fShowScheme)
                  (\ (x :: Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Source.Syntax.Scheme) ->
                   GHC.CString.unpackAppendCString#
                     Unbound.Generics.LocallyNameless.Embed.$fShowEmbed3
                     (SEDEL.Source.Syntax.$fShowScheme_$cshowsPrec
                        Unbound.Generics.LocallyNameless.Embed.$fShowEmbed2
                        x `cast`
                        (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                             <SEDEL.Source.Syntax.Scheme>_R)
                        Unbound.Generics.LocallyNameless.Embed.$fShowEmbed4))
                  (Unbound.Generics.LocallyNameless.Embed.$fShowEmbed_$cshowList
                     @ SEDEL.Source.Syntax.Scheme
                     SEDEL.Source.Syntax.$fShowScheme) -}
50492ae2a69487c508ff5e3ea46e1ab9
  $s$fAlphaEmbed_$cacompare' ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.Scheme
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.Scheme
    -> GHC.Types.Ordering
  {- Arity: 3, Strictness: <L,1*U(A,U)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.Scheme)
                   (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Source.Syntax.Scheme) ->
                 SEDEL.Source.Syntax.$fAlphaScheme_$cacompare'
                   (case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                      Unbound.Generics.LocallyNameless.Alpha.Term
                      ds3 })
                   ds
                     `cast`
                   (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                        <SEDEL.Source.Syntax.Scheme>_R)
                   ds1
                     `cast`
                   (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                        <SEDEL.Source.Syntax.Scheme>_R)) -}
300c33615f91b965f6c8339de7bbb88a
  $s$fAlphaEmbed_$caeq' ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.Scheme
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.Scheme
    -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,1*U(A,U)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.Scheme)
                   (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Source.Syntax.Scheme) ->
                 SEDEL.Source.Syntax.$fAlphaScheme_$caeq'
                   (case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                      Unbound.Generics.LocallyNameless.Alpha.Term
                      ds3 })
                   ds
                     `cast`
                   (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                        <SEDEL.Source.Syntax.Scheme>_R)
                   ds1
                     `cast`
                   (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                        <SEDEL.Source.Syntax.Scheme>_R)) -}
cf78042935181cc32cbdfe61307a65c2
  $s$fAlphaEmbed_$cclose ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Alpha.NamePatFind
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.Scheme
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.Scheme
  {- Arity: 3, Strictness: <S(SS),1*U(U,U)><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (b :: Unbound.Generics.LocallyNameless.Alpha.NamePatFind)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.Scheme) ->
                 case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                 case ds1 of wild1 {
                   Unbound.Generics.LocallyNameless.Alpha.Term
                   -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed6
                        @ SEDEL.Source.Syntax.Scheme
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> (SEDEL.Source.Syntax.$fAlphaScheme_$cclose
                         (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                            Unbound.Generics.LocallyNameless.Alpha.Term
                            ds2)
                         b
                         ds
                           `cast`
                         (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                              <SEDEL.Source.Syntax.Scheme>_R))
                        `cast`
                      (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.Scheme>_R)) } }) -}
1c740094b470cf2fdebd8293b2240b78
  $s$fAlphaEmbed_$cfreshen' ::
    Unbound.Generics.LocallyNameless.Fresh.Fresh m =>
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.Scheme
    -> m (Unbound.Generics.LocallyNameless.Embed.Embed
            SEDEL.Source.Syntax.Scheme,
          Unbound.Generics.PermM.Perm
            Unbound.Generics.LocallyNameless.Name.AnyName)
  {- Arity: 3,
     Strictness: <S(S(LLLC(S)L)L),1*U(1*U(A,A,A,1*C1(U),A),A)><S(SL),1*U(U,A)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   ($dFresh :: Unbound.Generics.LocallyNameless.Fresh.Fresh m)
                   (eta1 :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (eta2 :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.Scheme) ->
                 case eta1 of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                 case ds1 of wild1 {
                   Unbound.Generics.LocallyNameless.Alpha.Term
                   -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed1
                        @ SEDEL.Source.Syntax.Scheme
                        @ m
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> GHC.Base.return
                        @ m
                        (Unbound.Generics.LocallyNameless.Fresh.$p1Fresh @ m $dFresh)
                        @ (Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Source.Syntax.Scheme,
                           Unbound.Generics.PermM.Perm
                             Unbound.Generics.LocallyNameless.Name.AnyName)
                        (eta2,
                         (Data.Map.Internal.Tip
                            @ Unbound.Generics.LocallyNameless.Name.AnyName
                            @ Unbound.Generics.LocallyNameless.Name.AnyName)
                           `cast`
                         (Sym (Unbound.Generics.PermM.N:Perm[0]
                                   <Unbound.Generics.LocallyNameless.Name.AnyName>_N))) } }) -}
702a5c31a6e47fcf93d653cd65a9b6e8
  $s$fAlphaEmbed_$cisPat ::
    Unbound.Generics.LocallyNameless.Embed.Embed
      SEDEL.Source.Syntax.Scheme
    -> Unbound.Generics.LocallyNameless.Alpha.DisjointSet
         Unbound.Generics.LocallyNameless.Name.AnyName
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.Scheme) ->
                 case (SEDEL.Source.Syntax.$fAlphaScheme_$cisTerm
                         ds
                           `cast`
                         (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                              <SEDEL.Source.Syntax.Scheme>_R))
                        `cast`
                      (Data.Semigroup.Internal.N:All[0]) of wild {
                   GHC.Types.False
                   -> (GHC.Maybe.Nothing
                         @ [Unbound.Generics.LocallyNameless.Name.AnyName])
                        `cast`
                      (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                <Unbound.Generics.LocallyNameless.Name.AnyName>_R))
                   GHC.Types.True
                   -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed4
                        `cast`
                      (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                <Unbound.Generics.LocallyNameless.Name.AnyName>_R)) }) -}
4e4feaf7a5b16e713982bad85faa392b
  $s$fAlphaEmbed_$copen ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Alpha.NthPatFind
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.Scheme
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.Scheme
  {- Arity: 3, Strictness: <S(SS),1*U(U,U)><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (b :: Unbound.Generics.LocallyNameless.Alpha.NthPatFind)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.Scheme) ->
                 case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                 case ds1 of wild1 {
                   Unbound.Generics.LocallyNameless.Alpha.Term
                   -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed5
                        @ SEDEL.Source.Syntax.Scheme
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> (SEDEL.Source.Syntax.$fAlphaScheme_$copen
                         (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                            Unbound.Generics.LocallyNameless.Alpha.Term
                            ds2)
                         b
                         ds
                           `cast`
                         (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                              <SEDEL.Source.Syntax.Scheme>_R))
                        `cast`
                      (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.Scheme>_R)) } }) -}
599910b2fa7a9ba8f918a3f7f8187f39
  $s$fAlphaEmbed_$cswaps' ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.PermM.Perm
         Unbound.Generics.LocallyNameless.Name.AnyName
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.Scheme
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.Scheme
  {- Arity: 3, Strictness: <S(SS),1*U(U,U)><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (perm :: Unbound.Generics.PermM.Perm
                              Unbound.Generics.LocallyNameless.Name.AnyName)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.Scheme) ->
                 case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                 case ds1 of wild1 {
                   Unbound.Generics.LocallyNameless.Alpha.Term -> ds
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> (SEDEL.Source.Syntax.$fAlphaExpr_$cswaps'
                         (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                            Unbound.Generics.LocallyNameless.Alpha.Term
                            ds2)
                         perm
                         ds
                           `cast`
                         (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                              <SEDEL.Source.Syntax.Scheme>_R))
                        `cast`
                      (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.Scheme>_R)) } }) -}
db8828ffd4a2dcd5bfa124801ed8d92b
  $s$fApplicativeExceptT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
                  (SEDEL.Source.Inference.$s$fApplicativeExceptT_$s$fFunctorExceptT
                     @ e)
                  (SEDEL.Source.Inference.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure
                     @ e)
                  (Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                     @ GHC.Types.IO
                     @ e
                     GHC.Base.$fFunctorIO
                     GHC.Base.$fMonadIO)
                  (\ @ a
                     @ b
                     @ c
                     (f1 :: a -> b -> c)
                     (x :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a) ->
                   Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                     @ GHC.Types.IO
                     @ e
                     GHC.Base.$fFunctorIO
                     GHC.Base.$fMonadIO
                     @ b
                     @ c
                     (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                      case x `cast`
                           (Control.Monad.Trans.Except.N:ExceptT[0]
                                <e>_N <GHC.Types.IO>_R <a>_N ; GHC.Types.N:IO[0]
                                                                   <Data.Either.Either e a>_R)
                             s of ds { (#,#) ipv ipv1 ->
                      (# ipv,
                         Data.Either.$fApplicativeEither_$cfmap
                           @ e
                           @ a
                           @ (b -> c)
                           f1
                           ipv1 #) })
                       `cast`
                     (Sym (GHC.Types.N:IO[0]
                               <Data.Either.Either
                                  e (b -> c)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                            <e>_N <GHC.Types.IO>_R <b -> c>_N)))
                  (SEDEL.Source.Inference.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$c*>
                     @ e)
                  (\ @ a
                     @ b
                     (x :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a) ->
                   Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                     @ GHC.Types.IO
                     @ e
                     GHC.Base.$fFunctorIO
                     GHC.Base.$fMonadIO
                     @ b
                     @ a
                     (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                      case x `cast`
                           (Control.Monad.Trans.Except.N:ExceptT[0]
                                <e>_N <GHC.Types.IO>_R <a>_N ; GHC.Types.N:IO[0]
                                                                   <Data.Either.Either e a>_R)
                             s of ds { (#,#) ipv ipv1 ->
                      (# ipv,
                         Control.Monad.Trans.Except.$fApplicativeExceptT1
                           @ e
                           @ b
                           @ a
                           ipv1 #) })
                       `cast`
                     (Sym (GHC.Types.N:IO[0]
                               <Data.Either.Either
                                  e (b -> a)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                            <e>_N <GHC.Types.IO>_R <b -> a>_N))) -}
3446d66616eb10f2569677ee22e0d4c5
  $s$fApplicativeExceptT_$c<*>1 ::
    Control.Monad.Trans.Except.ExceptT e GHC.Types.IO (a -> b)
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Either.Either e b #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S(SS)),1*C1(U(U,1*U))><L,1*C1(U(U,1*U))><S,U>,
     Unfolding: (\ @ e
                   @ a
                   @ b
                   (w10 :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO (a -> b))
                   (w11 :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w10
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <GHC.Types.IO>_R <a -> b>_N ; GHC.Types.N:IO[0]
                                                                   <Data.Either.Either
                                                                      e (a -> b)>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   Data.Either.Left e1 -> (# ipv, Data.Either.Left @ e @ b e1 #)
                   Data.Either.Right k
                   -> case w11
                             `cast`
                           (Control.Monad.Trans.Except.N:ExceptT[0]
                                <e>_N <GHC.Types.IO>_R <a>_N ; GHC.Types.N:IO[0]
                                                                   <Data.Either.Either e a>_R)
                             ipv of ds2 { (#,#) ipv2 ipv3 ->
                      case ipv3 of wild1 {
                        Data.Either.Left e1 -> (# ipv2, Data.Either.Left @ e @ b e1 #)
                        Data.Either.Right x
                        -> (# ipv2, Data.Either.Right @ e @ b (k x) #) } } } }) -}
21dcb2bbb16c9899a8ae96b2c4f9822a
  $s$fApplicativeExceptT_$s$fApplicativeExceptT_$c*> ::
    Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S(SS)),1*C1(U(U,1*U))><L,1*C1(U(U,U))><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a)
                   (k :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case m1
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <GHC.Types.IO>_R <a>_N ; GHC.Types.N:IO[0]
                                                              <Data.Either.Either e a>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   Data.Either.Left e1 -> (# ipv, Data.Either.Left @ e @ b e1 #)
                   Data.Either.Right x
                   -> k `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <GHC.Types.IO>_R <b>_N ; GHC.Types.N:IO[0]
                                                              <Data.Either.Either e b>_R)
                        ipv } })
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a>_R
                 ->_R <Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <Data.Either.Either
                                  e b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                     <e>_N <GHC.Types.IO>_R <b>_N)) -}
87b49861f05dd29ad76e8e3bf0f955d4
  $s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure ::
    a -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ e @ a (a1 :: a) (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 (# s, Data.Either.Right @ e @ a a1 #))
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N).
                 <a>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <Data.Either.Either
                                  e a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                     <e>_N <GHC.Types.IO>_R <a>_N)) -}
e2595e6d501950aaa9d35acbabb40d6c
  $s$fApplicativeExceptT_$s$fFunctorExceptT ::
    GHC.Base.Functor
      (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
                  (Control.Monad.Trans.Except.$fFunctorExceptT_$cfmap
                     @ GHC.Types.IO
                     @ e
                     GHC.Base.$fFunctorIO)
                  (Control.Monad.Trans.Except.$fFunctorExceptT_$c<$
                     @ GHC.Types.IO
                     @ e
                     GHC.Base.$fFunctorIO) -}
5da15538e72196551ddad01479507bd4
  $s$fApplicativeFreshMT ::
    GHC.Base.Applicative
      (Unbound.Generics.LocallyNameless.Fresh.FreshMT
         (Control.Monad.Trans.Reader.ReaderT
            SEDEL.Environment.Ctx
            (Control.Monad.Trans.Except.ExceptT
               SEDEL.Environment.Err GHC.Types.IO)))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Fresh.FreshMT
                       (Control.Monad.Trans.Reader.ReaderT
                          SEDEL.Environment.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             SEDEL.Environment.Err GHC.Types.IO)))
                  SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorFreshMT
                  (\ @ a (eta1 :: a) (eta2 :: GHC.Integer.Type.Integer) ->
                   let {
                     m1 :: GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                 Data.Either.Either
                                   SEDEL.Environment.Err (a, GHC.Integer.Type.Integer) #)
                       {- Arity: 1 -}
                     = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                       (# s,
                          Data.Either.Right
                            @ SEDEL.Environment.Err
                            @ (a, GHC.Integer.Type.Integer)
                            (eta1, eta2) #)
                   } in
                   (\ (ds :: SEDEL.Environment.Ctx) -> m1)
                     `cast`
                   ((<SEDEL.Environment.Ctx>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <Data.Either.Either
                                      SEDEL.Environment.Err
                                      (a,
                                       GHC.Integer.Type.Integer)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <SEDEL.Environment.Err>_N
                                                                                <GHC.Types.IO>_R
                                                                                <(a,
                                                                                  GHC.Integer.Type.Integer)>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                            <*>_N
                                                                                                                            <SEDEL.Environment.Ctx>_R
                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                               SEDEL.Environment.Err
                                                                                                                               GHC.Types.IO>_R
                                                                                                                            <(a,
                                                                                                                              GHC.Integer.Type.Integer)>_N)))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Reader.ReaderT
                                    SEDEL.Environment.Ctx
                                    (Control.Monad.Trans.Except.ExceptT
                                       SEDEL.Environment.Err GHC.Types.IO)>_R
                                 <a>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                       SEDEL.Environment.Ctx
                                                                                                       (Control.Monad.Trans.Except.ExceptT
                                                                                                          SEDEL.Environment.Err
                                                                                                          GHC.Types.IO)>_N <a>_N)
                  (Unbound.Generics.LocallyNameless.Fresh.$fApplicativeFreshMT4
                     @ (Control.Monad.Trans.Reader.ReaderT
                          SEDEL.Environment.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             SEDEL.Environment.Err GHC.Types.IO))
                     (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fMonadReaderT
                        @ SEDEL.Environment.Ctx))
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                SEDEL.Environment.Ctx
                                                                                (Control.Monad.Trans.Except.ExceptT
                                                                                   SEDEL.Environment.Err
                                                                                   GHC.Types.IO)>_N <a
                                                                                                     -> b>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                     SEDEL.Environment.Ctx
                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                        SEDEL.Environment.Err
                                                                                        GHC.Types.IO)>_N <a>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Reader.ReaderT
                                    SEDEL.Environment.Ctx
                                    (Control.Monad.Trans.Except.ExceptT
                                       SEDEL.Environment.Err GHC.Types.IO)>_R
                                 <b>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                       SEDEL.Environment.Ctx
                                                                                                       (Control.Monad.Trans.Except.ExceptT
                                                                                                          SEDEL.Environment.Err
                                                                                                          GHC.Types.IO)>_N <b>_N)
                  (\ @ a
                     @ b
                     @ c
                     (eta1 :: a -> b -> c)
                     (eta2 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer
                                (Control.Monad.Trans.Reader.ReaderT
                                   SEDEL.Environment.Ctx
                                   (Control.Monad.Trans.Except.ExceptT
                                      SEDEL.Environment.Err GHC.Types.IO))
                                a)
                     (eta3 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer
                                (Control.Monad.Trans.Reader.ReaderT
                                   SEDEL.Environment.Ctx
                                   (Control.Monad.Trans.Except.ExceptT
                                      SEDEL.Environment.Err GHC.Types.IO))
                                b)
                     (eta4 :: GHC.Integer.Type.Integer) ->
                   Control.Monad.Trans.State.Lazy.$w$cliftA2
                     @ (Control.Monad.Trans.Reader.ReaderT
                          SEDEL.Environment.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             SEDEL.Environment.Err GHC.Types.IO))
                     @ GHC.Integer.Type.Integer
                     (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorReaderT
                        @ SEDEL.Environment.Ctx)
                     (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fMonadReaderT_$c>>=
                        @ SEDEL.Environment.Ctx)
                     (\ @ a1 (eta5 :: a1) ->
                      let {
                        m1 :: GHC.Prim.State# GHC.Prim.RealWorld
                              -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                    Data.Either.Either SEDEL.Environment.Err a1 #)
                          {- Arity: 1 -}
                        = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                          (# s, Data.Either.Right @ SEDEL.Environment.Err @ a1 eta5 #)
                      } in
                      (\ (ds :: SEDEL.Environment.Ctx) -> m1)
                        `cast`
                      ((<SEDEL.Environment.Ctx>_R
                        ->_R Sym (GHC.Types.N:IO[0]
                                      <Data.Either.Either
                                         SEDEL.Environment.Err
                                         a1>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                           <SEDEL.Environment.Err>_N
                                                           <GHC.Types.IO>_R
                                                           <a1>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                               <*>_N
                                                                               <SEDEL.Environment.Ctx>_R
                                                                               <Control.Monad.Trans.Except.ExceptT
                                                                                  SEDEL.Environment.Err
                                                                                  GHC.Types.IO>_R
                                                                               <a1>_N)))
                     @ a
                     @ b
                     @ c
                     eta1
                     eta2
                     eta3
                     eta4)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                     SEDEL.Environment.Ctx
                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                        SEDEL.Environment.Err
                                                                                        GHC.Types.IO)>_N <a>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                     SEDEL.Environment.Ctx
                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                        SEDEL.Environment.Err
                                                                                        GHC.Types.IO)>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Reader.ReaderT
                                    SEDEL.Environment.Ctx
                                    (Control.Monad.Trans.Except.ExceptT
                                       SEDEL.Environment.Err GHC.Types.IO)>_R
                                 <c>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                       SEDEL.Environment.Ctx
                                                                                                       (Control.Monad.Trans.Except.ExceptT
                                                                                                          SEDEL.Environment.Err
                                                                                                          GHC.Types.IO)>_N <c>_N)
                  (\ @ a
                     @ b
                     (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer
                                (Control.Monad.Trans.Reader.ReaderT
                                   SEDEL.Environment.Ctx
                                   (Control.Monad.Trans.Except.ExceptT
                                      SEDEL.Environment.Err GHC.Types.IO))
                                a)
                     (eta2 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer
                                (Control.Monad.Trans.Reader.ReaderT
                                   SEDEL.Environment.Ctx
                                   (Control.Monad.Trans.Except.ExceptT
                                      SEDEL.Environment.Err GHC.Types.IO))
                                b)
                     (eta3 :: GHC.Integer.Type.Integer) ->
                   let {
                     m1 :: Control.Monad.Trans.Reader.ReaderT
                             SEDEL.Environment.Ctx
                             (Control.Monad.Trans.Except.ExceptT
                                SEDEL.Environment.Err GHC.Types.IO)
                             (a, GHC.Integer.Type.Integer)
                     = eta1
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <GHC.Integer.Type.Integer>_N
                            <Control.Monad.Trans.Reader.ReaderT
                               SEDEL.Environment.Ctx
                               (Control.Monad.Trans.Except.ExceptT
                                  SEDEL.Environment.Err GHC.Types.IO)>_R
                            <a>_N)
                         eta3
                   } in
                   (\ (r1 :: SEDEL.Environment.Ctx)
                      (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                    case (m1
                            `cast`
                          (Control.Monad.Trans.Reader.N:ReaderT[0]
                               <*>_N
                               <SEDEL.Environment.Ctx>_R
                               <Control.Monad.Trans.Except.ExceptT
                                  SEDEL.Environment.Err GHC.Types.IO>_R
                               <(a, GHC.Integer.Type.Integer)>_N)
                            r1)
                           `cast`
                         (Control.Monad.Trans.Except.N:ExceptT[0]
                              <SEDEL.Environment.Err>_N
                              <GHC.Types.IO>_R
                              <(a, GHC.Integer.Type.Integer)>_N ; GHC.Types.N:IO[0]
                                                                      <Data.Either.Either
                                                                         SEDEL.Environment.Err
                                                                         (a,
                                                                          GHC.Integer.Type.Integer)>_R)
                           s of ds1 { (#,#) ipv ipv1 ->
                    case ipv1 of wild {
                      Data.Either.Left e1
                      -> (# ipv,
                            Data.Either.Left
                              @ SEDEL.Environment.Err
                              @ (b, GHC.Integer.Type.Integer)
                              e1 #)
                      Data.Either.Right x
                      -> ((eta2
                             `cast`
                           (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                <GHC.Integer.Type.Integer>_N
                                <Control.Monad.Trans.Reader.ReaderT
                                   SEDEL.Environment.Ctx
                                   (Control.Monad.Trans.Except.ExceptT
                                      SEDEL.Environment.Err GHC.Types.IO)>_R
                                <b>_N)
                             (case x of wild1 { (,) a1 s' -> s' }))
                            `cast`
                          (Control.Monad.Trans.Reader.N:ReaderT[0]
                               <*>_N
                               <SEDEL.Environment.Ctx>_R
                               <Control.Monad.Trans.Except.ExceptT
                                  SEDEL.Environment.Err GHC.Types.IO>_R
                               <(b, GHC.Integer.Type.Integer)>_N)
                            r1)
                           `cast`
                         (Control.Monad.Trans.Except.N:ExceptT[0]
                              <SEDEL.Environment.Err>_N
                              <GHC.Types.IO>_R
                              <(b, GHC.Integer.Type.Integer)>_N ; GHC.Types.N:IO[0]
                                                                      <Data.Either.Either
                                                                         SEDEL.Environment.Err
                                                                         (b,
                                                                          GHC.Integer.Type.Integer)>_R)
                           ipv } })
                     `cast`
                   ((<SEDEL.Environment.Ctx>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <Data.Either.Either
                                      SEDEL.Environment.Err
                                      (b,
                                       GHC.Integer.Type.Integer)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <SEDEL.Environment.Err>_N
                                                                                <GHC.Types.IO>_R
                                                                                <(b,
                                                                                  GHC.Integer.Type.Integer)>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                            <*>_N
                                                                                                                            <SEDEL.Environment.Ctx>_R
                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                               SEDEL.Environment.Err
                                                                                                                               GHC.Types.IO>_R
                                                                                                                            <(b,
                                                                                                                              GHC.Integer.Type.Integer)>_N)))
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                SEDEL.Environment.Ctx
                                                                                (Control.Monad.Trans.Except.ExceptT
                                                                                   SEDEL.Environment.Err
                                                                                   GHC.Types.IO)>_N <a>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                     SEDEL.Environment.Ctx
                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                        SEDEL.Environment.Err
                                                                                        GHC.Types.IO)>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Reader.ReaderT
                                    SEDEL.Environment.Ctx
                                    (Control.Monad.Trans.Except.ExceptT
                                       SEDEL.Environment.Err GHC.Types.IO)>_R
                                 <b>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                       SEDEL.Environment.Ctx
                                                                                                       (Control.Monad.Trans.Except.ExceptT
                                                                                                          SEDEL.Environment.Err
                                                                                                          GHC.Types.IO)>_N <b>_N)
                  (\ @ a
                     @ b
                     (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer
                                (Control.Monad.Trans.Reader.ReaderT
                                   SEDEL.Environment.Ctx
                                   (Control.Monad.Trans.Except.ExceptT
                                      SEDEL.Environment.Err GHC.Types.IO))
                                a)
                     (eta2 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer
                                (Control.Monad.Trans.Reader.ReaderT
                                   SEDEL.Environment.Ctx
                                   (Control.Monad.Trans.Except.ExceptT
                                      SEDEL.Environment.Err GHC.Types.IO))
                                b)
                     (eta3 :: GHC.Integer.Type.Integer) ->
                   Control.Monad.Trans.State.Lazy.$w$cliftA2
                     @ (Control.Monad.Trans.Reader.ReaderT
                          SEDEL.Environment.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             SEDEL.Environment.Err GHC.Types.IO))
                     @ GHC.Integer.Type.Integer
                     (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorReaderT
                        @ SEDEL.Environment.Ctx)
                     (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fMonadReaderT_$c>>=
                        @ SEDEL.Environment.Ctx)
                     (\ @ a1 (eta4 :: a1) ->
                      let {
                        m1 :: GHC.Prim.State# GHC.Prim.RealWorld
                              -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                    Data.Either.Either SEDEL.Environment.Err a1 #)
                          {- Arity: 1 -}
                        = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                          (# s, Data.Either.Right @ SEDEL.Environment.Err @ a1 eta4 #)
                      } in
                      (\ (ds :: SEDEL.Environment.Ctx) -> m1)
                        `cast`
                      ((<SEDEL.Environment.Ctx>_R
                        ->_R Sym (GHC.Types.N:IO[0]
                                      <Data.Either.Either
                                         SEDEL.Environment.Err
                                         a1>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                           <SEDEL.Environment.Err>_N
                                                           <GHC.Types.IO>_R
                                                           <a1>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                               <*>_N
                                                                               <SEDEL.Environment.Ctx>_R
                                                                               <Control.Monad.Trans.Except.ExceptT
                                                                                  SEDEL.Environment.Err
                                                                                  GHC.Types.IO>_R
                                                                               <a1>_N)))
                     @ a
                     @ b
                     @ a
                     (GHC.Base.const @ a @ b)
                     eta1
                     eta2
                     eta3)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                SEDEL.Environment.Ctx
                                                                                (Control.Monad.Trans.Except.ExceptT
                                                                                   SEDEL.Environment.Err
                                                                                   GHC.Types.IO)>_N <a>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                     SEDEL.Environment.Ctx
                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                        SEDEL.Environment.Err
                                                                                        GHC.Types.IO)>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Reader.ReaderT
                                    SEDEL.Environment.Ctx
                                    (Control.Monad.Trans.Except.ExceptT
                                       SEDEL.Environment.Err GHC.Types.IO)>_R
                                 <a>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                       SEDEL.Environment.Ctx
                                                                                                       (Control.Monad.Trans.Except.ExceptT
                                                                                                          SEDEL.Environment.Err
                                                                                                          GHC.Types.IO)>_N <a>_N) -}
4db0f1e5d6ad8be2c260004f56e8eaff
  $s$fApplicativeFreshMT_$s$fApplicativeReaderT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ r.
                  @ (Control.Monad.Trans.Reader.ReaderT
                       r
                       (Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO))
                  (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorReaderT
                     @ r)
                  (\ @ a (x :: a) ->
                   let {
                     m1 :: GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                 Data.Either.Either SEDEL.Environment.Err a #)
                       {- Arity: 1 -}
                     = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                       (# s, Data.Either.Right @ SEDEL.Environment.Err @ a x #)
                   } in
                   (\ (ds :: r) -> m1)
                     `cast`
                   ((<r>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <Data.Either.Either
                                      SEDEL.Environment.Err
                                      a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                       <SEDEL.Environment.Err>_N
                                                       <GHC.Types.IO>_R
                                                       <a>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                          <*>_N
                                                                          <r>_R
                                                                          <Control.Monad.Trans.Except.ExceptT
                                                                             SEDEL.Environment.Err
                                                                             GHC.Types.IO>_R
                                                                          <a>_N)))
                  (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fApplicativeReaderT_$c<*>
                     @ r)
                  (Control.Monad.Trans.Reader.$fApplicativeReaderT_$cliftA2
                     @ (Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO)
                     @ r
                     (SEDEL.Source.Inference.$s$fApplicativeExceptT
                        @ SEDEL.Environment.Err))
                  (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fApplicativeReaderT_$c*>
                     @ r)
                  (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fApplicativeReaderT_$c<*
                     @ r) -}
609f47b94c8020982c89f54a7c9a3362
  $s$fApplicativeFreshMT_$s$fApplicativeReaderT_$c*> ::
    Control.Monad.Trans.Reader.ReaderT
      r
      (Control.Monad.Trans.Except.ExceptT
         SEDEL.Environment.Err GHC.Types.IO)
      a
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         b
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(SS))),1*C1(C1(U(U,1*U)))><L,1*C1(C1(U(U,U)))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (u :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              SEDEL.Environment.Err GHC.Types.IO)
                           a)
                   (v :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              SEDEL.Environment.Err GHC.Types.IO)
                           b)
                   (r1 :: r)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (u `cast`
                       (Control.Monad.Trans.Reader.N:ReaderT[0]
                            <*>_N
                            <r>_R
                            <Control.Monad.Trans.Except.ExceptT
                               SEDEL.Environment.Err GHC.Types.IO>_R
                            <a>_N)
                         r1)
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <SEDEL.Environment.Err>_N
                           <GHC.Types.IO>_R
                           <a>_N ; GHC.Types.N:IO[0]
                                       <Data.Either.Either SEDEL.Environment.Err a>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   Data.Either.Left e1
                   -> (# ipv, Data.Either.Left @ SEDEL.Environment.Err @ b e1 #)
                   Data.Either.Right x
                   -> (v `cast`
                       (Control.Monad.Trans.Reader.N:ReaderT[0]
                            <*>_N
                            <r>_R
                            <Control.Monad.Trans.Except.ExceptT
                               SEDEL.Environment.Err GHC.Types.IO>_R
                            <b>_N)
                         r1)
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <SEDEL.Environment.Err>_N
                           <GHC.Types.IO>_R
                           <b>_N ; GHC.Types.N:IO[0]
                                       <Data.Either.Either SEDEL.Environment.Err b>_R)
                        ipv } })
                  `cast`
                (forall (r :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Reader.ReaderT
                    r
                    (Control.Monad.Trans.Except.ExceptT
                       SEDEL.Environment.Err GHC.Types.IO)
                    a>_R
                 ->_R <Control.Monad.Trans.Reader.ReaderT
                         r
                         (Control.Monad.Trans.Except.ExceptT
                            SEDEL.Environment.Err GHC.Types.IO)
                         b>_R
                 ->_R (<r>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <Data.Either.Either
                                        SEDEL.Environment.Err
                                        b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                         <SEDEL.Environment.Err>_N
                                                         <GHC.Types.IO>_R
                                                         <b>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                            <*>_N
                                                                            <r>_R
                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                               SEDEL.Environment.Err
                                                                               GHC.Types.IO>_R
                                                                            <b>_N)) -}
990ba017ed14333e7ec42cb595e063be
  $s$fApplicativeFreshMT_$s$fApplicativeReaderT_$c<* ::
    Control.Monad.Trans.Reader.ReaderT
      r
      (Control.Monad.Trans.Except.ExceptT
         SEDEL.Environment.Err GHC.Types.IO)
      a
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         b
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(LS))),1*C1(C1(U(U,U)))><L,1*C1(C1(U(U,1*U)))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (u :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              SEDEL.Environment.Err GHC.Types.IO)
                           a)
                   (v :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              SEDEL.Environment.Err GHC.Types.IO)
                           b)
                   (r1 :: r) ->
                 Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                   @ GHC.Types.IO
                   @ SEDEL.Environment.Err
                   GHC.Base.$fFunctorIO
                   GHC.Base.$fMonadIO
                   @ b
                   @ a
                   (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                    case (u `cast`
                          (Control.Monad.Trans.Reader.N:ReaderT[0]
                               <*>_N
                               <r>_R
                               <Control.Monad.Trans.Except.ExceptT
                                  SEDEL.Environment.Err GHC.Types.IO>_R
                               <a>_N)
                            r1)
                           `cast`
                         (Control.Monad.Trans.Except.N:ExceptT[0]
                              <SEDEL.Environment.Err>_N
                              <GHC.Types.IO>_R
                              <a>_N ; GHC.Types.N:IO[0]
                                          <Data.Either.Either SEDEL.Environment.Err a>_R)
                           s of ds { (#,#) ipv ipv1 ->
                    (# ipv,
                       Control.Monad.Trans.Except.$fApplicativeExceptT1
                         @ SEDEL.Environment.Err
                         @ b
                         @ a
                         ipv1 #) })
                     `cast`
                   (Sym (GHC.Types.N:IO[0]
                             <Data.Either.Either
                                SEDEL.Environment.Err
                                (b -> a)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                        <SEDEL.Environment.Err>_N
                                                        <GHC.Types.IO>_R
                                                        <b -> a>_N))
                   (v `cast`
                    (Control.Monad.Trans.Reader.N:ReaderT[0]
                         <*>_N
                         <r>_R
                         <Control.Monad.Trans.Except.ExceptT
                            SEDEL.Environment.Err GHC.Types.IO>_R
                         <b>_N)
                      r1))
                  `cast`
                (forall (r :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Reader.ReaderT
                    r
                    (Control.Monad.Trans.Except.ExceptT
                       SEDEL.Environment.Err GHC.Types.IO)
                    a>_R
                 ->_R <Control.Monad.Trans.Reader.ReaderT
                         r
                         (Control.Monad.Trans.Except.ExceptT
                            SEDEL.Environment.Err GHC.Types.IO)
                         b>_R
                 ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                               <*>_N
                               <r>_R
                               <Control.Monad.Trans.Except.ExceptT
                                  SEDEL.Environment.Err GHC.Types.IO>_R
                               <a>_N)) -}
05a5cc99122d137f213485b4a36ff17e
  $s$fApplicativeFreshMT_$s$fApplicativeReaderT_$c<*> ::
    Control.Monad.Trans.Reader.ReaderT
      r
      (Control.Monad.Trans.Except.ExceptT
         SEDEL.Environment.Err GHC.Types.IO)
      (a -> b)
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         a
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(U(U,1*U)))><L,1*C1(C(U(U,1*U)))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (f :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              SEDEL.Environment.Err GHC.Types.IO)
                           (a -> b))
                   (v :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              SEDEL.Environment.Err GHC.Types.IO)
                           a)
                   (r1 :: r) ->
                 Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                   @ GHC.Types.IO
                   @ SEDEL.Environment.Err
                   GHC.Base.$fFunctorIO
                   GHC.Base.$fMonadIO
                   @ a
                   @ b
                   (f `cast`
                    (Control.Monad.Trans.Reader.N:ReaderT[0]
                         <*>_N
                         <r>_R
                         <Control.Monad.Trans.Except.ExceptT
                            SEDEL.Environment.Err GHC.Types.IO>_R
                         <a -> b>_N)
                      r1)
                   (v `cast`
                    (Control.Monad.Trans.Reader.N:ReaderT[0]
                         <*>_N
                         <r>_R
                         <Control.Monad.Trans.Except.ExceptT
                            SEDEL.Environment.Err GHC.Types.IO>_R
                         <a>_N)
                      r1))
                  `cast`
                (forall (r :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Reader.ReaderT
                    r
                    (Control.Monad.Trans.Except.ExceptT
                       SEDEL.Environment.Err GHC.Types.IO)
                    (a -> b)>_R
                 ->_R <Control.Monad.Trans.Reader.ReaderT
                         r
                         (Control.Monad.Trans.Except.ExceptT
                            SEDEL.Environment.Err GHC.Types.IO)
                         a>_R
                 ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                               <*>_N
                               <r>_R
                               <Control.Monad.Trans.Except.ExceptT
                                  SEDEL.Environment.Err GHC.Types.IO>_R
                               <b>_N)) -}
7feea9888110d5ee33d25584ac591971
  $s$fApplicativeFreshMT_$s$fFunctorFreshMT ::
    GHC.Base.Functor
      (Unbound.Generics.LocallyNameless.Fresh.FreshMT
         (Control.Monad.Trans.Reader.ReaderT
            SEDEL.Environment.Ctx
            (Control.Monad.Trans.Except.ExceptT
               SEDEL.Environment.Err GHC.Types.IO)))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Fresh.FreshMT
                       (Control.Monad.Trans.Reader.ReaderT
                          SEDEL.Environment.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             SEDEL.Environment.Err GHC.Types.IO)))
                  (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorStateT_$cfmap
                     @ GHC.Integer.Type.Integer)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a -> b>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                     SEDEL.Environment.Ctx
                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                        SEDEL.Environment.Err
                                                                                        GHC.Types.IO)>_N <a>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                     SEDEL.Environment.Ctx
                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                        SEDEL.Environment.Err
                                                                                        GHC.Types.IO)>_N <b>_N)
                  (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorStateT1
                     @ GHC.Integer.Type.Integer)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                     SEDEL.Environment.Ctx
                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                        SEDEL.Environment.Err
                                                                                        GHC.Types.IO)>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Reader.ReaderT
                                    SEDEL.Environment.Ctx
                                    (Control.Monad.Trans.Except.ExceptT
                                       SEDEL.Environment.Err GHC.Types.IO)>_R
                                 <a>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                       SEDEL.Environment.Ctx
                                                                                                       (Control.Monad.Trans.Except.ExceptT
                                                                                                          SEDEL.Environment.Err
                                                                                                          GHC.Types.IO)>_N <a>_N) -}
a38d0e5ebe3ce62cbd1d2e0872cbab80
  $s$fApplicativeFreshMT_$s$fFunctorReaderT ::
    GHC.Base.Functor
      (Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ r.
                  @ (Control.Monad.Trans.Reader.ReaderT
                       r
                       (Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO))
                  (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorReaderT_$cfmap
                     @ r)
                  (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorReaderT_$c<$
                     @ r) -}
1b59c055467e50b8add3c1e053e28b9d
  $s$fApplicativeFreshMT_$s$fFunctorReaderT_$c<$ ::
    a
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         b
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><C(C(S(SL))),1*C1(C1(U(U,1*U)))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (x :: a)
                   (v :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              SEDEL.Environment.Err GHC.Types.IO)
                           b) ->
                 let {
                   lvl101 :: Data.Either.Either SEDEL.Environment.Err a
                   = Data.Either.Right @ SEDEL.Environment.Err @ a x
                 } in
                 (\ (x1 :: r) (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  case (v `cast`
                        (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N
                             <r>_R
                             <Control.Monad.Trans.Except.ExceptT
                                SEDEL.Environment.Err GHC.Types.IO>_R
                             <b>_N)
                          x1)
                         `cast`
                       (Control.Monad.Trans.Except.N:ExceptT[0]
                            <SEDEL.Environment.Err>_N
                            <GHC.Types.IO>_R
                            <b>_N ; GHC.Types.N:IO[0]
                                        <Data.Either.Either SEDEL.Environment.Err b>_R)
                         s of ds { (#,#) ipv ipv1 ->
                  (# ipv,
                     case ipv1 of wild {
                       Data.Either.Left x2
                       -> Data.Either.Left @ SEDEL.Environment.Err @ a x2
                       Data.Either.Right y -> lvl101 } #) })
                   `cast`
                 ((<r>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <Data.Either.Either
                                    SEDEL.Environment.Err
                                    a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                     <SEDEL.Environment.Err>_N
                                                     <GHC.Types.IO>_R
                                                     <a>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                        <*>_N
                                                                        <r>_R
                                                                        <Control.Monad.Trans.Except.ExceptT
                                                                           SEDEL.Environment.Err
                                                                           GHC.Types.IO>_R
                                                                        <a>_N))) -}
f5dccb6cc174985552a7a61b35b1cef0
  $s$fApplicativeFreshMT_$s$fFunctorReaderT_$cfmap ::
    (a -> b)
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         a
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*C1(U)><C(C(S(SL))),1*C1(C1(U(U,1*U)))><L,U><S,U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ r @ a @ b (f :: a -> b) ->
                 Control.Monad.Trans.Reader.mapReaderT
                   @ *
                   @ *
                   @ (Control.Monad.Trans.Except.ExceptT
                        SEDEL.Environment.Err GHC.Types.IO)
                   @ a
                   @ (Control.Monad.Trans.Except.ExceptT
                        SEDEL.Environment.Err GHC.Types.IO)
                   @ b
                   @ r
                   (\ (x :: GHC.Types.IO (Data.Either.Either SEDEL.Environment.Err a))
                      (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                    case x `cast`
                         (GHC.Types.N:IO[0] <Data.Either.Either SEDEL.Environment.Err a>_R)
                           s of ds { (#,#) ipv ipv1 ->
                    (# ipv,
                       Data.Either.$fApplicativeEither_$cfmap
                         @ SEDEL.Environment.Err
                         @ a
                         @ b
                         f
                         ipv1 #) })
                     `cast`
                   (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                             <SEDEL.Environment.Err>_N <GHC.Types.IO>_R <a>_N)
                    ->_R Sym (GHC.Types.N:IO[0]
                                  <Data.Either.Either
                                     SEDEL.Environment.Err
                                     b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                      <SEDEL.Environment.Err>_N
                                                      <GHC.Types.IO>_R
                                                      <b>_N))) -}
e34b2bd4761a143d342468e863bbb3b5
  $s$fApplicativeFreshMT_$s$fFunctorStateT1 ::
    a
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Reader.ReaderT
            SEDEL.Environment.Ctx
            (Control.Monad.Trans.Except.ExceptT
               SEDEL.Environment.Err GHC.Types.IO))
         b
    -> s
    -> Control.Monad.Trans.Reader.ReaderT
         SEDEL.Environment.Ctx
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         (a, s)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,1*C1(C(C1(U(U,1*U))))><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ s
                   @ a
                   @ b
                   (x :: a)
                   (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                              s
                              (Control.Monad.Trans.Reader.ReaderT
                                 SEDEL.Environment.Ctx
                                 (Control.Monad.Trans.Except.ExceptT
                                    SEDEL.Environment.Err GHC.Types.IO))
                              b)
                   (eta2 :: s) ->
                 let {
                   m1 :: Control.Monad.Trans.Reader.ReaderT
                           SEDEL.Environment.Ctx
                           (Control.Monad.Trans.Except.ExceptT
                              SEDEL.Environment.Err GHC.Types.IO)
                           (b, s)
                   = eta1
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N
                          <Control.Monad.Trans.Reader.ReaderT
                             SEDEL.Environment.Ctx
                             (Control.Monad.Trans.Except.ExceptT
                                SEDEL.Environment.Err GHC.Types.IO)>_R
                          <b>_N)
                       eta2
                 } in
                 (\ (x1 :: SEDEL.Environment.Ctx)
                    (s1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  case (m1
                          `cast`
                        (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N
                             <SEDEL.Environment.Ctx>_R
                             <Control.Monad.Trans.Except.ExceptT
                                SEDEL.Environment.Err GHC.Types.IO>_R
                             <(b, s)>_N)
                          x1)
                         `cast`
                       (Control.Monad.Trans.Except.N:ExceptT[0]
                            <SEDEL.Environment.Err>_N
                            <GHC.Types.IO>_R
                            <(b, s)>_N ; GHC.Types.N:IO[0]
                                             <Data.Either.Either SEDEL.Environment.Err (b, s)>_R)
                         s1 of ds { (#,#) ipv ipv1 ->
                  (# ipv,
                     case ipv1 of wild {
                       Data.Either.Left x2
                       -> Data.Either.Left @ SEDEL.Environment.Err @ (a, s) x2
                       Data.Either.Right y
                       -> Data.Either.Right
                            @ SEDEL.Environment.Err
                            @ (a, s)
                            (x, case y of wild1 { (,) a1 s' -> s' }) } #) })
                   `cast`
                 ((<SEDEL.Environment.Ctx>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <Data.Either.Either
                                    SEDEL.Environment.Err
                                    (a, s)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                          <SEDEL.Environment.Err>_N
                                                          <GHC.Types.IO>_R
                                                          <(a,
                                                            s)>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                               <*>_N
                                                                               <SEDEL.Environment.Ctx>_R
                                                                               <Control.Monad.Trans.Except.ExceptT
                                                                                  SEDEL.Environment.Err
                                                                                  GHC.Types.IO>_R
                                                                               <(a, s)>_N))) -}
b6d477077414a9765aa569f493c87d4c
  $s$fApplicativeFreshMT_$s$fFunctorStateT_$cfmap ::
    (a -> b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Reader.ReaderT
            SEDEL.Environment.Ctx
            (Control.Monad.Trans.Except.ExceptT
               SEDEL.Environment.Err GHC.Types.IO))
         a
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Reader.ReaderT
            SEDEL.Environment.Ctx
            (Control.Monad.Trans.Except.ExceptT
               SEDEL.Environment.Err GHC.Types.IO))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(U)><L,1*C1(C(C1(U(U,1*U))))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (f :: a -> b)
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Trans.Reader.ReaderT
                               SEDEL.Environment.Ctx
                               (Control.Monad.Trans.Except.ExceptT
                                  SEDEL.Environment.Err GHC.Types.IO))
                            a)
                   (s1 :: s) ->
                 let {
                   m2 :: Control.Monad.Trans.Reader.ReaderT
                           SEDEL.Environment.Ctx
                           (Control.Monad.Trans.Except.ExceptT
                              SEDEL.Environment.Err GHC.Types.IO)
                           (a, s)
                   = m1
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N
                          <Control.Monad.Trans.Reader.ReaderT
                             SEDEL.Environment.Ctx
                             (Control.Monad.Trans.Except.ExceptT
                                SEDEL.Environment.Err GHC.Types.IO)>_R
                          <a>_N)
                       s1
                 } in
                 (\ (x :: SEDEL.Environment.Ctx)
                    (s2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  case (m2
                          `cast`
                        (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N
                             <SEDEL.Environment.Ctx>_R
                             <Control.Monad.Trans.Except.ExceptT
                                SEDEL.Environment.Err GHC.Types.IO>_R
                             <(a, s)>_N)
                          x)
                         `cast`
                       (Control.Monad.Trans.Except.N:ExceptT[0]
                            <SEDEL.Environment.Err>_N
                            <GHC.Types.IO>_R
                            <(a, s)>_N ; GHC.Types.N:IO[0]
                                             <Data.Either.Either SEDEL.Environment.Err (a, s)>_R)
                         s2 of ds { (#,#) ipv ipv1 ->
                  (# ipv,
                     case ipv1 of wild {
                       Data.Either.Left x1
                       -> Data.Either.Left @ SEDEL.Environment.Err @ (b, s) x1
                       Data.Either.Right y
                       -> Data.Either.Right
                            @ SEDEL.Environment.Err
                            @ (b, s)
                            (f (case y of wild1 { (,) a1 s' -> a1 }),
                             case y of wild1 { (,) a1 s' -> s' }) } #) })
                   `cast`
                 ((<SEDEL.Environment.Ctx>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <Data.Either.Either
                                    SEDEL.Environment.Err
                                    (b, s)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                          <SEDEL.Environment.Err>_N
                                                          <GHC.Types.IO>_R
                                                          <(b,
                                                            s)>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                               <*>_N
                                                                               <SEDEL.Environment.Ctx>_R
                                                                               <Control.Monad.Trans.Except.ExceptT
                                                                                  SEDEL.Environment.Err
                                                                                  GHC.Types.IO>_R
                                                                               <(b, s)>_N)))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s
                         (Control.Monad.Trans.Reader.ReaderT
                            SEDEL.Environment.Ctx
                            (Control.Monad.Trans.Except.ExceptT
                               SEDEL.Environment.Err GHC.Types.IO))
                         a>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Trans.Reader.ReaderT
                                  SEDEL.Environment.Ctx
                                  (Control.Monad.Trans.Except.ExceptT
                                     SEDEL.Environment.Err GHC.Types.IO)>_R
                               <b>_N)) -}
b75a9ed012615e7ff7b0e0ecd22f9b38
  $s$fApplicativeFreshMT_$s$fMonadReaderT ::
    GHC.Base.Monad
      (Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ r.
                  @ (Control.Monad.Trans.Reader.ReaderT
                       r
                       (Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO))
                  (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fApplicativeReaderT
                     @ r)
                  (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fMonadReaderT_$c>>=
                     @ r)
                  (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fApplicativeReaderT_$c*>
                     @ r)
                  (\ @ a (eta1 :: a) ->
                   let {
                     m1 :: GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                 Data.Either.Either SEDEL.Environment.Err a #)
                       {- Arity: 1 -}
                     = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                       (# s, Data.Either.Right @ SEDEL.Environment.Err @ a eta1 #)
                   } in
                   (\ (ds :: r) -> m1)
                     `cast`
                   ((<r>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <Data.Either.Either
                                      SEDEL.Environment.Err
                                      a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                       <SEDEL.Environment.Err>_N
                                                       <GHC.Types.IO>_R
                                                       <a>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                          <*>_N
                                                                          <r>_R
                                                                          <Control.Monad.Trans.Except.ExceptT
                                                                             SEDEL.Environment.Err
                                                                             GHC.Types.IO>_R
                                                                          <a>_N)))
                  (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fMonadReaderT_$cfail
                     @ r) -}
5dafcb914cc5eeef96556d06f4ebef5c
  $s$fApplicativeFreshMT_$s$fMonadReaderT_$c>>= ::
    Control.Monad.Trans.Reader.ReaderT
      r
      (Control.Monad.Trans.Except.ExceptT
         SEDEL.Environment.Err GHC.Types.IO)
      a
    -> (a
        -> Control.Monad.Trans.Reader.ReaderT
             r
             (Control.Monad.Trans.Except.ExceptT
                SEDEL.Environment.Err GHC.Types.IO)
             b)
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(SS))),1*C1(C1(U(U,1*U)))><L,1*C1(C1(C1(U(U,U))))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Reader.ReaderT
                            r
                            (Control.Monad.Trans.Except.ExceptT
                               SEDEL.Environment.Err GHC.Types.IO)
                            a)
                   (k :: a
                         -> Control.Monad.Trans.Reader.ReaderT
                              r
                              (Control.Monad.Trans.Except.ExceptT
                                 SEDEL.Environment.Err GHC.Types.IO)
                              b)
                   (r1 :: r)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (m1
                         `cast`
                       (Control.Monad.Trans.Reader.N:ReaderT[0]
                            <*>_N
                            <r>_R
                            <Control.Monad.Trans.Except.ExceptT
                               SEDEL.Environment.Err GHC.Types.IO>_R
                            <a>_N)
                         r1)
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <SEDEL.Environment.Err>_N
                           <GHC.Types.IO>_R
                           <a>_N ; GHC.Types.N:IO[0]
                                       <Data.Either.Either SEDEL.Environment.Err a>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   Data.Either.Left e1
                   -> (# ipv, Data.Either.Left @ SEDEL.Environment.Err @ b e1 #)
                   Data.Either.Right x
                   -> ((k x)
                         `cast`
                       (Control.Monad.Trans.Reader.N:ReaderT[0]
                            <*>_N
                            <r>_R
                            <Control.Monad.Trans.Except.ExceptT
                               SEDEL.Environment.Err GHC.Types.IO>_R
                            <b>_N)
                         r1)
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <SEDEL.Environment.Err>_N
                           <GHC.Types.IO>_R
                           <b>_N ; GHC.Types.N:IO[0]
                                       <Data.Either.Either SEDEL.Environment.Err b>_R)
                        ipv } })
                  `cast`
                (forall (r :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Reader.ReaderT
                    r
                    (Control.Monad.Trans.Except.ExceptT
                       SEDEL.Environment.Err GHC.Types.IO)
                    a>_R
                 ->_R <a
                       -> Control.Monad.Trans.Reader.ReaderT
                            r
                            (Control.Monad.Trans.Except.ExceptT
                               SEDEL.Environment.Err GHC.Types.IO)
                            b>_R
                 ->_R (<r>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <Data.Either.Either
                                        SEDEL.Environment.Err
                                        b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                         <SEDEL.Environment.Err>_N
                                                         <GHC.Types.IO>_R
                                                         <b>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                            <*>_N
                                                                            <r>_R
                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                               SEDEL.Environment.Err
                                                                               GHC.Types.IO>_R
                                                                            <b>_N)) -}
6239421b9a729194f7a64c2d520f5ec4
  $s$fApplicativeFreshMT_$s$fMonadReaderT_$cfail ::
    GHC.Base.String
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         a
  {- Arity: 1, Strictness: <L,U>, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ r @ a (msg :: GHC.Base.String) ->
                 let {
                   m1 :: GHC.Types.IO (Data.Either.Either SEDEL.Environment.Err a)
                   = GHC.Magic.noinline
                       @ (forall a1. [GHC.Types.Char] -> GHC.Types.IO a1)
                       GHC.IO.failIO1
                         `cast`
                       (forall (a1 :: <*>_N).
                        <GHC.Base.String>_R ->_R Sym (GHC.Types.N:IO[0] <a1>_R))
                       @ (Data.Either.Either SEDEL.Environment.Err a)
                       msg
                 } in
                 (\ (ds :: r) -> m1)
                   `cast`
                 ((<r>_R
                   ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                 <SEDEL.Environment.Err>_N
                                 <GHC.Types.IO>_R
                                 <a>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                    <*>_N
                                                    <r>_R
                                                    <Control.Monad.Trans.Except.ExceptT
                                                       SEDEL.Environment.Err GHC.Types.IO>_R
                                                    <a>_N))) -}
8590d6636e8fede47f801c8f44146203
  $s$fFreshFreshMT_$s$fMonadFreshMT ::
    GHC.Base.Monad
      (Unbound.Generics.LocallyNameless.Fresh.FreshMT
         (Control.Monad.Trans.Reader.ReaderT
            SEDEL.Environment.Ctx
            (Control.Monad.Trans.Except.ExceptT
               SEDEL.Environment.Err GHC.Types.IO)))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Fresh.FreshMT
                       (Control.Monad.Trans.Reader.ReaderT
                          SEDEL.Environment.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             SEDEL.Environment.Err GHC.Types.IO)))
                  SEDEL.Source.Inference.$s$fApplicativeFreshMT
                  (SEDEL.Source.Inference.$s$fFreshFreshMT_$s$fMonadStateT_$c>>=
                     @ GHC.Integer.Type.Integer)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                SEDEL.Environment.Ctx
                                                                                (Control.Monad.Trans.Except.ExceptT
                                                                                   SEDEL.Environment.Err
                                                                                   GHC.Types.IO)>_N <a>_N
                   ->_R (<a>_R
                         ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                           SEDEL.Environment.Ctx
                                                                                           (Control.Monad.Trans.Except.ExceptT
                                                                                              SEDEL.Environment.Err
                                                                                              GHC.Types.IO)>_N <b>_N)
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                     SEDEL.Environment.Ctx
                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                        SEDEL.Environment.Err
                                                                                        GHC.Types.IO)>_N <b>_N)
                  (SEDEL.Source.Inference.$s$fFreshFreshMT_$s$fMonadStateT_$c>>
                     @ GHC.Integer.Type.Integer)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                SEDEL.Environment.Ctx
                                                                                (Control.Monad.Trans.Except.ExceptT
                                                                                   SEDEL.Environment.Err
                                                                                   GHC.Types.IO)>_N <a>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                     SEDEL.Environment.Ctx
                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                        SEDEL.Environment.Err
                                                                                        GHC.Types.IO)>_N <b>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                     SEDEL.Environment.Ctx
                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                        SEDEL.Environment.Err
                                                                                        GHC.Types.IO)>_N <b>_N)
                  (\ @ a (eta1 :: a) (eta2 :: GHC.Integer.Type.Integer) ->
                   let {
                     m1 :: GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                 Data.Either.Either
                                   SEDEL.Environment.Err (a, GHC.Integer.Type.Integer) #)
                       {- Arity: 1 -}
                     = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                       (# s,
                          Data.Either.Right
                            @ SEDEL.Environment.Err
                            @ (a, GHC.Integer.Type.Integer)
                            (eta1, eta2) #)
                   } in
                   (\ (ds :: SEDEL.Environment.Ctx) -> m1)
                     `cast`
                   ((<SEDEL.Environment.Ctx>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <Data.Either.Either
                                      SEDEL.Environment.Err
                                      (a,
                                       GHC.Integer.Type.Integer)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <SEDEL.Environment.Err>_N
                                                                                <GHC.Types.IO>_R
                                                                                <(a,
                                                                                  GHC.Integer.Type.Integer)>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                            <*>_N
                                                                                                                            <SEDEL.Environment.Ctx>_R
                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                               SEDEL.Environment.Err
                                                                                                                               GHC.Types.IO>_R
                                                                                                                            <(a,
                                                                                                                              GHC.Integer.Type.Integer)>_N)))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Reader.ReaderT
                                    SEDEL.Environment.Ctx
                                    (Control.Monad.Trans.Except.ExceptT
                                       SEDEL.Environment.Err GHC.Types.IO)>_R
                                 <a>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                       SEDEL.Environment.Ctx
                                                                                                       (Control.Monad.Trans.Except.ExceptT
                                                                                                          SEDEL.Environment.Err
                                                                                                          GHC.Types.IO)>_N <a>_N)
                  (SEDEL.Source.Inference.$s$fFreshFreshMT_$s$fMonadStateT_$cfail
                     @ GHC.Integer.Type.Integer)
                    `cast`
                  (forall (a :: <*>_N).
                   <[GHC.Types.Char]>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                     SEDEL.Environment.Ctx
                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                        SEDEL.Environment.Err
                                                                                        GHC.Types.IO)>_N <a>_N) -}
8b90ac97fc34dd87d7e1bd5533d3c35a
  $s$fFreshFreshMT_$s$fMonadStateT_$c>> ::
    Control.Monad.Trans.State.Lazy.StateT
      s
      (Control.Monad.Trans.Reader.ReaderT
         SEDEL.Environment.Ctx
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO))
      a
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Reader.ReaderT
            SEDEL.Environment.Ctx
            (Control.Monad.Trans.Except.ExceptT
               SEDEL.Environment.Err GHC.Types.IO))
         b
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Reader.ReaderT
            SEDEL.Environment.Ctx
            (Control.Monad.Trans.Except.ExceptT
               SEDEL.Environment.Err GHC.Types.IO))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(C1(U(U,1*U))))><L,C(C1(C1(U)))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Trans.Reader.ReaderT
                               SEDEL.Environment.Ctx
                               (Control.Monad.Trans.Except.ExceptT
                                  SEDEL.Environment.Err GHC.Types.IO))
                            a)
                   (k :: Control.Monad.Trans.State.Lazy.StateT
                           s
                           (Control.Monad.Trans.Reader.ReaderT
                              SEDEL.Environment.Ctx
                              (Control.Monad.Trans.Except.ExceptT
                                 SEDEL.Environment.Err GHC.Types.IO))
                           b)
                   (s1 :: s) ->
                 let {
                   m2 :: Control.Monad.Trans.Reader.ReaderT
                           SEDEL.Environment.Ctx
                           (Control.Monad.Trans.Except.ExceptT
                              SEDEL.Environment.Err GHC.Types.IO)
                           (a, s)
                   = m1
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N
                          <Control.Monad.Trans.Reader.ReaderT
                             SEDEL.Environment.Ctx
                             (Control.Monad.Trans.Except.ExceptT
                                SEDEL.Environment.Err GHC.Types.IO)>_R
                          <a>_N)
                       s1
                 } in
                 (\ (r1 :: SEDEL.Environment.Ctx)
                    (s2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  case (m2
                          `cast`
                        (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N
                             <SEDEL.Environment.Ctx>_R
                             <Control.Monad.Trans.Except.ExceptT
                                SEDEL.Environment.Err GHC.Types.IO>_R
                             <(a, s)>_N)
                          r1)
                         `cast`
                       (Control.Monad.Trans.Except.N:ExceptT[0]
                            <SEDEL.Environment.Err>_N
                            <GHC.Types.IO>_R
                            <(a, s)>_N ; GHC.Types.N:IO[0]
                                             <Data.Either.Either SEDEL.Environment.Err (a, s)>_R)
                         s2 of ds1 { (#,#) ipv ipv1 ->
                  case ipv1 of wild {
                    Data.Either.Left e1
                    -> (# ipv, Data.Either.Left @ SEDEL.Environment.Err @ (b, s) e1 #)
                    Data.Either.Right x
                    -> ((k `cast`
                         (Control.Monad.Trans.State.Lazy.N:StateT[0]
                              <s>_N
                              <Control.Monad.Trans.Reader.ReaderT
                                 SEDEL.Environment.Ctx
                                 (Control.Monad.Trans.Except.ExceptT
                                    SEDEL.Environment.Err GHC.Types.IO)>_R
                              <b>_N)
                           (case x of wild1 { (,) a1 s' -> s' }))
                          `cast`
                        (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N
                             <SEDEL.Environment.Ctx>_R
                             <Control.Monad.Trans.Except.ExceptT
                                SEDEL.Environment.Err GHC.Types.IO>_R
                             <(b, s)>_N)
                          r1)
                         `cast`
                       (Control.Monad.Trans.Except.N:ExceptT[0]
                            <SEDEL.Environment.Err>_N
                            <GHC.Types.IO>_R
                            <(b, s)>_N ; GHC.Types.N:IO[0]
                                             <Data.Either.Either SEDEL.Environment.Err (b, s)>_R)
                         ipv } })
                   `cast`
                 ((<SEDEL.Environment.Ctx>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <Data.Either.Either
                                    SEDEL.Environment.Err
                                    (b, s)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                          <SEDEL.Environment.Err>_N
                                                          <GHC.Types.IO>_R
                                                          <(b,
                                                            s)>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                               <*>_N
                                                                               <SEDEL.Environment.Ctx>_R
                                                                               <Control.Monad.Trans.Except.ExceptT
                                                                                  SEDEL.Environment.Err
                                                                                  GHC.Types.IO>_R
                                                                               <(b, s)>_N)))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s
                    (Control.Monad.Trans.Reader.ReaderT
                       SEDEL.Environment.Ctx
                       (Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO))
                    a>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s
                         (Control.Monad.Trans.Reader.ReaderT
                            SEDEL.Environment.Ctx
                            (Control.Monad.Trans.Except.ExceptT
                               SEDEL.Environment.Err GHC.Types.IO))
                         b>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Trans.Reader.ReaderT
                                  SEDEL.Environment.Ctx
                                  (Control.Monad.Trans.Except.ExceptT
                                     SEDEL.Environment.Err GHC.Types.IO)>_R
                               <b>_N)) -}
d1661dc268760d83aff6033448a2e3ff
  $s$fFreshFreshMT_$s$fMonadStateT_$c>>= ::
    Control.Monad.Trans.State.Lazy.StateT
      s
      (Control.Monad.Trans.Reader.ReaderT
         SEDEL.Environment.Ctx
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO))
      a
    -> (a
        -> Control.Monad.Trans.State.Lazy.StateT
             s
             (Control.Monad.Trans.Reader.ReaderT
                SEDEL.Environment.Ctx
                (Control.Monad.Trans.Except.ExceptT
                   SEDEL.Environment.Err GHC.Types.IO))
             b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Reader.ReaderT
            SEDEL.Environment.Ctx
            (Control.Monad.Trans.Except.ExceptT
               SEDEL.Environment.Err GHC.Types.IO))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(C1(U(U,1*U))))><L,C(C1(C1(C1(U))))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Trans.Reader.ReaderT
                               SEDEL.Environment.Ctx
                               (Control.Monad.Trans.Except.ExceptT
                                  SEDEL.Environment.Err GHC.Types.IO))
                            a)
                   (k :: a
                         -> Control.Monad.Trans.State.Lazy.StateT
                              s
                              (Control.Monad.Trans.Reader.ReaderT
                                 SEDEL.Environment.Ctx
                                 (Control.Monad.Trans.Except.ExceptT
                                    SEDEL.Environment.Err GHC.Types.IO))
                              b)
                   (s1 :: s) ->
                 let {
                   m2 :: Control.Monad.Trans.Reader.ReaderT
                           SEDEL.Environment.Ctx
                           (Control.Monad.Trans.Except.ExceptT
                              SEDEL.Environment.Err GHC.Types.IO)
                           (a, s)
                   = m1
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N
                          <Control.Monad.Trans.Reader.ReaderT
                             SEDEL.Environment.Ctx
                             (Control.Monad.Trans.Except.ExceptT
                                SEDEL.Environment.Err GHC.Types.IO)>_R
                          <a>_N)
                       s1
                 } in
                 (\ (r1 :: SEDEL.Environment.Ctx)
                    (s2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  case (m2
                          `cast`
                        (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N
                             <SEDEL.Environment.Ctx>_R
                             <Control.Monad.Trans.Except.ExceptT
                                SEDEL.Environment.Err GHC.Types.IO>_R
                             <(a, s)>_N)
                          r1)
                         `cast`
                       (Control.Monad.Trans.Except.N:ExceptT[0]
                            <SEDEL.Environment.Err>_N
                            <GHC.Types.IO>_R
                            <(a, s)>_N ; GHC.Types.N:IO[0]
                                             <Data.Either.Either SEDEL.Environment.Err (a, s)>_R)
                         s2 of ds1 { (#,#) ipv ipv1 ->
                  case ipv1 of wild {
                    Data.Either.Left e1
                    -> (# ipv, Data.Either.Left @ SEDEL.Environment.Err @ (b, s) e1 #)
                    Data.Either.Right x
                    -> (((k (case x of wild1 { (,) a1 s' -> a1 }))
                           `cast`
                         (Control.Monad.Trans.State.Lazy.N:StateT[0]
                              <s>_N
                              <Control.Monad.Trans.Reader.ReaderT
                                 SEDEL.Environment.Ctx
                                 (Control.Monad.Trans.Except.ExceptT
                                    SEDEL.Environment.Err GHC.Types.IO)>_R
                              <b>_N)
                           (case x of wild1 { (,) a1 s' -> s' }))
                          `cast`
                        (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N
                             <SEDEL.Environment.Ctx>_R
                             <Control.Monad.Trans.Except.ExceptT
                                SEDEL.Environment.Err GHC.Types.IO>_R
                             <(b, s)>_N)
                          r1)
                         `cast`
                       (Control.Monad.Trans.Except.N:ExceptT[0]
                            <SEDEL.Environment.Err>_N
                            <GHC.Types.IO>_R
                            <(b, s)>_N ; GHC.Types.N:IO[0]
                                             <Data.Either.Either SEDEL.Environment.Err (b, s)>_R)
                         ipv } })
                   `cast`
                 ((<SEDEL.Environment.Ctx>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <Data.Either.Either
                                    SEDEL.Environment.Err
                                    (b, s)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                          <SEDEL.Environment.Err>_N
                                                          <GHC.Types.IO>_R
                                                          <(b,
                                                            s)>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                               <*>_N
                                                                               <SEDEL.Environment.Ctx>_R
                                                                               <Control.Monad.Trans.Except.ExceptT
                                                                                  SEDEL.Environment.Err
                                                                                  GHC.Types.IO>_R
                                                                               <(b, s)>_N)))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s
                    (Control.Monad.Trans.Reader.ReaderT
                       SEDEL.Environment.Ctx
                       (Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO))
                    a>_R
                 ->_R <a
                       -> Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Trans.Reader.ReaderT
                               SEDEL.Environment.Ctx
                               (Control.Monad.Trans.Except.ExceptT
                                  SEDEL.Environment.Err GHC.Types.IO))
                            b>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Trans.Reader.ReaderT
                                  SEDEL.Environment.Ctx
                                  (Control.Monad.Trans.Except.ExceptT
                                     SEDEL.Environment.Err GHC.Types.IO)>_R
                               <b>_N)) -}
574bf455c0320948acf1207c55ed9b09
  $s$fFreshFreshMT_$s$fMonadStateT_$cfail ::
    GHC.Base.String
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Reader.ReaderT
            SEDEL.Environment.Ctx
            (Control.Monad.Trans.Except.ExceptT
               SEDEL.Environment.Err GHC.Types.IO))
         a
  {- Arity: 1, Strictness: <L,U>, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ s @ a (str :: GHC.Base.String) (ds :: s) ->
                 SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fMonadReaderT_$cfail
                   @ SEDEL.Environment.Ctx
                   @ (a, s)
                   str)
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <GHC.Base.String>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Trans.Reader.ReaderT
                                  SEDEL.Environment.Ctx
                                  (Control.Monad.Trans.Except.ExceptT
                                     SEDEL.Environment.Err GHC.Types.IO)>_R
                               <a>_N)) -}
77e0f02d2f6ff89000b14cfeb743b111
  $tc'EmptyC :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15059175027299350713##
                   7066447823182707419##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'EmptyC2
                   0#
                   SEDEL.Source.Inference.$tc'EmptyC1) -}
5595360306e34a313116f5e281dd9152
  $tc'EmptyC1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
a75c6867bcf2b0a4b4a10b4e77498daa
  $tc'EmptyC2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   SEDEL.Source.Inference.$tc'EmptyC3) -}
d175c8d2a8bc127d09e10f92886278f1
  $tc'EmptyC3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'EmptyC"#) -}
aabf31e9948edf5933931ee9ecd968f0
  $tc'EmptyD :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8985049179165338442##
                   14937819307228280272##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'EmptyD2
                   0#
                   SEDEL.Source.Inference.$tc'EmptyD1) -}
2cd20b6ecac9b5f3df9ad1d10850a416
  $tc'EmptyD1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
7f9e3682d6598e66fa033fc040f253db
  $tc'EmptyD2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   SEDEL.Source.Inference.$tc'EmptyD3) -}
fe3dd73e361f4aeaf5210b10ec23124f
  $tc'EmptyD3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'EmptyD"#) -}
e812b1f2652854b6318d831ffe0f8d36
  $tc'EmptyQ :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11784224235816202856##
                   4779325768401687468##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'EmptyQ2
                   0#
                   SEDEL.Source.Inference.$tc'EmptyQ1) -}
a1a14b7f453166f73da62b83ab8ce46c
  $tc'EmptyQ1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
0ce2b9d7488ab62f7ea1710165fe9db9
  $tc'EmptyQ2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   SEDEL.Source.Inference.$tc'EmptyQ3) -}
04b10c678cd2abb55c4bc25f6791bbd1
  $tc'EmptyQ3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'EmptyQ"#) -}
0f8dcc10673032467f42f3d6d757e421
  $tc'EmptyS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9188268066992237342##
                   2795848751500966900##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'EmptyS2
                   0#
                   SEDEL.Source.Inference.$tc'EmptyS1) -}
93bcf59465b4e7a1e05be7c38f0fab76
  $tc'EmptyS1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
5d1152f9855e7f2635240fce5fde4673
  $tc'EmptyS2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   SEDEL.Source.Inference.$tc'EmptyS3) -}
3c02fa03ffa94c4a5717daabb7756f33
  $tc'EmptyS3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'EmptyS"#) -}
99ecd4b3542eec251511bf75b99d71d7
  $tc'NegS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12148826560494987268##
                   10809487838620012890##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'NegS2
                   0#
                   SEDEL.Source.Inference.$tc'NegS1) -}
3f9c1cae41bddedcc7e3b4d328c934bc
  $tc'NegS1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
d5c7af2955ae5c54488455887eaffbc4
  $tc'NegS2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$tc'NegS3) -}
0cb808ca848ef8842cb782dda15006a0
  $tc'NegS3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NegS"#) -}
ef3683b5be4c7d651e637d69be836061
  $tc'NegT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12866821559023525768##
                   1565877890041158221##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'NegT2
                   0#
                   SEDEL.Source.Inference.$tc'NegT1) -}
fb205b9402efc850de58fc745bfa34b0
  $tc'NegT1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
1fb7a219fcd1e206edaa20d3477aaf6b
  $tc'NegT2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$tc'NegT3) -}
f0058caab8b269df22746b97183ea335
  $tc'NegT3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NegT"#) -}
6bdbd04aabcfde94fd9ed0d960b6f829
  $tc'PosS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5717195439771067002##
                   1070085866257300000##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'PosS1
                   0#
                   SEDEL.Source.Inference.$tc'NegS1) -}
68a6c1947d21016c4038b4a87965c808
  $tc'PosS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$tc'PosS2) -}
cd75a9dfe109924a8a65544ae4a54087
  $tc'PosS2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'PosS"#) -}
b07ce679ba198887083e46432f9bdb89
  $tc'PosT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10821995412046220501##
                   11645974800161212707##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'PosT1
                   0#
                   SEDEL.Source.Inference.$tc'NegT1) -}
d3e6be9cd871bea465e815f28898af09
  $tc'PosT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$tc'PosT2) -}
67ffe74624c8d4f9d152bce5dccc1dd1
  $tc'PosT2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'PosT"#) -}
9bef9ba2559421df157b792231c25268
  $tc'QA :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5001154949805423936##
                   9933405851264841829##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'QA2
                   0#
                   SEDEL.Source.Inference.$tc'QA1) -}
b5014cb8e07eebabf8bb59a5a584bb66
  $tc'QA1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
57bf9b9fb4a6b384a6b0c060be139383
  $tc'QA2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$tc'QA3) -}
450f306e4df7972c36c563bc8efa885d
  $tc'QA3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'QA"#) -}
f4e12ef747b64eccf04ba8da970d31f8
  $tc'QL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   465991369201380357##
                   1539413109649361632##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'QL2
                   0#
                   SEDEL.Source.Inference.$tc'QL1) -}
b31138d8c26d9f6b10faf8a4ef08508d
  $tc'QL1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
198fda3b405ce267bcdf60715e2d4f4d
  $tc'QL2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$tc'QL3) -}
4a0631ce1d08771839721a73218d74e9
  $tc'QL3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'QL"#) -}
a24302a00e1acf29a504ac94080ffaae
  $tc'SeqC :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3839828616073814802##
                   10906318525182744774##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'SeqC2
                   0#
                   SEDEL.Source.Inference.$tc'SeqC1) -}
fdb1a89a637f4f4956643b6582852070
  $tc'SeqC1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
c014d7fc3c92e0895ff54b8f89beb1fc
  $tc'SeqC2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$tc'SeqC3) -}
5972b55aa6ba0de0fa801f6a9805814e
  $tc'SeqC3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'SeqC"#) -}
0fcb8f6e40160ce744df8dfdc8d57d68
  $tc'SeqD :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5041067970201962346##
                   12255707091793215295##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'SeqD2
                   0#
                   SEDEL.Source.Inference.$tc'SeqD1) -}
fe90daed5733ec5aac2c366bbdf9b479
  $tc'SeqD1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
19599a0d2efb5d8e72dad24f86bad77f
  $tc'SeqD2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$tc'SeqD3) -}
d891775e1f5209145aba766251bda271
  $tc'SeqD3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'SeqD"#) -}
4bc071e3a17014891760569c546517b0
  $tcDisCons :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8987697561992040092##
                   5321143786523411041##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tcDisCons1
                   0#
                   GHC.Types.krep$*) -}
3f6172c6f57fec741d20e3eb97936600
  $tcDisCons1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   SEDEL.Source.Inference.$tcDisCons2) -}
cc8f61e5fdcc8cbf6d67e2e1d6761c6d
  $tcDisCons2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("DisCons"#) -}
1588f28617efe7acae5b70971262fe0d
  $tcPolar :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9586894273386467155##
                   2065523284674106229##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tcPolar1
                   0#
                   GHC.Types.krep$*) -}
05939134eee7d536c1cdc90c3df77af8
  $tcPolar1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$tcPolar2) -}
9524f580f75666cf6418a07a0895ca92
  $tcPolar2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Polar"#) -}
a2d65158a47624e8876c6875d76565a4
  $tcQueue :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3577288385873209363##
                   10678567721850043947##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tcQueue1
                   0#
                   GHC.Types.krep$*) -}
187e8e04f9eadc213d4f1e17d4a08efb
  $tcQueue1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$tcQueue2) -}
f6ce903fdf1732127ba7fa7f6d98463a
  $tcQueue2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Queue"#) -}
e782b04a9c0c864037d7c78e6d179cca
  $tcSubCons :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12811962212068106673##
                   9168078206660869487##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tcSubCons1
                   0#
                   GHC.Types.krep$*) -}
08bd1c9a81875d38939333d8ce296f07
  $tcSubCons1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   SEDEL.Source.Inference.$tcSubCons2) -}
1aee1d947f1e91d3b744b2b29e3ddf47
  $tcSubCons2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SubCons"#) -}
43d1c1896db4a5f9b2410abeae54745f
  $tcSubstitution :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2261019488069193682##
                   1327015062005974776##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tcSubstitution1
                   0#
                   GHC.Types.krep$*) -}
4eb7a977223d2ebf2e5be75ed461fdc4
  $tcSubstitution1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   SEDEL.Source.Inference.$tcSubstitution2) -}
f9a8df92981ed06d42b420c6ebe76b12
  $tcSubstitution2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Substitution"#) -}
fa250068e826952d849dbcf703de394c
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   SEDEL.Source.Inference.$trModule3
                   SEDEL.Source.Inference.$trModule1) -}
21eb4d7ac6707c30c1139bd69ff17c34
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$trModule2) -}
1047ec2d5c6353a5202011742a220728
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SEDEL.Source.Inference"#) -}
b3778563625d6e279ca2922cd5f19de1
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$trModule4) -}
2a9f7e27d3f0581d890ad67f8dcd1eeb
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("sedel-0.1.0.0-AhY9khA6pZOExbzZW5SwDc"#) -}
dbc67023426b467bcb4385630d73c2bc
  data DisCons
    = EmptyD
    | SeqD SEDEL.Source.Inference.DisRule
           SEDEL.Source.Inference.DisCons
78ad38e4b9ade2ce65a52bc1350720cb
  type DisRule =
    (SEDEL.Source.Syntax.SType, SEDEL.Source.Syntax.Scheme)
b1e90bc5c824dc6244215bc472f916f5
  data Polar
    = PosT SEDEL.Source.Syntax.SType | NegT SEDEL.Source.Syntax.SType
d1b9c29529c7c5685143e12b3b1a774c
  data Queue
    = EmptyQ
    | QL SEDEL.Source.Syntax.Label SEDEL.Source.Inference.Queue
    | QA SEDEL.Source.Syntax.SType SEDEL.Source.Inference.Queue
413f7908c7a77b6d8d62a0aadd1f6ba5
  data SubCons
    = EmptyC
    | SeqC SEDEL.Source.Inference.SubRule
           SEDEL.Source.Inference.SubCons
2e5d3282e0cb6b24f91ed50576e27e01
  type SubRule =
    (SEDEL.Source.Syntax.SType, SEDEL.Source.Syntax.SType)
5b9379518fd075302eb8ecdf5e46e9da
  data Substitution
    = EmptyS
    | PosS SEDEL.Source.Syntax.TyName
           SEDEL.Source.Syntax.SType
           SEDEL.Source.Inference.Substitution
    | NegS SEDEL.Source.Syntax.TyName
           SEDEL.Source.Syntax.SType
           SEDEL.Source.Inference.Substitution
594bd9149eab79e8fb42881719413b98
  tcModule ::
    SEDEL.Source.Syntax.Module
    -> SEDEL.Environment.TcMonad
         (SEDEL.Source.Syntax.Scheme, SEDEL.Target.Syntax.UExpr)
  {- Arity: 1, Strictness: <L,1*U(1*U,1*U(1*U(U,A,U,1*U,A,A)))>,
     Unfolding: (\ (m :: SEDEL.Source.Syntax.Module) ->
                 let {
                   m1 :: SEDEL.Environment.TcMonad
                           (SEDEL.Source.Syntax.Scheme, SEDEL.Target.Syntax.UExpr)
                   = case m of wild { SEDEL.Source.Syntax.Module ds1 ds2 ->
                     SEDEL.Source.Inference.tcModule_tcM
                       (GHC.Base.map
                          @ SEDEL.Source.Syntax.SDecl
                          @ SEDEL.Source.Syntax.SDecl
                          SEDEL.Source.Desugar.desugar1
                          ds1)
                       (case ds2 of wild1 { SEDEL.Source.Syntax.DefDecl mainE ->
                        case mainE of wild2 { SEDEL.Source.Syntax.TmBind ds ds4 ds5 ds3 ds6 ds7 ->
                        SEDEL.Source.Syntax.TmBind
                          ds
                          ds4
                          ds5
                          (SEDEL.Source.Desugar.desugarTmBind1 ds3)
                            `cast`
                          (Data.Functor.Identity.N:Identity[0] <SEDEL.Source.Syntax.Expr>_R)
                          ds6
                          ds7 } }) }
                 } in
                 (\ (s1 :: GHC.Integer.Type.Integer) ->
                  let {
                    m2 :: Control.Monad.Trans.Reader.ReaderT
                            SEDEL.Environment.Ctx
                            (Control.Monad.Trans.Except.ExceptT
                               SEDEL.Environment.Err GHC.Types.IO)
                            ((SEDEL.Source.Syntax.Scheme, SEDEL.Target.Syntax.UExpr),
                             GHC.Integer.Type.Integer)
                    = m1
                        `cast`
                      (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0] <Control.Monad.Trans.Reader.ReaderT
                                                                              SEDEL.Environment.Ctx
                                                                              (Control.Monad.Trans.Except.ExceptT
                                                                                 SEDEL.Environment.Err
                                                                                 GHC.Types.IO)>_N <(SEDEL.Source.Syntax.Scheme,
                                                                                                    SEDEL.Target.Syntax.UExpr)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                        <GHC.Integer.Type.Integer>_N
                                                                                                                                        <Control.Monad.Trans.Reader.ReaderT
                                                                                                                                           SEDEL.Environment.Ctx
                                                                                                                                           (Control.Monad.Trans.Except.ExceptT
                                                                                                                                              SEDEL.Environment.Err
                                                                                                                                              GHC.Types.IO)>_R
                                                                                                                                        <(SEDEL.Source.Syntax.Scheme,
                                                                                                                                          SEDEL.Target.Syntax.UExpr)>_N)
                        s1
                  } in
                  (\ (r1 :: SEDEL.Environment.Ctx)
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (m2
                           `cast`
                         (Control.Monad.Trans.Reader.N:ReaderT[0]
                              <*>_N
                              <SEDEL.Environment.Ctx>_R
                              <Control.Monad.Trans.Except.ExceptT
                                 SEDEL.Environment.Err GHC.Types.IO>_R
                              <((SEDEL.Source.Syntax.Scheme, SEDEL.Target.Syntax.UExpr),
                                GHC.Integer.Type.Integer)>_N)
                           r1)
                          `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <SEDEL.Environment.Err>_N
                             <GHC.Types.IO>_R
                             <((SEDEL.Source.Syntax.Scheme, SEDEL.Target.Syntax.UExpr),
                               GHC.Integer.Type.Integer)>_N ; GHC.Types.N:IO[0]
                                                                  <Data.Either.Either
                                                                     SEDEL.Environment.Err
                                                                     ((SEDEL.Source.Syntax.Scheme,
                                                                       SEDEL.Target.Syntax.UExpr),
                                                                      GHC.Integer.Type.Integer)>_R)
                          s of ds1 { (#,#) ipv ipv1 ->
                   case ipv1 of wild {
                     Data.Either.Left e1 -> ds1
                     Data.Either.Right x
                     -> case x of wild1 { (,) a1 s' ->
                        case a1 of wild2 { (,) ty target -> ds1 } } } })
                    `cast`
                  ((<SEDEL.Environment.Ctx>_R
                    ->_R Sym (GHC.Types.N:IO[0]
                                  <Data.Either.Either
                                     SEDEL.Environment.Err
                                     ((SEDEL.Source.Syntax.Scheme, SEDEL.Target.Syntax.UExpr),
                                      GHC.Integer.Type.Integer)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                               <SEDEL.Environment.Err>_N
                                                                               <GHC.Types.IO>_R
                                                                               <((SEDEL.Source.Syntax.Scheme,
                                                                                  SEDEL.Target.Syntax.UExpr),
                                                                                 GHC.Integer.Type.Integer)>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                           <*>_N
                                                                                                                           <SEDEL.Environment.Ctx>_R
                                                                                                                           <Control.Monad.Trans.Except.ExceptT
                                                                                                                              SEDEL.Environment.Err
                                                                                                                              GHC.Types.IO>_R
                                                                                                                           <((SEDEL.Source.Syntax.Scheme,
                                                                                                                              SEDEL.Target.Syntax.UExpr),
                                                                                                                             GHC.Integer.Type.Integer)>_N)))
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <GHC.Integer.Type.Integer>_N
                           <Control.Monad.Trans.Reader.ReaderT
                              SEDEL.Environment.Ctx
                              (Control.Monad.Trans.Except.ExceptT
                                 SEDEL.Environment.Err GHC.Types.IO)>_R
                           <(SEDEL.Source.Syntax.Scheme,
                             SEDEL.Target.Syntax.UExpr)>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                                           SEDEL.Environment.Ctx
                                                                                                                           (Control.Monad.Trans.Except.ExceptT
                                                                                                                              SEDEL.Environment.Err
                                                                                                                              GHC.Types.IO)>_N <(SEDEL.Source.Syntax.Scheme,
                                                                                                                                                 SEDEL.Target.Syntax.UExpr)>_N)) -}
2925be203f2404c82ba0749ab360c9d4
  tcModule_tcM ::
    [SEDEL.Source.Syntax.SDecl]
    -> SEDEL.Source.Syntax.TmBind
    -> SEDEL.Environment.TcMonad
         (SEDEL.Source.Syntax.Scheme, SEDEL.Target.Syntax.UExpr)
  {- Arity: 2, Strictness: <S,1*U><L,U(U,A,U,U,A,A)> -}
"SPEC/SEDEL.Source.Inference $fAlphaEmbed @ Scheme" [orphan] forall (v :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                            SEDEL.Source.Syntax.Scheme)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed @ SEDEL.Source.Syntax.Scheme
                                                      v
  = SEDEL.Source.Inference.$s$fAlpha(,)_$s$fAlphaEmbed
"SPEC/SEDEL.Source.Inference $fAlphaEmbed_$cacompare' @ Scheme" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                              SEDEL.Source.Syntax.Scheme)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cacompare' @ SEDEL.Source.Syntax.Scheme
                                                                  $dAlpha
  = SEDEL.Source.Inference.$s$fAlphaEmbed_$cacompare'
"SPEC/SEDEL.Source.Inference $fAlphaEmbed_$caeq' @ Scheme" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                         SEDEL.Source.Syntax.Scheme)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$caeq' @ SEDEL.Source.Syntax.Scheme
                                                             $dAlpha
  = SEDEL.Source.Inference.$s$fAlphaEmbed_$caeq'
"SPEC/SEDEL.Source.Inference $fAlphaEmbed_$cclose @ Scheme" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                          SEDEL.Source.Syntax.Scheme)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cclose @ SEDEL.Source.Syntax.Scheme
                                                              $dAlpha
  = SEDEL.Source.Inference.$s$fAlphaEmbed_$cclose
"SPEC/SEDEL.Source.Inference $fAlphaEmbed_$cfreshen' @ Scheme" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                             SEDEL.Source.Syntax.Scheme)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cfreshen' @ SEDEL.Source.Syntax.Scheme
                                                                 $dAlpha
  = SEDEL.Source.Inference.$s$fAlphaEmbed_$cfreshen'
"SPEC/SEDEL.Source.Inference $fAlphaEmbed_$cisPat @ Scheme" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                          SEDEL.Source.Syntax.Scheme)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cisPat @ SEDEL.Source.Syntax.Scheme
                                                              $dAlpha
  = SEDEL.Source.Inference.$s$fAlphaEmbed_$cisPat
"SPEC/SEDEL.Source.Inference $fAlphaEmbed_$copen @ Scheme" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                         SEDEL.Source.Syntax.Scheme)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$copen @ SEDEL.Source.Syntax.Scheme
                                                             $dAlpha
  = SEDEL.Source.Inference.$s$fAlphaEmbed_$copen
"SPEC/SEDEL.Source.Inference $fAlphaEmbed_$cswaps' @ Scheme" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                           SEDEL.Source.Syntax.Scheme)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cswaps' @ SEDEL.Source.Syntax.Scheme
                                                               $dAlpha
  = SEDEL.Source.Inference.$s$fAlphaEmbed_$cswaps'
"SPEC/SEDEL.Source.Inference $fApplicativeExceptT @ IO _" [orphan] forall @ e
                                                                          (v1 :: GHC.Base.Monad
                                                                                   GHC.Types.IO)
                                                                          (v :: GHC.Base.Functor
                                                                                  GHC.Types.IO)
  Control.Monad.Trans.Except.$fApplicativeExceptT @ GHC.Types.IO
                                                  @ e
                                                  v
                                                  v1
  = SEDEL.Source.Inference.$s$fApplicativeExceptT @ e
"SPEC/SEDEL.Source.Inference $fApplicativeExceptT_$c*> @ IO _" [orphan] forall @ e
                                                                               ($dMonad :: GHC.Base.Monad
                                                                                             GHC.Types.IO)
                                                                               ($dFunctor :: GHC.Base.Functor
                                                                                               GHC.Types.IO)
  Control.Monad.Trans.Except.$fApplicativeExceptT_$c*> @ GHC.Types.IO
                                                       @ e
                                                       $dFunctor
                                                       $dMonad
  = SEDEL.Source.Inference.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$c*>
      @ e
"SPEC/SEDEL.Source.Inference $fApplicativeExceptT_$cpure @ IO _" [orphan] forall @ e
                                                                                 ($dMonad :: GHC.Base.Monad
                                                                                               GHC.Types.IO)
                                                                                 ($dFunctor :: GHC.Base.Functor
                                                                                                 GHC.Types.IO)
  Control.Monad.Trans.Except.$fApplicativeExceptT_$cpure @ GHC.Types.IO
                                                         @ e
                                                         $dFunctor
                                                         $dMonad
  = SEDEL.Source.Inference.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure
      @ e
"SPEC/SEDEL.Source.Inference $fApplicativeFreshMT @ (ReaderT
                                                      Ctx (ExceptT Err IO))" [orphan] forall (v :: GHC.Base.Monad
                                                                                                                                                                  (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                     SEDEL.Environment.Ctx
                                                                                                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                        SEDEL.Environment.Err
                                                                                                                                                                        GHC.Types.IO)))
  Unbound.Generics.LocallyNameless.Fresh.$fApplicativeFreshMT @ (Control.Monad.Trans.Reader.ReaderT
                                                                   SEDEL.Environment.Ctx
                                                                   (Control.Monad.Trans.Except.ExceptT
                                                                      SEDEL.Environment.Err
                                                                      GHC.Types.IO))
                                                              v
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT
"SPEC/SEDEL.Source.Inference $fApplicativeReaderT @ (ExceptT
                                                      Err IO) _" [orphan] forall @ r
                                                                                                                                              (v :: GHC.Base.Applicative
                                                                                                                                                      (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                         SEDEL.Environment.Err
                                                                                                                                                         GHC.Types.IO))
  Control.Monad.Trans.Reader.$fApplicativeReaderT @ (Control.Monad.Trans.Except.ExceptT
                                                       SEDEL.Environment.Err GHC.Types.IO)
                                                  @ r
                                                  v
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fApplicativeReaderT
      @ r
"SPEC/SEDEL.Source.Inference $fApplicativeReaderT_$c*> @ (ExceptT
                                                           Err IO) _" [orphan] forall @ r
                                                                                                                                                        ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                            (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                               SEDEL.Environment.Err
                                                                                                                                                                               GHC.Types.IO))
  Control.Monad.Trans.Reader.$fApplicativeReaderT_$c*> @ (Control.Monad.Trans.Except.ExceptT
                                                            SEDEL.Environment.Err GHC.Types.IO)
                                                       @ r
                                                       $dApplicative
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fApplicativeReaderT_$c*>
      @ r
"SPEC/SEDEL.Source.Inference $fApplicativeReaderT_$c<* @ (ExceptT
                                                           Err IO) _" [orphan] forall @ r
                                                                                                                                                        ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                            (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                               SEDEL.Environment.Err
                                                                                                                                                                               GHC.Types.IO))
  Control.Monad.Trans.Reader.$fApplicativeReaderT_$c<* @ (Control.Monad.Trans.Except.ExceptT
                                                            SEDEL.Environment.Err GHC.Types.IO)
                                                       @ r
                                                       $dApplicative
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fApplicativeReaderT_$c<*
      @ r
"SPEC/SEDEL.Source.Inference $fApplicativeReaderT_$c<*> @ (ExceptT
                                                            Err IO) _" [orphan] forall @ r
                                                                                                                                                          ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                              (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                 SEDEL.Environment.Err
                                                                                                                                                                                 GHC.Types.IO))
  Control.Monad.Trans.Reader.$fApplicativeReaderT_$c<*> @ (Control.Monad.Trans.Except.ExceptT
                                                             SEDEL.Environment.Err GHC.Types.IO)
                                                        @ r
                                                        $dApplicative
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fApplicativeReaderT_$c<*>
      @ r
"SPEC/SEDEL.Source.Inference $fFunctorExceptT @ IO _" [orphan] forall @ e
                                                                      (v :: GHC.Base.Functor
                                                                              GHC.Types.IO)
  Control.Monad.Trans.Except.$fFunctorExceptT @ GHC.Types.IO @ e v
  = SEDEL.Source.Inference.$s$fApplicativeExceptT_$s$fFunctorExceptT
      @ e
"SPEC/SEDEL.Source.Inference $fFunctorFreshMT @ (ReaderT
                                                  Ctx (ExceptT Err IO))" [orphan] forall (v :: GHC.Base.Functor
                                                                                                                                                          (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                             SEDEL.Environment.Ctx
                                                                                                                                                             (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                SEDEL.Environment.Err
                                                                                                                                                                GHC.Types.IO)))
  Unbound.Generics.LocallyNameless.Fresh.$fFunctorFreshMT @ (Control.Monad.Trans.Reader.ReaderT
                                                               SEDEL.Environment.Ctx
                                                               (Control.Monad.Trans.Except.ExceptT
                                                                  SEDEL.Environment.Err
                                                                  GHC.Types.IO))
                                                          v
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorFreshMT
"SPEC/SEDEL.Source.Inference $fFunctorReaderT @ (ExceptT Err IO) _" [orphan] forall @ r
                                                                                    (v :: GHC.Base.Functor
                                                                                            (Control.Monad.Trans.Except.ExceptT
                                                                                               SEDEL.Environment.Err
                                                                                               GHC.Types.IO))
  Control.Monad.Trans.Reader.$fFunctorReaderT @ (Control.Monad.Trans.Except.ExceptT
                                                   SEDEL.Environment.Err GHC.Types.IO)
                                              @ r
                                              v
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorReaderT
      @ r
"SPEC/SEDEL.Source.Inference $fFunctorReaderT_$c<$ @ (ExceptT
                                                       Err IO) _" [orphan] forall @ r
                                                                                                                                                ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                   SEDEL.Environment.Err
                                                                                                                                                                   GHC.Types.IO))
  Control.Monad.Trans.Reader.$fFunctorReaderT_$c<$ @ (Control.Monad.Trans.Except.ExceptT
                                                        SEDEL.Environment.Err GHC.Types.IO)
                                                   @ r
                                                   $dFunctor
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorReaderT_$c<$
      @ r
"SPEC/SEDEL.Source.Inference $fFunctorReaderT_$cfmap @ (ExceptT
                                                         Err IO) _" [orphan] forall @ r
                                                                                                                                                    ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                    (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                       SEDEL.Environment.Err
                                                                                                                                                                       GHC.Types.IO))
  Control.Monad.Trans.Reader.$fFunctorReaderT_$cfmap @ (Control.Monad.Trans.Except.ExceptT
                                                          SEDEL.Environment.Err GHC.Types.IO)
                                                     @ r
                                                     $dFunctor
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorReaderT_$cfmap
      @ r
"SPEC/SEDEL.Source.Inference $fFunctorStateT1 @ (ReaderT
                                                  Ctx (ExceptT Err IO)) _" [orphan] forall @ s
                                                                                                                                                    ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                    (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                       SEDEL.Environment.Ctx
                                                                                                                                                                       (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                          SEDEL.Environment.Err
                                                                                                                                                                          GHC.Types.IO)))
  Control.Monad.Trans.State.Lazy.$fFunctorStateT1 @ (Control.Monad.Trans.Reader.ReaderT
                                                       SEDEL.Environment.Ctx
                                                       (Control.Monad.Trans.Except.ExceptT
                                                          SEDEL.Environment.Err GHC.Types.IO))
                                                  @ s
                                                  $dFunctor
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorStateT1
      @ s
"SPEC/SEDEL.Source.Inference $fFunctorStateT_$cfmap @ (ReaderT
                                                        Ctx (ExceptT Err IO)) _" [orphan] forall @ s
                                                                                                                                                                ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                                   SEDEL.Environment.Ctx
                                                                                                                                                                                   (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                      SEDEL.Environment.Err
                                                                                                                                                                                      GHC.Types.IO)))
  Control.Monad.Trans.State.Lazy.$fFunctorStateT_$cfmap @ (Control.Monad.Trans.Reader.ReaderT
                                                             SEDEL.Environment.Ctx
                                                             (Control.Monad.Trans.Except.ExceptT
                                                                SEDEL.Environment.Err GHC.Types.IO))
                                                        @ s
                                                        $dFunctor
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorStateT_$cfmap
      @ s
"SPEC/SEDEL.Source.Inference $fMonadFreshMT @ (ReaderT
                                                Ctx (ExceptT Err IO))" [orphan] forall (v :: GHC.Base.Monad
                                                                                                                                                      (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                         SEDEL.Environment.Ctx
                                                                                                                                                         (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                            SEDEL.Environment.Err
                                                                                                                                                            GHC.Types.IO)))
  Unbound.Generics.LocallyNameless.Fresh.$fMonadFreshMT @ (Control.Monad.Trans.Reader.ReaderT
                                                             SEDEL.Environment.Ctx
                                                             (Control.Monad.Trans.Except.ExceptT
                                                                SEDEL.Environment.Err GHC.Types.IO))
                                                        v
  = SEDEL.Source.Inference.$s$fFreshFreshMT_$s$fMonadFreshMT
"SPEC/SEDEL.Source.Inference $fMonadReaderT @ (ExceptT Err IO) _" [orphan] forall @ r
                                                                                  (v :: GHC.Base.Monad
                                                                                          (Control.Monad.Trans.Except.ExceptT
                                                                                             SEDEL.Environment.Err
                                                                                             GHC.Types.IO))
  Control.Monad.Trans.Reader.$fMonadReaderT @ (Control.Monad.Trans.Except.ExceptT
                                                 SEDEL.Environment.Err GHC.Types.IO)
                                            @ r
                                            v
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fMonadReaderT
      @ r
"SPEC/SEDEL.Source.Inference $fMonadReaderT_$c>>= @ (ExceptT
                                                      Err IO) _" [orphan] forall @ r
                                                                                                                                              ($dMonad :: GHC.Base.Monad
                                                                                                                                                            (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                               SEDEL.Environment.Err
                                                                                                                                                               GHC.Types.IO))
  Control.Monad.Trans.Reader.$fMonadReaderT_$c>>= @ (Control.Monad.Trans.Except.ExceptT
                                                       SEDEL.Environment.Err GHC.Types.IO)
                                                  @ r
                                                  $dMonad
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fMonadReaderT_$c>>=
      @ r
"SPEC/SEDEL.Source.Inference $fMonadReaderT_$cfail @ (ExceptT
                                                       Err IO) _" [orphan] forall @ r
                                                                                                                                                ($dMonad :: GHC.Base.Monad
                                                                                                                                                              (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                 SEDEL.Environment.Err
                                                                                                                                                                 GHC.Types.IO))
  Control.Monad.Trans.Reader.$fMonadReaderT_$cfail @ (Control.Monad.Trans.Except.ExceptT
                                                        SEDEL.Environment.Err GHC.Types.IO)
                                                   @ r
                                                   $dMonad
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fMonadReaderT_$cfail
      @ r
"SPEC/SEDEL.Source.Inference $fMonadStateT_$c>> @ (ReaderT
                                                    Ctx (ExceptT Err IO)) _" [orphan] forall @ s
                                                                                                                                                        ($dMonad :: GHC.Base.Monad
                                                                                                                                                                      (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                         SEDEL.Environment.Ctx
                                                                                                                                                                         (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                            SEDEL.Environment.Err
                                                                                                                                                                            GHC.Types.IO)))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>> @ (Control.Monad.Trans.Reader.ReaderT
                                                         SEDEL.Environment.Ctx
                                                         (Control.Monad.Trans.Except.ExceptT
                                                            SEDEL.Environment.Err GHC.Types.IO))
                                                    @ s
                                                    $dMonad
  = SEDEL.Source.Inference.$s$fFreshFreshMT_$s$fMonadStateT_$c>> @ s
"SPEC/SEDEL.Source.Inference $fMonadStateT_$c>>= @ (ReaderT
                                                     Ctx (ExceptT Err IO)) _" [orphan] forall @ s
                                                                                                                                                          ($dMonad :: GHC.Base.Monad
                                                                                                                                                                        (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                           SEDEL.Environment.Ctx
                                                                                                                                                                           (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                              SEDEL.Environment.Err
                                                                                                                                                                              GHC.Types.IO)))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>>= @ (Control.Monad.Trans.Reader.ReaderT
                                                          SEDEL.Environment.Ctx
                                                          (Control.Monad.Trans.Except.ExceptT
                                                             SEDEL.Environment.Err GHC.Types.IO))
                                                     @ s
                                                     $dMonad
  = SEDEL.Source.Inference.$s$fFreshFreshMT_$s$fMonadStateT_$c>>= @ s
"SPEC/SEDEL.Source.Inference $fMonadStateT_$cfail @ (ReaderT
                                                      Ctx (ExceptT Err IO)) _" [orphan] forall @ s
                                                                                                                                                            ($dMonad :: GHC.Base.Monad
                                                                                                                                                                          (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                             SEDEL.Environment.Ctx
                                                                                                                                                                             (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                SEDEL.Environment.Err
                                                                                                                                                                                GHC.Types.IO)))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$cfail @ (Control.Monad.Trans.Reader.ReaderT
                                                           SEDEL.Environment.Ctx
                                                           (Control.Monad.Trans.Except.ExceptT
                                                              SEDEL.Environment.Err GHC.Types.IO))
                                                      @ s
                                                      $dMonad
  = SEDEL.Source.Inference.$s$fFreshFreshMT_$s$fMonadStateT_$cfail
      @ s
"SPEC/SEDEL.Source.Inference $fShowEmbed @ Scheme" [orphan] forall (v :: GHC.Show.Show
                                                                           SEDEL.Source.Syntax.Scheme)
  Unbound.Generics.LocallyNameless.Embed.$fShowEmbed @ SEDEL.Source.Syntax.Scheme
                                                     v
  = SEDEL.Source.Inference.$s$fAlpha(,)_$s$fShowEmbed
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

