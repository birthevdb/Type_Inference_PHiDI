
==================== FINAL INTERFACE ====================
2019-08-12 12:24:59.607867 UTC

interface sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.Source.Inference 8063
  interface hash: e946323d6afacf873c337a806d6db6dc
  ABI hash: 7368c3ca56d42ec3dd60dd13d41dedcd
  export-list hash: e676ab92d73529ef24aa94f8bb5e7b2b
  orphan hash: f477a36db1668ddfef72a854c256f62b
  flag hash: 5455c992fe6bc042952aad8f14bafb4c
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  SEDEL.Source.Inference.tcModule
  SEDEL.Source.Inference.topLevelInfer
module dependencies: SEDEL.Common SEDEL.Environment
                     SEDEL.Intermediate.Desugar SEDEL.Intermediate.Subtyping
                     SEDEL.Intermediate.Syntax SEDEL.Intermediate.TypeCheck
                     SEDEL.PrettyPrint SEDEL.Source.Desugar SEDEL.Source.Syntax
                     SEDEL.Target.Syntax SEDEL.Translations SEDEL.Util
package dependencies: array-0.5.3.0 async-2.2.1 base-4.12.0.0
                      base-orphans-0.8 bifunctors-5.5.3 binary-0.8.6.0
                      bytestring-0.10.8.2 comonad-5.0.4 containers-0.6.0.1
                      deepseq-1.4.4.0 distributive-0.6 exceptions-0.10.0
                      ghc-boot-th-8.6.3 ghc-prim-0.5.3 hashable-1.2.7.0
                      integer-gmp-1.0.2.0 megaparsec-7.0.4 mtl-2.2.2
                      parser-combinators-1.0.1 pretty-1.1.3.6 prettyprinter-1.2.1
                      profunctors-5.3 protolude-0.2.3 stm-2.5.0.0 tagged-0.8.6
                      template-haskell-2.14.0.0 text-1.2.3.1 transformers-0.5.5.0
                      unbound-generics-0.4.0
orphans: sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.PrettyPrint
         sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.Source.Syntax
         sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.Intermediate.Syntax
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.1:Data.Text.Lazy
         text-1.2.3.1:Data.Text binary-0.8.6.0:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show stm-2.5.0.0:Control.Monad.STM
         transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         bifunctors-5.5.3:Data.Bifunctor.Biff
                         bifunctors-5.5.3:Data.Bifunctor.Clown
                         bifunctors-5.5.3:Data.Bifunctor.Joker
                         bifunctors-5.5.3:Data.Bifunctor.Product
                         bifunctors-5.5.3:Data.Bifunctor.Sum
                         bifunctors-5.5.3:Data.Bifunctor.Tannen
                         containers-0.6.0.1:Data.IntMap.Internal
                         containers-0.6.0.1:Data.IntSet.Internal
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Sequence.Internal
                         containers-0.6.0.1:Data.Set.Internal containers-0.6.0.1:Data.Tree
                         ghc-boot-th-8.6.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.6.3:GHC.LanguageExtensions.Type
                         megaparsec-7.0.4:Text.Megaparsec.Error
                         megaparsec-7.0.4:Text.Megaparsec.Pos
                         megaparsec-7.0.4:Text.Megaparsec.State
                         megaparsec-7.0.4:Text.Megaparsec.Stream
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         prettyprinter-1.2.1:Data.Text.Prettyprint.Doc.Internal
                         sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.Common
                         sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.Intermediate.Syntax
                         sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.Source.Syntax
                         sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ:SEDEL.Target.Syntax
                         tagged-0.8.6:Data.Tagged
                         template-haskell-2.14.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.1:Data.Text text-1.2.3.1:Data.Text.Lazy
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Bind
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Embed
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Ignore
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Name
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Rebind
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Rec
                         unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Shift
import  -/  base-4.12.0.0:Data.Foldable 00188ddf89c975fee76bdfad479443c1
import  -/  base-4.12.0.0:Data.Tuple c92a835d04b6c075a7031d4e28e53c71
import  -/  base-4.12.0.0:Debug.Trace 6e89d30f3850c77c707392fc46e9b589
import  -/  base-4.12.0.0:GHC.Base cc906f98291a1b830546e99a96674547
import  -/  base-4.12.0.0:GHC.Show 4e438f26d903388cc6c2c5d64ed01b98
import  -/  containers-0.6.0.1:Data.Set fbecd72656fbabb1b6d7c0788f3c4311
import  -/  containers-0.6.0.1:Data.Set.Internal f43887e2e489c4f3cc531d428708a7e6
import  -/  ghc-prim-0.5.3:GHC.Classes e0d9c979f6368701f34fa421754d2cce
import  -/  prettyprinter-1.2.1:Data.Text.Prettyprint.Doc 37bebc045f3a0cb8e8977c181970ecaf
import  -/  prettyprinter-1.2.1:Data.Text.Prettyprint.Doc.Internal 12d379fe6b8bbcab8bffc2d86df0e72f
import  -/  protolude-0.2.3:Protolude f69a0445642f255f4ede68732259560a
import  -/  SEDEL.Common ca6f88eb795bfe7d09e23d21fb3eb87f
  exports: 576471b9a47b800d5ba3919671488556
  Arith 477cbffa1e7281d92b0f71e3720dc821
  Comp 348f8575ea4d65185d0a29b6b8a92535
  Logical 5837ab3db90e339a87f10215bf5c0d98
import  -/  SEDEL.Environment d8bc650b7b97515a31f95e90c47efbdd
  exports: ee616ba5663dcc7668ccee4c280f41a3
  ITcMonad a663a611543ff4fb45576a560dd27aee
  STcMonad bb11cf842b3626b2d0a16273640f848c
  askCtx 7c1fc2ffe7762d1407261a9db8098ead
  errThrow 9b366fb6bce0343330f033f46888d5f8
  extendSourceLocation 0017739aeb1de8a127ef3095d7fba865
  extendVarCtx f10937fb0d700bcf9a21943ad3a4937f
  localCtx f7079019db813b242790e85f6101c903
  lookupTmDef c82a3c0b7eef4f69ecf35f84deb3920b
  lookupVarTy 26f2411054e0e29e4c5317da6665eac1
import  -/  SEDEL.Intermediate.Syntax f958fad6e88fb88eb220133854cd0fcf
  exports: 205c54e0e633701a9c7db27d9e71b968
  Acc 50449da8b79b6403275760f7c0f05ece
  And 15e1ded2f3bbcadc4162e4e119116ac9
  Anno 3b8b799c79e61b639c9369f6ac2bf4a7
  App ff2525441e5744c6dea8924ba85c5a89
  Arr 67bf5e54ab670aa4667f502840078175
  BoolT 10944865bc1859b72c3ba7f72dd63352
  BoolV 4e5f762e3449257dcbb3a6502f310b3c
  Bot 34d4918473f5638a6014941164b5887c
  BotT f96e7b92a373f30b30ed7c95531b198e
  DForall 6c1938680f5feebfa496fd3397ed5f1a
  DLam 223568e4f79a45b36c353b67b444df5d
  DRec' 195b7777b4066207efa79fa4c302ae9e
  FExpr bfd7da9f3e523c5cb9c209b4524af79c
  FType bfd7da9f3e523c5cb9c209b4524af79c
  If 726850f641f43936ed8a48922dec3845
  Lam 791c9dff8a0786da361ef25db8d8b8df
  LamA 14e691aa41f51a6791a7fb524a19dd47
  Letrec 19373a9fddf613155330e1de49c97a1d
  LitV 96c0449095baa9dc5fda4fc089c789b8
  Merge cf7e9ccafa838993db0db179148b5c9b
  NumT ccfcdffde64466a60dbb3dddbad25fae
  OpAbs 3d0162f4719435365b2a7c3d6a4c681b
  OpApp 149705c7531f3d1c949e153714b028a2
  Pos 56e7d56eddb105a3d7f1db50a1f1411e
  PrimOp e099b50bc31f3b0384a9ac0ceff59e5d
  Rec aed03fd874984984aa1bdab4a623bbd6
  Remove 9ecf3cc3609521576db3213519e5bf82
  SRecT f1108eca326ecc8b5cca8b18388ffffc
  TApp 2643e03238f98b08f49fc556fb26e0dd
  TVar 28a05eb0107d74d23292c869b32cb560
  Top fde26466ae2af9fe577da69bde44781b
  TopT 468057410ade7257fcfc41c369faaefb
  Var 731cc8c46e98b27624ba7cb24de70db3
import  -/  SEDEL.Intermediate.TypeCheck de4ede6c1afe2f2154c0b0a224d12c30
  exports: 66ae3a5106a601eac38789906f42f0f1
  bidirect 51beeb93bfc0bbc472add2307c9f081e
import  -/  SEDEL.PrettyPrint a34bffe1a10b43afb675c089919de4ed
  exports: 143f4b15e4a5a88e60030586dbaf2fd5
  DD 1eae107cabd0391d960075bba08dee9c
  DS 976d03e5d5e922389ab372fc4ef2aca9
import  -/  SEDEL.Source.Desugar 20ed66810c076b1d7e17421ae8bfcfeb
  exports: d7d075316e2e64861442d904030d79b9
  desugarTmBind 2f2fb11a9b8335a13868ab316498b2e9
  normalizeTmDecl 9aca1e59ca48302d41c3a955f0d2657e
import  -/  SEDEL.Source.Syntax ec83a0da1c10765115fe4a9f09c754b0
  exports: 9689242b0decab272007a11f45b72d7d
  And 0283b9e7440c4a3e47a1281e02970dde
  App c363422f50778c82e96747329eb9877e
  Arr df83e91aec2f80dc9d042375099bb771
  BoolT 21df8d7d01d510390fe4d585a4a596cd
  BoolV a99acac4209ebf13e71934080c423400
  BotT 77bd90a3bcfd29395ef1007b8a6a4ee6
  CtxSch 4ed625f0c5623da737d8111abd26a02d
  CtxUni e311e52302dce918c35f87bc8eac2da6
  DForall 0b90eb4f4665e714927dfbf10c3a2bda
  DefDecl 0bcb0cf0edd018dbef851783eba7cbb7
  Expr 350069ed8c9e308e7d171878eb06250d
  If 8adb062a80541f4537caeee81d7bc725
  Join fd0576a7fff161cbb30df37e3fc17cf8
  Label e739a3e6552cb99dfb25d8219b847fb6
  Lam 63512428e48d94b955997c9b670e149e
  Let 01c008f6cf31bc0acec7ee6debf6c39a
  LitV 0126dc7c0aca06604ce1c1866a4ca27b
  Meet 06799f30830af46a66c37e86fd796d49
  Merge 8618c4cff7c45435653614618dd77223
  Module d782678268308b8c889017b135bdd9f9
  NumT 539f9e6436bb2f46e0e1ed9aac813b1c
  P 38a54183865af29e6bb4dc58fd09aac0
  PAnd cb1bd11c644393f565803985f1abb20a
  PArr fe2a99d0131aa33b0f29a163b75d9b28
  PRecT c1e591e772f6b5a79d9cb0460894b674
  PType 350069ed8c9e308e7d171878eb06250d
  Pos caef810378ba48ca7966a52d7584d18f
  PrimOp 459db753a665a5d3d985408f034250f5
  Proj c9b17242d24bcebd4dda5844c7db7905
  Rec f54127b91625470e365ba58cc88fab42
  SRecT 4b07dd6d7293a4e5e53901cef6634094
  SType 2633b8b7955e013a3831a0582461061f
  SType 350069ed8c9e308e7d171878eb06250d
  Scheme 350069ed8c9e308e7d171878eb06250d
  TUni 350069ed8c9e308e7d171878eb06250d
  TVar 2d4c55a015b709b4614fff76215f0c95
  TmBind 350069ed8c9e308e7d171878eb06250d
  TmName 350069ed8c9e308e7d171878eb06250d
  Top 98e3b66dfbd16b59d9fe44f403ad750d
  TopT fa9c823349a4c24a48445d1081f1a548
  TyName 350069ed8c9e308e7d171878eb06250d
  Uni d569eef21041c954137d696a69bd704e
  Var 631e2156171f241947a37d09f9c20f3b
  mainExpr d782678268308b8c889017b135bdd9f9
import  -/  SEDEL.Target.Syntax f9564d1c960bf10a7f1f0df869d96941
  exports: 3e59938cb32396b7de7df23e937c55e6
  UExpr 0e81733f87df4b0be304d19977d9bf74
  UName 0e81733f87df4b0be304d19977d9bf74
import  -/  SEDEL.Translations 0dfc0348b4cbac2672b41df877291b98
  exports: 46cb638795fc3a212ad7feaba47a5e71
  sCtxtoICtx f5236f8ada0ab2d15bd81af0dc3d7f62
  translPType 0eca4251160f6cfde602b43d92a0a2cf
  translSType 5937d8642b1dbdcba7dcec2ca40c53b4
  translType b5ce5f4a294ba265b0b655f4f4fc962f
  translate 7afa07d5601693ebfa1f91cb0ebfa164
import  -/  SEDEL.Util c1534bfc592d5431439a65f47bff8b46
  exports: a4b496c924b84e318819b4bae94d6d7e
  getFreshUni fa636c9987c2e4947d117749c9f9e8d0
  topLike c999a92eaaa2d88a1cc774ffc43b62c5
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Class f3e62b8b4b5be304a48413d1f1e4625e
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Reader 3d5c6b0df34d74144ad9d24efee0de98
import  -/  unbound-generics-0.4.0:Unbound.Generics.LocallyNameless 36704d4dbfb3fb22f46cde363ae796f2
import  -/  unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Embed f74cff3aea20e9a2f5e6bfc539a9689b
import  -/  unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Fresh e0f8d49fe8e0f78dfcabb34436892778
import  -/  unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Name 81d6e7baa0bd0880e550478df477614a
import  -/  unbound-generics-0.4.0:Unbound.Generics.LocallyNameless.Operations d0c219408974b95413509bf76023577c
623f9de3e6377749a2ae3144bc15623e
  $fShowDelta :: GHC.Show.Show SEDEL.Source.Inference.Delta
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ SEDEL.Source.Inference.Delta
                  SEDEL.Source.Inference.$fShowDelta_$cshowsPrec
                  SEDEL.Source.Inference.$fShowDelta_$cshow
                  SEDEL.Source.Inference.$fShowDelta_$cshowList -}
623f9de3e6377749a2ae3144bc15623e
  $fShowDelta1 :: SEDEL.Source.Inference.Delta -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (SEDEL.Source.Inference.$fShowDelta_$cshowsPrec
                   SEDEL.Source.Inference.$fShowDelta2) -}
b4b450e8f9b1b3127bbacd025bfdde44
  $fShowDelta2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
623f9de3e6377749a2ae3144bc15623e
  $fShowDelta_$cshow ::
    SEDEL.Source.Inference.Delta -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: SEDEL.Source.Inference.Delta) ->
                 SEDEL.Source.Inference.$fShowDelta_$cshowsPrec
                   SEDEL.Source.Inference.$fShowDelta2
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
623f9de3e6377749a2ae3144bc15623e
  $fShowDelta_$cshowList ::
    [SEDEL.Source.Inference.Delta] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [SEDEL.Source.Inference.Delta]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ SEDEL.Source.Inference.Delta
                   SEDEL.Source.Inference.$fShowDelta1
                   ls
                   s) -}
623f9de3e6377749a2ae3144bc15623e
  $fShowDelta_$cshowsPrec ::
    GHC.Types.Int -> SEDEL.Source.Inference.Delta -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U> -}
263a177e1fcb33eaba9b791ae62b595b
  $fShowDisCons :: GHC.Show.Show SEDEL.Source.Inference.DisCons
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ SEDEL.Source.Inference.DisCons
                  SEDEL.Source.Inference.$fShowDisCons_$cshowsPrec
                  SEDEL.Source.Inference.$fShowDisCons_$cshow
                  SEDEL.Source.Inference.$fShowDisCons_$cshowList -}
263a177e1fcb33eaba9b791ae62b595b
  $fShowDisCons1 :: SEDEL.Source.Inference.DisCons -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (SEDEL.Source.Inference.$fShowDisCons_$cshowsPrec
                   SEDEL.Source.Inference.$fShowDelta2) -}
263a177e1fcb33eaba9b791ae62b595b
  $fShowDisCons_$cshow ::
    SEDEL.Source.Inference.DisCons -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: SEDEL.Source.Inference.DisCons) ->
                 SEDEL.Source.Inference.$fShowDisCons_$cshowsPrec
                   SEDEL.Source.Inference.$fShowDelta2
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
263a177e1fcb33eaba9b791ae62b595b
  $fShowDisCons_$cshowList ::
    [SEDEL.Source.Inference.DisCons] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [SEDEL.Source.Inference.DisCons])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ SEDEL.Source.Inference.DisCons
                   SEDEL.Source.Inference.$fShowDisCons1
                   ls
                   s) -}
263a177e1fcb33eaba9b791ae62b595b
  $fShowDisCons_$cshowsPrec ::
    GHC.Types.Int -> SEDEL.Source.Inference.DisCons -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U> -}
0e7aee499c938cfe66933adc4ab7ac8c
  $fShowPolar ::
    GHC.Show.Show typ =>
    GHC.Show.Show (SEDEL.Source.Inference.Polar typ)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ typ (v :: GHC.Show.Show typ).
                  @ (SEDEL.Source.Inference.Polar typ)
                  (SEDEL.Source.Inference.$fShowPolar_$cshowsPrec @ typ v)
                  (SEDEL.Source.Inference.$fShowPolar_$cshow @ typ v)
                  (SEDEL.Source.Inference.$fShowPolar_$cshowList @ typ v) -}
5a59da8416d00f3640045906e8d52334
  $fShowPolar1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   SEDEL.Source.Inference.$fShowPolar2) -}
3b44b0ed7de4fe93cc7e1a711a89ace1
  $fShowPolar2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("NegT "#) -}
d76c4e76c5707b6d528edb9b75b9ff6b
  $fShowPolar3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   SEDEL.Source.Inference.$fShowPolar4) -}
4843b47331efb5e8128ab4af6d67768e
  $fShowPolar4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("PosT "#) -}
893bdc51a1c4f8d75507ea2b70206c57
  $fShowPolar5 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
0e7aee499c938cfe66933adc4ab7ac8c
  $fShowPolar_$cshow ::
    GHC.Show.Show typ =>
    SEDEL.Source.Inference.Polar typ -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
     Unfolding: (\ @ typ
                   ($dShow :: GHC.Show.Show typ)
                   (x :: SEDEL.Source.Inference.Polar typ) ->
                 case x of wild {
                   SEDEL.Source.Inference.PosT b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        SEDEL.Source.Inference.$fShowPolar3
                        (GHC.Show.showsPrec
                           @ typ
                           $dShow
                           SEDEL.Source.Inference.$fShowPolar5
                           b1
                           (GHC.Types.[] @ GHC.Types.Char))
                   SEDEL.Source.Inference.NegT b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        SEDEL.Source.Inference.$fShowPolar1
                        (GHC.Show.showsPrec
                           @ typ
                           $dShow
                           SEDEL.Source.Inference.$fShowPolar5
                           b1
                           (GHC.Types.[] @ GHC.Types.Char)) }) -}
0e7aee499c938cfe66933adc4ab7ac8c
  $fShowPolar_$cshowList ::
    GHC.Show.Show typ =>
    [SEDEL.Source.Inference.Polar typ] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ typ
                   ($dShow :: GHC.Show.Show typ)
                   (ls :: [SEDEL.Source.Inference.Polar typ])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (SEDEL.Source.Inference.Polar typ)
                   (SEDEL.Source.Inference.$fShowPolar_$cshowsPrec
                      @ typ
                      $dShow
                      SEDEL.Source.Inference.$fShowDelta2)
                   ls
                   s) -}
0e7aee499c938cfe66933adc4ab7ac8c
  $fShowPolar_$cshowsPrec ::
    GHC.Show.Show typ =>
    GHC.Types.Int -> SEDEL.Source.Inference.Polar typ -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ typ
                   (w :: GHC.Show.Show typ)
                   (w7 :: GHC.Types.Int)
                   (w8 :: SEDEL.Source.Inference.Polar typ) ->
                 case w7 of ww { GHC.Types.I# ww1 ->
                 SEDEL.Source.Inference.$w$cshowsPrec @ typ w ww1 w8 }) -}
1a1a0d66ba44f254e55da669d7beafe4
  $fShowPrSubs ::
    GHC.Show.Show typ =>
    GHC.Show.Show (SEDEL.Source.Inference.PrSubs typ)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ typ (v :: GHC.Show.Show typ).
                  @ (SEDEL.Source.Inference.PrSubs typ)
                  (SEDEL.Source.Inference.$fShowPrSubs_$cshowsPrec @ typ v)
                  (SEDEL.Source.Inference.$fShowPrSubs_$cshow @ typ v)
                  (SEDEL.Source.Inference.$fShowPrSubs_$cshowList @ typ v) -}
1a1a0d66ba44f254e55da669d7beafe4
  $fShowPrSubs_$cshow ::
    GHC.Show.Show typ =>
    SEDEL.Source.Inference.PrSubs typ -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ typ
                   ($dShow :: GHC.Show.Show typ)
                   (x :: SEDEL.Source.Inference.PrSubs typ) ->
                 SEDEL.Source.Inference.$fShowPrSubs_$cshowsPrec
                   @ typ
                   $dShow
                   SEDEL.Source.Inference.$fShowDelta2
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
1a1a0d66ba44f254e55da669d7beafe4
  $fShowPrSubs_$cshowList ::
    GHC.Show.Show typ =>
    [SEDEL.Source.Inference.PrSubs typ] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ typ
                   ($dShow :: GHC.Show.Show typ)
                   (ls :: [SEDEL.Source.Inference.PrSubs typ])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (SEDEL.Source.Inference.PrSubs typ)
                   (SEDEL.Source.Inference.$fShowPrSubs_$cshowsPrec
                      @ typ
                      $dShow
                      SEDEL.Source.Inference.$fShowDelta2)
                   ls
                   s) -}
1a1a0d66ba44f254e55da669d7beafe4
  $fShowPrSubs_$cshowsPrec ::
    GHC.Show.Show typ =>
    GHC.Types.Int
    -> SEDEL.Source.Inference.PrSubs typ -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><L,1*U(U)><S,1*U> -}
25d9b1a0ff68b6537e91a2d06b348452
  $fShowQueue :: GHC.Show.Show SEDEL.Source.Inference.Queue
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ SEDEL.Source.Inference.Queue
                  SEDEL.Source.Inference.$fShowQueue_$cshowsPrec
                  SEDEL.Source.Inference.$fShowQueue_$cshow
                  SEDEL.Source.Inference.$fShowQueue_$cshowList -}
25d9b1a0ff68b6537e91a2d06b348452
  $fShowQueue1 :: SEDEL.Source.Inference.Queue -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (SEDEL.Source.Inference.$fShowQueue_$cshowsPrec
                   SEDEL.Source.Inference.$fShowDelta2) -}
25d9b1a0ff68b6537e91a2d06b348452
  $fShowQueue_$cshow ::
    SEDEL.Source.Inference.Queue -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: SEDEL.Source.Inference.Queue) ->
                 SEDEL.Source.Inference.$fShowQueue_$cshowsPrec
                   SEDEL.Source.Inference.$fShowDelta2
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
25d9b1a0ff68b6537e91a2d06b348452
  $fShowQueue_$cshowList ::
    [SEDEL.Source.Inference.Queue] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [SEDEL.Source.Inference.Queue]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ SEDEL.Source.Inference.Queue
                   SEDEL.Source.Inference.$fShowQueue1
                   ls
                   s) -}
25d9b1a0ff68b6537e91a2d06b348452
  $fShowQueue_$cshowsPrec ::
    GHC.Types.Int -> SEDEL.Source.Inference.Queue -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U> -}
94202e7bea8fd879340fecf360dffa4e
  $fShowSubCons :: GHC.Show.Show SEDEL.Source.Inference.SubCons
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ SEDEL.Source.Inference.SubCons
                  SEDEL.Source.Inference.$fShowSubCons_$cshowsPrec
                  SEDEL.Source.Inference.$fShowSubCons_$cshow
                  SEDEL.Source.Inference.$fShowSubCons_$cshowList -}
94202e7bea8fd879340fecf360dffa4e
  $fShowSubCons1 :: SEDEL.Source.Inference.SubCons -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (SEDEL.Source.Inference.$fShowSubCons_$cshowsPrec
                   SEDEL.Source.Inference.$fShowDelta2) -}
94202e7bea8fd879340fecf360dffa4e
  $fShowSubCons_$cshow ::
    SEDEL.Source.Inference.SubCons -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: SEDEL.Source.Inference.SubCons) ->
                 SEDEL.Source.Inference.$fShowSubCons_$cshowsPrec
                   SEDEL.Source.Inference.$fShowDelta2
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
94202e7bea8fd879340fecf360dffa4e
  $fShowSubCons_$cshowList ::
    [SEDEL.Source.Inference.SubCons] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [SEDEL.Source.Inference.SubCons])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ SEDEL.Source.Inference.SubCons
                   SEDEL.Source.Inference.$fShowSubCons1
                   ls
                   s) -}
94202e7bea8fd879340fecf360dffa4e
  $fShowSubCons_$cshowsPrec ::
    GHC.Types.Int -> SEDEL.Source.Inference.SubCons -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U> -}
1c41f715367e98c6d0205722756d8a11
  $fShowSubstitution ::
    GHC.Show.Show typ =>
    GHC.Show.Show (SEDEL.Source.Inference.Substitution typ)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ typ (v :: GHC.Show.Show typ).
                  @ (SEDEL.Source.Inference.Substitution typ)
                  (SEDEL.Source.Inference.$fShowSubstitution_$cshowsPrec @ typ v)
                  (SEDEL.Source.Inference.$fShowSubstitution_$cshow @ typ v)
                  (SEDEL.Source.Inference.$fShowSubstitution_$cshowList @ typ v) -}
1c41f715367e98c6d0205722756d8a11
  $fShowSubstitution_$cshow ::
    GHC.Show.Show typ =>
    SEDEL.Source.Inference.Substitution typ -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ typ
                   ($dShow :: GHC.Show.Show typ)
                   (x :: SEDEL.Source.Inference.Substitution typ) ->
                 SEDEL.Source.Inference.$fShowSubstitution_$cshowsPrec
                   @ typ
                   $dShow
                   SEDEL.Source.Inference.$fShowDelta2
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
1c41f715367e98c6d0205722756d8a11
  $fShowSubstitution_$cshowList ::
    GHC.Show.Show typ =>
    [SEDEL.Source.Inference.Substitution typ] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ typ
                   ($dShow :: GHC.Show.Show typ)
                   (ls :: [SEDEL.Source.Inference.Substitution typ])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (SEDEL.Source.Inference.Substitution typ)
                   (SEDEL.Source.Inference.$fShowSubstitution_$cshowsPrec
                      @ typ
                      $dShow
                      SEDEL.Source.Inference.$fShowDelta2)
                   ls
                   s) -}
1c41f715367e98c6d0205722756d8a11
  $fShowSubstitution_$cshowsPrec ::
    GHC.Show.Show typ =>
    GHC.Types.Int
    -> SEDEL.Source.Inference.Substitution typ -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><L,1*U(U)><S,1*U> -}
6d28b425e8a778f6c0f1f879ac7060e8
  $s$fAlpha(,)_$s$fAlphaEmbed ::
    Unbound.Generics.LocallyNameless.Alpha.Alpha
      (Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType)
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Embed.Embed
                       SEDEL.Source.Syntax.SType)
                  SEDEL.Source.Inference.$s$fAlpha(,)_$s$fShowEmbed
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType)
                     (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Source.Syntax.SType) ->
                   SEDEL.Source.Syntax.$fAlphaSType_$caeq'
                     (case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                      Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                        Unbound.Generics.LocallyNameless.Alpha.Term
                        ds3 })
                     ds
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Source.Syntax.SType>_R)
                     ds1
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Source.Syntax.SType>_R))
                  (Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cfvAny'
                     @ SEDEL.Source.Syntax.SType
                     SEDEL.Source.Syntax.$fAlphaSType)
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (b :: Unbound.Generics.LocallyNameless.Alpha.NamePatFind)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed6
                          @ SEDEL.Source.Syntax.SType
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> (SEDEL.Source.Syntax.$fAlphaSType_$cclose
                           (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                              Unbound.Generics.LocallyNameless.Alpha.Term
                              ds2)
                           b
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R))
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <SEDEL.Source.Syntax.SType>_R)) } })
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (b :: Unbound.Generics.LocallyNameless.Alpha.NthPatFind)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed5
                          @ SEDEL.Source.Syntax.SType
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> (SEDEL.Source.Syntax.$fAlphaSType_$copen
                           (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                              Unbound.Generics.LocallyNameless.Alpha.Term
                              ds2)
                           b
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R))
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <SEDEL.Source.Syntax.SType>_R)) } })
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   case (SEDEL.Source.Syntax.$fAlphaSType_$cisTerm
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R))
                          `cast`
                        (Data.Semigroup.Internal.N:All[0]) of wild {
                     GHC.Types.False
                     -> (GHC.Maybe.Nothing
                           @ [Unbound.Generics.LocallyNameless.Name.AnyName])
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                  <Unbound.Generics.LocallyNameless.Name.AnyName>_R))
                     GHC.Types.True
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed4
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                  <Unbound.Generics.LocallyNameless.Name.AnyName>_R)) })
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   GHC.Types.False)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      SEDEL.Source.Syntax.SType>_R
                   ->_R Sym (Data.Semigroup.Internal.N:All[0]))
                  SEDEL.Source.Syntax.$fAlphaSType_$cisTerm
                    `cast`
                  (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                            <SEDEL.Source.Syntax.SType>_R)
                   ->_R Data.Semigroup.Internal.N:All[0])
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   Data.Either.Left
                     @ GHC.Integer.Type.Integer
                     @ Unbound.Generics.LocallyNameless.Name.AnyName)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      SEDEL.Source.Syntax.SType>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Alpha.N:NthPatFind[0]))
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   Unbound.Generics.LocallyNameless.Alpha.$fAlpha()2)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      SEDEL.Source.Syntax.SType>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Alpha.N:NamePatFind[0]))
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (perm :: Unbound.Generics.PermM.Perm
                                Unbound.Generics.LocallyNameless.Name.AnyName)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term -> ds
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> (SEDEL.Source.Syntax.$fAlphaScheme_$cswaps'
                           (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                              Unbound.Generics.LocallyNameless.Alpha.Term
                              ds2)
                           perm
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R))
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <SEDEL.Source.Syntax.SType>_R)) } })
                  (\ @ m :: * -> *
                     @ b
                     ($dLFresh :: Unbound.Generics.LocallyNameless.LFresh.LFresh m) ->
                   Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed2
                     @ b
                     @ m
                     @ SEDEL.Source.Syntax.SType)
                  (\ @ m :: * -> *
                     ($dFresh :: Unbound.Generics.LocallyNameless.Fresh.Fresh m)
                     (eta4 :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (eta5 :: Unbound.Generics.LocallyNameless.Embed.Embed
                                SEDEL.Source.Syntax.SType) ->
                   case eta4 of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed1
                          @ SEDEL.Source.Syntax.SType
                          @ m
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> GHC.Base.return
                          @ m
                          (Unbound.Generics.LocallyNameless.Fresh.$p1Fresh @ m $dFresh)
                          @ (Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Source.Syntax.SType,
                             Unbound.Generics.PermM.Perm
                               Unbound.Generics.LocallyNameless.Name.AnyName)
                          (eta5,
                           (Data.Map.Internal.Tip
                              @ Unbound.Generics.LocallyNameless.Name.AnyName
                              @ Unbound.Generics.LocallyNameless.Name.AnyName)
                             `cast`
                           (Sym (Unbound.Generics.PermM.N:Perm[0]
                                     <Unbound.Generics.LocallyNameless.Name.AnyName>_N))) } })
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType)
                     (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Source.Syntax.SType) ->
                   SEDEL.Source.Syntax.$fAlphaSType_$cacompare'
                     (case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                      Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                        Unbound.Generics.LocallyNameless.Alpha.Term
                        ds3 })
                     ds
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Source.Syntax.SType>_R)
                     ds1
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Source.Syntax.SType>_R)) -}
f0bfaf4b5c6d4432fd76ad382b1fab7b
  $s$fAlpha(,)_$s$fAlphaEmbed1 ::
    Unbound.Generics.LocallyNameless.Alpha.Alpha
      (Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Intermediate.Syntax.FType)
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Embed.Embed
                       SEDEL.Intermediate.Syntax.FType)
                  SEDEL.Source.Inference.$s$fAlpha(,)_$s$fShowEmbed1
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Intermediate.Syntax.FType)
                     (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Intermediate.Syntax.FType) ->
                   SEDEL.Intermediate.Syntax.$fAlphaFType_$caeq'
                     (case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                      Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                        Unbound.Generics.LocallyNameless.Alpha.Term
                        ds3 })
                     ds
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Intermediate.Syntax.FType>_R)
                     ds1
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Intermediate.Syntax.FType>_R))
                  (Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cfvAny'
                     @ SEDEL.Intermediate.Syntax.FType
                     SEDEL.Intermediate.Syntax.$fAlphaFType)
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (b :: Unbound.Generics.LocallyNameless.Alpha.NamePatFind)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Intermediate.Syntax.FType) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed6
                          @ SEDEL.Intermediate.Syntax.FType
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> (SEDEL.Intermediate.Syntax.$fAlphaFType_$cclose
                           (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                              Unbound.Generics.LocallyNameless.Alpha.Term
                              ds2)
                           b
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Intermediate.Syntax.FType>_R))
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <SEDEL.Intermediate.Syntax.FType>_R)) } })
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (b :: Unbound.Generics.LocallyNameless.Alpha.NthPatFind)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Intermediate.Syntax.FType) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed5
                          @ SEDEL.Intermediate.Syntax.FType
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> (SEDEL.Intermediate.Syntax.$fAlphaFType_$copen
                           (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                              Unbound.Generics.LocallyNameless.Alpha.Term
                              ds2)
                           b
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Intermediate.Syntax.FType>_R))
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <SEDEL.Intermediate.Syntax.FType>_R)) } })
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Intermediate.Syntax.FType) ->
                   case (SEDEL.Intermediate.Syntax.$fAlphaFType_$cisTerm
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Intermediate.Syntax.FType>_R))
                          `cast`
                        (Data.Semigroup.Internal.N:All[0]) of wild {
                     GHC.Types.False
                     -> (GHC.Maybe.Nothing
                           @ [Unbound.Generics.LocallyNameless.Name.AnyName])
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                  <Unbound.Generics.LocallyNameless.Name.AnyName>_R))
                     GHC.Types.True
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed4
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                  <Unbound.Generics.LocallyNameless.Name.AnyName>_R)) })
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Intermediate.Syntax.FType) ->
                   GHC.Types.False)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      SEDEL.Intermediate.Syntax.FType>_R
                   ->_R Sym (Data.Semigroup.Internal.N:All[0]))
                  SEDEL.Intermediate.Syntax.$fAlphaFType_$cisTerm
                    `cast`
                  (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                            <SEDEL.Intermediate.Syntax.FType>_R)
                   ->_R Data.Semigroup.Internal.N:All[0])
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Intermediate.Syntax.FType) ->
                   Data.Either.Left
                     @ GHC.Integer.Type.Integer
                     @ Unbound.Generics.LocallyNameless.Name.AnyName)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      SEDEL.Intermediate.Syntax.FType>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Alpha.N:NthPatFind[0]))
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Intermediate.Syntax.FType) ->
                   Unbound.Generics.LocallyNameless.Alpha.$fAlpha()2)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      SEDEL.Intermediate.Syntax.FType>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Alpha.N:NamePatFind[0]))
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (perm :: Unbound.Generics.PermM.Perm
                                Unbound.Generics.LocallyNameless.Name.AnyName)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Intermediate.Syntax.FType) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term -> ds
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> (SEDEL.Intermediate.Syntax.$fAlphaFExpr_$cswaps'
                           (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                              Unbound.Generics.LocallyNameless.Alpha.Term
                              ds2)
                           perm
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Intermediate.Syntax.FType>_R))
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <SEDEL.Intermediate.Syntax.FType>_R)) } })
                  (\ @ m :: * -> *
                     @ b
                     ($dLFresh :: Unbound.Generics.LocallyNameless.LFresh.LFresh m) ->
                   Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed2
                     @ b
                     @ m
                     @ SEDEL.Intermediate.Syntax.FType)
                  (\ @ m :: * -> *
                     ($dFresh :: Unbound.Generics.LocallyNameless.Fresh.Fresh m)
                     (eta4 :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (eta5 :: Unbound.Generics.LocallyNameless.Embed.Embed
                                SEDEL.Intermediate.Syntax.FType) ->
                   case eta4 of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed1
                          @ SEDEL.Intermediate.Syntax.FType
                          @ m
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> GHC.Base.return
                          @ m
                          (Unbound.Generics.LocallyNameless.Fresh.$p1Fresh @ m $dFresh)
                          @ (Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Intermediate.Syntax.FType,
                             Unbound.Generics.PermM.Perm
                               Unbound.Generics.LocallyNameless.Name.AnyName)
                          (eta5,
                           (Data.Map.Internal.Tip
                              @ Unbound.Generics.LocallyNameless.Name.AnyName
                              @ Unbound.Generics.LocallyNameless.Name.AnyName)
                             `cast`
                           (Sym (Unbound.Generics.PermM.N:Perm[0]
                                     <Unbound.Generics.LocallyNameless.Name.AnyName>_N))) } })
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Intermediate.Syntax.FType)
                     (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Intermediate.Syntax.FType) ->
                   SEDEL.Intermediate.Syntax.$fAlphaFType_$cacompare'
                     (case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                      Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                        Unbound.Generics.LocallyNameless.Alpha.Term
                        ds3 })
                     ds
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Intermediate.Syntax.FType>_R)
                     ds1
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Intermediate.Syntax.FType>_R)) -}
fbf380a19e91bd4cd5336b50b5fa8ac5
  $s$fAlpha(,)_$s$fAlphaEmbed2 ::
    Unbound.Generics.LocallyNameless.Alpha.Alpha
      (Unbound.Generics.LocallyNameless.Embed.Embed
         (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType))
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Embed.Embed
                       (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType))
                  SEDEL.Source.Inference.$s$fAlpha(,)_$s$fShowEmbed2
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType))
                     (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                               (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)) ->
                   case ds
                          `cast`
                        (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                             <GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType>_R) of wild {
                     GHC.Maybe.Nothing
                     -> case ds1
                               `cast`
                             (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType>_R) of wild1 {
                          GHC.Maybe.Nothing -> GHC.Types.True
                          GHC.Maybe.Just g1 -> GHC.Types.False }
                     GHC.Maybe.Just g1
                     -> case ds1
                               `cast`
                             (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType>_R) of wild1 {
                          GHC.Maybe.Nothing -> GHC.Types.False
                          GHC.Maybe.Just g2
                          -> SEDEL.Intermediate.Syntax.$fAlphaFType_$caeq'
                               (case ctx of wild2 { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                                Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                                  Unbound.Generics.LocallyNameless.Alpha.Term
                                  ds3 })
                               g1
                               g2 } })
                  (Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cfvAny'
                     @ (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)
                     SEDEL.Source.Inference.$s$fAlpha(,)_$s$fAlphaMaybe)
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (b :: Unbound.Generics.LocallyNameless.Alpha.NamePatFind)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed6
                          @ (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> case ds
                               `cast`
                             (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType>_R) of wild2 {
                          GHC.Maybe.Nothing
                          -> (GHC.Maybe.Nothing @ SEDEL.Intermediate.Syntax.FType)
                               `cast`
                             (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                       <GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType>_R))
                          GHC.Maybe.Just g1
                          -> (GHC.Maybe.Just
                                @ SEDEL.Intermediate.Syntax.FType
                                (SEDEL.Intermediate.Syntax.$fAlphaFType_$cclose
                                   (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                                      Unbound.Generics.LocallyNameless.Alpha.Term
                                      ds2)
                                   b
                                   g1))
                               `cast`
                             (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                       <GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType>_R)) } } })
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (b :: Unbound.Generics.LocallyNameless.Alpha.NthPatFind)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed5
                          @ (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> case ds
                               `cast`
                             (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType>_R) of wild2 {
                          GHC.Maybe.Nothing
                          -> (GHC.Maybe.Nothing @ SEDEL.Intermediate.Syntax.FType)
                               `cast`
                             (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                       <GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType>_R))
                          GHC.Maybe.Just g1
                          -> (GHC.Maybe.Just
                                @ SEDEL.Intermediate.Syntax.FType
                                (SEDEL.Intermediate.Syntax.$fAlphaFType_$copen
                                   (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                                      Unbound.Generics.LocallyNameless.Alpha.Term
                                      ds2)
                                   b
                                   g1))
                               `cast`
                             (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                       <GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType>_R)) } } })
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)) ->
                   case ds
                          `cast`
                        (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                             <GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType>_R) of wild {
                     GHC.Maybe.Nothing
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed4
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                  <Unbound.Generics.LocallyNameless.Name.AnyName>_R))
                     GHC.Maybe.Just g1
                     -> case (SEDEL.Intermediate.Syntax.$fAlphaFType_$cisTerm g1)
                               `cast`
                             (Data.Semigroup.Internal.N:All[0]) of wild1 {
                          GHC.Types.False
                          -> (GHC.Maybe.Nothing
                                @ [Unbound.Generics.LocallyNameless.Name.AnyName])
                               `cast`
                             (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                       <Unbound.Generics.LocallyNameless.Name.AnyName>_R))
                          GHC.Types.True
                          -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed4
                               `cast`
                             (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                       <Unbound.Generics.LocallyNameless.Name.AnyName>_R)) } })
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)) ->
                   GHC.Types.False)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)>_R
                   ->_R Sym (Data.Semigroup.Internal.N:All[0]))
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)) ->
                   case ds
                          `cast`
                        (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                             <GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType>_R) of wild {
                     GHC.Maybe.Nothing
                     -> GHC.Types.True `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                     GHC.Maybe.Just g1
                     -> SEDEL.Intermediate.Syntax.$fAlphaFType_$cisTerm g1 })
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)>_R
                   ->_R Data.Semigroup.Internal.N:All[0])
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)) ->
                   Data.Either.Left
                     @ GHC.Integer.Type.Integer
                     @ Unbound.Generics.LocallyNameless.Name.AnyName)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Alpha.N:NthPatFind[0]))
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)) ->
                   Unbound.Generics.LocallyNameless.Alpha.$fAlpha()2)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Alpha.N:NamePatFind[0]))
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (perm :: Unbound.Generics.PermM.Perm
                                Unbound.Generics.LocallyNameless.Name.AnyName)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term -> ds
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> case ds
                               `cast`
                             (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType>_R) of wild2 {
                          GHC.Maybe.Nothing
                          -> (GHC.Maybe.Nothing @ SEDEL.Intermediate.Syntax.FType)
                               `cast`
                             (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                       <GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType>_R))
                          GHC.Maybe.Just g1
                          -> (GHC.Maybe.Just
                                @ SEDEL.Intermediate.Syntax.FType
                                (SEDEL.Intermediate.Syntax.$fAlphaFExpr_$cswaps'
                                   (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                                      Unbound.Generics.LocallyNameless.Alpha.Term
                                      ds2)
                                   perm
                                   g1))
                               `cast`
                             (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                       <GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType>_R)) } } })
                  (\ @ m :: * -> *
                     @ b
                     ($dLFresh :: Unbound.Generics.LocallyNameless.LFresh.LFresh m) ->
                   Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed2
                     @ b
                     @ m
                     @ (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType))
                  (\ @ m :: * -> *
                     ($dFresh :: Unbound.Generics.LocallyNameless.Fresh.Fresh m)
                     (eta4 :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (eta5 :: Unbound.Generics.LocallyNameless.Embed.Embed
                                (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)) ->
                   case eta4 of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed1
                          @ (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)
                          @ m
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> GHC.Base.return
                          @ m
                          (Unbound.Generics.LocallyNameless.Fresh.$p1Fresh @ m $dFresh)
                          @ (Unbound.Generics.LocallyNameless.Embed.Embed
                               (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType),
                             Unbound.Generics.PermM.Perm
                               Unbound.Generics.LocallyNameless.Name.AnyName)
                          (eta5,
                           (Data.Map.Internal.Tip
                              @ Unbound.Generics.LocallyNameless.Name.AnyName
                              @ Unbound.Generics.LocallyNameless.Name.AnyName)
                             `cast`
                           (Sym (Unbound.Generics.PermM.N:Perm[0]
                                     <Unbound.Generics.LocallyNameless.Name.AnyName>_N))) } })
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType))
                     (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                               (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)) ->
                   case ds
                          `cast`
                        (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                             <GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType>_R) of wild {
                     GHC.Maybe.Nothing
                     -> case ds1
                               `cast`
                             (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType>_R) of wild1 {
                          GHC.Maybe.Nothing -> GHC.Types.EQ
                          GHC.Maybe.Just g1 -> GHC.Types.LT }
                     GHC.Maybe.Just g1
                     -> case ds1
                               `cast`
                             (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType>_R) of wild1 {
                          GHC.Maybe.Nothing -> GHC.Types.GT
                          GHC.Maybe.Just g2
                          -> SEDEL.Intermediate.Syntax.$fAlphaFType_$cacompare'
                               (case ctx of wild2 { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                                Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                                  Unbound.Generics.LocallyNameless.Alpha.Term
                                  ds3 })
                               g1
                               g2 } }) -}
6c85d817df5fd9975b80f377328d6b22
  $s$fAlpha(,)_$s$fAlphaMaybe ::
    Unbound.Generics.LocallyNameless.Alpha.Alpha
      (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)
                  SEDEL.Source.Inference.$s$fAlpha(,)_$s$fShowMaybe
                  SEDEL.Source.Inference.$s$fAlpha(,)_$s$fAlphaMaybe_$caeq'
                  SEDEL.Source.Inference.$s$fAlpha(,)_$s$fAlphaMaybe_$cfvAny'
                  SEDEL.Source.Inference.$s$fAlpha(,)_$s$fAlphaMaybe_$cclose
                  SEDEL.Source.Inference.$s$fAlpha(,)_$s$fAlphaMaybe_$copen
                  (\ (x :: GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType) ->
                   case x of wild {
                     GHC.Maybe.Nothing
                     -> (GHC.Maybe.Just
                           @ [Unbound.Generics.LocallyNameless.Name.AnyName]
                           (GHC.Types.[] @ Unbound.Generics.LocallyNameless.Name.AnyName))
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                  <Unbound.Generics.LocallyNameless.Name.AnyName>_R))
                     GHC.Maybe.Just g1
                     -> SEDEL.Intermediate.Syntax.$fAlphaFType_$cisPat g1 })
                  (\ (x :: GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType) ->
                   case x of wild {
                     GHC.Maybe.Nothing
                     -> GHC.Types.True `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                     GHC.Maybe.Just g1
                     -> SEDEL.Intermediate.Syntax.$fAlphaFType_$cisTerm g1 })
                  SEDEL.Source.Inference.$s$fAlpha(,)_$s$fAlphaMaybe_$cisEmbed
                  (\ (x :: GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType) ->
                   case x of wild {
                     GHC.Maybe.Nothing
                     -> (Data.Either.Left
                           @ GHC.Integer.Type.Integer
                           @ Unbound.Generics.LocallyNameless.Name.AnyName)
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Alpha.N:NthPatFind[0]))
                     GHC.Maybe.Just g1
                     -> SEDEL.Intermediate.Syntax.$fAlphaFType_$cnthPatFind g1 })
                  (\ (x :: GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType) ->
                   case x of wild {
                     GHC.Maybe.Nothing
                     -> Unbound.Generics.LocallyNameless.Alpha.$fAlpha()2
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Alpha.N:NamePatFind[0]))
                     GHC.Maybe.Just g1
                     -> SEDEL.Intermediate.Syntax.$fAlphaFType_$cnamePatFind g1 })
                  SEDEL.Source.Inference.$s$fAlpha(,)_$s$fAlphaMaybe_$cswaps'
                  SEDEL.Source.Inference.$s$fAlpha(,)_$s$fAlphaMaybe_$clfreshen'
                  (Unbound.Generics.LocallyNameless.Alpha.$fAlphaMaybe_$cfreshen'
                     @ SEDEL.Intermediate.Syntax.FType
                     SEDEL.Intermediate.Syntax.$fAlphaFType)
                  (\ (c :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (eta4 :: GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)
                     (eta5 :: GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType) ->
                   case eta4 of wild {
                     GHC.Maybe.Nothing
                     -> case eta5 of wild1 {
                          GHC.Maybe.Nothing -> GHC.Types.EQ
                          GHC.Maybe.Just g1 -> GHC.Types.LT }
                     GHC.Maybe.Just g1
                     -> case eta5 of wild1 {
                          GHC.Maybe.Nothing -> GHC.Types.GT
                          GHC.Maybe.Just g2
                          -> SEDEL.Intermediate.Syntax.$fAlphaFType_$cacompare'
                               c
                               g1
                               g2 } }) -}
e50f82c68ddd0c832657f6236d4a438c
  $s$fAlpha(,)_$s$fAlphaMaybe_$caeq' ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType
    -> GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType
    -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U(U,U)><S,1*U><S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ (c :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (x :: GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)
                   (y :: GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType) ->
                 case x of wild {
                   GHC.Maybe.Nothing
                   -> case y of wild1 {
                        GHC.Maybe.Nothing -> GHC.Types.True
                        GHC.Maybe.Just g1 -> GHC.Types.False }
                   GHC.Maybe.Just g1
                   -> case y of wild1 {
                        GHC.Maybe.Nothing -> GHC.Types.False
                        GHC.Maybe.Just g2
                        -> SEDEL.Intermediate.Syntax.$fAlphaFType_$caeq' c g1 g2 } }) -}
15a6115331cf691da6c488eaa491c451
  $s$fAlpha(,)_$s$fAlphaMaybe_$cclose ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Alpha.NamePatFind
    -> GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType
    -> GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType
  {- Arity: 3, Strictness: <L,U(U,U)><L,U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (c :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (b :: Unbound.Generics.LocallyNameless.Alpha.NamePatFind)
                   (x :: GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType) ->
                 case x of wild {
                   GHC.Maybe.Nothing
                   -> GHC.Maybe.Nothing @ SEDEL.Intermediate.Syntax.FType
                   GHC.Maybe.Just g1
                   -> GHC.Maybe.Just
                        @ SEDEL.Intermediate.Syntax.FType
                        (SEDEL.Intermediate.Syntax.$fAlphaFType_$cclose c b g1) }) -}
6ea30e1da3a032a00aec4ae2935e7765
  $s$fAlpha(,)_$s$fAlphaMaybe_$cfvAny' ::
    (Data.Functor.Contravariant.Contravariant f,
     GHC.Base.Applicative f) =>
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> (Unbound.Generics.LocallyNameless.Name.AnyName
        -> f Unbound.Generics.LocallyNameless.Name.AnyName)
    -> GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType
    -> f (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)
  {- Arity: 2, Strictness: <L,U(U,U)><L,U(U(U,U),U,U,U,U,U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ f6 :: * -> *
                   ($dContravariant :: Data.Functor.Contravariant.Contravariant f6)
                   ($dApplicative :: GHC.Base.Applicative f6) ->
                 let {
                   $dFunctor :: GHC.Base.Functor f6
                   = GHC.Base.$p1Applicative @ f6 $dApplicative
                 } in
                 \ (c :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (nfn :: Unbound.Generics.LocallyNameless.Name.AnyName
                           -> f6 Unbound.Generics.LocallyNameless.Name.AnyName) ->
                 let {
                   f7 :: f6 (GHC.Generics.Rep
                               (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType) GHC.Types.Any)
                         -> f6 (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)
                   = GHC.Base.fmap
                       @ f6
                       $dFunctor
                       @ (GHC.Generics.Rep
                            (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType) GHC.Types.Any)
                       @ (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)
                       (GHC.Generics.$fGenericMaybe_$cto
                          @ SEDEL.Intermediate.Syntax.FType
                          @ GHC.Types.Any)
                 } in
                 let {
                   f8 :: f6 ((GHC.Generics.:+:)
                               (GHC.Generics.C1
                                  ('GHC.Generics.MetaCons
                                     "Nothing" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                  GHC.Generics.U1)
                               (GHC.Generics.C1
                                  ('GHC.Generics.MetaCons
                                     "Just" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                  (GHC.Generics.S1
                                     ('GHC.Generics.MetaSel
                                        'GHC.Maybe.Nothing
                                        'GHC.Generics.NoSourceUnpackedness
                                        'GHC.Generics.NoSourceStrictness
                                        'GHC.Generics.DecidedLazy)
                                     (GHC.Generics.Rec0 SEDEL.Intermediate.Syntax.FType)))
                               GHC.Types.Any)
                         -> f6 (GHC.Generics.M1
                                  GHC.Generics.D
                                  ('GHC.Generics.MetaData
                                     "Maybe" "GHC.Maybe" "base" 'GHC.Types.False)
                                  (GHC.Generics.C1
                                     ('GHC.Generics.MetaCons
                                        "Nothing" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                     GHC.Generics.U1
                                   GHC.Generics.:+: GHC.Generics.C1
                                                      ('GHC.Generics.MetaCons
                                                         "Just"
                                                         'GHC.Generics.PrefixI
                                                         'GHC.Types.False)
                                                      (GHC.Generics.S1
                                                         ('GHC.Generics.MetaSel
                                                            'GHC.Maybe.Nothing
                                                            'GHC.Generics.NoSourceUnpackedness
                                                            'GHC.Generics.NoSourceStrictness
                                                            'GHC.Generics.DecidedLazy)
                                                         (GHC.Generics.Rec0
                                                            SEDEL.Intermediate.Syntax.FType)))
                                  GHC.Types.Any)
                   = GHC.Base.fmap
                       @ f6
                       (GHC.Base.$p1Applicative @ f6 $dApplicative)
                       @ ((GHC.Generics.:+:)
                            (GHC.Generics.C1
                               ('GHC.Generics.MetaCons
                                  "Nothing" 'GHC.Generics.PrefixI 'GHC.Types.False)
                               GHC.Generics.U1)
                            (GHC.Generics.C1
                               ('GHC.Generics.MetaCons
                                  "Just" 'GHC.Generics.PrefixI 'GHC.Types.False)
                               (GHC.Generics.S1
                                  ('GHC.Generics.MetaSel
                                     'GHC.Maybe.Nothing
                                     'GHC.Generics.NoSourceUnpackedness
                                     'GHC.Generics.NoSourceStrictness
                                     'GHC.Generics.DecidedLazy)
                                  (GHC.Generics.Rec0 SEDEL.Intermediate.Syntax.FType)))
                            GHC.Types.Any)
                       @ (GHC.Generics.M1
                            GHC.Generics.D
                            ('GHC.Generics.MetaData
                               "Maybe" "GHC.Maybe" "base" 'GHC.Types.False)
                            (GHC.Generics.C1
                               ('GHC.Generics.MetaCons
                                  "Nothing" 'GHC.Generics.PrefixI 'GHC.Types.False)
                               GHC.Generics.U1
                             GHC.Generics.:+: GHC.Generics.C1
                                                ('GHC.Generics.MetaCons
                                                   "Just" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                                (GHC.Generics.S1
                                                   ('GHC.Generics.MetaSel
                                                      'GHC.Maybe.Nothing
                                                      'GHC.Generics.NoSourceUnpackedness
                                                      'GHC.Generics.NoSourceStrictness
                                                      'GHC.Generics.DecidedLazy)
                                                   (GHC.Generics.Rec0
                                                      SEDEL.Intermediate.Syntax.FType)))
                            GHC.Types.Any)
                       (\ (v :: (GHC.Generics.:+:)
                                  (GHC.Generics.C1
                                     ('GHC.Generics.MetaCons
                                        "Nothing" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                     GHC.Generics.U1)
                                  (GHC.Generics.C1
                                     ('GHC.Generics.MetaCons
                                        "Just" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                     (GHC.Generics.S1
                                        ('GHC.Generics.MetaSel
                                           'GHC.Maybe.Nothing
                                           'GHC.Generics.NoSourceUnpackedness
                                           'GHC.Generics.NoSourceStrictness
                                           'GHC.Generics.DecidedLazy)
                                        (GHC.Generics.Rec0 SEDEL.Intermediate.Syntax.FType)))
                                  GHC.Types.Any) ->
                        v)
                         `cast`
                       (<(GHC.Generics.:+:)
                           (GHC.Generics.C1
                              ('GHC.Generics.MetaCons
                                 "Nothing" 'GHC.Generics.PrefixI 'GHC.Types.False)
                              GHC.Generics.U1)
                           (GHC.Generics.C1
                              ('GHC.Generics.MetaCons
                                 "Just" 'GHC.Generics.PrefixI 'GHC.Types.False)
                              (GHC.Generics.S1
                                 ('GHC.Generics.MetaSel
                                    'GHC.Maybe.Nothing
                                    'GHC.Generics.NoSourceUnpackedness
                                    'GHC.Generics.NoSourceStrictness
                                    'GHC.Generics.DecidedLazy)
                                 (GHC.Generics.Rec0 SEDEL.Intermediate.Syntax.FType)))
                           GHC.Types.Any>_R
                        ->_R Sym (GHC.Generics.N:M1[0]
                                      <*>_N
                                      <GHC.Generics.D>_P
                                      <'GHC.Generics.MetaData
                                         "Maybe" "GHC.Maybe" "base" 'GHC.Types.False>_P
                                      <GHC.Generics.C1
                                         ('GHC.Generics.MetaCons
                                            "Nothing" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                         GHC.Generics.U1
                                       GHC.Generics.:+: GHC.Generics.C1
                                                          ('GHC.Generics.MetaCons
                                                             "Just"
                                                             'GHC.Generics.PrefixI
                                                             'GHC.Types.False)
                                                          (GHC.Generics.S1
                                                             ('GHC.Generics.MetaSel
                                                                'GHC.Maybe.Nothing
                                                                'GHC.Generics.NoSourceUnpackedness
                                                                'GHC.Generics.NoSourceStrictness
                                                                'GHC.Generics.DecidedLazy)
                                                             (GHC.Generics.Rec0
                                                                SEDEL.Intermediate.Syntax.FType))>_R) <GHC.Types.Any>_N)
                 } in
                 let {
                   $dFunctor1 :: GHC.Base.Functor f6
                   = GHC.Base.$p1Applicative @ f6 $dApplicative
                 } in
                 \ (x :: GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType) ->
                 f7
                   (f8
                      (case x of wild {
                         GHC.Maybe.Nothing
                         -> GHC.Base.fmap
                              @ f6
                              $dFunctor1
                              @ (GHC.Generics.M1
                                   GHC.Generics.C
                                   ('GHC.Generics.MetaCons
                                      "Nothing" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                   GHC.Generics.U1
                                   GHC.Types.Any)
                              @ ((GHC.Generics.:+:)
                                   (GHC.Generics.M1
                                      GHC.Generics.C
                                      ('GHC.Generics.MetaCons
                                         "Nothing" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                      GHC.Generics.U1)
                                   (GHC.Generics.M1
                                      GHC.Generics.C
                                      ('GHC.Generics.MetaCons
                                         "Just" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                      (GHC.Generics.S1
                                         ('GHC.Generics.MetaSel
                                            'GHC.Maybe.Nothing
                                            'GHC.Generics.NoSourceUnpackedness
                                            'GHC.Generics.NoSourceStrictness
                                            'GHC.Generics.DecidedLazy)
                                         (GHC.Generics.Rec0 SEDEL.Intermediate.Syntax.FType)))
                                   GHC.Types.Any)
                              (GHC.Generics.L1
                                 @ *
                                 @ (GHC.Generics.M1
                                      GHC.Generics.C
                                      ('GHC.Generics.MetaCons
                                         "Nothing" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                      GHC.Generics.U1)
                                 @ (GHC.Generics.M1
                                      GHC.Generics.C
                                      ('GHC.Generics.MetaCons
                                         "Just" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                      (GHC.Generics.S1
                                         ('GHC.Generics.MetaSel
                                            'GHC.Maybe.Nothing
                                            'GHC.Generics.NoSourceUnpackedness
                                            'GHC.Generics.NoSourceStrictness
                                            'GHC.Generics.DecidedLazy)
                                         (GHC.Generics.Rec0 SEDEL.Intermediate.Syntax.FType)))
                                 @ GHC.Types.Any)
                              (GHC.Base.fmap
                                 @ f6
                                 (GHC.Base.$p1Applicative @ f6 $dApplicative)
                                 @ (GHC.Generics.U1 GHC.Types.Any)
                                 @ (GHC.Generics.M1
                                      GHC.Generics.C
                                      ('GHC.Generics.MetaCons
                                         "Nothing" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                      GHC.Generics.U1
                                      GHC.Types.Any)
                                 (\ (v :: GHC.Generics.U1 GHC.Types.Any) -> v)
                                   `cast`
                                 (<GHC.Generics.U1 GHC.Types.Any>_R
                                  ->_R Sym (GHC.Generics.N:M1[0]
                                                <*>_N
                                                <GHC.Generics.C>_P
                                                <'GHC.Generics.MetaCons
                                                   "Nothing"
                                                   'GHC.Generics.PrefixI
                                                   'GHC.Types.False>_P
                                                <GHC.Generics.U1>_R) <GHC.Types.Any>_N)
                                 (GHC.Base.pure
                                    @ f6
                                    $dApplicative
                                    @ (GHC.Generics.U1 GHC.Types.Any)
                                    (GHC.Generics.U1 @ * @ GHC.Types.Any)))
                         GHC.Maybe.Just g1
                         -> GHC.Base.fmap
                              @ f6
                              $dFunctor1
                              @ (GHC.Generics.M1
                                   GHC.Generics.C
                                   ('GHC.Generics.MetaCons
                                      "Just" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                   (GHC.Generics.S1
                                      ('GHC.Generics.MetaSel
                                         'GHC.Maybe.Nothing
                                         'GHC.Generics.NoSourceUnpackedness
                                         'GHC.Generics.NoSourceStrictness
                                         'GHC.Generics.DecidedLazy)
                                      (GHC.Generics.Rec0 SEDEL.Intermediate.Syntax.FType))
                                   GHC.Types.Any)
                              @ ((GHC.Generics.:+:)
                                   (GHC.Generics.M1
                                      GHC.Generics.C
                                      ('GHC.Generics.MetaCons
                                         "Nothing" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                      GHC.Generics.U1)
                                   (GHC.Generics.M1
                                      GHC.Generics.C
                                      ('GHC.Generics.MetaCons
                                         "Just" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                      (GHC.Generics.S1
                                         ('GHC.Generics.MetaSel
                                            'GHC.Maybe.Nothing
                                            'GHC.Generics.NoSourceUnpackedness
                                            'GHC.Generics.NoSourceStrictness
                                            'GHC.Generics.DecidedLazy)
                                         (GHC.Generics.Rec0 SEDEL.Intermediate.Syntax.FType)))
                                   GHC.Types.Any)
                              (GHC.Generics.R1
                                 @ *
                                 @ (GHC.Generics.M1
                                      GHC.Generics.C
                                      ('GHC.Generics.MetaCons
                                         "Nothing" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                      GHC.Generics.U1)
                                 @ (GHC.Generics.M1
                                      GHC.Generics.C
                                      ('GHC.Generics.MetaCons
                                         "Just" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                      (GHC.Generics.S1
                                         ('GHC.Generics.MetaSel
                                            'GHC.Maybe.Nothing
                                            'GHC.Generics.NoSourceUnpackedness
                                            'GHC.Generics.NoSourceStrictness
                                            'GHC.Generics.DecidedLazy)
                                         (GHC.Generics.Rec0 SEDEL.Intermediate.Syntax.FType)))
                                 @ GHC.Types.Any)
                              (GHC.Base.fmap
                                 @ f6
                                 (GHC.Base.$p1Applicative @ f6 $dApplicative)
                                 @ (GHC.Generics.M1
                                      GHC.Generics.S
                                      ('GHC.Generics.MetaSel
                                         'GHC.Maybe.Nothing
                                         'GHC.Generics.NoSourceUnpackedness
                                         'GHC.Generics.NoSourceStrictness
                                         'GHC.Generics.DecidedLazy)
                                      (GHC.Generics.Rec0 SEDEL.Intermediate.Syntax.FType)
                                      GHC.Types.Any)
                                 @ (GHC.Generics.M1
                                      GHC.Generics.C
                                      ('GHC.Generics.MetaCons
                                         "Just" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                      (GHC.Generics.M1
                                         GHC.Generics.S
                                         ('GHC.Generics.MetaSel
                                            'GHC.Maybe.Nothing
                                            'GHC.Generics.NoSourceUnpackedness
                                            'GHC.Generics.NoSourceStrictness
                                            'GHC.Generics.DecidedLazy)
                                         (GHC.Generics.Rec0 SEDEL.Intermediate.Syntax.FType))
                                      GHC.Types.Any)
                                 (\ (v :: GHC.Generics.M1
                                            GHC.Generics.S
                                            ('GHC.Generics.MetaSel
                                               'GHC.Maybe.Nothing
                                               'GHC.Generics.NoSourceUnpackedness
                                               'GHC.Generics.NoSourceStrictness
                                               'GHC.Generics.DecidedLazy)
                                            (GHC.Generics.Rec0 SEDEL.Intermediate.Syntax.FType)
                                            GHC.Types.Any) ->
                                  v)
                                   `cast`
                                 (<GHC.Generics.M1
                                     GHC.Generics.S
                                     ('GHC.Generics.MetaSel
                                        'GHC.Maybe.Nothing
                                        'GHC.Generics.NoSourceUnpackedness
                                        'GHC.Generics.NoSourceStrictness
                                        'GHC.Generics.DecidedLazy)
                                     (GHC.Generics.Rec0 SEDEL.Intermediate.Syntax.FType)
                                     GHC.Types.Any>_R
                                  ->_R Sym (GHC.Generics.N:M1[0]
                                                <*>_N
                                                <GHC.Generics.C>_P
                                                <'GHC.Generics.MetaCons
                                                   "Just" 'GHC.Generics.PrefixI 'GHC.Types.False>_P
                                                <GHC.Generics.M1
                                                   GHC.Generics.S
                                                   ('GHC.Generics.MetaSel
                                                      'GHC.Maybe.Nothing
                                                      'GHC.Generics.NoSourceUnpackedness
                                                      'GHC.Generics.NoSourceStrictness
                                                      'GHC.Generics.DecidedLazy)
                                                   (GHC.Generics.Rec0
                                                      SEDEL.Intermediate.Syntax.FType)>_R) <GHC.Types.Any>_N)
                                 (GHC.Base.fmap
                                    @ f6
                                    (GHC.Base.$p1Applicative @ f6 $dApplicative)
                                    @ (GHC.Generics.K1
                                         GHC.Generics.R
                                         SEDEL.Intermediate.Syntax.FType
                                         GHC.Types.Any)
                                    @ (GHC.Generics.M1
                                         GHC.Generics.S
                                         ('GHC.Generics.MetaSel
                                            'GHC.Maybe.Nothing
                                            'GHC.Generics.NoSourceUnpackedness
                                            'GHC.Generics.NoSourceStrictness
                                            'GHC.Generics.DecidedLazy)
                                         (GHC.Generics.K1
                                            GHC.Generics.R SEDEL.Intermediate.Syntax.FType)
                                         GHC.Types.Any)
                                    (\ (v :: GHC.Generics.K1
                                               GHC.Generics.R
                                               SEDEL.Intermediate.Syntax.FType
                                               GHC.Types.Any) ->
                                     v)
                                      `cast`
                                    (<GHC.Generics.K1
                                        GHC.Generics.R
                                        SEDEL.Intermediate.Syntax.FType
                                        GHC.Types.Any>_R
                                     ->_R Sym (GHC.Generics.N:M1[0]
                                                   <*>_N
                                                   <GHC.Generics.S>_P
                                                   <'GHC.Generics.MetaSel
                                                      'GHC.Maybe.Nothing
                                                      'GHC.Generics.NoSourceUnpackedness
                                                      'GHC.Generics.NoSourceStrictness
                                                      'GHC.Generics.DecidedLazy>_P
                                                   <GHC.Generics.K1
                                                      GHC.Generics.R
                                                      SEDEL.Intermediate.Syntax.FType>_R) <GHC.Types.Any>_N)
                                    (GHC.Base.fmap
                                       @ f6
                                       (GHC.Base.$p1Applicative @ f6 $dApplicative)
                                       @ SEDEL.Intermediate.Syntax.FType
                                       @ (GHC.Generics.K1
                                            GHC.Generics.R
                                            SEDEL.Intermediate.Syntax.FType
                                            GHC.Types.Any)
                                       (\ (v :: SEDEL.Intermediate.Syntax.FType) -> v)
                                         `cast`
                                       (<SEDEL.Intermediate.Syntax.FType>_R
                                        ->_R Sym (GHC.Generics.N:K1[0]
                                                      <*>_N
                                                      <GHC.Generics.R>_P
                                                      <SEDEL.Intermediate.Syntax.FType>_R
                                                      <GHC.Types.Any>_P))
                                       (SEDEL.Intermediate.Syntax.$fAlphaFType_$cfvAny'
                                          @ f6
                                          $dContravariant
                                          $dApplicative
                                          c
                                          nfn
                                          g1)))) }))
                     `cast`
                   (<f6>_R (Sym (GHC.Generics.Rep_Maybe[0]
                                     <SEDEL.Intermediate.Syntax.FType>_N) <GHC.Types.Any>_N))) -}
6eb6c3495228e1ac7616792352b65a2f
  $s$fAlpha(,)_$s$fAlphaMaybe_$cisEmbed ::
    GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (ds :: GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType) ->
                 GHC.Types.False) -}
b894285a7086bead57760b3ce30a112b
  $s$fAlpha(,)_$s$fAlphaMaybe_$clfreshen' ::
    Unbound.Generics.LocallyNameless.LFresh.LFresh m =>
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType
    -> (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType
        -> Unbound.Generics.PermM.Perm
             Unbound.Generics.LocallyNameless.Name.AnyName
        -> m b)
    -> m b
  {- Arity: 4,
     Strictness: <L,U(U(U,U,U,U,U),U,U,U)><L,U(U,U)><S,1*U><L,C(C1(U))>,
     Inline: (sat-args=3),
     Unfolding: InlineRule (3, False, False)
                (\ @ m :: * -> *
                   @ b
                   ($dLFresh :: Unbound.Generics.LocallyNameless.LFresh.LFresh m)
                   (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (m1 :: GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)
                   (cont :: GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType
                            -> Unbound.Generics.PermM.Perm
                                 Unbound.Generics.LocallyNameless.Name.AnyName
                            -> m b) ->
                 case m1 of wild {
                   GHC.Maybe.Nothing
                   -> cont
                        (GHC.Maybe.Nothing @ SEDEL.Intermediate.Syntax.FType)
                        (Data.Map.Internal.Tip
                           @ Unbound.Generics.LocallyNameless.Name.AnyName
                           @ Unbound.Generics.LocallyNameless.Name.AnyName)
                          `cast`
                        (Sym (Unbound.Generics.PermM.N:Perm[0]
                                  <Unbound.Generics.LocallyNameless.Name.AnyName>_N))
                   GHC.Maybe.Just g1
                   -> SEDEL.Intermediate.Syntax.$fAlphaFType_$clfreshen'
                        @ m
                        @ b
                        $dLFresh
                        ctx
                        g1
                        (\ (x :: SEDEL.Intermediate.Syntax.FType) ->
                         cont (GHC.Maybe.Just @ SEDEL.Intermediate.Syntax.FType x)) }) -}
583d598ced817feac98f6764e98fbb0c
  $s$fAlpha(,)_$s$fAlphaMaybe_$copen ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Alpha.NthPatFind
    -> GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType
    -> GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType
  {- Arity: 3, Strictness: <L,U(U,U)><L,U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (c :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (b :: Unbound.Generics.LocallyNameless.Alpha.NthPatFind)
                   (x :: GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType) ->
                 case x of wild {
                   GHC.Maybe.Nothing
                   -> GHC.Maybe.Nothing @ SEDEL.Intermediate.Syntax.FType
                   GHC.Maybe.Just g1
                   -> GHC.Maybe.Just
                        @ SEDEL.Intermediate.Syntax.FType
                        (SEDEL.Intermediate.Syntax.$fAlphaFType_$copen c b g1) }) -}
15cbdad9b39c9c640fb25340dac3b444
  $s$fAlpha(,)_$s$fAlphaMaybe_$cswaps' ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.PermM.Perm
         Unbound.Generics.LocallyNameless.Name.AnyName
    -> GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType
    -> GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType
  {- Arity: 3, Strictness: <L,U(U,U)><L,U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (perm :: Unbound.Generics.PermM.Perm
                              Unbound.Generics.LocallyNameless.Name.AnyName)
                   (x :: GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType) ->
                 case x of wild {
                   GHC.Maybe.Nothing
                   -> GHC.Maybe.Nothing @ SEDEL.Intermediate.Syntax.FType
                   GHC.Maybe.Just g1
                   -> GHC.Maybe.Just
                        @ SEDEL.Intermediate.Syntax.FType
                        (SEDEL.Intermediate.Syntax.$fAlphaFExpr_$cswaps' ctx perm g1) }) -}
069cec803e79c63102a8f4da8ad7d7a8
  $s$fAlpha(,)_$s$fShowEmbed ::
    GHC.Show.Show
      (Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Embed.Embed
                       SEDEL.Source.Syntax.SType)
                  (Unbound.Generics.LocallyNameless.Embed.$fShowEmbed_$cshowsPrec
                     @ SEDEL.Source.Syntax.SType
                     SEDEL.Source.Syntax.$fShowSType)
                  (\ (x :: Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Source.Syntax.SType) ->
                   GHC.CString.unpackAppendCString#
                     Unbound.Generics.LocallyNameless.Embed.$fShowEmbed3
                     (SEDEL.Source.Syntax.$fShowSType_$cshowsPrec
                        Unbound.Generics.LocallyNameless.Embed.$fShowEmbed2
                        x `cast`
                        (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                             <SEDEL.Source.Syntax.SType>_R)
                        Unbound.Generics.LocallyNameless.Embed.$fShowEmbed4))
                  (Unbound.Generics.LocallyNameless.Embed.$fShowEmbed_$cshowList
                     @ SEDEL.Source.Syntax.SType
                     SEDEL.Source.Syntax.$fShowSType) -}
32d2fed21983d374d6bf608d972e022c
  $s$fAlpha(,)_$s$fShowEmbed1 ::
    GHC.Show.Show
      (Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Intermediate.Syntax.FType)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Embed.Embed
                       SEDEL.Intermediate.Syntax.FType)
                  (Unbound.Generics.LocallyNameless.Embed.$fShowEmbed_$cshowsPrec
                     @ SEDEL.Intermediate.Syntax.FType
                     SEDEL.Intermediate.Syntax.$fShowFType)
                  (\ (x :: Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Intermediate.Syntax.FType) ->
                   GHC.CString.unpackAppendCString#
                     Unbound.Generics.LocallyNameless.Embed.$fShowEmbed3
                     (SEDEL.Intermediate.Syntax.$fShowFType_$cshowsPrec
                        Unbound.Generics.LocallyNameless.Embed.$fShowEmbed2
                        x `cast`
                        (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                             <SEDEL.Intermediate.Syntax.FType>_R)
                        Unbound.Generics.LocallyNameless.Embed.$fShowEmbed4))
                  (Unbound.Generics.LocallyNameless.Embed.$fShowEmbed_$cshowList
                     @ SEDEL.Intermediate.Syntax.FType
                     SEDEL.Intermediate.Syntax.$fShowFType) -}
1f9599336f15c17157f5836de6441eff
  $s$fAlpha(,)_$s$fShowEmbed2 ::
    GHC.Show.Show
      (Unbound.Generics.LocallyNameless.Embed.Embed
         (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Embed.Embed
                       (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType))
                  (Unbound.Generics.LocallyNameless.Embed.$fShowEmbed_$cshowsPrec
                     @ (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)
                     SEDEL.Source.Inference.$s$fAlpha(,)_$s$fShowMaybe)
                  (\ (x :: Unbound.Generics.LocallyNameless.Embed.Embed
                             (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)) ->
                   GHC.CString.unpackAppendCString#
                     Unbound.Generics.LocallyNameless.Embed.$fShowEmbed3
                     (case x `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType>_R) of wild {
                        GHC.Maybe.Nothing
                        -> GHC.Base.augment
                             @ GHC.Types.Char
                             (\ @ b
                                (c :: GHC.Types.Char -> b -> b)[OneShot]
                                (n :: b)[OneShot] ->
                              GHC.Base.foldr @ GHC.Types.Char @ b c n GHC.Show.$fShowMaybe4)
                             Unbound.Generics.LocallyNameless.Embed.$fShowEmbed4
                        GHC.Maybe.Just b1
                        -> GHC.Base.augment
                             @ GHC.Types.Char
                             (\ @ b
                                (c :: GHC.Types.Char -> b -> b)[OneShot]
                                (n :: b)[OneShot] ->
                              GHC.Base.foldr @ GHC.Types.Char @ b c n GHC.Show.$fShowMaybe1)
                             (SEDEL.Intermediate.Syntax.$fShowFType_$cshowsPrec
                                GHC.Show.appPrec1
                                b1
                                Unbound.Generics.LocallyNameless.Embed.$fShowEmbed4) }))
                  (Unbound.Generics.LocallyNameless.Embed.$fShowEmbed_$cshowList
                     @ (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)
                     SEDEL.Source.Inference.$s$fAlpha(,)_$s$fShowMaybe) -}
f4c75e62157279a1a6d17e0f576fc481
  $s$fAlpha(,)_$s$fShowMaybe ::
    GHC.Show.Show (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)
                  (GHC.Show.$fShowMaybe_$cshowsPrec
                     @ SEDEL.Intermediate.Syntax.FType
                     SEDEL.Intermediate.Syntax.$fShowFType)
                  (\ (x :: GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType) ->
                   case x of wild {
                     GHC.Maybe.Nothing -> GHC.Show.$fShowMaybe4
                     GHC.Maybe.Just b1
                     -> GHC.Base.augment
                          @ GHC.Types.Char
                          (\ @ b
                             (c :: GHC.Types.Char -> b -> b)[OneShot]
                             (n :: b)[OneShot] ->
                           GHC.Base.foldr @ GHC.Types.Char @ b c n GHC.Show.$fShowMaybe1)
                          (SEDEL.Intermediate.Syntax.$fShowFType_$cshowsPrec
                             GHC.Show.appPrec1
                             b1
                             (GHC.Types.[] @ GHC.Types.Char)) })
                  (\ (ls :: [GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType])
                     (s :: GHC.Base.String) ->
                   GHC.Show.showList__
                     @ (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)
                     (GHC.Show.$fShowMaybe_$cshowsPrec
                        @ SEDEL.Intermediate.Syntax.FType
                        SEDEL.Intermediate.Syntax.$fShowFType
                        GHC.Show.$fShow(,)1)
                     ls
                     s) -}
f7606a4d48c1494c657593c573101ada
  $s$fAlphaEmbed_$cacompare'1 ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
    -> GHC.Types.Ordering
  {- Arity: 3, Strictness: <L,1*U(A,U)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType)
                   (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Source.Syntax.SType) ->
                 SEDEL.Source.Syntax.$fAlphaSType_$cacompare'
                   (case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                      Unbound.Generics.LocallyNameless.Alpha.Term
                      ds3 })
                   ds
                     `cast`
                   (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                        <SEDEL.Source.Syntax.SType>_R)
                   ds1
                     `cast`
                   (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                        <SEDEL.Source.Syntax.SType>_R)) -}
27a37f1061cc775ef679e95ab55ae375
  $s$fAlphaEmbed_$cacompare'2 ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Intermediate.Syntax.FType
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Intermediate.Syntax.FType
    -> GHC.Types.Ordering
  {- Arity: 3, Strictness: <L,1*U(A,U)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Intermediate.Syntax.FType)
                   (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Intermediate.Syntax.FType) ->
                 SEDEL.Intermediate.Syntax.$fAlphaFType_$cacompare'
                   (case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                      Unbound.Generics.LocallyNameless.Alpha.Term
                      ds3 })
                   ds
                     `cast`
                   (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                        <SEDEL.Intermediate.Syntax.FType>_R)
                   ds1
                     `cast`
                   (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                        <SEDEL.Intermediate.Syntax.FType>_R)) -}
393c9c5b64651e6312123b7865ec485b
  $s$fAlphaEmbed_$caeq'1 ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
    -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,1*H><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType)
                   (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Source.Syntax.SType) ->
                 SEDEL.Source.Syntax.$fAlphaSType_$caeq'
                   (case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                      Unbound.Generics.LocallyNameless.Alpha.Term
                      ds3 })
                   ds
                     `cast`
                   (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                        <SEDEL.Source.Syntax.SType>_R)
                   ds1
                     `cast`
                   (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                        <SEDEL.Source.Syntax.SType>_R)) -}
e21d777564f89f23427bf8576273ad5e
  $s$fAlphaEmbed_$caeq'2 ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Intermediate.Syntax.FType
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Intermediate.Syntax.FType
    -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,1*U(A,U)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Intermediate.Syntax.FType)
                   (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Intermediate.Syntax.FType) ->
                 SEDEL.Intermediate.Syntax.$fAlphaFType_$caeq'
                   (case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                      Unbound.Generics.LocallyNameless.Alpha.Term
                      ds3 })
                   ds
                     `cast`
                   (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                        <SEDEL.Intermediate.Syntax.FType>_R)
                   ds1
                     `cast`
                   (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                        <SEDEL.Intermediate.Syntax.FType>_R)) -}
ddfeeab44da2669c18a25112cdb7672f
  $s$fAlphaEmbed_$cclose1 ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Alpha.NamePatFind
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
  {- Arity: 3, Strictness: <S(SS),1*U(U,U)><L,C(U)><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (b :: Unbound.Generics.LocallyNameless.Alpha.NamePatFind)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType) ->
                 case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                 case ds1 of wild1 {
                   Unbound.Generics.LocallyNameless.Alpha.Term
                   -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed6
                        @ SEDEL.Source.Syntax.SType
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> (SEDEL.Source.Syntax.$fAlphaSType_$cclose
                         (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                            Unbound.Generics.LocallyNameless.Alpha.Term
                            ds2)
                         b
                         ds
                           `cast`
                         (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                              <SEDEL.Source.Syntax.SType>_R))
                        `cast`
                      (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R)) } }) -}
ac4870d21aa83c42fed64a03d86e0d85
  $s$fAlphaEmbed_$cclose2 ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Alpha.NamePatFind
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Intermediate.Syntax.FType
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Intermediate.Syntax.FType
  {- Arity: 3, Strictness: <S(SS),1*U(U,U)><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (b :: Unbound.Generics.LocallyNameless.Alpha.NamePatFind)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Intermediate.Syntax.FType) ->
                 case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                 case ds1 of wild1 {
                   Unbound.Generics.LocallyNameless.Alpha.Term
                   -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed6
                        @ SEDEL.Intermediate.Syntax.FType
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> (SEDEL.Intermediate.Syntax.$fAlphaFType_$cclose
                         (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                            Unbound.Generics.LocallyNameless.Alpha.Term
                            ds2)
                         b
                         ds
                           `cast`
                         (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                              <SEDEL.Intermediate.Syntax.FType>_R))
                        `cast`
                      (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Intermediate.Syntax.FType>_R)) } }) -}
fa813f1467af1b1318b3fa7cda95bf90
  $s$fAlphaEmbed_$cfreshen' ::
    Unbound.Generics.LocallyNameless.Fresh.Fresh m =>
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
    -> m (Unbound.Generics.LocallyNameless.Embed.Embed
            SEDEL.Source.Syntax.SType,
          Unbound.Generics.PermM.Perm
            Unbound.Generics.LocallyNameless.Name.AnyName)
  {- Arity: 3,
     Strictness: <S(S(LLLC(S)L)L),1*U(1*U(A,A,A,1*C1(U),A),A)><S(SL),1*U(U,A)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   ($dFresh :: Unbound.Generics.LocallyNameless.Fresh.Fresh m)
                   (eta4 :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (eta5 :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                 case eta4 of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                 case ds1 of wild1 {
                   Unbound.Generics.LocallyNameless.Alpha.Term
                   -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed1
                        @ SEDEL.Source.Syntax.SType
                        @ m
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> GHC.Base.return
                        @ m
                        (Unbound.Generics.LocallyNameless.Fresh.$p1Fresh @ m $dFresh)
                        @ (Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Source.Syntax.SType,
                           Unbound.Generics.PermM.Perm
                             Unbound.Generics.LocallyNameless.Name.AnyName)
                        (eta5,
                         (Data.Map.Internal.Tip
                            @ Unbound.Generics.LocallyNameless.Name.AnyName
                            @ Unbound.Generics.LocallyNameless.Name.AnyName)
                           `cast`
                         (Sym (Unbound.Generics.PermM.N:Perm[0]
                                   <Unbound.Generics.LocallyNameless.Name.AnyName>_N))) } }) -}
34f35c735edbd0ef4f77233865272925
  $s$fAlphaEmbed_$cfreshen'1 ::
    Unbound.Generics.LocallyNameless.Fresh.Fresh m =>
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Intermediate.Syntax.FType
    -> m (Unbound.Generics.LocallyNameless.Embed.Embed
            SEDEL.Intermediate.Syntax.FType,
          Unbound.Generics.PermM.Perm
            Unbound.Generics.LocallyNameless.Name.AnyName)
  {- Arity: 3,
     Strictness: <S(S(LLLC(S)L)L),1*U(1*U(A,A,A,1*C1(U),A),A)><S(SL),1*U(U,A)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   ($dFresh :: Unbound.Generics.LocallyNameless.Fresh.Fresh m)
                   (eta4 :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (eta5 :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Intermediate.Syntax.FType) ->
                 case eta4 of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                 case ds1 of wild1 {
                   Unbound.Generics.LocallyNameless.Alpha.Term
                   -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed1
                        @ SEDEL.Intermediate.Syntax.FType
                        @ m
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> GHC.Base.return
                        @ m
                        (Unbound.Generics.LocallyNameless.Fresh.$p1Fresh @ m $dFresh)
                        @ (Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Intermediate.Syntax.FType,
                           Unbound.Generics.PermM.Perm
                             Unbound.Generics.LocallyNameless.Name.AnyName)
                        (eta5,
                         (Data.Map.Internal.Tip
                            @ Unbound.Generics.LocallyNameless.Name.AnyName
                            @ Unbound.Generics.LocallyNameless.Name.AnyName)
                           `cast`
                         (Sym (Unbound.Generics.PermM.N:Perm[0]
                                   <Unbound.Generics.LocallyNameless.Name.AnyName>_N))) } }) -}
33c6ae8ce59cb4c9824f1ab045e9954a
  $s$fAlphaEmbed_$cisPat1 ::
    Unbound.Generics.LocallyNameless.Embed.Embed
      SEDEL.Source.Syntax.SType
    -> Unbound.Generics.LocallyNameless.Alpha.DisjointSet
         Unbound.Generics.LocallyNameless.Name.AnyName
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType) ->
                 case (SEDEL.Source.Syntax.$fAlphaSType_$cisTerm
                         ds
                           `cast`
                         (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                              <SEDEL.Source.Syntax.SType>_R))
                        `cast`
                      (Data.Semigroup.Internal.N:All[0]) of wild {
                   GHC.Types.False
                   -> (GHC.Maybe.Nothing
                         @ [Unbound.Generics.LocallyNameless.Name.AnyName])
                        `cast`
                      (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                <Unbound.Generics.LocallyNameless.Name.AnyName>_R))
                   GHC.Types.True
                   -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed4
                        `cast`
                      (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                <Unbound.Generics.LocallyNameless.Name.AnyName>_R)) }) -}
76d6f13dfa6d20c90f1680d406084a45
  $s$fAlphaEmbed_$cisPat2 ::
    Unbound.Generics.LocallyNameless.Embed.Embed
      SEDEL.Intermediate.Syntax.FType
    -> Unbound.Generics.LocallyNameless.Alpha.DisjointSet
         Unbound.Generics.LocallyNameless.Name.AnyName
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Intermediate.Syntax.FType) ->
                 case (SEDEL.Intermediate.Syntax.$fAlphaFType_$cisTerm
                         ds
                           `cast`
                         (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                              <SEDEL.Intermediate.Syntax.FType>_R))
                        `cast`
                      (Data.Semigroup.Internal.N:All[0]) of wild {
                   GHC.Types.False
                   -> (GHC.Maybe.Nothing
                         @ [Unbound.Generics.LocallyNameless.Name.AnyName])
                        `cast`
                      (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                <Unbound.Generics.LocallyNameless.Name.AnyName>_R))
                   GHC.Types.True
                   -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed4
                        `cast`
                      (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                <Unbound.Generics.LocallyNameless.Name.AnyName>_R)) }) -}
cac34583109f070ecc8f55890864300e
  $s$fAlphaEmbed_$copen1 ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Alpha.NthPatFind
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
  {- Arity: 3, Strictness: <S(SS),1*U(U,U)><L,C(U)><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (b :: Unbound.Generics.LocallyNameless.Alpha.NthPatFind)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType) ->
                 case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                 case ds1 of wild1 {
                   Unbound.Generics.LocallyNameless.Alpha.Term
                   -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed5
                        @ SEDEL.Source.Syntax.SType
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> (SEDEL.Source.Syntax.$fAlphaSType_$copen
                         (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                            Unbound.Generics.LocallyNameless.Alpha.Term
                            ds2)
                         b
                         ds
                           `cast`
                         (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                              <SEDEL.Source.Syntax.SType>_R))
                        `cast`
                      (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R)) } }) -}
72144ca4c12d82260d0135ef0fcda4de
  $s$fAlphaEmbed_$copen2 ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Alpha.NthPatFind
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Intermediate.Syntax.FType
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Intermediate.Syntax.FType
  {- Arity: 3, Strictness: <S(SS),1*U(U,U)><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (b :: Unbound.Generics.LocallyNameless.Alpha.NthPatFind)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Intermediate.Syntax.FType) ->
                 case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                 case ds1 of wild1 {
                   Unbound.Generics.LocallyNameless.Alpha.Term
                   -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed5
                        @ SEDEL.Intermediate.Syntax.FType
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> (SEDEL.Intermediate.Syntax.$fAlphaFType_$copen
                         (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                            Unbound.Generics.LocallyNameless.Alpha.Term
                            ds2)
                         b
                         ds
                           `cast`
                         (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                              <SEDEL.Intermediate.Syntax.FType>_R))
                        `cast`
                      (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Intermediate.Syntax.FType>_R)) } }) -}
77a30f7b81c9593e34dc0d790c1fff72
  $s$fAlphaEmbed_$cswaps'1 ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.PermM.Perm
         Unbound.Generics.LocallyNameless.Name.AnyName
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
  {- Arity: 3, Strictness: <S(SL),1*U(U,A)><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (perm :: Unbound.Generics.PermM.Perm
                              Unbound.Generics.LocallyNameless.Name.AnyName)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType) ->
                 case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                 case ds1 of wild1 {
                   Unbound.Generics.LocallyNameless.Alpha.Term -> ds
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> (SEDEL.Source.Syntax.$fAlphaScheme_$cswaps'
                         (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                            Unbound.Generics.LocallyNameless.Alpha.Term
                            ds2)
                         perm
                         ds
                           `cast`
                         (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                              <SEDEL.Source.Syntax.SType>_R))
                        `cast`
                      (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R)) } }) -}
dc505fd132e450745a0e3ddeb384c3ba
  $s$fAlphaEmbed_$cswaps'2 ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.PermM.Perm
         Unbound.Generics.LocallyNameless.Name.AnyName
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Intermediate.Syntax.FType
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Intermediate.Syntax.FType
  {- Arity: 3, Strictness: <S(SS),1*U(U,U)><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (perm :: Unbound.Generics.PermM.Perm
                              Unbound.Generics.LocallyNameless.Name.AnyName)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Intermediate.Syntax.FType) ->
                 case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                 case ds1 of wild1 {
                   Unbound.Generics.LocallyNameless.Alpha.Term -> ds
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> (SEDEL.Intermediate.Syntax.$fAlphaFExpr_$cswaps'
                         (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                            Unbound.Generics.LocallyNameless.Alpha.Term
                            ds2)
                         perm
                         ds
                           `cast`
                         (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                              <SEDEL.Intermediate.Syntax.FType>_R))
                        `cast`
                      (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Intermediate.Syntax.FType>_R)) } }) -}
52b4c0841bd20fe28fb14da26a6efe3e
  $s$fAlphaMaybe_$cacompare' ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType
    -> GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType
    -> GHC.Types.Ordering
  {- Arity: 3, Strictness: <L,U(U,U)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (c :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (eta4 :: GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)
                   (eta5 :: GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType) ->
                 case eta4 of wild {
                   GHC.Maybe.Nothing
                   -> case eta5 of wild1 {
                        GHC.Maybe.Nothing -> GHC.Types.EQ
                        GHC.Maybe.Just g1 -> GHC.Types.LT }
                   GHC.Maybe.Just g1
                   -> case eta5 of wild1 {
                        GHC.Maybe.Nothing -> GHC.Types.GT
                        GHC.Maybe.Just g2
                        -> SEDEL.Intermediate.Syntax.$fAlphaFType_$cacompare'
                             c
                             g1
                             g2 } }) -}
9861ab96dc95740218e87b5cf410c6d9
  $s$fApplicativeExceptT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
                  (SEDEL.Source.Inference.$s$fApplicativeExceptT_$s$fFunctorExceptT
                     @ e)
                  (SEDEL.Source.Inference.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure
                     @ e)
                  (Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                     @ GHC.Types.IO
                     @ e
                     GHC.Base.$fFunctorIO
                     GHC.Base.$fMonadIO)
                  (\ @ a
                     @ b
                     @ c
                     (f6 :: a -> b -> c)
                     (x :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a) ->
                   Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                     @ GHC.Types.IO
                     @ e
                     GHC.Base.$fFunctorIO
                     GHC.Base.$fMonadIO
                     @ b
                     @ c
                     (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                      case x `cast`
                           (Control.Monad.Trans.Except.N:ExceptT[0]
                                <e>_N <GHC.Types.IO>_R <a>_N ; GHC.Types.N:IO[0]
                                                                   <Data.Either.Either e a>_R)
                             s of ds { (#,#) ipv ipv1 ->
                      (# ipv,
                         Data.Either.$fApplicativeEither_$cfmap
                           @ e
                           @ a
                           @ (b -> c)
                           f6
                           ipv1 #) })
                       `cast`
                     (Sym (GHC.Types.N:IO[0]
                               <Data.Either.Either
                                  e (b -> c)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                            <e>_N <GHC.Types.IO>_R <b -> c>_N)))
                  (SEDEL.Source.Inference.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$c*>
                     @ e)
                  (\ @ a
                     @ b
                     (x :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a) ->
                   Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                     @ GHC.Types.IO
                     @ e
                     GHC.Base.$fFunctorIO
                     GHC.Base.$fMonadIO
                     @ b
                     @ a
                     (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                      case x `cast`
                           (Control.Monad.Trans.Except.N:ExceptT[0]
                                <e>_N <GHC.Types.IO>_R <a>_N ; GHC.Types.N:IO[0]
                                                                   <Data.Either.Either e a>_R)
                             s of ds { (#,#) ipv ipv1 ->
                      (# ipv,
                         Control.Monad.Trans.Except.$fApplicativeExceptT1
                           @ e
                           @ b
                           @ a
                           ipv1 #) })
                       `cast`
                     (Sym (GHC.Types.N:IO[0]
                               <Data.Either.Either
                                  e (b -> a)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                            <e>_N <GHC.Types.IO>_R <b -> a>_N))) -}
758e93e6a87ce14aff0486caaf421a23
  $s$fApplicativeExceptT_$c<*>1 ::
    Control.Monad.Trans.Except.ExceptT e GHC.Types.IO (a -> b)
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Either.Either e b #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S(SS)),1*C1(U(U,1*U))><L,1*C1(U(U,1*U))><S,U>,
     Unfolding: (\ @ e
                   @ a
                   @ b
                   (w7 :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO (a -> b))
                   (w8 :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w7
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <GHC.Types.IO>_R <a -> b>_N ; GHC.Types.N:IO[0]
                                                                   <Data.Either.Either
                                                                      e (a -> b)>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   Data.Either.Left e1 -> (# ipv, Data.Either.Left @ e @ b e1 #)
                   Data.Either.Right k
                   -> case w8
                             `cast`
                           (Control.Monad.Trans.Except.N:ExceptT[0]
                                <e>_N <GHC.Types.IO>_R <a>_N ; GHC.Types.N:IO[0]
                                                                   <Data.Either.Either e a>_R)
                             ipv of ds2 { (#,#) ipv2 ipv3 ->
                      case ipv3 of wild1 {
                        Data.Either.Left e1 -> (# ipv2, Data.Either.Left @ e @ b e1 #)
                        Data.Either.Right x
                        -> (# ipv2, Data.Either.Right @ e @ b (k x) #) } } } }) -}
6167f2040a1aa108ff069cd1c8d9bd06
  $s$fApplicativeExceptT_$s$fApplicativeExceptT_$c*> ::
    Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S(SS)),1*C1(U(U,1*U))><L,1*C1(U(U,U))><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a)
                   (k :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case m1
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <GHC.Types.IO>_R <a>_N ; GHC.Types.N:IO[0]
                                                              <Data.Either.Either e a>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   Data.Either.Left e1 -> (# ipv, Data.Either.Left @ e @ b e1 #)
                   Data.Either.Right x
                   -> k `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <GHC.Types.IO>_R <b>_N ; GHC.Types.N:IO[0]
                                                              <Data.Either.Either e b>_R)
                        ipv } })
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a>_R
                 ->_R <Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <Data.Either.Either
                                  e b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                     <e>_N <GHC.Types.IO>_R <b>_N)) -}
646813b68e429e030e8bd8c62f0cf372
  $s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure ::
    a -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ e @ a (a1 :: a) (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 (# s, Data.Either.Right @ e @ a a1 #))
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N).
                 <a>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <Data.Either.Either
                                  e a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                     <e>_N <GHC.Types.IO>_R <a>_N)) -}
a4afc44ef315ee74983cb2e60da71e0a
  $s$fApplicativeExceptT_$s$fFunctorExceptT ::
    GHC.Base.Functor
      (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
                  (Control.Monad.Trans.Except.$fFunctorExceptT_$cfmap
                     @ GHC.Types.IO
                     @ e
                     GHC.Base.$fFunctorIO)
                  (Control.Monad.Trans.Except.$fFunctorExceptT_$c<$
                     @ GHC.Types.IO
                     @ e
                     GHC.Base.$fFunctorIO) -}
0fb574305dc867e0f7e4d95508e909c4
  $s$fApplicativeFreshMT ::
    GHC.Base.Applicative
      (Unbound.Generics.LocallyNameless.Fresh.FreshMT
         (Control.Monad.Trans.Reader.ReaderT
            (SEDEL.Environment.Ctx
               SEDEL.Source.Syntax.TmName
               SEDEL.Source.Syntax.CtxType
               SEDEL.Source.Syntax.TyName
               SEDEL.Source.Syntax.Kind
               SEDEL.Source.Syntax.SType
               SEDEL.Source.Syntax.Expr)
            (Control.Monad.Trans.Except.ExceptT
               SEDEL.Environment.Err GHC.Types.IO)))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Fresh.FreshMT
                       (Control.Monad.Trans.Reader.ReaderT
                          (SEDEL.Environment.Ctx
                             SEDEL.Source.Syntax.TmName
                             SEDEL.Source.Syntax.CtxType
                             SEDEL.Source.Syntax.TyName
                             SEDEL.Source.Syntax.Kind
                             SEDEL.Source.Syntax.SType
                             SEDEL.Source.Syntax.Expr)
                          (Control.Monad.Trans.Except.ExceptT
                             SEDEL.Environment.Err GHC.Types.IO)))
                  SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorFreshMT
                  (\ @ a (eta4 :: a) (eta5 :: GHC.Integer.Type.Integer) ->
                   let {
                     m1 :: GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                 Data.Either.Either
                                   SEDEL.Environment.Err (a, GHC.Integer.Type.Integer) #)
                       {- Arity: 1 -}
                     = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                       (# s,
                          Data.Either.Right
                            @ SEDEL.Environment.Err
                            @ (a, GHC.Integer.Type.Integer)
                            (eta4, eta5) #)
                   } in
                   (\ (ds :: SEDEL.Environment.Ctx
                               SEDEL.Source.Syntax.TmName
                               SEDEL.Source.Syntax.CtxType
                               SEDEL.Source.Syntax.TyName
                               SEDEL.Source.Syntax.Kind
                               SEDEL.Source.Syntax.SType
                               SEDEL.Source.Syntax.Expr) ->
                    m1)
                     `cast`
                   ((<SEDEL.Environment.Ctx
                        SEDEL.Source.Syntax.TmName
                        SEDEL.Source.Syntax.CtxType
                        SEDEL.Source.Syntax.TyName
                        SEDEL.Source.Syntax.Kind
                        SEDEL.Source.Syntax.SType
                        SEDEL.Source.Syntax.Expr>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <Data.Either.Either
                                      SEDEL.Environment.Err
                                      (a,
                                       GHC.Integer.Type.Integer)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <SEDEL.Environment.Err>_N
                                                                                <GHC.Types.IO>_R
                                                                                <(a,
                                                                                  GHC.Integer.Type.Integer)>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                            <*>_N
                                                                                                                            <SEDEL.Environment.Ctx
                                                                                                                               SEDEL.Source.Syntax.TmName
                                                                                                                               SEDEL.Source.Syntax.CtxType
                                                                                                                               SEDEL.Source.Syntax.TyName
                                                                                                                               SEDEL.Source.Syntax.Kind
                                                                                                                               SEDEL.Source.Syntax.SType
                                                                                                                               SEDEL.Source.Syntax.Expr>_R
                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                               SEDEL.Environment.Err
                                                                                                                               GHC.Types.IO>_R
                                                                                                                            <(a,
                                                                                                                              GHC.Integer.Type.Integer)>_N)))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Reader.ReaderT
                                    (SEDEL.Environment.Ctx
                                       SEDEL.Source.Syntax.TmName
                                       SEDEL.Source.Syntax.CtxType
                                       SEDEL.Source.Syntax.TyName
                                       SEDEL.Source.Syntax.Kind
                                       SEDEL.Source.Syntax.SType
                                       SEDEL.Source.Syntax.Expr)
                                    (Control.Monad.Trans.Except.ExceptT
                                       SEDEL.Environment.Err GHC.Types.IO)>_R
                                 <a>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                       (SEDEL.Environment.Ctx
                                                                                                          SEDEL.Source.Syntax.TmName
                                                                                                          SEDEL.Source.Syntax.CtxType
                                                                                                          SEDEL.Source.Syntax.TyName
                                                                                                          SEDEL.Source.Syntax.Kind
                                                                                                          SEDEL.Source.Syntax.SType
                                                                                                          SEDEL.Source.Syntax.Expr)
                                                                                                       (Control.Monad.Trans.Except.ExceptT
                                                                                                          SEDEL.Environment.Err
                                                                                                          GHC.Types.IO)>_N <a>_N)
                  (Unbound.Generics.LocallyNameless.Fresh.$fApplicativeFreshMT4
                     @ (Control.Monad.Trans.Reader.ReaderT
                          (SEDEL.Environment.Ctx
                             SEDEL.Source.Syntax.TmName
                             SEDEL.Source.Syntax.CtxType
                             SEDEL.Source.Syntax.TyName
                             SEDEL.Source.Syntax.Kind
                             SEDEL.Source.Syntax.SType
                             SEDEL.Source.Syntax.Expr)
                          (Control.Monad.Trans.Except.ExceptT
                             SEDEL.Environment.Err GHC.Types.IO))
                     (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fMonadReaderT
                        @ (SEDEL.Environment.Ctx
                             SEDEL.Source.Syntax.TmName
                             SEDEL.Source.Syntax.CtxType
                             SEDEL.Source.Syntax.TyName
                             SEDEL.Source.Syntax.Kind
                             SEDEL.Source.Syntax.SType
                             SEDEL.Source.Syntax.Expr)))
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                (SEDEL.Environment.Ctx
                                                                                   SEDEL.Source.Syntax.TmName
                                                                                   SEDEL.Source.Syntax.CtxType
                                                                                   SEDEL.Source.Syntax.TyName
                                                                                   SEDEL.Source.Syntax.Kind
                                                                                   SEDEL.Source.Syntax.SType
                                                                                   SEDEL.Source.Syntax.Expr)
                                                                                (Control.Monad.Trans.Except.ExceptT
                                                                                   SEDEL.Environment.Err
                                                                                   GHC.Types.IO)>_N <a
                                                                                                     -> b>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                     (SEDEL.Environment.Ctx
                                                                                        SEDEL.Source.Syntax.TmName
                                                                                        SEDEL.Source.Syntax.CtxType
                                                                                        SEDEL.Source.Syntax.TyName
                                                                                        SEDEL.Source.Syntax.Kind
                                                                                        SEDEL.Source.Syntax.SType
                                                                                        SEDEL.Source.Syntax.Expr)
                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                        SEDEL.Environment.Err
                                                                                        GHC.Types.IO)>_N <a>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Reader.ReaderT
                                    (SEDEL.Environment.Ctx
                                       SEDEL.Source.Syntax.TmName
                                       SEDEL.Source.Syntax.CtxType
                                       SEDEL.Source.Syntax.TyName
                                       SEDEL.Source.Syntax.Kind
                                       SEDEL.Source.Syntax.SType
                                       SEDEL.Source.Syntax.Expr)
                                    (Control.Monad.Trans.Except.ExceptT
                                       SEDEL.Environment.Err GHC.Types.IO)>_R
                                 <b>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                       (SEDEL.Environment.Ctx
                                                                                                          SEDEL.Source.Syntax.TmName
                                                                                                          SEDEL.Source.Syntax.CtxType
                                                                                                          SEDEL.Source.Syntax.TyName
                                                                                                          SEDEL.Source.Syntax.Kind
                                                                                                          SEDEL.Source.Syntax.SType
                                                                                                          SEDEL.Source.Syntax.Expr)
                                                                                                       (Control.Monad.Trans.Except.ExceptT
                                                                                                          SEDEL.Environment.Err
                                                                                                          GHC.Types.IO)>_N <b>_N)
                  (\ @ a
                     @ b
                     @ c
                     (eta4 :: a -> b -> c)
                     (eta5 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer
                                (Control.Monad.Trans.Reader.ReaderT
                                   (SEDEL.Environment.Ctx
                                      SEDEL.Source.Syntax.TmName
                                      SEDEL.Source.Syntax.CtxType
                                      SEDEL.Source.Syntax.TyName
                                      SEDEL.Source.Syntax.Kind
                                      SEDEL.Source.Syntax.SType
                                      SEDEL.Source.Syntax.Expr)
                                   (Control.Monad.Trans.Except.ExceptT
                                      SEDEL.Environment.Err GHC.Types.IO))
                                a)
                     (eta6 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer
                                (Control.Monad.Trans.Reader.ReaderT
                                   (SEDEL.Environment.Ctx
                                      SEDEL.Source.Syntax.TmName
                                      SEDEL.Source.Syntax.CtxType
                                      SEDEL.Source.Syntax.TyName
                                      SEDEL.Source.Syntax.Kind
                                      SEDEL.Source.Syntax.SType
                                      SEDEL.Source.Syntax.Expr)
                                   (Control.Monad.Trans.Except.ExceptT
                                      SEDEL.Environment.Err GHC.Types.IO))
                                b)
                     (eta7 :: GHC.Integer.Type.Integer) ->
                   Control.Monad.Trans.State.Lazy.$w$cliftA2
                     @ (Control.Monad.Trans.Reader.ReaderT
                          (SEDEL.Environment.Ctx
                             SEDEL.Source.Syntax.TmName
                             SEDEL.Source.Syntax.CtxType
                             SEDEL.Source.Syntax.TyName
                             SEDEL.Source.Syntax.Kind
                             SEDEL.Source.Syntax.SType
                             SEDEL.Source.Syntax.Expr)
                          (Control.Monad.Trans.Except.ExceptT
                             SEDEL.Environment.Err GHC.Types.IO))
                     @ GHC.Integer.Type.Integer
                     (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorReaderT
                        @ (SEDEL.Environment.Ctx
                             SEDEL.Source.Syntax.TmName
                             SEDEL.Source.Syntax.CtxType
                             SEDEL.Source.Syntax.TyName
                             SEDEL.Source.Syntax.Kind
                             SEDEL.Source.Syntax.SType
                             SEDEL.Source.Syntax.Expr))
                     (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fMonadReaderT_$c>>=
                        @ (SEDEL.Environment.Ctx
                             SEDEL.Source.Syntax.TmName
                             SEDEL.Source.Syntax.CtxType
                             SEDEL.Source.Syntax.TyName
                             SEDEL.Source.Syntax.Kind
                             SEDEL.Source.Syntax.SType
                             SEDEL.Source.Syntax.Expr))
                     (\ @ a1 (eta8 :: a1) ->
                      let {
                        m1 :: GHC.Prim.State# GHC.Prim.RealWorld
                              -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                    Data.Either.Either SEDEL.Environment.Err a1 #)
                          {- Arity: 1 -}
                        = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                          (# s, Data.Either.Right @ SEDEL.Environment.Err @ a1 eta8 #)
                      } in
                      (\ (ds :: SEDEL.Environment.Ctx
                                  SEDEL.Source.Syntax.TmName
                                  SEDEL.Source.Syntax.CtxType
                                  SEDEL.Source.Syntax.TyName
                                  SEDEL.Source.Syntax.Kind
                                  SEDEL.Source.Syntax.SType
                                  SEDEL.Source.Syntax.Expr) ->
                       m1)
                        `cast`
                      ((<SEDEL.Environment.Ctx
                           SEDEL.Source.Syntax.TmName
                           SEDEL.Source.Syntax.CtxType
                           SEDEL.Source.Syntax.TyName
                           SEDEL.Source.Syntax.Kind
                           SEDEL.Source.Syntax.SType
                           SEDEL.Source.Syntax.Expr>_R
                        ->_R Sym (GHC.Types.N:IO[0]
                                      <Data.Either.Either
                                         SEDEL.Environment.Err
                                         a1>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                           <SEDEL.Environment.Err>_N
                                                           <GHC.Types.IO>_R
                                                           <a1>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                               <*>_N
                                                                               <SEDEL.Environment.Ctx
                                                                                  SEDEL.Source.Syntax.TmName
                                                                                  SEDEL.Source.Syntax.CtxType
                                                                                  SEDEL.Source.Syntax.TyName
                                                                                  SEDEL.Source.Syntax.Kind
                                                                                  SEDEL.Source.Syntax.SType
                                                                                  SEDEL.Source.Syntax.Expr>_R
                                                                               <Control.Monad.Trans.Except.ExceptT
                                                                                  SEDEL.Environment.Err
                                                                                  GHC.Types.IO>_R
                                                                               <a1>_N)))
                     @ a
                     @ b
                     @ c
                     eta4
                     eta5
                     eta6
                     eta7)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                     (SEDEL.Environment.Ctx
                                                                                        SEDEL.Source.Syntax.TmName
                                                                                        SEDEL.Source.Syntax.CtxType
                                                                                        SEDEL.Source.Syntax.TyName
                                                                                        SEDEL.Source.Syntax.Kind
                                                                                        SEDEL.Source.Syntax.SType
                                                                                        SEDEL.Source.Syntax.Expr)
                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                        SEDEL.Environment.Err
                                                                                        GHC.Types.IO)>_N <a>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                     (SEDEL.Environment.Ctx
                                                                                        SEDEL.Source.Syntax.TmName
                                                                                        SEDEL.Source.Syntax.CtxType
                                                                                        SEDEL.Source.Syntax.TyName
                                                                                        SEDEL.Source.Syntax.Kind
                                                                                        SEDEL.Source.Syntax.SType
                                                                                        SEDEL.Source.Syntax.Expr)
                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                        SEDEL.Environment.Err
                                                                                        GHC.Types.IO)>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Reader.ReaderT
                                    (SEDEL.Environment.Ctx
                                       SEDEL.Source.Syntax.TmName
                                       SEDEL.Source.Syntax.CtxType
                                       SEDEL.Source.Syntax.TyName
                                       SEDEL.Source.Syntax.Kind
                                       SEDEL.Source.Syntax.SType
                                       SEDEL.Source.Syntax.Expr)
                                    (Control.Monad.Trans.Except.ExceptT
                                       SEDEL.Environment.Err GHC.Types.IO)>_R
                                 <c>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                       (SEDEL.Environment.Ctx
                                                                                                          SEDEL.Source.Syntax.TmName
                                                                                                          SEDEL.Source.Syntax.CtxType
                                                                                                          SEDEL.Source.Syntax.TyName
                                                                                                          SEDEL.Source.Syntax.Kind
                                                                                                          SEDEL.Source.Syntax.SType
                                                                                                          SEDEL.Source.Syntax.Expr)
                                                                                                       (Control.Monad.Trans.Except.ExceptT
                                                                                                          SEDEL.Environment.Err
                                                                                                          GHC.Types.IO)>_N <c>_N)
                  (\ @ a
                     @ b
                     (eta4 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer
                                (Control.Monad.Trans.Reader.ReaderT
                                   (SEDEL.Environment.Ctx
                                      SEDEL.Source.Syntax.TmName
                                      SEDEL.Source.Syntax.CtxType
                                      SEDEL.Source.Syntax.TyName
                                      SEDEL.Source.Syntax.Kind
                                      SEDEL.Source.Syntax.SType
                                      SEDEL.Source.Syntax.Expr)
                                   (Control.Monad.Trans.Except.ExceptT
                                      SEDEL.Environment.Err GHC.Types.IO))
                                a)
                     (eta5 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer
                                (Control.Monad.Trans.Reader.ReaderT
                                   (SEDEL.Environment.Ctx
                                      SEDEL.Source.Syntax.TmName
                                      SEDEL.Source.Syntax.CtxType
                                      SEDEL.Source.Syntax.TyName
                                      SEDEL.Source.Syntax.Kind
                                      SEDEL.Source.Syntax.SType
                                      SEDEL.Source.Syntax.Expr)
                                   (Control.Monad.Trans.Except.ExceptT
                                      SEDEL.Environment.Err GHC.Types.IO))
                                b)
                     (eta6 :: GHC.Integer.Type.Integer) ->
                   let {
                     m1 :: Control.Monad.Trans.Reader.ReaderT
                             (SEDEL.Environment.Ctx
                                SEDEL.Source.Syntax.TmName
                                SEDEL.Source.Syntax.CtxType
                                SEDEL.Source.Syntax.TyName
                                SEDEL.Source.Syntax.Kind
                                SEDEL.Source.Syntax.SType
                                SEDEL.Source.Syntax.Expr)
                             (Control.Monad.Trans.Except.ExceptT
                                SEDEL.Environment.Err GHC.Types.IO)
                             (a, GHC.Integer.Type.Integer)
                     = eta4
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <GHC.Integer.Type.Integer>_N
                            <Control.Monad.Trans.Reader.ReaderT
                               (SEDEL.Environment.Ctx
                                  SEDEL.Source.Syntax.TmName
                                  SEDEL.Source.Syntax.CtxType
                                  SEDEL.Source.Syntax.TyName
                                  SEDEL.Source.Syntax.Kind
                                  SEDEL.Source.Syntax.SType
                                  SEDEL.Source.Syntax.Expr)
                               (Control.Monad.Trans.Except.ExceptT
                                  SEDEL.Environment.Err GHC.Types.IO)>_R
                            <a>_N)
                         eta6
                   } in
                   (\ (r1 :: SEDEL.Environment.Ctx
                               SEDEL.Source.Syntax.TmName
                               SEDEL.Source.Syntax.CtxType
                               SEDEL.Source.Syntax.TyName
                               SEDEL.Source.Syntax.Kind
                               SEDEL.Source.Syntax.SType
                               SEDEL.Source.Syntax.Expr)
                      (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                    case (m1
                            `cast`
                          (Control.Monad.Trans.Reader.N:ReaderT[0]
                               <*>_N
                               <SEDEL.Environment.Ctx
                                  SEDEL.Source.Syntax.TmName
                                  SEDEL.Source.Syntax.CtxType
                                  SEDEL.Source.Syntax.TyName
                                  SEDEL.Source.Syntax.Kind
                                  SEDEL.Source.Syntax.SType
                                  SEDEL.Source.Syntax.Expr>_R
                               <Control.Monad.Trans.Except.ExceptT
                                  SEDEL.Environment.Err GHC.Types.IO>_R
                               <(a, GHC.Integer.Type.Integer)>_N)
                            r1)
                           `cast`
                         (Control.Monad.Trans.Except.N:ExceptT[0]
                              <SEDEL.Environment.Err>_N
                              <GHC.Types.IO>_R
                              <(a, GHC.Integer.Type.Integer)>_N ; GHC.Types.N:IO[0]
                                                                      <Data.Either.Either
                                                                         SEDEL.Environment.Err
                                                                         (a,
                                                                          GHC.Integer.Type.Integer)>_R)
                           s of ds1 { (#,#) ipv ipv1 ->
                    case ipv1 of wild {
                      Data.Either.Left e1
                      -> (# ipv,
                            Data.Either.Left
                              @ SEDEL.Environment.Err
                              @ (b, GHC.Integer.Type.Integer)
                              e1 #)
                      Data.Either.Right x
                      -> ((eta5
                             `cast`
                           (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                <GHC.Integer.Type.Integer>_N
                                <Control.Monad.Trans.Reader.ReaderT
                                   (SEDEL.Environment.Ctx
                                      SEDEL.Source.Syntax.TmName
                                      SEDEL.Source.Syntax.CtxType
                                      SEDEL.Source.Syntax.TyName
                                      SEDEL.Source.Syntax.Kind
                                      SEDEL.Source.Syntax.SType
                                      SEDEL.Source.Syntax.Expr)
                                   (Control.Monad.Trans.Except.ExceptT
                                      SEDEL.Environment.Err GHC.Types.IO)>_R
                                <b>_N)
                             (case x of wild1 { (,) a1 s' -> s' }))
                            `cast`
                          (Control.Monad.Trans.Reader.N:ReaderT[0]
                               <*>_N
                               <SEDEL.Environment.Ctx
                                  SEDEL.Source.Syntax.TmName
                                  SEDEL.Source.Syntax.CtxType
                                  SEDEL.Source.Syntax.TyName
                                  SEDEL.Source.Syntax.Kind
                                  SEDEL.Source.Syntax.SType
                                  SEDEL.Source.Syntax.Expr>_R
                               <Control.Monad.Trans.Except.ExceptT
                                  SEDEL.Environment.Err GHC.Types.IO>_R
                               <(b, GHC.Integer.Type.Integer)>_N)
                            r1)
                           `cast`
                         (Control.Monad.Trans.Except.N:ExceptT[0]
                              <SEDEL.Environment.Err>_N
                              <GHC.Types.IO>_R
                              <(b, GHC.Integer.Type.Integer)>_N ; GHC.Types.N:IO[0]
                                                                      <Data.Either.Either
                                                                         SEDEL.Environment.Err
                                                                         (b,
                                                                          GHC.Integer.Type.Integer)>_R)
                           ipv } })
                     `cast`
                   ((<SEDEL.Environment.Ctx
                        SEDEL.Source.Syntax.TmName
                        SEDEL.Source.Syntax.CtxType
                        SEDEL.Source.Syntax.TyName
                        SEDEL.Source.Syntax.Kind
                        SEDEL.Source.Syntax.SType
                        SEDEL.Source.Syntax.Expr>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <Data.Either.Either
                                      SEDEL.Environment.Err
                                      (b,
                                       GHC.Integer.Type.Integer)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <SEDEL.Environment.Err>_N
                                                                                <GHC.Types.IO>_R
                                                                                <(b,
                                                                                  GHC.Integer.Type.Integer)>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                            <*>_N
                                                                                                                            <SEDEL.Environment.Ctx
                                                                                                                               SEDEL.Source.Syntax.TmName
                                                                                                                               SEDEL.Source.Syntax.CtxType
                                                                                                                               SEDEL.Source.Syntax.TyName
                                                                                                                               SEDEL.Source.Syntax.Kind
                                                                                                                               SEDEL.Source.Syntax.SType
                                                                                                                               SEDEL.Source.Syntax.Expr>_R
                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                               SEDEL.Environment.Err
                                                                                                                               GHC.Types.IO>_R
                                                                                                                            <(b,
                                                                                                                              GHC.Integer.Type.Integer)>_N)))
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                (SEDEL.Environment.Ctx
                                                                                   SEDEL.Source.Syntax.TmName
                                                                                   SEDEL.Source.Syntax.CtxType
                                                                                   SEDEL.Source.Syntax.TyName
                                                                                   SEDEL.Source.Syntax.Kind
                                                                                   SEDEL.Source.Syntax.SType
                                                                                   SEDEL.Source.Syntax.Expr)
                                                                                (Control.Monad.Trans.Except.ExceptT
                                                                                   SEDEL.Environment.Err
                                                                                   GHC.Types.IO)>_N <a>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                     (SEDEL.Environment.Ctx
                                                                                        SEDEL.Source.Syntax.TmName
                                                                                        SEDEL.Source.Syntax.CtxType
                                                                                        SEDEL.Source.Syntax.TyName
                                                                                        SEDEL.Source.Syntax.Kind
                                                                                        SEDEL.Source.Syntax.SType
                                                                                        SEDEL.Source.Syntax.Expr)
                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                        SEDEL.Environment.Err
                                                                                        GHC.Types.IO)>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Reader.ReaderT
                                    (SEDEL.Environment.Ctx
                                       SEDEL.Source.Syntax.TmName
                                       SEDEL.Source.Syntax.CtxType
                                       SEDEL.Source.Syntax.TyName
                                       SEDEL.Source.Syntax.Kind
                                       SEDEL.Source.Syntax.SType
                                       SEDEL.Source.Syntax.Expr)
                                    (Control.Monad.Trans.Except.ExceptT
                                       SEDEL.Environment.Err GHC.Types.IO)>_R
                                 <b>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                       (SEDEL.Environment.Ctx
                                                                                                          SEDEL.Source.Syntax.TmName
                                                                                                          SEDEL.Source.Syntax.CtxType
                                                                                                          SEDEL.Source.Syntax.TyName
                                                                                                          SEDEL.Source.Syntax.Kind
                                                                                                          SEDEL.Source.Syntax.SType
                                                                                                          SEDEL.Source.Syntax.Expr)
                                                                                                       (Control.Monad.Trans.Except.ExceptT
                                                                                                          SEDEL.Environment.Err
                                                                                                          GHC.Types.IO)>_N <b>_N)
                  (\ @ a
                     @ b
                     (eta4 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer
                                (Control.Monad.Trans.Reader.ReaderT
                                   (SEDEL.Environment.Ctx
                                      SEDEL.Source.Syntax.TmName
                                      SEDEL.Source.Syntax.CtxType
                                      SEDEL.Source.Syntax.TyName
                                      SEDEL.Source.Syntax.Kind
                                      SEDEL.Source.Syntax.SType
                                      SEDEL.Source.Syntax.Expr)
                                   (Control.Monad.Trans.Except.ExceptT
                                      SEDEL.Environment.Err GHC.Types.IO))
                                a)
                     (eta5 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer
                                (Control.Monad.Trans.Reader.ReaderT
                                   (SEDEL.Environment.Ctx
                                      SEDEL.Source.Syntax.TmName
                                      SEDEL.Source.Syntax.CtxType
                                      SEDEL.Source.Syntax.TyName
                                      SEDEL.Source.Syntax.Kind
                                      SEDEL.Source.Syntax.SType
                                      SEDEL.Source.Syntax.Expr)
                                   (Control.Monad.Trans.Except.ExceptT
                                      SEDEL.Environment.Err GHC.Types.IO))
                                b)
                     (eta6 :: GHC.Integer.Type.Integer) ->
                   Control.Monad.Trans.State.Lazy.$w$cliftA2
                     @ (Control.Monad.Trans.Reader.ReaderT
                          (SEDEL.Environment.Ctx
                             SEDEL.Source.Syntax.TmName
                             SEDEL.Source.Syntax.CtxType
                             SEDEL.Source.Syntax.TyName
                             SEDEL.Source.Syntax.Kind
                             SEDEL.Source.Syntax.SType
                             SEDEL.Source.Syntax.Expr)
                          (Control.Monad.Trans.Except.ExceptT
                             SEDEL.Environment.Err GHC.Types.IO))
                     @ GHC.Integer.Type.Integer
                     (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorReaderT
                        @ (SEDEL.Environment.Ctx
                             SEDEL.Source.Syntax.TmName
                             SEDEL.Source.Syntax.CtxType
                             SEDEL.Source.Syntax.TyName
                             SEDEL.Source.Syntax.Kind
                             SEDEL.Source.Syntax.SType
                             SEDEL.Source.Syntax.Expr))
                     (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fMonadReaderT_$c>>=
                        @ (SEDEL.Environment.Ctx
                             SEDEL.Source.Syntax.TmName
                             SEDEL.Source.Syntax.CtxType
                             SEDEL.Source.Syntax.TyName
                             SEDEL.Source.Syntax.Kind
                             SEDEL.Source.Syntax.SType
                             SEDEL.Source.Syntax.Expr))
                     (\ @ a1 (eta7 :: a1) ->
                      let {
                        m1 :: GHC.Prim.State# GHC.Prim.RealWorld
                              -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                    Data.Either.Either SEDEL.Environment.Err a1 #)
                          {- Arity: 1 -}
                        = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                          (# s, Data.Either.Right @ SEDEL.Environment.Err @ a1 eta7 #)
                      } in
                      (\ (ds :: SEDEL.Environment.Ctx
                                  SEDEL.Source.Syntax.TmName
                                  SEDEL.Source.Syntax.CtxType
                                  SEDEL.Source.Syntax.TyName
                                  SEDEL.Source.Syntax.Kind
                                  SEDEL.Source.Syntax.SType
                                  SEDEL.Source.Syntax.Expr) ->
                       m1)
                        `cast`
                      ((<SEDEL.Environment.Ctx
                           SEDEL.Source.Syntax.TmName
                           SEDEL.Source.Syntax.CtxType
                           SEDEL.Source.Syntax.TyName
                           SEDEL.Source.Syntax.Kind
                           SEDEL.Source.Syntax.SType
                           SEDEL.Source.Syntax.Expr>_R
                        ->_R Sym (GHC.Types.N:IO[0]
                                      <Data.Either.Either
                                         SEDEL.Environment.Err
                                         a1>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                           <SEDEL.Environment.Err>_N
                                                           <GHC.Types.IO>_R
                                                           <a1>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                               <*>_N
                                                                               <SEDEL.Environment.Ctx
                                                                                  SEDEL.Source.Syntax.TmName
                                                                                  SEDEL.Source.Syntax.CtxType
                                                                                  SEDEL.Source.Syntax.TyName
                                                                                  SEDEL.Source.Syntax.Kind
                                                                                  SEDEL.Source.Syntax.SType
                                                                                  SEDEL.Source.Syntax.Expr>_R
                                                                               <Control.Monad.Trans.Except.ExceptT
                                                                                  SEDEL.Environment.Err
                                                                                  GHC.Types.IO>_R
                                                                               <a1>_N)))
                     @ a
                     @ b
                     @ a
                     (GHC.Base.const @ a @ b)
                     eta4
                     eta5
                     eta6)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                (SEDEL.Environment.Ctx
                                                                                   SEDEL.Source.Syntax.TmName
                                                                                   SEDEL.Source.Syntax.CtxType
                                                                                   SEDEL.Source.Syntax.TyName
                                                                                   SEDEL.Source.Syntax.Kind
                                                                                   SEDEL.Source.Syntax.SType
                                                                                   SEDEL.Source.Syntax.Expr)
                                                                                (Control.Monad.Trans.Except.ExceptT
                                                                                   SEDEL.Environment.Err
                                                                                   GHC.Types.IO)>_N <a>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                     (SEDEL.Environment.Ctx
                                                                                        SEDEL.Source.Syntax.TmName
                                                                                        SEDEL.Source.Syntax.CtxType
                                                                                        SEDEL.Source.Syntax.TyName
                                                                                        SEDEL.Source.Syntax.Kind
                                                                                        SEDEL.Source.Syntax.SType
                                                                                        SEDEL.Source.Syntax.Expr)
                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                        SEDEL.Environment.Err
                                                                                        GHC.Types.IO)>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Reader.ReaderT
                                    (SEDEL.Environment.Ctx
                                       SEDEL.Source.Syntax.TmName
                                       SEDEL.Source.Syntax.CtxType
                                       SEDEL.Source.Syntax.TyName
                                       SEDEL.Source.Syntax.Kind
                                       SEDEL.Source.Syntax.SType
                                       SEDEL.Source.Syntax.Expr)
                                    (Control.Monad.Trans.Except.ExceptT
                                       SEDEL.Environment.Err GHC.Types.IO)>_R
                                 <a>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                       (SEDEL.Environment.Ctx
                                                                                                          SEDEL.Source.Syntax.TmName
                                                                                                          SEDEL.Source.Syntax.CtxType
                                                                                                          SEDEL.Source.Syntax.TyName
                                                                                                          SEDEL.Source.Syntax.Kind
                                                                                                          SEDEL.Source.Syntax.SType
                                                                                                          SEDEL.Source.Syntax.Expr)
                                                                                                       (Control.Monad.Trans.Except.ExceptT
                                                                                                          SEDEL.Environment.Err
                                                                                                          GHC.Types.IO)>_N <a>_N) -}
548d6d4e9ab3e1e78b9fdb0dfa722b9e
  $s$fApplicativeFreshMT_$s$fApplicativeReaderT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ r.
                  @ (Control.Monad.Trans.Reader.ReaderT
                       r
                       (Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO))
                  (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorReaderT
                     @ r)
                  (\ @ a (x :: a) ->
                   let {
                     m1 :: GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                 Data.Either.Either SEDEL.Environment.Err a #)
                       {- Arity: 1 -}
                     = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                       (# s, Data.Either.Right @ SEDEL.Environment.Err @ a x #)
                   } in
                   (\ (ds :: r) -> m1)
                     `cast`
                   ((<r>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <Data.Either.Either
                                      SEDEL.Environment.Err
                                      a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                       <SEDEL.Environment.Err>_N
                                                       <GHC.Types.IO>_R
                                                       <a>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                          <*>_N
                                                                          <r>_R
                                                                          <Control.Monad.Trans.Except.ExceptT
                                                                             SEDEL.Environment.Err
                                                                             GHC.Types.IO>_R
                                                                          <a>_N)))
                  (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fApplicativeReaderT_$c<*>
                     @ r)
                  (Control.Monad.Trans.Reader.$fApplicativeReaderT_$cliftA2
                     @ (Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO)
                     @ r
                     (SEDEL.Source.Inference.$s$fApplicativeExceptT
                        @ SEDEL.Environment.Err))
                  (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fApplicativeReaderT_$c*>
                     @ r)
                  (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fApplicativeReaderT_$c<*
                     @ r) -}
e8297df885c070e1187ee0f63e60dd12
  $s$fApplicativeFreshMT_$s$fApplicativeReaderT_$c*> ::
    Control.Monad.Trans.Reader.ReaderT
      r
      (Control.Monad.Trans.Except.ExceptT
         SEDEL.Environment.Err GHC.Types.IO)
      a
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         b
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(SS))),1*C1(C1(U(U,1*U)))><L,1*C1(C1(U(U,U)))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (u :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              SEDEL.Environment.Err GHC.Types.IO)
                           a)
                   (v :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              SEDEL.Environment.Err GHC.Types.IO)
                           b)
                   (r1 :: r)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (u `cast`
                       (Control.Monad.Trans.Reader.N:ReaderT[0]
                            <*>_N
                            <r>_R
                            <Control.Monad.Trans.Except.ExceptT
                               SEDEL.Environment.Err GHC.Types.IO>_R
                            <a>_N)
                         r1)
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <SEDEL.Environment.Err>_N
                           <GHC.Types.IO>_R
                           <a>_N ; GHC.Types.N:IO[0]
                                       <Data.Either.Either SEDEL.Environment.Err a>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   Data.Either.Left e1
                   -> (# ipv, Data.Either.Left @ SEDEL.Environment.Err @ b e1 #)
                   Data.Either.Right x
                   -> (v `cast`
                       (Control.Monad.Trans.Reader.N:ReaderT[0]
                            <*>_N
                            <r>_R
                            <Control.Monad.Trans.Except.ExceptT
                               SEDEL.Environment.Err GHC.Types.IO>_R
                            <b>_N)
                         r1)
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <SEDEL.Environment.Err>_N
                           <GHC.Types.IO>_R
                           <b>_N ; GHC.Types.N:IO[0]
                                       <Data.Either.Either SEDEL.Environment.Err b>_R)
                        ipv } })
                  `cast`
                (forall (r :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Reader.ReaderT
                    r
                    (Control.Monad.Trans.Except.ExceptT
                       SEDEL.Environment.Err GHC.Types.IO)
                    a>_R
                 ->_R <Control.Monad.Trans.Reader.ReaderT
                         r
                         (Control.Monad.Trans.Except.ExceptT
                            SEDEL.Environment.Err GHC.Types.IO)
                         b>_R
                 ->_R (<r>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <Data.Either.Either
                                        SEDEL.Environment.Err
                                        b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                         <SEDEL.Environment.Err>_N
                                                         <GHC.Types.IO>_R
                                                         <b>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                            <*>_N
                                                                            <r>_R
                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                               SEDEL.Environment.Err
                                                                               GHC.Types.IO>_R
                                                                            <b>_N)) -}
65d8faee752e925edebb829c8fef4d0b
  $s$fApplicativeFreshMT_$s$fApplicativeReaderT_$c<* ::
    Control.Monad.Trans.Reader.ReaderT
      r
      (Control.Monad.Trans.Except.ExceptT
         SEDEL.Environment.Err GHC.Types.IO)
      a
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         b
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(LS))),1*C1(C1(U(U,U)))><L,1*C1(C1(U(U,1*U)))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (u :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              SEDEL.Environment.Err GHC.Types.IO)
                           a)
                   (v :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              SEDEL.Environment.Err GHC.Types.IO)
                           b)
                   (r1 :: r) ->
                 Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                   @ GHC.Types.IO
                   @ SEDEL.Environment.Err
                   GHC.Base.$fFunctorIO
                   GHC.Base.$fMonadIO
                   @ b
                   @ a
                   (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                    case (u `cast`
                          (Control.Monad.Trans.Reader.N:ReaderT[0]
                               <*>_N
                               <r>_R
                               <Control.Monad.Trans.Except.ExceptT
                                  SEDEL.Environment.Err GHC.Types.IO>_R
                               <a>_N)
                            r1)
                           `cast`
                         (Control.Monad.Trans.Except.N:ExceptT[0]
                              <SEDEL.Environment.Err>_N
                              <GHC.Types.IO>_R
                              <a>_N ; GHC.Types.N:IO[0]
                                          <Data.Either.Either SEDEL.Environment.Err a>_R)
                           s of ds { (#,#) ipv ipv1 ->
                    (# ipv,
                       Control.Monad.Trans.Except.$fApplicativeExceptT1
                         @ SEDEL.Environment.Err
                         @ b
                         @ a
                         ipv1 #) })
                     `cast`
                   (Sym (GHC.Types.N:IO[0]
                             <Data.Either.Either
                                SEDEL.Environment.Err
                                (b -> a)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                        <SEDEL.Environment.Err>_N
                                                        <GHC.Types.IO>_R
                                                        <b -> a>_N))
                   (v `cast`
                    (Control.Monad.Trans.Reader.N:ReaderT[0]
                         <*>_N
                         <r>_R
                         <Control.Monad.Trans.Except.ExceptT
                            SEDEL.Environment.Err GHC.Types.IO>_R
                         <b>_N)
                      r1))
                  `cast`
                (forall (r :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Reader.ReaderT
                    r
                    (Control.Monad.Trans.Except.ExceptT
                       SEDEL.Environment.Err GHC.Types.IO)
                    a>_R
                 ->_R <Control.Monad.Trans.Reader.ReaderT
                         r
                         (Control.Monad.Trans.Except.ExceptT
                            SEDEL.Environment.Err GHC.Types.IO)
                         b>_R
                 ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                               <*>_N
                               <r>_R
                               <Control.Monad.Trans.Except.ExceptT
                                  SEDEL.Environment.Err GHC.Types.IO>_R
                               <a>_N)) -}
604a353c23f97557ba8febb6c2442ee8
  $s$fApplicativeFreshMT_$s$fApplicativeReaderT_$c<*> ::
    Control.Monad.Trans.Reader.ReaderT
      r
      (Control.Monad.Trans.Except.ExceptT
         SEDEL.Environment.Err GHC.Types.IO)
      (a -> b)
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         a
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(U(U,1*U)))><L,1*C1(C(U(U,1*U)))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (f6 :: Control.Monad.Trans.Reader.ReaderT
                            r
                            (Control.Monad.Trans.Except.ExceptT
                               SEDEL.Environment.Err GHC.Types.IO)
                            (a -> b))
                   (v :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              SEDEL.Environment.Err GHC.Types.IO)
                           a)
                   (r1 :: r) ->
                 Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                   @ GHC.Types.IO
                   @ SEDEL.Environment.Err
                   GHC.Base.$fFunctorIO
                   GHC.Base.$fMonadIO
                   @ a
                   @ b
                   (f6
                      `cast`
                    (Control.Monad.Trans.Reader.N:ReaderT[0]
                         <*>_N
                         <r>_R
                         <Control.Monad.Trans.Except.ExceptT
                            SEDEL.Environment.Err GHC.Types.IO>_R
                         <a -> b>_N)
                      r1)
                   (v `cast`
                    (Control.Monad.Trans.Reader.N:ReaderT[0]
                         <*>_N
                         <r>_R
                         <Control.Monad.Trans.Except.ExceptT
                            SEDEL.Environment.Err GHC.Types.IO>_R
                         <a>_N)
                      r1))
                  `cast`
                (forall (r :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Reader.ReaderT
                    r
                    (Control.Monad.Trans.Except.ExceptT
                       SEDEL.Environment.Err GHC.Types.IO)
                    (a -> b)>_R
                 ->_R <Control.Monad.Trans.Reader.ReaderT
                         r
                         (Control.Monad.Trans.Except.ExceptT
                            SEDEL.Environment.Err GHC.Types.IO)
                         a>_R
                 ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                               <*>_N
                               <r>_R
                               <Control.Monad.Trans.Except.ExceptT
                                  SEDEL.Environment.Err GHC.Types.IO>_R
                               <b>_N)) -}
08c7462d5d981bcccc3b9c4ab51ec152
  $s$fApplicativeFreshMT_$s$fFunctorFreshMT ::
    GHC.Base.Functor
      (Unbound.Generics.LocallyNameless.Fresh.FreshMT
         (Control.Monad.Trans.Reader.ReaderT
            (SEDEL.Environment.Ctx
               SEDEL.Source.Syntax.TmName
               SEDEL.Source.Syntax.CtxType
               SEDEL.Source.Syntax.TyName
               SEDEL.Source.Syntax.Kind
               SEDEL.Source.Syntax.SType
               SEDEL.Source.Syntax.Expr)
            (Control.Monad.Trans.Except.ExceptT
               SEDEL.Environment.Err GHC.Types.IO)))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Fresh.FreshMT
                       (Control.Monad.Trans.Reader.ReaderT
                          (SEDEL.Environment.Ctx
                             SEDEL.Source.Syntax.TmName
                             SEDEL.Source.Syntax.CtxType
                             SEDEL.Source.Syntax.TyName
                             SEDEL.Source.Syntax.Kind
                             SEDEL.Source.Syntax.SType
                             SEDEL.Source.Syntax.Expr)
                          (Control.Monad.Trans.Except.ExceptT
                             SEDEL.Environment.Err GHC.Types.IO)))
                  (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorStateT_$cfmap
                     @ GHC.Integer.Type.Integer)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a -> b>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                     (SEDEL.Environment.Ctx
                                                                                        SEDEL.Source.Syntax.TmName
                                                                                        SEDEL.Source.Syntax.CtxType
                                                                                        SEDEL.Source.Syntax.TyName
                                                                                        SEDEL.Source.Syntax.Kind
                                                                                        SEDEL.Source.Syntax.SType
                                                                                        SEDEL.Source.Syntax.Expr)
                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                        SEDEL.Environment.Err
                                                                                        GHC.Types.IO)>_N <a>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                     (SEDEL.Environment.Ctx
                                                                                        SEDEL.Source.Syntax.TmName
                                                                                        SEDEL.Source.Syntax.CtxType
                                                                                        SEDEL.Source.Syntax.TyName
                                                                                        SEDEL.Source.Syntax.Kind
                                                                                        SEDEL.Source.Syntax.SType
                                                                                        SEDEL.Source.Syntax.Expr)
                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                        SEDEL.Environment.Err
                                                                                        GHC.Types.IO)>_N <b>_N)
                  (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorStateT1
                     @ GHC.Integer.Type.Integer)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                     (SEDEL.Environment.Ctx
                                                                                        SEDEL.Source.Syntax.TmName
                                                                                        SEDEL.Source.Syntax.CtxType
                                                                                        SEDEL.Source.Syntax.TyName
                                                                                        SEDEL.Source.Syntax.Kind
                                                                                        SEDEL.Source.Syntax.SType
                                                                                        SEDEL.Source.Syntax.Expr)
                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                        SEDEL.Environment.Err
                                                                                        GHC.Types.IO)>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Reader.ReaderT
                                    (SEDEL.Environment.Ctx
                                       SEDEL.Source.Syntax.TmName
                                       SEDEL.Source.Syntax.CtxType
                                       SEDEL.Source.Syntax.TyName
                                       SEDEL.Source.Syntax.Kind
                                       SEDEL.Source.Syntax.SType
                                       SEDEL.Source.Syntax.Expr)
                                    (Control.Monad.Trans.Except.ExceptT
                                       SEDEL.Environment.Err GHC.Types.IO)>_R
                                 <a>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                       (SEDEL.Environment.Ctx
                                                                                                          SEDEL.Source.Syntax.TmName
                                                                                                          SEDEL.Source.Syntax.CtxType
                                                                                                          SEDEL.Source.Syntax.TyName
                                                                                                          SEDEL.Source.Syntax.Kind
                                                                                                          SEDEL.Source.Syntax.SType
                                                                                                          SEDEL.Source.Syntax.Expr)
                                                                                                       (Control.Monad.Trans.Except.ExceptT
                                                                                                          SEDEL.Environment.Err
                                                                                                          GHC.Types.IO)>_N <a>_N) -}
2e93a79a4de1cce0d211d8bb089a29fd
  $s$fApplicativeFreshMT_$s$fFunctorReaderT ::
    GHC.Base.Functor
      (Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ r.
                  @ (Control.Monad.Trans.Reader.ReaderT
                       r
                       (Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO))
                  (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorReaderT_$cfmap
                     @ r)
                  (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorReaderT_$c<$
                     @ r) -}
6ef281489531d9943bc0aa2eb9bec6ea
  $s$fApplicativeFreshMT_$s$fFunctorReaderT_$c<$ ::
    a
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         b
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><C(C(S(SL))),1*C1(C1(U(U,1*U)))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (x :: a)
                   (v :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              SEDEL.Environment.Err GHC.Types.IO)
                           b) ->
                 let {
                   lvl213 :: Data.Either.Either SEDEL.Environment.Err a
                   = Data.Either.Right @ SEDEL.Environment.Err @ a x
                 } in
                 (\ (x1 :: r) (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  case (v `cast`
                        (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N
                             <r>_R
                             <Control.Monad.Trans.Except.ExceptT
                                SEDEL.Environment.Err GHC.Types.IO>_R
                             <b>_N)
                          x1)
                         `cast`
                       (Control.Monad.Trans.Except.N:ExceptT[0]
                            <SEDEL.Environment.Err>_N
                            <GHC.Types.IO>_R
                            <b>_N ; GHC.Types.N:IO[0]
                                        <Data.Either.Either SEDEL.Environment.Err b>_R)
                         s of ds { (#,#) ipv ipv1 ->
                  (# ipv,
                     case ipv1 of wild {
                       Data.Either.Left x2
                       -> Data.Either.Left @ SEDEL.Environment.Err @ a x2
                       Data.Either.Right y -> lvl213 } #) })
                   `cast`
                 ((<r>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <Data.Either.Either
                                    SEDEL.Environment.Err
                                    a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                     <SEDEL.Environment.Err>_N
                                                     <GHC.Types.IO>_R
                                                     <a>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                        <*>_N
                                                                        <r>_R
                                                                        <Control.Monad.Trans.Except.ExceptT
                                                                           SEDEL.Environment.Err
                                                                           GHC.Types.IO>_R
                                                                        <a>_N))) -}
62021b8b29e835e46041e4ec2618d62b
  $s$fApplicativeFreshMT_$s$fFunctorReaderT_$cfmap ::
    (a -> b)
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         a
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*C1(U)><C(C(S(SL))),1*C1(C1(U(U,1*U)))><L,U><S,U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ r @ a @ b (f6 :: a -> b) ->
                 Control.Monad.Trans.Reader.mapReaderT
                   @ *
                   @ *
                   @ (Control.Monad.Trans.Except.ExceptT
                        SEDEL.Environment.Err GHC.Types.IO)
                   @ a
                   @ (Control.Monad.Trans.Except.ExceptT
                        SEDEL.Environment.Err GHC.Types.IO)
                   @ b
                   @ r
                   (\ (x :: GHC.Types.IO (Data.Either.Either SEDEL.Environment.Err a))
                      (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                    case x `cast`
                         (GHC.Types.N:IO[0] <Data.Either.Either SEDEL.Environment.Err a>_R)
                           s of ds { (#,#) ipv ipv1 ->
                    (# ipv,
                       Data.Either.$fApplicativeEither_$cfmap
                         @ SEDEL.Environment.Err
                         @ a
                         @ b
                         f6
                         ipv1 #) })
                     `cast`
                   (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                             <SEDEL.Environment.Err>_N <GHC.Types.IO>_R <a>_N)
                    ->_R Sym (GHC.Types.N:IO[0]
                                  <Data.Either.Either
                                     SEDEL.Environment.Err
                                     b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                      <SEDEL.Environment.Err>_N
                                                      <GHC.Types.IO>_R
                                                      <b>_N))) -}
dda573ec303d2cc2735fa95e2bd11725
  $s$fApplicativeFreshMT_$s$fFunctorStateT1 ::
    a
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Reader.ReaderT
            (SEDEL.Environment.Ctx
               SEDEL.Source.Syntax.TmName
               SEDEL.Source.Syntax.CtxType
               SEDEL.Source.Syntax.TyName
               SEDEL.Source.Syntax.Kind
               SEDEL.Source.Syntax.SType
               SEDEL.Source.Syntax.Expr)
            (Control.Monad.Trans.Except.ExceptT
               SEDEL.Environment.Err GHC.Types.IO))
         b
    -> s
    -> Control.Monad.Trans.Reader.ReaderT
         (SEDEL.Environment.Ctx
            SEDEL.Source.Syntax.TmName
            SEDEL.Source.Syntax.CtxType
            SEDEL.Source.Syntax.TyName
            SEDEL.Source.Syntax.Kind
            SEDEL.Source.Syntax.SType
            SEDEL.Source.Syntax.Expr)
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         (a, s)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,1*C1(C(C1(U(U,1*U))))><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ s
                   @ a
                   @ b
                   (x :: a)
                   (eta4 :: Control.Monad.Trans.State.Lazy.StateT
                              s
                              (Control.Monad.Trans.Reader.ReaderT
                                 (SEDEL.Environment.Ctx
                                    SEDEL.Source.Syntax.TmName
                                    SEDEL.Source.Syntax.CtxType
                                    SEDEL.Source.Syntax.TyName
                                    SEDEL.Source.Syntax.Kind
                                    SEDEL.Source.Syntax.SType
                                    SEDEL.Source.Syntax.Expr)
                                 (Control.Monad.Trans.Except.ExceptT
                                    SEDEL.Environment.Err GHC.Types.IO))
                              b)
                   (eta5 :: s) ->
                 let {
                   m1 :: Control.Monad.Trans.Reader.ReaderT
                           (SEDEL.Environment.Ctx
                              SEDEL.Source.Syntax.TmName
                              SEDEL.Source.Syntax.CtxType
                              SEDEL.Source.Syntax.TyName
                              SEDEL.Source.Syntax.Kind
                              SEDEL.Source.Syntax.SType
                              SEDEL.Source.Syntax.Expr)
                           (Control.Monad.Trans.Except.ExceptT
                              SEDEL.Environment.Err GHC.Types.IO)
                           (b, s)
                   = eta4
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N
                          <Control.Monad.Trans.Reader.ReaderT
                             (SEDEL.Environment.Ctx
                                SEDEL.Source.Syntax.TmName
                                SEDEL.Source.Syntax.CtxType
                                SEDEL.Source.Syntax.TyName
                                SEDEL.Source.Syntax.Kind
                                SEDEL.Source.Syntax.SType
                                SEDEL.Source.Syntax.Expr)
                             (Control.Monad.Trans.Except.ExceptT
                                SEDEL.Environment.Err GHC.Types.IO)>_R
                          <b>_N)
                       eta5
                 } in
                 (\ (x1 :: SEDEL.Environment.Ctx
                             SEDEL.Source.Syntax.TmName
                             SEDEL.Source.Syntax.CtxType
                             SEDEL.Source.Syntax.TyName
                             SEDEL.Source.Syntax.Kind
                             SEDEL.Source.Syntax.SType
                             SEDEL.Source.Syntax.Expr)
                    (s1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  case (m1
                          `cast`
                        (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N
                             <SEDEL.Environment.Ctx
                                SEDEL.Source.Syntax.TmName
                                SEDEL.Source.Syntax.CtxType
                                SEDEL.Source.Syntax.TyName
                                SEDEL.Source.Syntax.Kind
                                SEDEL.Source.Syntax.SType
                                SEDEL.Source.Syntax.Expr>_R
                             <Control.Monad.Trans.Except.ExceptT
                                SEDEL.Environment.Err GHC.Types.IO>_R
                             <(b, s)>_N)
                          x1)
                         `cast`
                       (Control.Monad.Trans.Except.N:ExceptT[0]
                            <SEDEL.Environment.Err>_N
                            <GHC.Types.IO>_R
                            <(b, s)>_N ; GHC.Types.N:IO[0]
                                             <Data.Either.Either SEDEL.Environment.Err (b, s)>_R)
                         s1 of ds { (#,#) ipv ipv1 ->
                  (# ipv,
                     case ipv1 of wild {
                       Data.Either.Left x2
                       -> Data.Either.Left @ SEDEL.Environment.Err @ (a, s) x2
                       Data.Either.Right y
                       -> Data.Either.Right
                            @ SEDEL.Environment.Err
                            @ (a, s)
                            (x, case y of wild1 { (,) a1 s' -> s' }) } #) })
                   `cast`
                 ((<SEDEL.Environment.Ctx
                      SEDEL.Source.Syntax.TmName
                      SEDEL.Source.Syntax.CtxType
                      SEDEL.Source.Syntax.TyName
                      SEDEL.Source.Syntax.Kind
                      SEDEL.Source.Syntax.SType
                      SEDEL.Source.Syntax.Expr>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <Data.Either.Either
                                    SEDEL.Environment.Err
                                    (a, s)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                          <SEDEL.Environment.Err>_N
                                                          <GHC.Types.IO>_R
                                                          <(a,
                                                            s)>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                               <*>_N
                                                                               <SEDEL.Environment.Ctx
                                                                                  SEDEL.Source.Syntax.TmName
                                                                                  SEDEL.Source.Syntax.CtxType
                                                                                  SEDEL.Source.Syntax.TyName
                                                                                  SEDEL.Source.Syntax.Kind
                                                                                  SEDEL.Source.Syntax.SType
                                                                                  SEDEL.Source.Syntax.Expr>_R
                                                                               <Control.Monad.Trans.Except.ExceptT
                                                                                  SEDEL.Environment.Err
                                                                                  GHC.Types.IO>_R
                                                                               <(a, s)>_N))) -}
b21e3eb68319aa5c7aec5d8519dc3b7c
  $s$fApplicativeFreshMT_$s$fFunctorStateT_$cfmap ::
    (a -> b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Reader.ReaderT
            (SEDEL.Environment.Ctx
               SEDEL.Source.Syntax.TmName
               SEDEL.Source.Syntax.CtxType
               SEDEL.Source.Syntax.TyName
               SEDEL.Source.Syntax.Kind
               SEDEL.Source.Syntax.SType
               SEDEL.Source.Syntax.Expr)
            (Control.Monad.Trans.Except.ExceptT
               SEDEL.Environment.Err GHC.Types.IO))
         a
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Reader.ReaderT
            (SEDEL.Environment.Ctx
               SEDEL.Source.Syntax.TmName
               SEDEL.Source.Syntax.CtxType
               SEDEL.Source.Syntax.TyName
               SEDEL.Source.Syntax.Kind
               SEDEL.Source.Syntax.SType
               SEDEL.Source.Syntax.Expr)
            (Control.Monad.Trans.Except.ExceptT
               SEDEL.Environment.Err GHC.Types.IO))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(U)><L,1*C1(C(C1(U(U,1*U))))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (f6 :: a -> b)
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Trans.Reader.ReaderT
                               (SEDEL.Environment.Ctx
                                  SEDEL.Source.Syntax.TmName
                                  SEDEL.Source.Syntax.CtxType
                                  SEDEL.Source.Syntax.TyName
                                  SEDEL.Source.Syntax.Kind
                                  SEDEL.Source.Syntax.SType
                                  SEDEL.Source.Syntax.Expr)
                               (Control.Monad.Trans.Except.ExceptT
                                  SEDEL.Environment.Err GHC.Types.IO))
                            a)
                   (s1 :: s) ->
                 let {
                   m2 :: Control.Monad.Trans.Reader.ReaderT
                           (SEDEL.Environment.Ctx
                              SEDEL.Source.Syntax.TmName
                              SEDEL.Source.Syntax.CtxType
                              SEDEL.Source.Syntax.TyName
                              SEDEL.Source.Syntax.Kind
                              SEDEL.Source.Syntax.SType
                              SEDEL.Source.Syntax.Expr)
                           (Control.Monad.Trans.Except.ExceptT
                              SEDEL.Environment.Err GHC.Types.IO)
                           (a, s)
                   = m1
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N
                          <Control.Monad.Trans.Reader.ReaderT
                             (SEDEL.Environment.Ctx
                                SEDEL.Source.Syntax.TmName
                                SEDEL.Source.Syntax.CtxType
                                SEDEL.Source.Syntax.TyName
                                SEDEL.Source.Syntax.Kind
                                SEDEL.Source.Syntax.SType
                                SEDEL.Source.Syntax.Expr)
                             (Control.Monad.Trans.Except.ExceptT
                                SEDEL.Environment.Err GHC.Types.IO)>_R
                          <a>_N)
                       s1
                 } in
                 (\ (x :: SEDEL.Environment.Ctx
                            SEDEL.Source.Syntax.TmName
                            SEDEL.Source.Syntax.CtxType
                            SEDEL.Source.Syntax.TyName
                            SEDEL.Source.Syntax.Kind
                            SEDEL.Source.Syntax.SType
                            SEDEL.Source.Syntax.Expr)
                    (s2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  case (m2
                          `cast`
                        (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N
                             <SEDEL.Environment.Ctx
                                SEDEL.Source.Syntax.TmName
                                SEDEL.Source.Syntax.CtxType
                                SEDEL.Source.Syntax.TyName
                                SEDEL.Source.Syntax.Kind
                                SEDEL.Source.Syntax.SType
                                SEDEL.Source.Syntax.Expr>_R
                             <Control.Monad.Trans.Except.ExceptT
                                SEDEL.Environment.Err GHC.Types.IO>_R
                             <(a, s)>_N)
                          x)
                         `cast`
                       (Control.Monad.Trans.Except.N:ExceptT[0]
                            <SEDEL.Environment.Err>_N
                            <GHC.Types.IO>_R
                            <(a, s)>_N ; GHC.Types.N:IO[0]
                                             <Data.Either.Either SEDEL.Environment.Err (a, s)>_R)
                         s2 of ds { (#,#) ipv ipv1 ->
                  (# ipv,
                     case ipv1 of wild {
                       Data.Either.Left x1
                       -> Data.Either.Left @ SEDEL.Environment.Err @ (b, s) x1
                       Data.Either.Right y
                       -> Data.Either.Right
                            @ SEDEL.Environment.Err
                            @ (b, s)
                            (f6 (case y of wild1 { (,) a1 s' -> a1 }),
                             case y of wild1 { (,) a1 s' -> s' }) } #) })
                   `cast`
                 ((<SEDEL.Environment.Ctx
                      SEDEL.Source.Syntax.TmName
                      SEDEL.Source.Syntax.CtxType
                      SEDEL.Source.Syntax.TyName
                      SEDEL.Source.Syntax.Kind
                      SEDEL.Source.Syntax.SType
                      SEDEL.Source.Syntax.Expr>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <Data.Either.Either
                                    SEDEL.Environment.Err
                                    (b, s)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                          <SEDEL.Environment.Err>_N
                                                          <GHC.Types.IO>_R
                                                          <(b,
                                                            s)>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                               <*>_N
                                                                               <SEDEL.Environment.Ctx
                                                                                  SEDEL.Source.Syntax.TmName
                                                                                  SEDEL.Source.Syntax.CtxType
                                                                                  SEDEL.Source.Syntax.TyName
                                                                                  SEDEL.Source.Syntax.Kind
                                                                                  SEDEL.Source.Syntax.SType
                                                                                  SEDEL.Source.Syntax.Expr>_R
                                                                               <Control.Monad.Trans.Except.ExceptT
                                                                                  SEDEL.Environment.Err
                                                                                  GHC.Types.IO>_R
                                                                               <(b, s)>_N)))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s
                         (Control.Monad.Trans.Reader.ReaderT
                            (SEDEL.Environment.Ctx
                               SEDEL.Source.Syntax.TmName
                               SEDEL.Source.Syntax.CtxType
                               SEDEL.Source.Syntax.TyName
                               SEDEL.Source.Syntax.Kind
                               SEDEL.Source.Syntax.SType
                               SEDEL.Source.Syntax.Expr)
                            (Control.Monad.Trans.Except.ExceptT
                               SEDEL.Environment.Err GHC.Types.IO))
                         a>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Trans.Reader.ReaderT
                                  (SEDEL.Environment.Ctx
                                     SEDEL.Source.Syntax.TmName
                                     SEDEL.Source.Syntax.CtxType
                                     SEDEL.Source.Syntax.TyName
                                     SEDEL.Source.Syntax.Kind
                                     SEDEL.Source.Syntax.SType
                                     SEDEL.Source.Syntax.Expr)
                                  (Control.Monad.Trans.Except.ExceptT
                                     SEDEL.Environment.Err GHC.Types.IO)>_R
                               <b>_N)) -}
300b4584cc750f3b3184a572cee3aa0d
  $s$fApplicativeFreshMT_$s$fMonadReaderT ::
    GHC.Base.Monad
      (Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ r.
                  @ (Control.Monad.Trans.Reader.ReaderT
                       r
                       (Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO))
                  (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fApplicativeReaderT
                     @ r)
                  (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fMonadReaderT_$c>>=
                     @ r)
                  (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fApplicativeReaderT_$c*>
                     @ r)
                  (\ @ a (eta4 :: a) ->
                   let {
                     m1 :: GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                 Data.Either.Either SEDEL.Environment.Err a #)
                       {- Arity: 1 -}
                     = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                       (# s, Data.Either.Right @ SEDEL.Environment.Err @ a eta4 #)
                   } in
                   (\ (ds :: r) -> m1)
                     `cast`
                   ((<r>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <Data.Either.Either
                                      SEDEL.Environment.Err
                                      a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                       <SEDEL.Environment.Err>_N
                                                       <GHC.Types.IO>_R
                                                       <a>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                          <*>_N
                                                                          <r>_R
                                                                          <Control.Monad.Trans.Except.ExceptT
                                                                             SEDEL.Environment.Err
                                                                             GHC.Types.IO>_R
                                                                          <a>_N)))
                  (SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fMonadReaderT_$cfail
                     @ r) -}
442facd7f2954376bb5d06651f478e93
  $s$fApplicativeFreshMT_$s$fMonadReaderT_$c>>= ::
    Control.Monad.Trans.Reader.ReaderT
      r
      (Control.Monad.Trans.Except.ExceptT
         SEDEL.Environment.Err GHC.Types.IO)
      a
    -> (a
        -> Control.Monad.Trans.Reader.ReaderT
             r
             (Control.Monad.Trans.Except.ExceptT
                SEDEL.Environment.Err GHC.Types.IO)
             b)
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(SS))),1*C1(C1(U(U,1*U)))><L,1*C1(C1(C1(U(U,U))))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Reader.ReaderT
                            r
                            (Control.Monad.Trans.Except.ExceptT
                               SEDEL.Environment.Err GHC.Types.IO)
                            a)
                   (k :: a
                         -> Control.Monad.Trans.Reader.ReaderT
                              r
                              (Control.Monad.Trans.Except.ExceptT
                                 SEDEL.Environment.Err GHC.Types.IO)
                              b)
                   (r1 :: r)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (m1
                         `cast`
                       (Control.Monad.Trans.Reader.N:ReaderT[0]
                            <*>_N
                            <r>_R
                            <Control.Monad.Trans.Except.ExceptT
                               SEDEL.Environment.Err GHC.Types.IO>_R
                            <a>_N)
                         r1)
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <SEDEL.Environment.Err>_N
                           <GHC.Types.IO>_R
                           <a>_N ; GHC.Types.N:IO[0]
                                       <Data.Either.Either SEDEL.Environment.Err a>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   Data.Either.Left e1
                   -> (# ipv, Data.Either.Left @ SEDEL.Environment.Err @ b e1 #)
                   Data.Either.Right x
                   -> ((k x)
                         `cast`
                       (Control.Monad.Trans.Reader.N:ReaderT[0]
                            <*>_N
                            <r>_R
                            <Control.Monad.Trans.Except.ExceptT
                               SEDEL.Environment.Err GHC.Types.IO>_R
                            <b>_N)
                         r1)
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <SEDEL.Environment.Err>_N
                           <GHC.Types.IO>_R
                           <b>_N ; GHC.Types.N:IO[0]
                                       <Data.Either.Either SEDEL.Environment.Err b>_R)
                        ipv } })
                  `cast`
                (forall (r :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Reader.ReaderT
                    r
                    (Control.Monad.Trans.Except.ExceptT
                       SEDEL.Environment.Err GHC.Types.IO)
                    a>_R
                 ->_R <a
                       -> Control.Monad.Trans.Reader.ReaderT
                            r
                            (Control.Monad.Trans.Except.ExceptT
                               SEDEL.Environment.Err GHC.Types.IO)
                            b>_R
                 ->_R (<r>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <Data.Either.Either
                                        SEDEL.Environment.Err
                                        b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                         <SEDEL.Environment.Err>_N
                                                         <GHC.Types.IO>_R
                                                         <b>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                            <*>_N
                                                                            <r>_R
                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                               SEDEL.Environment.Err
                                                                               GHC.Types.IO>_R
                                                                            <b>_N)) -}
5bc2c1630010e4bbea0aec5eed25ae29
  $s$fApplicativeFreshMT_$s$fMonadReaderT_$cfail ::
    GHC.Base.String
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         a
  {- Arity: 1, Strictness: <L,U>, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ r @ a (msg :: GHC.Base.String) ->
                 let {
                   m1 :: GHC.Types.IO (Data.Either.Either SEDEL.Environment.Err a)
                   = GHC.Magic.noinline
                       @ (forall a1. [GHC.Types.Char] -> GHC.Types.IO a1)
                       GHC.IO.failIO1
                         `cast`
                       (forall (a1 :: <*>_N).
                        <GHC.Base.String>_R ->_R Sym (GHC.Types.N:IO[0] <a1>_R))
                       @ (Data.Either.Either SEDEL.Environment.Err a)
                       msg
                 } in
                 (\ (ds :: r) -> m1)
                   `cast`
                 ((<r>_R
                   ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                 <SEDEL.Environment.Err>_N
                                 <GHC.Types.IO>_R
                                 <a>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                    <*>_N
                                                    <r>_R
                                                    <Control.Monad.Trans.Except.ExceptT
                                                       SEDEL.Environment.Err GHC.Types.IO>_R
                                                    <a>_N))) -}
286c0002adb0d191bff0aff4b88e735e
  $s$fFreshFreshMT_$s$fMonadFreshMT ::
    GHC.Base.Monad
      (Unbound.Generics.LocallyNameless.Fresh.FreshMT
         (Control.Monad.Trans.Reader.ReaderT
            (SEDEL.Environment.Ctx
               SEDEL.Source.Syntax.TmName
               SEDEL.Source.Syntax.CtxType
               SEDEL.Source.Syntax.TyName
               SEDEL.Source.Syntax.Kind
               SEDEL.Source.Syntax.SType
               SEDEL.Source.Syntax.Expr)
            (Control.Monad.Trans.Except.ExceptT
               SEDEL.Environment.Err GHC.Types.IO)))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Fresh.FreshMT
                       (Control.Monad.Trans.Reader.ReaderT
                          (SEDEL.Environment.Ctx
                             SEDEL.Source.Syntax.TmName
                             SEDEL.Source.Syntax.CtxType
                             SEDEL.Source.Syntax.TyName
                             SEDEL.Source.Syntax.Kind
                             SEDEL.Source.Syntax.SType
                             SEDEL.Source.Syntax.Expr)
                          (Control.Monad.Trans.Except.ExceptT
                             SEDEL.Environment.Err GHC.Types.IO)))
                  SEDEL.Source.Inference.$s$fApplicativeFreshMT
                  (SEDEL.Source.Inference.$s$fFreshFreshMT_$s$fMonadStateT_$c>>=
                     @ GHC.Integer.Type.Integer)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                (SEDEL.Environment.Ctx
                                                                                   SEDEL.Source.Syntax.TmName
                                                                                   SEDEL.Source.Syntax.CtxType
                                                                                   SEDEL.Source.Syntax.TyName
                                                                                   SEDEL.Source.Syntax.Kind
                                                                                   SEDEL.Source.Syntax.SType
                                                                                   SEDEL.Source.Syntax.Expr)
                                                                                (Control.Monad.Trans.Except.ExceptT
                                                                                   SEDEL.Environment.Err
                                                                                   GHC.Types.IO)>_N <a>_N
                   ->_R (<a>_R
                         ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                           (SEDEL.Environment.Ctx
                                                                                              SEDEL.Source.Syntax.TmName
                                                                                              SEDEL.Source.Syntax.CtxType
                                                                                              SEDEL.Source.Syntax.TyName
                                                                                              SEDEL.Source.Syntax.Kind
                                                                                              SEDEL.Source.Syntax.SType
                                                                                              SEDEL.Source.Syntax.Expr)
                                                                                           (Control.Monad.Trans.Except.ExceptT
                                                                                              SEDEL.Environment.Err
                                                                                              GHC.Types.IO)>_N <b>_N)
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                     (SEDEL.Environment.Ctx
                                                                                        SEDEL.Source.Syntax.TmName
                                                                                        SEDEL.Source.Syntax.CtxType
                                                                                        SEDEL.Source.Syntax.TyName
                                                                                        SEDEL.Source.Syntax.Kind
                                                                                        SEDEL.Source.Syntax.SType
                                                                                        SEDEL.Source.Syntax.Expr)
                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                        SEDEL.Environment.Err
                                                                                        GHC.Types.IO)>_N <b>_N)
                  (SEDEL.Source.Inference.$s$fFreshFreshMT_$s$fMonadStateT_$c>>
                     @ GHC.Integer.Type.Integer)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                (SEDEL.Environment.Ctx
                                                                                   SEDEL.Source.Syntax.TmName
                                                                                   SEDEL.Source.Syntax.CtxType
                                                                                   SEDEL.Source.Syntax.TyName
                                                                                   SEDEL.Source.Syntax.Kind
                                                                                   SEDEL.Source.Syntax.SType
                                                                                   SEDEL.Source.Syntax.Expr)
                                                                                (Control.Monad.Trans.Except.ExceptT
                                                                                   SEDEL.Environment.Err
                                                                                   GHC.Types.IO)>_N <a>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                     (SEDEL.Environment.Ctx
                                                                                        SEDEL.Source.Syntax.TmName
                                                                                        SEDEL.Source.Syntax.CtxType
                                                                                        SEDEL.Source.Syntax.TyName
                                                                                        SEDEL.Source.Syntax.Kind
                                                                                        SEDEL.Source.Syntax.SType
                                                                                        SEDEL.Source.Syntax.Expr)
                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                        SEDEL.Environment.Err
                                                                                        GHC.Types.IO)>_N <b>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                     (SEDEL.Environment.Ctx
                                                                                        SEDEL.Source.Syntax.TmName
                                                                                        SEDEL.Source.Syntax.CtxType
                                                                                        SEDEL.Source.Syntax.TyName
                                                                                        SEDEL.Source.Syntax.Kind
                                                                                        SEDEL.Source.Syntax.SType
                                                                                        SEDEL.Source.Syntax.Expr)
                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                        SEDEL.Environment.Err
                                                                                        GHC.Types.IO)>_N <b>_N)
                  (\ @ a (eta4 :: a) (eta5 :: GHC.Integer.Type.Integer) ->
                   let {
                     m1 :: GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                 Data.Either.Either
                                   SEDEL.Environment.Err (a, GHC.Integer.Type.Integer) #)
                       {- Arity: 1 -}
                     = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                       (# s,
                          Data.Either.Right
                            @ SEDEL.Environment.Err
                            @ (a, GHC.Integer.Type.Integer)
                            (eta4, eta5) #)
                   } in
                   (\ (ds :: SEDEL.Environment.Ctx
                               SEDEL.Source.Syntax.TmName
                               SEDEL.Source.Syntax.CtxType
                               SEDEL.Source.Syntax.TyName
                               SEDEL.Source.Syntax.Kind
                               SEDEL.Source.Syntax.SType
                               SEDEL.Source.Syntax.Expr) ->
                    m1)
                     `cast`
                   ((<SEDEL.Environment.Ctx
                        SEDEL.Source.Syntax.TmName
                        SEDEL.Source.Syntax.CtxType
                        SEDEL.Source.Syntax.TyName
                        SEDEL.Source.Syntax.Kind
                        SEDEL.Source.Syntax.SType
                        SEDEL.Source.Syntax.Expr>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <Data.Either.Either
                                      SEDEL.Environment.Err
                                      (a,
                                       GHC.Integer.Type.Integer)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <SEDEL.Environment.Err>_N
                                                                                <GHC.Types.IO>_R
                                                                                <(a,
                                                                                  GHC.Integer.Type.Integer)>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                            <*>_N
                                                                                                                            <SEDEL.Environment.Ctx
                                                                                                                               SEDEL.Source.Syntax.TmName
                                                                                                                               SEDEL.Source.Syntax.CtxType
                                                                                                                               SEDEL.Source.Syntax.TyName
                                                                                                                               SEDEL.Source.Syntax.Kind
                                                                                                                               SEDEL.Source.Syntax.SType
                                                                                                                               SEDEL.Source.Syntax.Expr>_R
                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                               SEDEL.Environment.Err
                                                                                                                               GHC.Types.IO>_R
                                                                                                                            <(a,
                                                                                                                              GHC.Integer.Type.Integer)>_N)))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Reader.ReaderT
                                    (SEDEL.Environment.Ctx
                                       SEDEL.Source.Syntax.TmName
                                       SEDEL.Source.Syntax.CtxType
                                       SEDEL.Source.Syntax.TyName
                                       SEDEL.Source.Syntax.Kind
                                       SEDEL.Source.Syntax.SType
                                       SEDEL.Source.Syntax.Expr)
                                    (Control.Monad.Trans.Except.ExceptT
                                       SEDEL.Environment.Err GHC.Types.IO)>_R
                                 <a>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                       (SEDEL.Environment.Ctx
                                                                                                          SEDEL.Source.Syntax.TmName
                                                                                                          SEDEL.Source.Syntax.CtxType
                                                                                                          SEDEL.Source.Syntax.TyName
                                                                                                          SEDEL.Source.Syntax.Kind
                                                                                                          SEDEL.Source.Syntax.SType
                                                                                                          SEDEL.Source.Syntax.Expr)
                                                                                                       (Control.Monad.Trans.Except.ExceptT
                                                                                                          SEDEL.Environment.Err
                                                                                                          GHC.Types.IO)>_N <a>_N)
                  (SEDEL.Source.Inference.$s$fFreshFreshMT_$s$fMonadStateT_$cfail
                     @ GHC.Integer.Type.Integer)
                    `cast`
                  (forall (a :: <*>_N).
                   <[GHC.Types.Char]>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                     (SEDEL.Environment.Ctx
                                                                                        SEDEL.Source.Syntax.TmName
                                                                                        SEDEL.Source.Syntax.CtxType
                                                                                        SEDEL.Source.Syntax.TyName
                                                                                        SEDEL.Source.Syntax.Kind
                                                                                        SEDEL.Source.Syntax.SType
                                                                                        SEDEL.Source.Syntax.Expr)
                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                        SEDEL.Environment.Err
                                                                                        GHC.Types.IO)>_N <a>_N) -}
7755431d8326c03e979bf2968c9d9ac6
  $s$fFreshFreshMT_$s$fMonadStateT_$c>> ::
    Control.Monad.Trans.State.Lazy.StateT
      s
      (Control.Monad.Trans.Reader.ReaderT
         (SEDEL.Environment.Ctx
            SEDEL.Source.Syntax.TmName
            SEDEL.Source.Syntax.CtxType
            SEDEL.Source.Syntax.TyName
            SEDEL.Source.Syntax.Kind
            SEDEL.Source.Syntax.SType
            SEDEL.Source.Syntax.Expr)
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO))
      a
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Reader.ReaderT
            (SEDEL.Environment.Ctx
               SEDEL.Source.Syntax.TmName
               SEDEL.Source.Syntax.CtxType
               SEDEL.Source.Syntax.TyName
               SEDEL.Source.Syntax.Kind
               SEDEL.Source.Syntax.SType
               SEDEL.Source.Syntax.Expr)
            (Control.Monad.Trans.Except.ExceptT
               SEDEL.Environment.Err GHC.Types.IO))
         b
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Reader.ReaderT
            (SEDEL.Environment.Ctx
               SEDEL.Source.Syntax.TmName
               SEDEL.Source.Syntax.CtxType
               SEDEL.Source.Syntax.TyName
               SEDEL.Source.Syntax.Kind
               SEDEL.Source.Syntax.SType
               SEDEL.Source.Syntax.Expr)
            (Control.Monad.Trans.Except.ExceptT
               SEDEL.Environment.Err GHC.Types.IO))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(C1(U(U,1*U))))><L,C(C1(C1(U)))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Trans.Reader.ReaderT
                               (SEDEL.Environment.Ctx
                                  SEDEL.Source.Syntax.TmName
                                  SEDEL.Source.Syntax.CtxType
                                  SEDEL.Source.Syntax.TyName
                                  SEDEL.Source.Syntax.Kind
                                  SEDEL.Source.Syntax.SType
                                  SEDEL.Source.Syntax.Expr)
                               (Control.Monad.Trans.Except.ExceptT
                                  SEDEL.Environment.Err GHC.Types.IO))
                            a)
                   (k :: Control.Monad.Trans.State.Lazy.StateT
                           s
                           (Control.Monad.Trans.Reader.ReaderT
                              (SEDEL.Environment.Ctx
                                 SEDEL.Source.Syntax.TmName
                                 SEDEL.Source.Syntax.CtxType
                                 SEDEL.Source.Syntax.TyName
                                 SEDEL.Source.Syntax.Kind
                                 SEDEL.Source.Syntax.SType
                                 SEDEL.Source.Syntax.Expr)
                              (Control.Monad.Trans.Except.ExceptT
                                 SEDEL.Environment.Err GHC.Types.IO))
                           b)
                   (s1 :: s) ->
                 let {
                   m2 :: Control.Monad.Trans.Reader.ReaderT
                           (SEDEL.Environment.Ctx
                              SEDEL.Source.Syntax.TmName
                              SEDEL.Source.Syntax.CtxType
                              SEDEL.Source.Syntax.TyName
                              SEDEL.Source.Syntax.Kind
                              SEDEL.Source.Syntax.SType
                              SEDEL.Source.Syntax.Expr)
                           (Control.Monad.Trans.Except.ExceptT
                              SEDEL.Environment.Err GHC.Types.IO)
                           (a, s)
                   = m1
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N
                          <Control.Monad.Trans.Reader.ReaderT
                             (SEDEL.Environment.Ctx
                                SEDEL.Source.Syntax.TmName
                                SEDEL.Source.Syntax.CtxType
                                SEDEL.Source.Syntax.TyName
                                SEDEL.Source.Syntax.Kind
                                SEDEL.Source.Syntax.SType
                                SEDEL.Source.Syntax.Expr)
                             (Control.Monad.Trans.Except.ExceptT
                                SEDEL.Environment.Err GHC.Types.IO)>_R
                          <a>_N)
                       s1
                 } in
                 (\ (r1 :: SEDEL.Environment.Ctx
                             SEDEL.Source.Syntax.TmName
                             SEDEL.Source.Syntax.CtxType
                             SEDEL.Source.Syntax.TyName
                             SEDEL.Source.Syntax.Kind
                             SEDEL.Source.Syntax.SType
                             SEDEL.Source.Syntax.Expr)
                    (s2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  case (m2
                          `cast`
                        (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N
                             <SEDEL.Environment.Ctx
                                SEDEL.Source.Syntax.TmName
                                SEDEL.Source.Syntax.CtxType
                                SEDEL.Source.Syntax.TyName
                                SEDEL.Source.Syntax.Kind
                                SEDEL.Source.Syntax.SType
                                SEDEL.Source.Syntax.Expr>_R
                             <Control.Monad.Trans.Except.ExceptT
                                SEDEL.Environment.Err GHC.Types.IO>_R
                             <(a, s)>_N)
                          r1)
                         `cast`
                       (Control.Monad.Trans.Except.N:ExceptT[0]
                            <SEDEL.Environment.Err>_N
                            <GHC.Types.IO>_R
                            <(a, s)>_N ; GHC.Types.N:IO[0]
                                             <Data.Either.Either SEDEL.Environment.Err (a, s)>_R)
                         s2 of ds1 { (#,#) ipv ipv1 ->
                  case ipv1 of wild {
                    Data.Either.Left e1
                    -> (# ipv, Data.Either.Left @ SEDEL.Environment.Err @ (b, s) e1 #)
                    Data.Either.Right x
                    -> ((k `cast`
                         (Control.Monad.Trans.State.Lazy.N:StateT[0]
                              <s>_N
                              <Control.Monad.Trans.Reader.ReaderT
                                 (SEDEL.Environment.Ctx
                                    SEDEL.Source.Syntax.TmName
                                    SEDEL.Source.Syntax.CtxType
                                    SEDEL.Source.Syntax.TyName
                                    SEDEL.Source.Syntax.Kind
                                    SEDEL.Source.Syntax.SType
                                    SEDEL.Source.Syntax.Expr)
                                 (Control.Monad.Trans.Except.ExceptT
                                    SEDEL.Environment.Err GHC.Types.IO)>_R
                              <b>_N)
                           (case x of wild1 { (,) a1 s' -> s' }))
                          `cast`
                        (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N
                             <SEDEL.Environment.Ctx
                                SEDEL.Source.Syntax.TmName
                                SEDEL.Source.Syntax.CtxType
                                SEDEL.Source.Syntax.TyName
                                SEDEL.Source.Syntax.Kind
                                SEDEL.Source.Syntax.SType
                                SEDEL.Source.Syntax.Expr>_R
                             <Control.Monad.Trans.Except.ExceptT
                                SEDEL.Environment.Err GHC.Types.IO>_R
                             <(b, s)>_N)
                          r1)
                         `cast`
                       (Control.Monad.Trans.Except.N:ExceptT[0]
                            <SEDEL.Environment.Err>_N
                            <GHC.Types.IO>_R
                            <(b, s)>_N ; GHC.Types.N:IO[0]
                                             <Data.Either.Either SEDEL.Environment.Err (b, s)>_R)
                         ipv } })
                   `cast`
                 ((<SEDEL.Environment.Ctx
                      SEDEL.Source.Syntax.TmName
                      SEDEL.Source.Syntax.CtxType
                      SEDEL.Source.Syntax.TyName
                      SEDEL.Source.Syntax.Kind
                      SEDEL.Source.Syntax.SType
                      SEDEL.Source.Syntax.Expr>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <Data.Either.Either
                                    SEDEL.Environment.Err
                                    (b, s)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                          <SEDEL.Environment.Err>_N
                                                          <GHC.Types.IO>_R
                                                          <(b,
                                                            s)>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                               <*>_N
                                                                               <SEDEL.Environment.Ctx
                                                                                  SEDEL.Source.Syntax.TmName
                                                                                  SEDEL.Source.Syntax.CtxType
                                                                                  SEDEL.Source.Syntax.TyName
                                                                                  SEDEL.Source.Syntax.Kind
                                                                                  SEDEL.Source.Syntax.SType
                                                                                  SEDEL.Source.Syntax.Expr>_R
                                                                               <Control.Monad.Trans.Except.ExceptT
                                                                                  SEDEL.Environment.Err
                                                                                  GHC.Types.IO>_R
                                                                               <(b, s)>_N)))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s
                    (Control.Monad.Trans.Reader.ReaderT
                       (SEDEL.Environment.Ctx
                          SEDEL.Source.Syntax.TmName
                          SEDEL.Source.Syntax.CtxType
                          SEDEL.Source.Syntax.TyName
                          SEDEL.Source.Syntax.Kind
                          SEDEL.Source.Syntax.SType
                          SEDEL.Source.Syntax.Expr)
                       (Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO))
                    a>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s
                         (Control.Monad.Trans.Reader.ReaderT
                            (SEDEL.Environment.Ctx
                               SEDEL.Source.Syntax.TmName
                               SEDEL.Source.Syntax.CtxType
                               SEDEL.Source.Syntax.TyName
                               SEDEL.Source.Syntax.Kind
                               SEDEL.Source.Syntax.SType
                               SEDEL.Source.Syntax.Expr)
                            (Control.Monad.Trans.Except.ExceptT
                               SEDEL.Environment.Err GHC.Types.IO))
                         b>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Trans.Reader.ReaderT
                                  (SEDEL.Environment.Ctx
                                     SEDEL.Source.Syntax.TmName
                                     SEDEL.Source.Syntax.CtxType
                                     SEDEL.Source.Syntax.TyName
                                     SEDEL.Source.Syntax.Kind
                                     SEDEL.Source.Syntax.SType
                                     SEDEL.Source.Syntax.Expr)
                                  (Control.Monad.Trans.Except.ExceptT
                                     SEDEL.Environment.Err GHC.Types.IO)>_R
                               <b>_N)) -}
2b0bbde45ead73b723b2a0158b931d1b
  $s$fFreshFreshMT_$s$fMonadStateT_$c>>= ::
    Control.Monad.Trans.State.Lazy.StateT
      s
      (Control.Monad.Trans.Reader.ReaderT
         (SEDEL.Environment.Ctx
            SEDEL.Source.Syntax.TmName
            SEDEL.Source.Syntax.CtxType
            SEDEL.Source.Syntax.TyName
            SEDEL.Source.Syntax.Kind
            SEDEL.Source.Syntax.SType
            SEDEL.Source.Syntax.Expr)
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO))
      a
    -> (a
        -> Control.Monad.Trans.State.Lazy.StateT
             s
             (Control.Monad.Trans.Reader.ReaderT
                (SEDEL.Environment.Ctx
                   SEDEL.Source.Syntax.TmName
                   SEDEL.Source.Syntax.CtxType
                   SEDEL.Source.Syntax.TyName
                   SEDEL.Source.Syntax.Kind
                   SEDEL.Source.Syntax.SType
                   SEDEL.Source.Syntax.Expr)
                (Control.Monad.Trans.Except.ExceptT
                   SEDEL.Environment.Err GHC.Types.IO))
             b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Reader.ReaderT
            (SEDEL.Environment.Ctx
               SEDEL.Source.Syntax.TmName
               SEDEL.Source.Syntax.CtxType
               SEDEL.Source.Syntax.TyName
               SEDEL.Source.Syntax.Kind
               SEDEL.Source.Syntax.SType
               SEDEL.Source.Syntax.Expr)
            (Control.Monad.Trans.Except.ExceptT
               SEDEL.Environment.Err GHC.Types.IO))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(C1(U(U,1*U))))><L,C(C1(C1(C1(U))))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Trans.Reader.ReaderT
                               (SEDEL.Environment.Ctx
                                  SEDEL.Source.Syntax.TmName
                                  SEDEL.Source.Syntax.CtxType
                                  SEDEL.Source.Syntax.TyName
                                  SEDEL.Source.Syntax.Kind
                                  SEDEL.Source.Syntax.SType
                                  SEDEL.Source.Syntax.Expr)
                               (Control.Monad.Trans.Except.ExceptT
                                  SEDEL.Environment.Err GHC.Types.IO))
                            a)
                   (k :: a
                         -> Control.Monad.Trans.State.Lazy.StateT
                              s
                              (Control.Monad.Trans.Reader.ReaderT
                                 (SEDEL.Environment.Ctx
                                    SEDEL.Source.Syntax.TmName
                                    SEDEL.Source.Syntax.CtxType
                                    SEDEL.Source.Syntax.TyName
                                    SEDEL.Source.Syntax.Kind
                                    SEDEL.Source.Syntax.SType
                                    SEDEL.Source.Syntax.Expr)
                                 (Control.Monad.Trans.Except.ExceptT
                                    SEDEL.Environment.Err GHC.Types.IO))
                              b)
                   (s1 :: s) ->
                 let {
                   m2 :: Control.Monad.Trans.Reader.ReaderT
                           (SEDEL.Environment.Ctx
                              SEDEL.Source.Syntax.TmName
                              SEDEL.Source.Syntax.CtxType
                              SEDEL.Source.Syntax.TyName
                              SEDEL.Source.Syntax.Kind
                              SEDEL.Source.Syntax.SType
                              SEDEL.Source.Syntax.Expr)
                           (Control.Monad.Trans.Except.ExceptT
                              SEDEL.Environment.Err GHC.Types.IO)
                           (a, s)
                   = m1
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N
                          <Control.Monad.Trans.Reader.ReaderT
                             (SEDEL.Environment.Ctx
                                SEDEL.Source.Syntax.TmName
                                SEDEL.Source.Syntax.CtxType
                                SEDEL.Source.Syntax.TyName
                                SEDEL.Source.Syntax.Kind
                                SEDEL.Source.Syntax.SType
                                SEDEL.Source.Syntax.Expr)
                             (Control.Monad.Trans.Except.ExceptT
                                SEDEL.Environment.Err GHC.Types.IO)>_R
                          <a>_N)
                       s1
                 } in
                 (\ (r1 :: SEDEL.Environment.Ctx
                             SEDEL.Source.Syntax.TmName
                             SEDEL.Source.Syntax.CtxType
                             SEDEL.Source.Syntax.TyName
                             SEDEL.Source.Syntax.Kind
                             SEDEL.Source.Syntax.SType
                             SEDEL.Source.Syntax.Expr)
                    (s2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  case (m2
                          `cast`
                        (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N
                             <SEDEL.Environment.Ctx
                                SEDEL.Source.Syntax.TmName
                                SEDEL.Source.Syntax.CtxType
                                SEDEL.Source.Syntax.TyName
                                SEDEL.Source.Syntax.Kind
                                SEDEL.Source.Syntax.SType
                                SEDEL.Source.Syntax.Expr>_R
                             <Control.Monad.Trans.Except.ExceptT
                                SEDEL.Environment.Err GHC.Types.IO>_R
                             <(a, s)>_N)
                          r1)
                         `cast`
                       (Control.Monad.Trans.Except.N:ExceptT[0]
                            <SEDEL.Environment.Err>_N
                            <GHC.Types.IO>_R
                            <(a, s)>_N ; GHC.Types.N:IO[0]
                                             <Data.Either.Either SEDEL.Environment.Err (a, s)>_R)
                         s2 of ds1 { (#,#) ipv ipv1 ->
                  case ipv1 of wild {
                    Data.Either.Left e1
                    -> (# ipv, Data.Either.Left @ SEDEL.Environment.Err @ (b, s) e1 #)
                    Data.Either.Right x
                    -> (((k (case x of wild1 { (,) a1 s' -> a1 }))
                           `cast`
                         (Control.Monad.Trans.State.Lazy.N:StateT[0]
                              <s>_N
                              <Control.Monad.Trans.Reader.ReaderT
                                 (SEDEL.Environment.Ctx
                                    SEDEL.Source.Syntax.TmName
                                    SEDEL.Source.Syntax.CtxType
                                    SEDEL.Source.Syntax.TyName
                                    SEDEL.Source.Syntax.Kind
                                    SEDEL.Source.Syntax.SType
                                    SEDEL.Source.Syntax.Expr)
                                 (Control.Monad.Trans.Except.ExceptT
                                    SEDEL.Environment.Err GHC.Types.IO)>_R
                              <b>_N)
                           (case x of wild1 { (,) a1 s' -> s' }))
                          `cast`
                        (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N
                             <SEDEL.Environment.Ctx
                                SEDEL.Source.Syntax.TmName
                                SEDEL.Source.Syntax.CtxType
                                SEDEL.Source.Syntax.TyName
                                SEDEL.Source.Syntax.Kind
                                SEDEL.Source.Syntax.SType
                                SEDEL.Source.Syntax.Expr>_R
                             <Control.Monad.Trans.Except.ExceptT
                                SEDEL.Environment.Err GHC.Types.IO>_R
                             <(b, s)>_N)
                          r1)
                         `cast`
                       (Control.Monad.Trans.Except.N:ExceptT[0]
                            <SEDEL.Environment.Err>_N
                            <GHC.Types.IO>_R
                            <(b, s)>_N ; GHC.Types.N:IO[0]
                                             <Data.Either.Either SEDEL.Environment.Err (b, s)>_R)
                         ipv } })
                   `cast`
                 ((<SEDEL.Environment.Ctx
                      SEDEL.Source.Syntax.TmName
                      SEDEL.Source.Syntax.CtxType
                      SEDEL.Source.Syntax.TyName
                      SEDEL.Source.Syntax.Kind
                      SEDEL.Source.Syntax.SType
                      SEDEL.Source.Syntax.Expr>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <Data.Either.Either
                                    SEDEL.Environment.Err
                                    (b, s)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                          <SEDEL.Environment.Err>_N
                                                          <GHC.Types.IO>_R
                                                          <(b,
                                                            s)>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                               <*>_N
                                                                               <SEDEL.Environment.Ctx
                                                                                  SEDEL.Source.Syntax.TmName
                                                                                  SEDEL.Source.Syntax.CtxType
                                                                                  SEDEL.Source.Syntax.TyName
                                                                                  SEDEL.Source.Syntax.Kind
                                                                                  SEDEL.Source.Syntax.SType
                                                                                  SEDEL.Source.Syntax.Expr>_R
                                                                               <Control.Monad.Trans.Except.ExceptT
                                                                                  SEDEL.Environment.Err
                                                                                  GHC.Types.IO>_R
                                                                               <(b, s)>_N)))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s
                    (Control.Monad.Trans.Reader.ReaderT
                       (SEDEL.Environment.Ctx
                          SEDEL.Source.Syntax.TmName
                          SEDEL.Source.Syntax.CtxType
                          SEDEL.Source.Syntax.TyName
                          SEDEL.Source.Syntax.Kind
                          SEDEL.Source.Syntax.SType
                          SEDEL.Source.Syntax.Expr)
                       (Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO))
                    a>_R
                 ->_R <a
                       -> Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Trans.Reader.ReaderT
                               (SEDEL.Environment.Ctx
                                  SEDEL.Source.Syntax.TmName
                                  SEDEL.Source.Syntax.CtxType
                                  SEDEL.Source.Syntax.TyName
                                  SEDEL.Source.Syntax.Kind
                                  SEDEL.Source.Syntax.SType
                                  SEDEL.Source.Syntax.Expr)
                               (Control.Monad.Trans.Except.ExceptT
                                  SEDEL.Environment.Err GHC.Types.IO))
                            b>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Trans.Reader.ReaderT
                                  (SEDEL.Environment.Ctx
                                     SEDEL.Source.Syntax.TmName
                                     SEDEL.Source.Syntax.CtxType
                                     SEDEL.Source.Syntax.TyName
                                     SEDEL.Source.Syntax.Kind
                                     SEDEL.Source.Syntax.SType
                                     SEDEL.Source.Syntax.Expr)
                                  (Control.Monad.Trans.Except.ExceptT
                                     SEDEL.Environment.Err GHC.Types.IO)>_R
                               <b>_N)) -}
e0f1d8c6bff2d4b0f03076085860a017
  $s$fFreshFreshMT_$s$fMonadStateT_$cfail ::
    GHC.Base.String
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Reader.ReaderT
            (SEDEL.Environment.Ctx
               SEDEL.Source.Syntax.TmName
               SEDEL.Source.Syntax.CtxType
               SEDEL.Source.Syntax.TyName
               SEDEL.Source.Syntax.Kind
               SEDEL.Source.Syntax.SType
               SEDEL.Source.Syntax.Expr)
            (Control.Monad.Trans.Except.ExceptT
               SEDEL.Environment.Err GHC.Types.IO))
         a
  {- Arity: 1, Strictness: <L,U>, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ s @ a (str :: GHC.Base.String) (ds :: s) ->
                 SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fMonadReaderT_$cfail
                   @ (SEDEL.Environment.Ctx
                        SEDEL.Source.Syntax.TmName
                        SEDEL.Source.Syntax.CtxType
                        SEDEL.Source.Syntax.TyName
                        SEDEL.Source.Syntax.Kind
                        SEDEL.Source.Syntax.SType
                        SEDEL.Source.Syntax.Expr)
                   @ (a, s)
                   str)
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <GHC.Base.String>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Trans.Reader.ReaderT
                                  (SEDEL.Environment.Ctx
                                     SEDEL.Source.Syntax.TmName
                                     SEDEL.Source.Syntax.CtxType
                                     SEDEL.Source.Syntax.TyName
                                     SEDEL.Source.Syntax.Kind
                                     SEDEL.Source.Syntax.SType
                                     SEDEL.Source.Syntax.Expr)
                                  (Control.Monad.Trans.Except.ExceptT
                                     SEDEL.Environment.Err GHC.Types.IO)>_R
                               <a>_N)) -}
6ff32b3f9578d7b913e136a7c04b9357
  $s$fShowEmbed_$cshowsPrec2 ::
    GHC.Types.Int
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,A><L,U>, Inline: [2],
     Unfolding: InlineRule (2, True, True)
                (\ (w7 :: GHC.Types.Int)
                   (w8 :: Unbound.Generics.LocallyNameless.Embed.Embed
                            (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)) ->
                 Unbound.Generics.LocallyNameless.Embed.$w$cshowsPrec
                   @ (GHC.Maybe.Maybe SEDEL.Intermediate.Syntax.FType)
                   SEDEL.Source.Inference.$s$fAlpha(,)_$s$fShowMaybe
                   w8) -}
22a0ff7c0ad5cc700b00aa64cd7d38c0
  $s$wsplitS ::
    SEDEL.Source.Syntax.TyName
    -> Data.Set.Internal.Set SEDEL.Source.Syntax.TyName
    -> (# Data.Set.Internal.Set SEDEL.Source.Syntax.TyName,
          Data.Set.Internal.Set SEDEL.Source.Syntax.TyName #)
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [~] -}
2cd04ff0636ff5a305c8f8a3a8be5e72
  $sinsertR_$sgo3 ::
    SEDEL.Source.Syntax.TyName
    -> SEDEL.Source.Syntax.TyName
    -> Data.Set.Internal.Set SEDEL.Source.Syntax.TyName
    -> Data.Set.Internal.Set SEDEL.Source.Syntax.TyName
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U> -}
e95a2a9075c2ad5cb7e4cbb3a99cc2de
  $sinsert_$sgo3 ::
    SEDEL.Source.Syntax.TyName
    -> SEDEL.Source.Syntax.TyName
    -> Data.Set.Internal.Set SEDEL.Source.Syntax.TyName
    -> Data.Set.Internal.Set SEDEL.Source.Syntax.TyName
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U> -}
4cc638542ee9f7037574aac4e3309e28
  $sinsert_$sgo8 ::
    SEDEL.Source.Syntax.TmName
    -> a1
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.TmName a1
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.TmName a1
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
e960c9679ec9f54ffed86517019894a1
  $sunion ::
    Data.Set.Internal.Set SEDEL.Source.Syntax.TyName
    -> Data.Set.Internal.Set SEDEL.Source.Syntax.TyName
    -> Data.Set.Internal.Set SEDEL.Source.Syntax.TyName
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [~] -}
562298cdfbb5a36f77d32a2f8693624c
  $tc'Del :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4333020629375285470##
                   7706083401557971053##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'Del2
                   0#
                   SEDEL.Source.Inference.$tc'Del1) -}
b0af0940113535f355840ba32f270efe
  $tc'Del1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
9b6e010798359bbf1df1c7506d69a40a
  $tc'Del2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$tc'Del3) -}
664df7a2949b7623aba2b6751f91ed36
  $tc'Del3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Del"#) -}
4c5c2b1d77bbbd479225425f93c29849
  $tc'EmptyC :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11688771327939914939##
                   7264205228038294415##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'EmptyC2
                   0#
                   SEDEL.Source.Inference.$tc'EmptyC1) -}
2baaf986bc2276839860057279f376d4
  $tc'EmptyC1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
d4ed952be61139d8a6a1ca409df909fd
  $tc'EmptyC2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   SEDEL.Source.Inference.$tc'EmptyC3) -}
3b616eef0d9c3607e5aaf7613eef7dcd
  $tc'EmptyC3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'EmptyC"#) -}
837005261ff96ac3287ba79111d49025
  $tc'EmptyD :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16325492665898400161##
                   5788059358986359081##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'EmptyD2
                   0#
                   SEDEL.Source.Inference.$tc'EmptyD1) -}
252e4c76e5935f0c9c8d566d78e02dbf
  $tc'EmptyD1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
4074deff5ed9ef756f61b762075b8ca8
  $tc'EmptyD2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   SEDEL.Source.Inference.$tc'EmptyD3) -}
fd2e9a1cd7cba2ddf17ef74d3214a62b
  $tc'EmptyD3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'EmptyD"#) -}
e3bc90ad626010edc80c1c44824a509c
  $tc'EmptyDelta :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6487839218825220130##
                   16205670915982298475##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'EmptyDelta2
                   0#
                   SEDEL.Source.Inference.$tc'EmptyDelta1) -}
eedbcea3ce96abf3ab57f1730a91d6e9
  $tc'EmptyDelta1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
19664bfde31a2038af022ea8ab82588c
  $tc'EmptyDelta2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   SEDEL.Source.Inference.$tc'EmptyDelta3) -}
9813162291c6180e0f7296a971c26ba6
  $tc'EmptyDelta3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'EmptyDelta"#) -}
1641a6d0423cad75f514475b4ab105a8
  $tc'EmptyPrS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   721373734685814498##
                   5177552649451047721##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'EmptyPrS2
                   1#
                   SEDEL.Source.Inference.$tc'EmptyPrS1) -}
5c77d7574880767aa29bd8cc45d10041
  $tc'EmptyPrS1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
f0db6613123131075bbbdd21dabbbd8e
  $tc'EmptyPrS2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   SEDEL.Source.Inference.$tc'EmptyPrS3) -}
b11cb9ac47a373611ecd43f806d68b78
  $tc'EmptyPrS3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'EmptyPrS"#) -}
064a57450dc4783e27a4cc39a515718d
  $tc'EmptyQ :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4179619413619328245##
                   13334748897898129447##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'EmptyQ2
                   0#
                   SEDEL.Source.Inference.$tc'EmptyQ1) -}
58554976fbe85df392ed768d8e4836b7
  $tc'EmptyQ1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
131b3a873479c50bf7e2db5dbcbab1a3
  $tc'EmptyQ2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   SEDEL.Source.Inference.$tc'EmptyQ3) -}
9cde0316c1278891992143d49664455e
  $tc'EmptyQ3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'EmptyQ"#) -}
e4c9eeea61a6425963f5a062058dc2cf
  $tc'EmptyS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16853482460962239170##
                   15956594540332973157##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'EmptyS2
                   1#
                   SEDEL.Source.Inference.$tc'EmptyS1) -}
80fe6d73b39e1d744cb34898c6eb72b8
  $tc'EmptyS1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
e2a9bfb1d562a1c602b610be0045e803
  $tc'EmptyS2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   SEDEL.Source.Inference.$tc'EmptyS3) -}
8802e5eeee9e750c3623fd3c94d693f9
  $tc'EmptyS3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'EmptyS"#) -}
402c7eff66e5ead08e297cf1fabd1c12
  $tc'NegS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3831213370237482172##
                   1196971088900346642##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'NegS2
                   1#
                   SEDEL.Source.Inference.$tc'NegS1) -}
679a60f74ea6ef5f99d382fafd35a669
  $tc'NegS1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
862374f2339df4501f357eddd8257477
  $tc'NegS2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$tc'NegS3) -}
7d95a388c0875178437aee15b002daa6
  $tc'NegS3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NegS"#) -}
1afbda6a03d690b1d5692e02ee1755f6
  $tc'NegT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9999248578274349904##
                   15790141521421760040##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'NegT2
                   1#
                   SEDEL.Source.Inference.$tc'NegT1) -}
18e7d504dd76977e8daa30152bcedc9e
  $tc'NegT1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
406b7df957bd6d03c57eccdd990a1b72
  $tc'NegT2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$tc'NegT3) -}
497042431c02e9d3a1fca21d4c7e035e
  $tc'NegT3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NegT"#) -}
6eaeb6001100e38ca3df378a98080018
  $tc'PosS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11349790303216265209##
                   2052682375043009462##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'PosS1
                   1#
                   SEDEL.Source.Inference.$tc'NegS1) -}
4571db5847635d03c9881693a9a24a2d
  $tc'PosS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$tc'PosS2) -}
80247d61ed5f60a593593307c7d1ba9c
  $tc'PosS2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'PosS"#) -}
a531ceb87ec9796be14376e0d8ae2bd1
  $tc'PosT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17936899809696629783##
                   17161943984705200787##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'PosT1
                   1#
                   SEDEL.Source.Inference.$tc'NegT1) -}
193102158a5ac963d53e753ae178a1b0
  $tc'PosT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$tc'PosT2) -}
2445f03681bb2c59f1a104f07d1617ed
  $tc'PosT2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'PosT"#) -}
56527f4a461283420cd234048dcd967c
  $tc'QA :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7237900318090955241##
                   15762440738411074184##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'QA2
                   0#
                   SEDEL.Source.Inference.$tc'QA1) -}
508ab8b0c5567e0ece4f6e88094f0a17
  $tc'QA1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
a1a0f0a514b6f543ebb28a69a9f29908
  $tc'QA2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$tc'QA3) -}
d86621899f095b92e95c930f56226386
  $tc'QA3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'QA"#) -}
e3bdd4ee713a11fdb1246795cbb567fd
  $tc'QL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15173122144645291270##
                   15164097719717850343##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'QL2
                   0#
                   SEDEL.Source.Inference.$tc'QL1) -}
dd546df85d9ecdbe1a10ec6a7e9b361d
  $tc'QL1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
4b387f44f8de45e77d6ce531ca5b85e8
  $tc'QL2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$tc'QL3) -}
e931f8138499851f1475f3ffcc9b7b65
  $tc'QL3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'QL"#) -}
22737817151020b29484f29a80b8d3ad
  $tc'SeqC :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5819098198782888462##
                   3049636017835070055##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'SeqC2
                   0#
                   SEDEL.Source.Inference.$tc'SeqC1) -}
b39d04c791a376c8e17b33e6816e46cd
  $tc'SeqC1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
9c25dca583685f6c1fba71a682c163f2
  $tc'SeqC2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$tc'SeqC3) -}
1ee977544e54f5bf790c65706016f4f8
  $tc'SeqC3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'SeqC"#) -}
79f409ffe053a228f61527a8d4b2c72c
  $tc'SeqD :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15502294161115829353##
                   731243454296724894##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'SeqD2
                   0#
                   SEDEL.Source.Inference.$tc'SeqD1) -}
408f1f549f034d2d6d9be453e032df56
  $tc'SeqD1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
de030ccdc5e8fa71210de6a518291172
  $tc'SeqD2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$tc'SeqD3) -}
899423e82cee4927bb96630772f4818b
  $tc'SeqD3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'SeqD"#) -}
1a8216d3edc351762ad3d6cfc5630013
  $tc'Subs :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   578897847581572764##
                   9924487620732582816##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tc'Subs2
                   1#
                   SEDEL.Source.Inference.$tc'Subs1) -}
b94216dba27d293566d9e24392cef10d
  $tc'Subs1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
9fcd889b423f465cd549aceba23202e6
  $tc'Subs2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$tc'Subs3) -}
cff6e8b6e746195cbd1fe64a7a1c3c29
  $tc'Subs3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Subs"#) -}
65fb66eebb1272db340cad20f9dab586
  $tcDelta :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11093037416887112977##
                   14208453100967743838##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tcDelta1
                   0#
                   GHC.Types.krep$*) -}
4a0187429e38ce1a64e415f1c0eefb68
  $tcDelta1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$tcDelta2) -}
9bddab780280bc99063819d40899f9cb
  $tcDelta2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Delta"#) -}
c1044dd2735f1ba2ff70b12bb6fc8f9c
  $tcDisCons :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11935496992618601272##
                   17900948061250833768##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tcDisCons1
                   0#
                   GHC.Types.krep$*) -}
73b3faa1806857131723f67da6f18b57
  $tcDisCons1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   SEDEL.Source.Inference.$tcDisCons2) -}
0416430a66702fd2d9e5dc58f28f5c45
  $tcDisCons2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("DisCons"#) -}
a8181c826e66fab94396c41ccdf595cb
  $tcPolar :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11596658266054781273##
                   16435898476759330032##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tcPolar1
                   0#
                   GHC.Types.krep$*Arr*) -}
4b9c343f57cb821960e4a212c917b105
  $tcPolar1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$tcPolar2) -}
a9df9189d3b2b944d54ce8b97618c864
  $tcPolar2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Polar"#) -}
b8b3e5c86264c6dec361e95cbe6fc773
  $tcPrSubs :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9568662294694513102##
                   10869875893487970289##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tcPrSubs1
                   0#
                   GHC.Types.krep$*Arr*) -}
75379bd61e3e9c6fa0e0498bf12eab44
  $tcPrSubs1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$tcPrSubs2) -}
c7f30d03bc1e7a9259b269f5ba5d2671
  $tcPrSubs2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("PrSubs"#) -}
77c9ec7eadb9673cbcd8cb37f4031062
  $tcQueue :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16148431708400443733##
                   9325447606629416413##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tcQueue1
                   0#
                   GHC.Types.krep$*) -}
cb494b90563a9ccec57f20c4e6619712
  $tcQueue1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$tcQueue2) -}
fcb4130575bf558469e60c7772ddc4dd
  $tcQueue2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Queue"#) -}
61f96915eafded5de32a79d248565cfe
  $tcSubCons :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18278095035513210292##
                   12395359008827620424##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tcSubCons1
                   0#
                   GHC.Types.krep$*) -}
efde6b5b8f921d7acb7f6e10260cecc1
  $tcSubCons1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   SEDEL.Source.Inference.$tcSubCons2) -}
c40511bdfc074a2e8bfa8cb5ccae6a0a
  $tcSubCons2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SubCons"#) -}
562a1306036eb02f6b00cd9c1f30827e
  $tcSubstitution :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15880833861944586010##
                   12087605746808453979##
                   SEDEL.Source.Inference.$trModule
                   SEDEL.Source.Inference.$tcSubstitution1
                   0#
                   GHC.Types.krep$*Arr*) -}
a0bbb4bc81dfa7bdb88c2ec70ffb1e65
  $tcSubstitution1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   SEDEL.Source.Inference.$tcSubstitution2) -}
294ce1aa5f450871f40a320da65e0cb8
  $tcSubstitution2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Substitution"#) -}
56e85cbd5223ae353834a0fe853ec327
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   SEDEL.Source.Inference.$trModule3
                   SEDEL.Source.Inference.$trModule1) -}
aca2e30120ba44830c932da1ff428e68
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$trModule2) -}
aeb99fdeb078973da12b3695915ca2b3
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SEDEL.Source.Inference"#) -}
dbf022f56f799fbfb53fc78ba6aead7e
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Inference.$trModule4) -}
02cfc5ffb3009e9f4ce0d46bd8be27cf
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("sedel-0.1.0.0-CGdrjkISkKsB7AvhzRMuoJ"#) -}
0e7aee499c938cfe66933adc4ab7ac8c
  $w$cshowsPrec ::
    GHC.Show.Show typ =>
    GHC.Prim.Int# -> SEDEL.Source.Inference.Polar typ -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [2],
     Unfolding: (\ @ typ
                   (w :: GHC.Show.Show typ)
                   (ww :: GHC.Prim.Int#)
                   (w7 :: SEDEL.Source.Inference.Polar typ) ->
                 case w7 of wild {
                   SEDEL.Source.Inference.PosT b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ typ w SEDEL.Source.Inference.$fShowPolar5 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             SEDEL.Source.Inference.$fShowPolar3
                             (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                SEDEL.Source.Inference.$fShowPolar3
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) }
                   SEDEL.Source.Inference.NegT b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ typ w SEDEL.Source.Inference.$fShowPolar5 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             SEDEL.Source.Inference.$fShowPolar1
                             (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                SEDEL.Source.Inference.$fShowPolar1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) } }) -}
623f9de3e6377749a2ae3144bc15623e
  data Delta
    = EmptyDelta
    | Del (SEDEL.Source.Syntax.SType, SEDEL.Source.Syntax.SType)
          SEDEL.Source.Inference.Delta
263a177e1fcb33eaba9b791ae62b595b
  data DisCons
    = EmptyD
    | SeqD SEDEL.Source.Inference.DisRule
           SEDEL.Source.Inference.DisCons
a0d36cf6f4161d14b3f354768f09b91f
  type DisRule =
    (SEDEL.Source.Syntax.PType, SEDEL.Source.Syntax.PType)
0e7aee499c938cfe66933adc4ab7ac8c
  data Polar typ = PosT typ | NegT typ
1a1a0d66ba44f254e55da669d7beafe4
  data PrSubs typ
    = EmptyPrS
    | Subs SEDEL.Source.Syntax.TUni
           typ
           (SEDEL.Source.Inference.PrSubs typ)
25d9b1a0ff68b6537e91a2d06b348452
  data Queue
    = EmptyQ
    | QL SEDEL.Source.Syntax.Label SEDEL.Source.Inference.Queue
    | QA SEDEL.Source.Syntax.PType SEDEL.Source.Inference.Queue
94202e7bea8fd879340fecf360dffa4e
  data SubCons
    = EmptyC
    | SeqC SEDEL.Source.Inference.SubRule
           SEDEL.Source.Inference.SubCons
53367171b5522b5cd40de1ec3d5e0419
  type SubRule =
    (SEDEL.Source.Syntax.PType, SEDEL.Source.Syntax.PType)
1c41f715367e98c6d0205722756d8a11
  data Substitution typ
    = EmptyS
    | PosS SEDEL.Source.Syntax.TUni
           typ
           (SEDEL.Source.Inference.Substitution typ)
    | NegS SEDEL.Source.Syntax.TUni
           typ
           (SEDEL.Source.Inference.Substitution typ)
77f549d7df07626102303856cde41df7
  tcModule ::
    SEDEL.Source.Syntax.Module
    -> SEDEL.Environment.STcMonad
         (SEDEL.Source.Syntax.Scheme, SEDEL.Target.Syntax.UExpr)
  {- Arity: 1, Strictness: <L,1*U(A,1*U(1*U(1*U,A,1*U,1*U,A,A)))> -}
ef9fd05064ff70b7e5316a4af5fdfcb4
  topLevelInfer ::
    SEDEL.Source.Syntax.Expr
    -> SEDEL.Environment.STcMonad
         (SEDEL.Source.Syntax.Scheme, SEDEL.Intermediate.Syntax.FExpr)
  {- Arity: 1, Strictness: <L,1*U> -}
instance GHC.Show.Show [SEDEL.Source.Inference.Delta]
  = SEDEL.Source.Inference.$fShowDelta
instance GHC.Show.Show [SEDEL.Source.Inference.DisCons]
  = SEDEL.Source.Inference.$fShowDisCons
instance GHC.Show.Show [SEDEL.Source.Inference.Polar]
  = SEDEL.Source.Inference.$fShowPolar
instance GHC.Show.Show [SEDEL.Source.Inference.PrSubs]
  = SEDEL.Source.Inference.$fShowPrSubs
instance GHC.Show.Show [SEDEL.Source.Inference.Queue]
  = SEDEL.Source.Inference.$fShowQueue
instance GHC.Show.Show [SEDEL.Source.Inference.SubCons]
  = SEDEL.Source.Inference.$fShowSubCons
instance GHC.Show.Show [SEDEL.Source.Inference.Substitution]
  = SEDEL.Source.Inference.$fShowSubstitution
"SPEC/SEDEL.Source.Inference $fAlphaEmbed @ (Maybe FType)" [orphan] forall (v :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                   (GHC.Maybe.Maybe
                                                                                      SEDEL.Intermediate.Syntax.FType))
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed @ (GHC.Maybe.Maybe
                                                           SEDEL.Intermediate.Syntax.FType)
                                                      v
  = SEDEL.Source.Inference.$s$fAlpha(,)_$s$fAlphaEmbed2
"SPEC/SEDEL.Source.Inference $fAlphaEmbed @ FType" [orphan] forall (v :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                           SEDEL.Intermediate.Syntax.FType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed @ SEDEL.Intermediate.Syntax.FType
                                                      v
  = SEDEL.Source.Inference.$s$fAlpha(,)_$s$fAlphaEmbed1
"SPEC/SEDEL.Source.Inference $fAlphaEmbed @ SType" [orphan] forall (v :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                           SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed @ SEDEL.Source.Syntax.SType
                                                      v
  = SEDEL.Source.Inference.$s$fAlpha(,)_$s$fAlphaEmbed
"SPEC/SEDEL.Source.Inference $fAlphaEmbed_$cacompare' @ FType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                             SEDEL.Intermediate.Syntax.FType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cacompare' @ SEDEL.Intermediate.Syntax.FType
                                                                  $dAlpha
  = SEDEL.Source.Inference.$s$fAlphaEmbed_$cacompare'2
"SPEC/SEDEL.Source.Inference $fAlphaEmbed_$cacompare' @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                             SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cacompare' @ SEDEL.Source.Syntax.SType
                                                                  $dAlpha
  = SEDEL.Source.Inference.$s$fAlphaEmbed_$cacompare'1
"SPEC/SEDEL.Source.Inference $fAlphaEmbed_$caeq' @ FType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                        SEDEL.Intermediate.Syntax.FType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$caeq' @ SEDEL.Intermediate.Syntax.FType
                                                             $dAlpha
  = SEDEL.Source.Inference.$s$fAlphaEmbed_$caeq'2
"SPEC/SEDEL.Source.Inference $fAlphaEmbed_$caeq' @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                        SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$caeq' @ SEDEL.Source.Syntax.SType
                                                             $dAlpha
  = SEDEL.Source.Inference.$s$fAlphaEmbed_$caeq'1
"SPEC/SEDEL.Source.Inference $fAlphaEmbed_$cclose @ FType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                         SEDEL.Intermediate.Syntax.FType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cclose @ SEDEL.Intermediate.Syntax.FType
                                                              $dAlpha
  = SEDEL.Source.Inference.$s$fAlphaEmbed_$cclose2
"SPEC/SEDEL.Source.Inference $fAlphaEmbed_$cclose @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                         SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cclose @ SEDEL.Source.Syntax.SType
                                                              $dAlpha
  = SEDEL.Source.Inference.$s$fAlphaEmbed_$cclose1
"SPEC/SEDEL.Source.Inference $fAlphaEmbed_$cfreshen' @ FType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                            SEDEL.Intermediate.Syntax.FType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cfreshen' @ SEDEL.Intermediate.Syntax.FType
                                                                 $dAlpha
  = SEDEL.Source.Inference.$s$fAlphaEmbed_$cfreshen'1
"SPEC/SEDEL.Source.Inference $fAlphaEmbed_$cfreshen' @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                            SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cfreshen' @ SEDEL.Source.Syntax.SType
                                                                 $dAlpha
  = SEDEL.Source.Inference.$s$fAlphaEmbed_$cfreshen'
"SPEC/SEDEL.Source.Inference $fAlphaEmbed_$cisPat @ FType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                         SEDEL.Intermediate.Syntax.FType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cisPat @ SEDEL.Intermediate.Syntax.FType
                                                              $dAlpha
  = SEDEL.Source.Inference.$s$fAlphaEmbed_$cisPat2
"SPEC/SEDEL.Source.Inference $fAlphaEmbed_$cisPat @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                         SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cisPat @ SEDEL.Source.Syntax.SType
                                                              $dAlpha
  = SEDEL.Source.Inference.$s$fAlphaEmbed_$cisPat1
"SPEC/SEDEL.Source.Inference $fAlphaEmbed_$copen @ FType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                        SEDEL.Intermediate.Syntax.FType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$copen @ SEDEL.Intermediate.Syntax.FType
                                                             $dAlpha
  = SEDEL.Source.Inference.$s$fAlphaEmbed_$copen2
"SPEC/SEDEL.Source.Inference $fAlphaEmbed_$copen @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                        SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$copen @ SEDEL.Source.Syntax.SType
                                                             $dAlpha
  = SEDEL.Source.Inference.$s$fAlphaEmbed_$copen1
"SPEC/SEDEL.Source.Inference $fAlphaEmbed_$cswaps' @ FType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                          SEDEL.Intermediate.Syntax.FType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cswaps' @ SEDEL.Intermediate.Syntax.FType
                                                               $dAlpha
  = SEDEL.Source.Inference.$s$fAlphaEmbed_$cswaps'2
"SPEC/SEDEL.Source.Inference $fAlphaEmbed_$cswaps' @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                          SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cswaps' @ SEDEL.Source.Syntax.SType
                                                               $dAlpha
  = SEDEL.Source.Inference.$s$fAlphaEmbed_$cswaps'1
"SPEC/SEDEL.Source.Inference $fAlphaMaybe @ FType" [orphan] forall (v :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                           SEDEL.Intermediate.Syntax.FType)
  Unbound.Generics.LocallyNameless.Alpha.$fAlphaMaybe @ SEDEL.Intermediate.Syntax.FType
                                                      v
  = SEDEL.Source.Inference.$s$fAlpha(,)_$s$fAlphaMaybe
"SPEC/SEDEL.Source.Inference $fAlphaMaybe_$cacompare' @ FType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                             SEDEL.Intermediate.Syntax.FType)
  Unbound.Generics.LocallyNameless.Alpha.$fAlphaMaybe_$cacompare' @ SEDEL.Intermediate.Syntax.FType
                                                                  $dAlpha
  = SEDEL.Source.Inference.$s$fAlphaMaybe_$cacompare'
"SPEC/SEDEL.Source.Inference $fAlphaMaybe_$caeq' @ FType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                        SEDEL.Intermediate.Syntax.FType)
  Unbound.Generics.LocallyNameless.Alpha.$fAlphaMaybe_$caeq' @ SEDEL.Intermediate.Syntax.FType
                                                             $dAlpha
  = SEDEL.Source.Inference.$s$fAlpha(,)_$s$fAlphaMaybe_$caeq'
"SPEC/SEDEL.Source.Inference $fAlphaMaybe_$cclose @ FType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                         SEDEL.Intermediate.Syntax.FType)
  Unbound.Generics.LocallyNameless.Alpha.$fAlphaMaybe_$cclose @ SEDEL.Intermediate.Syntax.FType
                                                              $dAlpha
  = SEDEL.Source.Inference.$s$fAlpha(,)_$s$fAlphaMaybe_$cclose
"SPEC/SEDEL.Source.Inference $fAlphaMaybe_$cfvAny' @ FType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                          SEDEL.Intermediate.Syntax.FType)
  Unbound.Generics.LocallyNameless.Alpha.$fAlphaMaybe_$cfvAny' @ SEDEL.Intermediate.Syntax.FType
                                                               $dAlpha
  = SEDEL.Source.Inference.$s$fAlpha(,)_$s$fAlphaMaybe_$cfvAny'
"SPEC/SEDEL.Source.Inference $fAlphaMaybe_$cisEmbed @ FType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                           SEDEL.Intermediate.Syntax.FType)
  Unbound.Generics.LocallyNameless.Alpha.$fAlphaMaybe_$cisEmbed @ SEDEL.Intermediate.Syntax.FType
                                                                $dAlpha
  = SEDEL.Source.Inference.$s$fAlpha(,)_$s$fAlphaMaybe_$cisEmbed
"SPEC/SEDEL.Source.Inference $fAlphaMaybe_$clfreshen' @ FType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                             SEDEL.Intermediate.Syntax.FType)
  Unbound.Generics.LocallyNameless.Alpha.$fAlphaMaybe_$clfreshen' @ SEDEL.Intermediate.Syntax.FType
                                                                  $dAlpha
  = SEDEL.Source.Inference.$s$fAlpha(,)_$s$fAlphaMaybe_$clfreshen'
"SPEC/SEDEL.Source.Inference $fAlphaMaybe_$copen @ FType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                        SEDEL.Intermediate.Syntax.FType)
  Unbound.Generics.LocallyNameless.Alpha.$fAlphaMaybe_$copen @ SEDEL.Intermediate.Syntax.FType
                                                             $dAlpha
  = SEDEL.Source.Inference.$s$fAlpha(,)_$s$fAlphaMaybe_$copen
"SPEC/SEDEL.Source.Inference $fAlphaMaybe_$cswaps' @ FType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                          SEDEL.Intermediate.Syntax.FType)
  Unbound.Generics.LocallyNameless.Alpha.$fAlphaMaybe_$cswaps' @ SEDEL.Intermediate.Syntax.FType
                                                               $dAlpha
  = SEDEL.Source.Inference.$s$fAlpha(,)_$s$fAlphaMaybe_$cswaps'
"SPEC/SEDEL.Source.Inference $fApplicativeExceptT @ IO _" [orphan] forall @ e
                                                                          (v1 :: GHC.Base.Monad
                                                                                   GHC.Types.IO)
                                                                          (v :: GHC.Base.Functor
                                                                                  GHC.Types.IO)
  Control.Monad.Trans.Except.$fApplicativeExceptT @ GHC.Types.IO
                                                  @ e
                                                  v
                                                  v1
  = SEDEL.Source.Inference.$s$fApplicativeExceptT @ e
"SPEC/SEDEL.Source.Inference $fApplicativeExceptT_$c*> @ IO _" [orphan] forall @ e
                                                                               ($dMonad :: GHC.Base.Monad
                                                                                             GHC.Types.IO)
                                                                               ($dFunctor :: GHC.Base.Functor
                                                                                               GHC.Types.IO)
  Control.Monad.Trans.Except.$fApplicativeExceptT_$c*> @ GHC.Types.IO
                                                       @ e
                                                       $dFunctor
                                                       $dMonad
  = SEDEL.Source.Inference.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$c*>
      @ e
"SPEC/SEDEL.Source.Inference $fApplicativeExceptT_$cpure @ IO _" [orphan] forall @ e
                                                                                 ($dMonad :: GHC.Base.Monad
                                                                                               GHC.Types.IO)
                                                                                 ($dFunctor :: GHC.Base.Functor
                                                                                                 GHC.Types.IO)
  Control.Monad.Trans.Except.$fApplicativeExceptT_$cpure @ GHC.Types.IO
                                                         @ e
                                                         $dFunctor
                                                         $dMonad
  = SEDEL.Source.Inference.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure
      @ e
"SPEC/SEDEL.Source.Inference $fApplicativeFreshMT @ (ReaderT
                                                      (Ctx TmName CtxType TyName Kind SType Expr)
                                                      (ExceptT Err IO))" [orphan] forall (v :: GHC.Base.Monad
                                                                                                                                                                                                                                                                (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                                                                                                                   (SEDEL.Environment.Ctx
                                                                                                                                                                                                                                                                      SEDEL.Source.Syntax.TmName
                                                                                                                                                                                                                                                                      SEDEL.Source.Syntax.CtxType
                                                                                                                                                                                                                                                                      SEDEL.Source.Syntax.TyName
                                                                                                                                                                                                                                                                      SEDEL.Source.Syntax.Kind
                                                                                                                                                                                                                                                                      SEDEL.Source.Syntax.SType
                                                                                                                                                                                                                                                                      SEDEL.Source.Syntax.Expr)
                                                                                                                                                                                                                                                                   (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                      SEDEL.Environment.Err
                                                                                                                                                                                                                                                                      GHC.Types.IO)))
  Unbound.Generics.LocallyNameless.Fresh.$fApplicativeFreshMT @ (Control.Monad.Trans.Reader.ReaderT
                                                                   (SEDEL.Environment.Ctx
                                                                      SEDEL.Source.Syntax.TmName
                                                                      SEDEL.Source.Syntax.CtxType
                                                                      SEDEL.Source.Syntax.TyName
                                                                      SEDEL.Source.Syntax.Kind
                                                                      SEDEL.Source.Syntax.SType
                                                                      SEDEL.Source.Syntax.Expr)
                                                                   (Control.Monad.Trans.Except.ExceptT
                                                                      SEDEL.Environment.Err
                                                                      GHC.Types.IO))
                                                              v
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT
"SPEC/SEDEL.Source.Inference $fApplicativeReaderT @ (ExceptT
                                                      Err IO) _" [orphan] forall @ r
                                                                                                                                              (v :: GHC.Base.Applicative
                                                                                                                                                      (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                         SEDEL.Environment.Err
                                                                                                                                                         GHC.Types.IO))
  Control.Monad.Trans.Reader.$fApplicativeReaderT @ (Control.Monad.Trans.Except.ExceptT
                                                       SEDEL.Environment.Err GHC.Types.IO)
                                                  @ r
                                                  v
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fApplicativeReaderT
      @ r
"SPEC/SEDEL.Source.Inference $fApplicativeReaderT_$c*> @ (ExceptT
                                                           Err IO) _" [orphan] forall @ r
                                                                                                                                                        ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                            (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                               SEDEL.Environment.Err
                                                                                                                                                                               GHC.Types.IO))
  Control.Monad.Trans.Reader.$fApplicativeReaderT_$c*> @ (Control.Monad.Trans.Except.ExceptT
                                                            SEDEL.Environment.Err GHC.Types.IO)
                                                       @ r
                                                       $dApplicative
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fApplicativeReaderT_$c*>
      @ r
"SPEC/SEDEL.Source.Inference $fApplicativeReaderT_$c<* @ (ExceptT
                                                           Err IO) _" [orphan] forall @ r
                                                                                                                                                        ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                            (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                               SEDEL.Environment.Err
                                                                                                                                                                               GHC.Types.IO))
  Control.Monad.Trans.Reader.$fApplicativeReaderT_$c<* @ (Control.Monad.Trans.Except.ExceptT
                                                            SEDEL.Environment.Err GHC.Types.IO)
                                                       @ r
                                                       $dApplicative
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fApplicativeReaderT_$c<*
      @ r
"SPEC/SEDEL.Source.Inference $fApplicativeReaderT_$c<*> @ (ExceptT
                                                            Err IO) _" [orphan] forall @ r
                                                                                                                                                          ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                              (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                 SEDEL.Environment.Err
                                                                                                                                                                                 GHC.Types.IO))
  Control.Monad.Trans.Reader.$fApplicativeReaderT_$c<*> @ (Control.Monad.Trans.Except.ExceptT
                                                             SEDEL.Environment.Err GHC.Types.IO)
                                                        @ r
                                                        $dApplicative
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fApplicativeReaderT_$c<*>
      @ r
"SPEC/SEDEL.Source.Inference $fFunctorExceptT @ IO _" [orphan] forall @ e
                                                                      (v :: GHC.Base.Functor
                                                                              GHC.Types.IO)
  Control.Monad.Trans.Except.$fFunctorExceptT @ GHC.Types.IO @ e v
  = SEDEL.Source.Inference.$s$fApplicativeExceptT_$s$fFunctorExceptT
      @ e
"SPEC/SEDEL.Source.Inference $fFunctorFreshMT @ (ReaderT
                                                  (Ctx TmName CtxType TyName Kind SType Expr)
                                                  (ExceptT Err IO))" [orphan] forall (v :: GHC.Base.Functor
                                                                                                                                                                                                                                                    (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                                                                                                       (SEDEL.Environment.Ctx
                                                                                                                                                                                                                                                          SEDEL.Source.Syntax.TmName
                                                                                                                                                                                                                                                          SEDEL.Source.Syntax.CtxType
                                                                                                                                                                                                                                                          SEDEL.Source.Syntax.TyName
                                                                                                                                                                                                                                                          SEDEL.Source.Syntax.Kind
                                                                                                                                                                                                                                                          SEDEL.Source.Syntax.SType
                                                                                                                                                                                                                                                          SEDEL.Source.Syntax.Expr)
                                                                                                                                                                                                                                                       (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                          SEDEL.Environment.Err
                                                                                                                                                                                                                                                          GHC.Types.IO)))
  Unbound.Generics.LocallyNameless.Fresh.$fFunctorFreshMT @ (Control.Monad.Trans.Reader.ReaderT
                                                               (SEDEL.Environment.Ctx
                                                                  SEDEL.Source.Syntax.TmName
                                                                  SEDEL.Source.Syntax.CtxType
                                                                  SEDEL.Source.Syntax.TyName
                                                                  SEDEL.Source.Syntax.Kind
                                                                  SEDEL.Source.Syntax.SType
                                                                  SEDEL.Source.Syntax.Expr)
                                                               (Control.Monad.Trans.Except.ExceptT
                                                                  SEDEL.Environment.Err
                                                                  GHC.Types.IO))
                                                          v
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorFreshMT
"SPEC/SEDEL.Source.Inference $fFunctorReaderT @ (ExceptT Err IO) _" [orphan] forall @ r
                                                                                    (v :: GHC.Base.Functor
                                                                                            (Control.Monad.Trans.Except.ExceptT
                                                                                               SEDEL.Environment.Err
                                                                                               GHC.Types.IO))
  Control.Monad.Trans.Reader.$fFunctorReaderT @ (Control.Monad.Trans.Except.ExceptT
                                                   SEDEL.Environment.Err GHC.Types.IO)
                                              @ r
                                              v
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorReaderT
      @ r
"SPEC/SEDEL.Source.Inference $fFunctorReaderT_$c<$ @ (ExceptT
                                                       Err IO) _" [orphan] forall @ r
                                                                                                                                                ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                   SEDEL.Environment.Err
                                                                                                                                                                   GHC.Types.IO))
  Control.Monad.Trans.Reader.$fFunctorReaderT_$c<$ @ (Control.Monad.Trans.Except.ExceptT
                                                        SEDEL.Environment.Err GHC.Types.IO)
                                                   @ r
                                                   $dFunctor
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorReaderT_$c<$
      @ r
"SPEC/SEDEL.Source.Inference $fFunctorReaderT_$cfmap @ (ExceptT
                                                         Err IO) _" [orphan] forall @ r
                                                                                                                                                    ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                    (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                       SEDEL.Environment.Err
                                                                                                                                                                       GHC.Types.IO))
  Control.Monad.Trans.Reader.$fFunctorReaderT_$cfmap @ (Control.Monad.Trans.Except.ExceptT
                                                          SEDEL.Environment.Err GHC.Types.IO)
                                                     @ r
                                                     $dFunctor
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorReaderT_$cfmap
      @ r
"SPEC/SEDEL.Source.Inference $fFunctorStateT1 @ (ReaderT
                                                  (Ctx TmName CtxType TyName Kind SType Expr)
                                                  (ExceptT Err IO)) _" [orphan] forall @ s
                                                                                                                                                                                                                                              ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                                                                                              (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                                                                                                                 (SEDEL.Environment.Ctx
                                                                                                                                                                                                                                                                    SEDEL.Source.Syntax.TmName
                                                                                                                                                                                                                                                                    SEDEL.Source.Syntax.CtxType
                                                                                                                                                                                                                                                                    SEDEL.Source.Syntax.TyName
                                                                                                                                                                                                                                                                    SEDEL.Source.Syntax.Kind
                                                                                                                                                                                                                                                                    SEDEL.Source.Syntax.SType
                                                                                                                                                                                                                                                                    SEDEL.Source.Syntax.Expr)
                                                                                                                                                                                                                                                                 (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                    SEDEL.Environment.Err
                                                                                                                                                                                                                                                                    GHC.Types.IO)))
  Control.Monad.Trans.State.Lazy.$fFunctorStateT1 @ (Control.Monad.Trans.Reader.ReaderT
                                                       (SEDEL.Environment.Ctx
                                                          SEDEL.Source.Syntax.TmName
                                                          SEDEL.Source.Syntax.CtxType
                                                          SEDEL.Source.Syntax.TyName
                                                          SEDEL.Source.Syntax.Kind
                                                          SEDEL.Source.Syntax.SType
                                                          SEDEL.Source.Syntax.Expr)
                                                       (Control.Monad.Trans.Except.ExceptT
                                                          SEDEL.Environment.Err GHC.Types.IO))
                                                  @ s
                                                  $dFunctor
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorStateT1
      @ s
"SPEC/SEDEL.Source.Inference $fFunctorStateT_$cfmap @ (ReaderT
                                                        (Ctx TmName CtxType TyName Kind SType Expr)
                                                        (ExceptT Err IO)) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                                                                                                                (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                                                                                                                                   (SEDEL.Environment.Ctx
                                                                                                                                                                                                                                                                                      SEDEL.Source.Syntax.TmName
                                                                                                                                                                                                                                                                                      SEDEL.Source.Syntax.CtxType
                                                                                                                                                                                                                                                                                      SEDEL.Source.Syntax.TyName
                                                                                                                                                                                                                                                                                      SEDEL.Source.Syntax.Kind
                                                                                                                                                                                                                                                                                      SEDEL.Source.Syntax.SType
                                                                                                                                                                                                                                                                                      SEDEL.Source.Syntax.Expr)
                                                                                                                                                                                                                                                                                   (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                      SEDEL.Environment.Err
                                                                                                                                                                                                                                                                                      GHC.Types.IO)))
  Control.Monad.Trans.State.Lazy.$fFunctorStateT_$cfmap @ (Control.Monad.Trans.Reader.ReaderT
                                                             (SEDEL.Environment.Ctx
                                                                SEDEL.Source.Syntax.TmName
                                                                SEDEL.Source.Syntax.CtxType
                                                                SEDEL.Source.Syntax.TyName
                                                                SEDEL.Source.Syntax.Kind
                                                                SEDEL.Source.Syntax.SType
                                                                SEDEL.Source.Syntax.Expr)
                                                             (Control.Monad.Trans.Except.ExceptT
                                                                SEDEL.Environment.Err GHC.Types.IO))
                                                        @ s
                                                        $dFunctor
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fFunctorStateT_$cfmap
      @ s
"SPEC/SEDEL.Source.Inference $fMonadFreshMT @ (ReaderT
                                                (Ctx TmName CtxType TyName Kind SType Expr)
                                                (ExceptT Err IO))" [orphan] forall (v :: GHC.Base.Monad
                                                                                                                                                                                                                                              (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                                                                                                 (SEDEL.Environment.Ctx
                                                                                                                                                                                                                                                    SEDEL.Source.Syntax.TmName
                                                                                                                                                                                                                                                    SEDEL.Source.Syntax.CtxType
                                                                                                                                                                                                                                                    SEDEL.Source.Syntax.TyName
                                                                                                                                                                                                                                                    SEDEL.Source.Syntax.Kind
                                                                                                                                                                                                                                                    SEDEL.Source.Syntax.SType
                                                                                                                                                                                                                                                    SEDEL.Source.Syntax.Expr)
                                                                                                                                                                                                                                                 (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                    SEDEL.Environment.Err
                                                                                                                                                                                                                                                    GHC.Types.IO)))
  Unbound.Generics.LocallyNameless.Fresh.$fMonadFreshMT @ (Control.Monad.Trans.Reader.ReaderT
                                                             (SEDEL.Environment.Ctx
                                                                SEDEL.Source.Syntax.TmName
                                                                SEDEL.Source.Syntax.CtxType
                                                                SEDEL.Source.Syntax.TyName
                                                                SEDEL.Source.Syntax.Kind
                                                                SEDEL.Source.Syntax.SType
                                                                SEDEL.Source.Syntax.Expr)
                                                             (Control.Monad.Trans.Except.ExceptT
                                                                SEDEL.Environment.Err GHC.Types.IO))
                                                        v
  = SEDEL.Source.Inference.$s$fFreshFreshMT_$s$fMonadFreshMT
"SPEC/SEDEL.Source.Inference $fMonadReaderT @ (ExceptT Err IO) _" [orphan] forall @ r
                                                                                  (v :: GHC.Base.Monad
                                                                                          (Control.Monad.Trans.Except.ExceptT
                                                                                             SEDEL.Environment.Err
                                                                                             GHC.Types.IO))
  Control.Monad.Trans.Reader.$fMonadReaderT @ (Control.Monad.Trans.Except.ExceptT
                                                 SEDEL.Environment.Err GHC.Types.IO)
                                            @ r
                                            v
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fMonadReaderT
      @ r
"SPEC/SEDEL.Source.Inference $fMonadReaderT_$c>>= @ (ExceptT
                                                      Err IO) _" [orphan] forall @ r
                                                                                                                                              ($dMonad :: GHC.Base.Monad
                                                                                                                                                            (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                               SEDEL.Environment.Err
                                                                                                                                                               GHC.Types.IO))
  Control.Monad.Trans.Reader.$fMonadReaderT_$c>>= @ (Control.Monad.Trans.Except.ExceptT
                                                       SEDEL.Environment.Err GHC.Types.IO)
                                                  @ r
                                                  $dMonad
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fMonadReaderT_$c>>=
      @ r
"SPEC/SEDEL.Source.Inference $fMonadReaderT_$cfail @ (ExceptT
                                                       Err IO) _" [orphan] forall @ r
                                                                                                                                                ($dMonad :: GHC.Base.Monad
                                                                                                                                                              (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                 SEDEL.Environment.Err
                                                                                                                                                                 GHC.Types.IO))
  Control.Monad.Trans.Reader.$fMonadReaderT_$cfail @ (Control.Monad.Trans.Except.ExceptT
                                                        SEDEL.Environment.Err GHC.Types.IO)
                                                   @ r
                                                   $dMonad
  = SEDEL.Source.Inference.$s$fApplicativeFreshMT_$s$fMonadReaderT_$cfail
      @ r
"SPEC/SEDEL.Source.Inference $fMonadStateT_$c>> @ (ReaderT
                                                    (Ctx TmName CtxType TyName Kind SType Expr)
                                                    (ExceptT Err IO)) _" [orphan] forall @ s
                                                                                                                                                                                                                                                    ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                  (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                                                                                                                     (SEDEL.Environment.Ctx
                                                                                                                                                                                                                                                                        SEDEL.Source.Syntax.TmName
                                                                                                                                                                                                                                                                        SEDEL.Source.Syntax.CtxType
                                                                                                                                                                                                                                                                        SEDEL.Source.Syntax.TyName
                                                                                                                                                                                                                                                                        SEDEL.Source.Syntax.Kind
                                                                                                                                                                                                                                                                        SEDEL.Source.Syntax.SType
                                                                                                                                                                                                                                                                        SEDEL.Source.Syntax.Expr)
                                                                                                                                                                                                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                        SEDEL.Environment.Err
                                                                                                                                                                                                                                                                        GHC.Types.IO)))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>> @ (Control.Monad.Trans.Reader.ReaderT
                                                         (SEDEL.Environment.Ctx
                                                            SEDEL.Source.Syntax.TmName
                                                            SEDEL.Source.Syntax.CtxType
                                                            SEDEL.Source.Syntax.TyName
                                                            SEDEL.Source.Syntax.Kind
                                                            SEDEL.Source.Syntax.SType
                                                            SEDEL.Source.Syntax.Expr)
                                                         (Control.Monad.Trans.Except.ExceptT
                                                            SEDEL.Environment.Err GHC.Types.IO))
                                                    @ s
                                                    $dMonad
  = SEDEL.Source.Inference.$s$fFreshFreshMT_$s$fMonadStateT_$c>> @ s
"SPEC/SEDEL.Source.Inference $fMonadStateT_$c>>= @ (ReaderT
                                                     (Ctx TmName CtxType TyName Kind SType Expr)
                                                     (ExceptT Err IO)) _" [orphan] forall @ s
                                                                                                                                                                                                                                                       ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                     (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                                                                                                                        (SEDEL.Environment.Ctx
                                                                                                                                                                                                                                                                           SEDEL.Source.Syntax.TmName
                                                                                                                                                                                                                                                                           SEDEL.Source.Syntax.CtxType
                                                                                                                                                                                                                                                                           SEDEL.Source.Syntax.TyName
                                                                                                                                                                                                                                                                           SEDEL.Source.Syntax.Kind
                                                                                                                                                                                                                                                                           SEDEL.Source.Syntax.SType
                                                                                                                                                                                                                                                                           SEDEL.Source.Syntax.Expr)
                                                                                                                                                                                                                                                                        (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                           SEDEL.Environment.Err
                                                                                                                                                                                                                                                                           GHC.Types.IO)))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>>= @ (Control.Monad.Trans.Reader.ReaderT
                                                          (SEDEL.Environment.Ctx
                                                             SEDEL.Source.Syntax.TmName
                                                             SEDEL.Source.Syntax.CtxType
                                                             SEDEL.Source.Syntax.TyName
                                                             SEDEL.Source.Syntax.Kind
                                                             SEDEL.Source.Syntax.SType
                                                             SEDEL.Source.Syntax.Expr)
                                                          (Control.Monad.Trans.Except.ExceptT
                                                             SEDEL.Environment.Err GHC.Types.IO))
                                                     @ s
                                                     $dMonad
  = SEDEL.Source.Inference.$s$fFreshFreshMT_$s$fMonadStateT_$c>>= @ s
"SPEC/SEDEL.Source.Inference $fMonadStateT_$cfail @ (ReaderT
                                                      (Ctx TmName CtxType TyName Kind SType Expr)
                                                      (ExceptT Err IO)) _" [orphan] forall @ s
                                                                                                                                                                                                                                                          ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                        (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                                                                                                                           (SEDEL.Environment.Ctx
                                                                                                                                                                                                                                                                              SEDEL.Source.Syntax.TmName
                                                                                                                                                                                                                                                                              SEDEL.Source.Syntax.CtxType
                                                                                                                                                                                                                                                                              SEDEL.Source.Syntax.TyName
                                                                                                                                                                                                                                                                              SEDEL.Source.Syntax.Kind
                                                                                                                                                                                                                                                                              SEDEL.Source.Syntax.SType
                                                                                                                                                                                                                                                                              SEDEL.Source.Syntax.Expr)
                                                                                                                                                                                                                                                                           (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                              SEDEL.Environment.Err
                                                                                                                                                                                                                                                                              GHC.Types.IO)))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$cfail @ (Control.Monad.Trans.Reader.ReaderT
                                                           (SEDEL.Environment.Ctx
                                                              SEDEL.Source.Syntax.TmName
                                                              SEDEL.Source.Syntax.CtxType
                                                              SEDEL.Source.Syntax.TyName
                                                              SEDEL.Source.Syntax.Kind
                                                              SEDEL.Source.Syntax.SType
                                                              SEDEL.Source.Syntax.Expr)
                                                           (Control.Monad.Trans.Except.ExceptT
                                                              SEDEL.Environment.Err GHC.Types.IO))
                                                      @ s
                                                      $dMonad
  = SEDEL.Source.Inference.$s$fFreshFreshMT_$s$fMonadStateT_$cfail
      @ s
"SPEC/SEDEL.Source.Inference $fShowEmbed @ (Maybe FType)" [orphan] forall (v :: GHC.Show.Show
                                                                                  (GHC.Maybe.Maybe
                                                                                     SEDEL.Intermediate.Syntax.FType))
  Unbound.Generics.LocallyNameless.Embed.$fShowEmbed @ (GHC.Maybe.Maybe
                                                          SEDEL.Intermediate.Syntax.FType)
                                                     v
  = SEDEL.Source.Inference.$s$fAlpha(,)_$s$fShowEmbed2
"SPEC/SEDEL.Source.Inference $fShowEmbed @ FType" [orphan] forall (v :: GHC.Show.Show
                                                                          SEDEL.Intermediate.Syntax.FType)
  Unbound.Generics.LocallyNameless.Embed.$fShowEmbed @ SEDEL.Intermediate.Syntax.FType
                                                     v
  = SEDEL.Source.Inference.$s$fAlpha(,)_$s$fShowEmbed1
"SPEC/SEDEL.Source.Inference $fShowEmbed @ SType" [orphan] forall (v :: GHC.Show.Show
                                                                          SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fShowEmbed @ SEDEL.Source.Syntax.SType
                                                     v
  = SEDEL.Source.Inference.$s$fAlpha(,)_$s$fShowEmbed
"SPEC/SEDEL.Source.Inference $fShowEmbed_$cshowsPrec @ (Maybe FType)" [orphan] [2] forall (w :: GHC.Show.Show
                                                                                                  (GHC.Maybe.Maybe
                                                                                                     SEDEL.Intermediate.Syntax.FType))
  Unbound.Generics.LocallyNameless.Embed.$fShowEmbed_$cshowsPrec @ (GHC.Maybe.Maybe
                                                                      SEDEL.Intermediate.Syntax.FType)
                                                                 w
  = SEDEL.Source.Inference.$s$fShowEmbed_$cshowsPrec2
"SPEC/SEDEL.Source.Inference $fShowMaybe @ FType" [orphan] forall (v :: GHC.Show.Show
                                                                          SEDEL.Intermediate.Syntax.FType)
  GHC.Show.$fShowMaybe @ SEDEL.Intermediate.Syntax.FType v
  = SEDEL.Source.Inference.$s$fAlpha(,)_$s$fShowMaybe
"SPEC/SEDEL.Source.Inference $wsplitS @ TyName" [orphan] [2] forall (w :: GHC.Classes.Ord
                                                                            SEDEL.Source.Syntax.TyName)
  Data.Set.Internal.$wsplitS @ (Unbound.Generics.LocallyNameless.Name.Name
                                  SEDEL.Source.Syntax.SType)
                             w
  = SEDEL.Source.Inference.$s$wsplitS
"SPEC/SEDEL.Source.Inference union @ TyName" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                         SEDEL.Source.Syntax.TyName)
  Data.Set.Internal.union @ (Unbound.Generics.LocallyNameless.Name.Name
                               SEDEL.Source.Syntax.SType)
                          $dOrd
  = SEDEL.Source.Inference.$sunion
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

