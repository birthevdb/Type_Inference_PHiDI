
==================== FINAL INTERFACE ====================
2019-02-26 08:34:16.481001 UTC

interface sedel-0.1.0.0-BGuUapfeRSQ3zXo3bqhidP:SEDEL.Source.TypeCheck 8044
  interface hash: 215fc0fc4833b55291a73a8f9489edc8
  ABI hash: e086d70507d5a15d14010cdc5d52618e
  export-list hash: 76f27327e0a5f27744e80e53f69ecfb1
  orphan hash: d0ceb416289085eb85fec65fdea929d4
  flag hash: 771a54017036b4ef94f6be9126074e0d
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  SEDEL.Source.TypeCheck.tcModule
module dependencies: SEDEL.Common SEDEL.Environment
                     SEDEL.PrettyPrint SEDEL.Source.Desugar SEDEL.Source.Subtyping
                     SEDEL.Source.Syntax SEDEL.Target.Syntax SEDEL.Util
package dependencies: StateVar-1.1.1.1 array-0.5.2.0 async-2.2.1
                      base-4.11.1.0 base-orphans-0.7 bifunctors-5.5.3 binary-0.8.5.1
                      bytestring-0.10.8.2 comonad-5.0.4 containers-0.5.11.0
                      contravariant-1.4.1 deepseq-1.4.3.0 distributive-0.5.3
                      exceptions-0.10.0 ghc-boot-th-8.4.4 ghc-prim-0.5.2.0
                      hashable-1.2.7.0 integer-gmp-1.0.2.0 megaparsec-6.5.0 mtl-2.2.2
                      parser-combinators-1.0.0 pretty-1.1.3.6 prettyprinter-1.2.1
                      profunctors-5.2.2 protolude-0.2.2 stm-2.4.5.1 tagged-0.8.5
                      template-haskell-2.13.0.0 text-1.2.3.1 transformers-0.5.5.0
                      unbound-generics-0.3.4
orphans: sedel-0.1.0.0-BGuUapfeRSQ3zXo3bqhidP:SEDEL.PrettyPrint
         sedel-0.1.0.0-BGuUapfeRSQ3zXo3bqhidP:SEDEL.Source.Syntax
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.1:Data.Text.Lazy
         text-1.2.3.1:Data.Text binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show stm-2.4.5.1:Control.Monad.STM
         transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Complex base-4.11.1.0:Data.Functor.Compose
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         bifunctors-5.5.3:Data.Bifunctor.Biff
                         bifunctors-5.5.3:Data.Bifunctor.Clown
                         bifunctors-5.5.3:Data.Bifunctor.Joker
                         bifunctors-5.5.3:Data.Bifunctor.Product
                         bifunctors-5.5.3:Data.Bifunctor.Sum
                         bifunctors-5.5.3:Data.Bifunctor.Tannen
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         ghc-boot-th-8.4.4:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.4:GHC.LanguageExtensions.Type
                         megaparsec-6.5.0:Text.Megaparsec.Error
                         megaparsec-6.5.0:Text.Megaparsec.Pos
                         megaparsec-6.5.0:Text.Megaparsec.State
                         megaparsec-6.5.0:Text.Megaparsec.Stream
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         prettyprinter-1.2.1:Data.Text.Prettyprint.Doc.Internal
                         sedel-0.1.0.0-BGuUapfeRSQ3zXo3bqhidP:SEDEL.Common
                         sedel-0.1.0.0-BGuUapfeRSQ3zXo3bqhidP:SEDEL.Source.Syntax
                         sedel-0.1.0.0-BGuUapfeRSQ3zXo3bqhidP:SEDEL.Target.Syntax
                         tagged-0.8.5:Data.Tagged
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.1:Data.Text text-1.2.3.1:Data.Text.Lazy
                         unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Bind
                         unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Embed
                         unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Name
                         unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Rebind
                         unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Rec
                         unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Shift
import  -/  base-4.11.1.0:Control.Monad c5f960c67d822497578bffbd3e4c01cf
import  -/  base-4.11.1.0:Data.Bifunctor a977586bad544f929bb5bc7f139aaa1c
import  -/  base-4.11.1.0:Data.Either 39d922b371c4c52d426e9ee66de8371a
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.Functor f522c3501272159820fd6f242510732f
import  -/  base-4.11.1.0:Data.Maybe 409c3da2b142470b68be39ce1d97a9f7
import  -/  base-4.11.1.0:Data.Traversable 7ad4edb9184ea1ae8e73f6b94f115c8c
import  -/  base-4.11.1.0:Data.Tuple 3af66f3ac61ed95ba8a3a3f68ebc5003
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  containers-0.5.11.0:Data.Map 0dbdaec812ef695a364aa6c69e7f7d53
import  -/  containers-0.5.11.0:Data.Map.Internal 0150e210d0ae8df0f3a0669d5e32d8fa
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  mtl-2.2.2:Control.Monad.Error.Class df146c18e27154b8df4c8637c59fd61b
import  -/  prettyprinter-1.2.1:Data.Text.Prettyprint.Doc 04e8924fa6b26857d25f7e89f331b3ec
import  -/  prettyprinter-1.2.1:Data.Text.Prettyprint.Doc.Internal 4dbff1ffd6a8a023b5e8586c0275223e
import  -/  prettyprinter-1.2.1:Data.Text.Prettyprint.Doc.Symbols.Ascii e965189d3854891aaef2f95b81655ee5
import  -/  protolude-0.2.2:Protolude ec8c9f1921240ba85c2826100dc947ec
import  -/  protolude-0.2.2:Protolude.Safe 58184cd6eb44914f74af97565ba57928
import  -/  protolude-0.2.2:Unsafe 522d50bc66143516888af57cdb121738
import  -/  SEDEL.Common 09f7298ba1fa8793b51809d87ff74b30
  exports: f3e61cff89cd8529684da86ece3c0a45
  Arith f7fe6387143aa84e6738506b1f896774
  Comp 0ffc1eb707b1a3c7f47f038984f944d4
  Equ e4cd480182774a7cd54e42cd1bd95792
  Logical b7768423591bd03d2d1824ef255c4024
  Neq 6164569898ae6e177eb1207ff284aeb5
import  -/  SEDEL.Environment 58bb2a9dac114da6febda68e6bcab706
  exports: 9b596c30b7faa0d674ead96b5fbae4e0
  Ctx 4d40b76497431ab3e2b46fb381d29825
  TcMonad 2993bda6ca1aa509196cffef0897dad2
  askCtx 3726505e5c41e2fb9b997967293a315a
  errThrow cc71f8a413ca264032e5a44caa583457
  extendConstrainedTVarCtx 26c0f00eb485887313683fb5132d1873
  extendSourceLocation 14af75c061e5c8aa0125aa04bc2a91dc
  extendTVarCtx e336ab63c868471604a9e43bd4b5c3f4
  extendVarCtx 7a1c812da1af8d35d7821e1c6a1353ed
  localCtx 38ae9f97ee1f98c8eb1e209f64a14748
  lookupTVarConstraint f02758182b337510dd97b0ac5868c941
  lookupTVarConstraintMaybe e3b4f6d247d8429f01222f133b109a71
  lookupTVarKindMaybe ca80196cfc2952a70aa15fa52a5a0030
  lookupTmDef aa52003bd432162b87b3a75bddc5d1dd
  lookupVarTy 1b00ade681667ac2466e8c062893c5fb
import  -/  SEDEL.PrettyPrint 49a6e7b74cbc1b9f5143d39fe1ec859b
  exports: 19ba40565495f539d4becea748f89418
  DD 8ca0d1c95642c2656d6ca19f3b6e41d3
  DS 7fc8fd265f83868515a063f3b34deaec
  pprint 49a1ae40012cb52312ba8f259909743d
import  -/  SEDEL.Source.Desugar e0fff59af80c6d3af0cc3f4186d67c8c
  exports: e58276cebab59c57ad9f74a548b02afd
  desugar 2b9028e2b160b9439becf5253fa1464f
  desugarTmBind 41eb3c3d5a5f822d998c3b6514212bed
  expandType 4060b21e2cef634273a57ce6ee606ea6
  normalizeTmDecl 42d4a09225ce0a39d213c6b1d1f8dc79
import  -/  SEDEL.Source.Subtyping 1be88ae1a52440846bd02698b682de86
  exports: ec840d81bd352504060d0a1bc9f8b012
  subtype cff08958466fec617a1f346f949cca42
import  -/  SEDEL.Source.Syntax 0548d3668eda4620fc3ff3e6cf2368fb
  exports: 6168fc739a7e41a0b25e4ca6cc08e10c
  Acc 74ebf2ad9ea6b84a3d630c1999b0183f
  And d67643cb17880b1abddc6abf91d4f8a5
  App ba2b2df00e3d440fb7ee2e97fad450c2
  Arr 397e828962dfd176efed92f2c56bc256
  BoolT b4482118f31960df2ddce6c8690c9ecd
  BoolV 005d6c0408741f530dfe1a3c5dcceda9
  BotT a3a7b862a4bceb4a662ac6984df90188
  DForall 2b7a02b818deac1f73f2f3a86bff1b86
  DRec 2513c98ff2386be4280e3e970adb31bb
  DefDecl ffb024ff311997f02685d1ed6f6687b4
  Expr e82999745a2326527e020a915d2988cd
  If 2ecc6f234beebffd69578a89390cb75d
  Kind e82999745a2326527e020a915d2988cd
  Label 48063cbab0cf231dc589db9acdc7a78c
  Lam d55f0f183a033abcc4314ddffdc9d233
  LamA 384c9fe854b392e7c0e51c021088a74c
  Letrec c5ec78127f48cd6d07be6d328051b53c
  LitV eb60ab0602473dbfe5de4a7a55c9326b
  Merge 4cd641e29b94c82fdea109d702d90942
  Module 7d59ce65ff4a7973051c3d91efa08af0
  NumT 3904495283f24212d1d2fea38e0c7b6b
  Pos 6ffb775a97b8719becb153b1aad8bcb5
  PrimOp 4dd191b54fb6a326270c86d18b2a3192
  SDecl bd8d2ba90c5b92ed1fc11747f631d4c0
  SRecT b2e8745a356f68d4ee38e06d46be62f9
  SType e82999745a2326527e020a915d2988cd
  Star 91d4a7c25ef46a369bec0ba8c24d5fbe
  TVar 8a2dafe14d3e9f11f76bcae45d3021c4
  TmBind e82999745a2326527e020a915d2988cd
  TmName e82999745a2326527e020a915d2988cd
  Top 414867fb90328e5b1b256a7cc866e8b5
  TopT 37aa61935fae500ca4d2904f9fa8d48b
  Var 54737d5977b92619bc58e6ac2bf3ec0b
  mainExpr 7d59ce65ff4a7973051c3d91efa08af0
  moduleEntries 7d59ce65ff4a7973051c3d91efa08af0
import  -/  SEDEL.Target.Syntax c6622e5f9abe8f28e85d7c0c0a6e79a5
  exports: d7a64829c71f2f04f965636abc6b48e6
  UApp 23c4b2f9f0933d37c321e885ceea82c6
  UBoolV 7bb92bc1bda6067988bc17679a8c6143
  UExpr 9bfcea255d0153a0de696df7d2ee637a
  UIf 241b4ee8290ac277f844e637fcf793dd
  ULam 127fec481f4b9ad0d8803d73f02a2b2d
  ULet 4c3d30e8a955991e75db7b5e153b2bcf
  ULitV c599a4801c5a9cffb85b4dd0800c31d6
  UName 9bfcea255d0153a0de696df7d2ee637a
  UP1 c799fcc7b660c15cef276903d934962f
  UP2 902a5585480b9b4128ba53215ad6a2cd
  UPair 3edbd9516fc6a64a3db1538a6f2cd0d4
  UPrimOp e6a2c6a1b2944fabdb7c8244fbadb3f1
  UUnit 21b0fe465af1ff42966a8df3370fd172
  UVar e844003c4b21cecd01af5481fb61dce2
  elam 6c8ec9e83c515c6322298605466a765f
  elet 72b9d4d87c747df28842c2f91b9a577b
  evar ce3174e8c8ad72030bb8db8723b589f8
import  -/  SEDEL.Util 9c7b554d120905f8937ada4b7a10aaf5
  exports: 0dc9e2e0bf37de7f9de603f3ef4259bd
  translate 9cb53985a630d52941ac814a4816df94
import  -/  unbound-generics-0.3.4:Unbound.Generics.LocallyNameless 8dd357a9d9fbbcf23f41fb39ba00f4e4
import  -/  unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Embed a6d67338db1f14cf42fb5b5b69a561d5
import  -/  unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Fresh 6f0bdf2414300284a1d43f913bee508e
import  -/  unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Name 34633dd5588f50a53bac3c657a64a3ac
import  -/  unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Operations 86bd0dbc8cb450c4ba4e75dad5d99714
654c80e719300fd982ef1a14283cd09f
  $s$fAlpha(,)3 ::
    Unbound.Generics.LocallyNameless.Alpha.Alpha
      (Unbound.Generics.LocallyNameless.Name.Name
         SEDEL.Source.Syntax.SType,
       Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType)
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Name.Name
                       SEDEL.Source.Syntax.SType,
                     Unbound.Generics.LocallyNameless.Embed.Embed
                       SEDEL.Source.Syntax.SType)
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fShow(,)3
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$caeq'3
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$cfvAny'3
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$cclose3
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$copen3
                  (\ (x :: (Unbound.Generics.LocallyNameless.Name.Name
                              SEDEL.Source.Syntax.SType,
                            Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType)) ->
                   case x of wild { (,) g1 g2 ->
                   case g1 of wild1 {
                     Unbound.Generics.LocallyNameless.Name.Fn ds1 ds2
                     -> let {
                          xs :: Unbound.Generics.LocallyNameless.Name.AnyName
                          = Unbound.Generics.LocallyNameless.Name.AnyName
                              @ SEDEL.Source.Syntax.SType
                              SEDEL.Source.Syntax.$fAlphaSType16
                                `cast`
                              (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <SEDEL.Source.Syntax.SType>_N)
                              wild1
                        } in
                        case (SEDEL.Source.Syntax.$fAlphaSType_$cisTerm
                                g2
                                  `cast`
                                (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                     <SEDEL.Source.Syntax.SType>_R))
                               `cast`
                             (Data.Semigroup.Internal.N:All[0]) of wild2 {
                          GHC.Types.False
                          -> (GHC.Base.Nothing
                                @ [Unbound.Generics.LocallyNameless.Name.AnyName])
                               `cast`
                             (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                       <Unbound.Generics.LocallyNameless.Name.AnyName>_R))
                          GHC.Types.True
                          -> case Data.OldList.intersectBy
                                    @ Unbound.Generics.LocallyNameless.Name.AnyName
                                    Unbound.Generics.LocallyNameless.Name.$fEqAnyName_$c==
                                    (GHC.Types.:
                                       @ Unbound.Generics.LocallyNameless.Name.AnyName
                                       xs
                                       (GHC.Types.[]
                                          @ Unbound.Generics.LocallyNameless.Name.AnyName))
                                    (GHC.Types.[]
                                       @ Unbound.Generics.LocallyNameless.Name.AnyName) of wild3 {
                               []
                               -> (GHC.Base.Just
                                     @ [Unbound.Generics.LocallyNameless.Name.AnyName]
                                     (GHC.Base.build
                                        @ Unbound.Generics.LocallyNameless.Name.AnyName
                                        (\ @ b
                                           (c :: Unbound.Generics.LocallyNameless.Name.AnyName
                                                 -> b -> b)[OneShot]
                                           (n :: b)[OneShot] ->
                                         c xs n)))
                                    `cast`
                                  (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                            <Unbound.Generics.LocallyNameless.Name.AnyName>_R))
                               : ds4 ds5
                               -> (GHC.Base.Nothing
                                     @ [Unbound.Generics.LocallyNameless.Name.AnyName])
                                    `cast`
                                  (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                            <Unbound.Generics.LocallyNameless.Name.AnyName>_R)) } }
                     Unbound.Generics.LocallyNameless.Name.Bn ipv ipv1
                     -> (GHC.Base.Nothing
                           @ [Unbound.Generics.LocallyNameless.Name.AnyName])
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                  <Unbound.Generics.LocallyNameless.Name.AnyName>_R)) } })
                  (\ (x :: (Unbound.Generics.LocallyNameless.Name.Name
                              SEDEL.Source.Syntax.SType,
                            Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType)) ->
                   case x of wild { (,) g1 g2 ->
                   GHC.Types.False `cast` (Sym (Data.Semigroup.Internal.N:All[0])) })
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$cisEmbed3
                  (\ (x :: (Unbound.Generics.LocallyNameless.Name.Name
                              SEDEL.Source.Syntax.SType,
                            Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType)) ->
                   case x of wild { (,) g1 g2 ->
                   (\ (i :: GHC.Integer.Type.Integer) ->
                    case GHC.Integer.Type.eqInteger#
                           i
                           Unbound.Generics.LocallyNameless.Alpha.$fAlpha()4 of wild1 {
                      DEFAULT
                      -> case GHC.Integer.Type.minusInteger
                                i
                                Unbound.Generics.LocallyNameless.Alpha.$fAlphaAnyName9 of vx { DEFAULT ->
                         Data.Either.Left
                           @ GHC.Integer.Type.Integer
                           @ Unbound.Generics.LocallyNameless.Name.AnyName
                           vx }
                      1#
                      -> Data.Either.Right
                           @ GHC.Integer.Type.Integer
                           @ Unbound.Generics.LocallyNameless.Name.AnyName
                           (Unbound.Generics.LocallyNameless.Name.AnyName
                              @ SEDEL.Source.Syntax.SType
                              SEDEL.Source.Syntax.$fAlphaSType16
                                `cast`
                              (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <SEDEL.Source.Syntax.SType>_N)
                              g1) })
                     `cast`
                   (Sym (Unbound.Generics.LocallyNameless.Alpha.N:NthPatFind[0])) })
                  (\ (x :: (Unbound.Generics.LocallyNameless.Name.Name
                              SEDEL.Source.Syntax.SType,
                            Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType)) ->
                   case x of wild { (,) g1 g2 ->
                   (\ (nm :: Unbound.Generics.LocallyNameless.Name.AnyName) ->
                    case Unbound.Generics.LocallyNameless.Alpha.$fAlphaName4
                           @ SEDEL.Source.Syntax.SType
                           SEDEL.Source.Syntax.$fAlphaSType16
                             `cast`
                           (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <SEDEL.Source.Syntax.SType>_N)
                           g1
                           nm of wild1 {
                      Data.Either.Left n
                      -> case GHC.Integer.Type.plusInteger
                                n
                                Unbound.Generics.LocallyNameless.Alpha.$fAlpha()4 of vx { DEFAULT ->
                         Data.Either.Left
                           @ GHC.Integer.Type.Integer
                           @ GHC.Integer.Type.Integer
                           vx }
                      Data.Either.Right ds2 -> wild1 })
                     `cast`
                   (Sym (Unbound.Generics.LocallyNameless.Alpha.N:NamePatFind[0])) })
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$cswaps'3
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$clfreshen'3
                  (Unbound.Generics.LocallyNameless.Alpha.$fAlpha(,)_$cfreshen'
                     @ (Unbound.Generics.LocallyNameless.Name.Name
                          SEDEL.Source.Syntax.SType)
                     @ (Unbound.Generics.LocallyNameless.Embed.Embed
                          SEDEL.Source.Syntax.SType)
                     SEDEL.Source.Syntax.$fAlphaSType_$s$fAlphaName
                     SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlphaEmbed1)
                  (Unbound.Generics.LocallyNameless.Alpha.$fAlpha(,)_$cacompare'
                     @ (Unbound.Generics.LocallyNameless.Name.Name
                          SEDEL.Source.Syntax.SType)
                     @ (Unbound.Generics.LocallyNameless.Embed.Embed
                          SEDEL.Source.Syntax.SType)
                     SEDEL.Source.Syntax.$fAlphaSType_$s$fAlphaName
                     SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlphaEmbed1) -}
841830657b8bdbbbe2de7c7efb9713ea
  $s$fAlpha(,)_$cfreshen'1 ::
    Unbound.Generics.LocallyNameless.Fresh.Fresh m =>
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> (Unbound.Generics.LocallyNameless.Name.Name
          SEDEL.Source.Syntax.SType,
        Unbound.Generics.LocallyNameless.Embed.Embed
          SEDEL.Source.Syntax.SType)
    -> m ((Unbound.Generics.LocallyNameless.Name.Name
             SEDEL.Source.Syntax.SType,
           Unbound.Generics.LocallyNameless.Embed.Embed
             SEDEL.Source.Syntax.SType),
          Unbound.Generics.PermM.Perm
            Unbound.Generics.LocallyNameless.Name.AnyName)
  {- Arity: 3,
     Strictness: <S(S(LC(C(S))LLL)L),U(U(U,U,U,U,U),U)><L,U><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   (w2 :: Unbound.Generics.LocallyNameless.Fresh.Fresh m)
                   (w3 :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (w4 :: (Unbound.Generics.LocallyNameless.Name.Name
                             SEDEL.Source.Syntax.SType,
                           Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Source.Syntax.SType)) ->
                 case w4 of ww { (,) ww1 ww2 ->
                 Unbound.Generics.LocallyNameless.Alpha.$w$cfreshen'
                   @ (Unbound.Generics.LocallyNameless.Name.Name
                        SEDEL.Source.Syntax.SType)
                   @ (Unbound.Generics.LocallyNameless.Embed.Embed
                        SEDEL.Source.Syntax.SType)
                   SEDEL.Source.Syntax.$fAlphaSType_$s$fAlphaName
                   SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlphaEmbed1
                   @ m
                   w2
                   w3
                   ww1
                   ww2 }) -}
cc670265b1aef71c3d8fa7485a23ae32
  $s$fAlpha(,)_$s$fAlpha(,)_$caeq'3 ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> (Unbound.Generics.LocallyNameless.Name.Name
          SEDEL.Source.Syntax.SType,
        Unbound.Generics.LocallyNameless.Embed.Embed
          SEDEL.Source.Syntax.SType)
    -> (Unbound.Generics.LocallyNameless.Name.Name
          SEDEL.Source.Syntax.SType,
        Unbound.Generics.LocallyNameless.Embed.Embed
          SEDEL.Source.Syntax.SType)
    -> GHC.Types.Bool
  {- Arity: 3,
     Strictness: <S(SS),1*U(U,U)><S,1*U(1*U,1*U)><S,1*U(1*U,1*U)>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ (c :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (x :: (Unbound.Generics.LocallyNameless.Name.Name
                            SEDEL.Source.Syntax.SType,
                          Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType))
                   (y :: (Unbound.Generics.LocallyNameless.Name.Name
                            SEDEL.Source.Syntax.SType,
                          Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType)) ->
                 case x of wild { (,) g1 g2 ->
                 case y of wild1 { (,) g4 g5 ->
                 case c of wild2 { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds ds1 ->
                 case ds of wild3 {
                   Unbound.Generics.LocallyNameless.Alpha.Term
                   -> case Unbound.Generics.LocallyNameless.Name.$fEqAnyName_$c==1
                             @ SEDEL.Source.Syntax.SType
                             g1
                             g4 of wild4 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> SEDEL.Source.Syntax.$fAlphaSType_$caeq'
                             (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                                Unbound.Generics.LocallyNameless.Alpha.Term
                                ds1)
                             g2
                               `cast`
                             (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <SEDEL.Source.Syntax.SType>_R)
                             g5
                               `cast`
                             (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <SEDEL.Source.Syntax.SType>_R) }
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> SEDEL.Source.Syntax.$fAlphaSType_$caeq'
                        (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                           Unbound.Generics.LocallyNameless.Alpha.Term
                           ds1)
                        g2
                          `cast`
                        (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                             <SEDEL.Source.Syntax.SType>_R)
                        g5
                          `cast`
                        (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                             <SEDEL.Source.Syntax.SType>_R) } } } }) -}
71d3558c6f3e3372f52d460923d41f88
  $s$fAlpha(,)_$s$fAlpha(,)_$cclose3 ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Alpha.NamePatFind
    -> (Unbound.Generics.LocallyNameless.Name.Name
          SEDEL.Source.Syntax.SType,
        Unbound.Generics.LocallyNameless.Embed.Embed
          SEDEL.Source.Syntax.SType)
    -> (Unbound.Generics.LocallyNameless.Name.Name
          SEDEL.Source.Syntax.SType,
        Unbound.Generics.LocallyNameless.Embed.Embed
          SEDEL.Source.Syntax.SType)
  {- Arity: 3, Strictness: <L,U(U,U)><L,U><S,1*U(1*U,1*U)>m,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (c :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (b1 :: Unbound.Generics.LocallyNameless.Alpha.NamePatFind)
                   (x :: (Unbound.Generics.LocallyNameless.Name.Name
                            SEDEL.Source.Syntax.SType,
                          Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType)) ->
                 case x of wild { (,) g1 g2 ->
                 (Unbound.Generics.LocallyNameless.Alpha.$fAlphaAnyName_$cclose1
                    @ SEDEL.Source.Syntax.SType
                    SEDEL.Source.Syntax.$fAlphaSType16
                      `cast`
                    (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <SEDEL.Source.Syntax.SType>_N)
                    c
                    b1
                    g1,
                  case c of wild1 { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                  case ds1 of wild2 {
                    Unbound.Generics.LocallyNameless.Alpha.Term
                    -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed6
                         @ SEDEL.Source.Syntax.SType
                    Unbound.Generics.LocallyNameless.Alpha.Pat
                    -> (SEDEL.Source.Syntax.$fAlphaSType_$cclose
                          (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                             Unbound.Generics.LocallyNameless.Alpha.Term
                             ds2)
                          b1
                          g2
                            `cast`
                          (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                               <SEDEL.Source.Syntax.SType>_R))
                         `cast`
                       (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                 <SEDEL.Source.Syntax.SType>_R)) } }) }) -}
3f9e89e75b308117d998203aa7e5dacd
  $s$fAlpha(,)_$s$fAlpha(,)_$cfvAny'3 ::
    (Data.Functor.Contravariant.Contravariant f,
     GHC.Base.Applicative f) =>
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> (Unbound.Generics.LocallyNameless.Name.AnyName
        -> f Unbound.Generics.LocallyNameless.Name.AnyName)
    -> (Unbound.Generics.LocallyNameless.Name.Name
          SEDEL.Source.Syntax.SType,
        Unbound.Generics.LocallyNameless.Embed.Embed
          SEDEL.Source.Syntax.SType)
    -> f (Unbound.Generics.LocallyNameless.Name.Name
            SEDEL.Source.Syntax.SType,
          Unbound.Generics.LocallyNameless.Embed.Embed
            SEDEL.Source.Syntax.SType)
  {- Arity: 2, Strictness: <L,U(U,U)><L,U(U(U,U),U,U,U,U,U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ f :: * -> *
                   ($dContravariant :: Data.Functor.Contravariant.Contravariant f)
                   ($dApplicative :: GHC.Base.Applicative f) ->
                 let {
                   $dFunctor :: GHC.Base.Functor f
                   = GHC.Base.$p1Applicative @ f $dApplicative
                 } in
                 \ (c :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (nfn :: Unbound.Generics.LocallyNameless.Name.AnyName
                           -> f Unbound.Generics.LocallyNameless.Name.AnyName) ->
                 let {
                   f1 :: f (GHC.Generics.Rep
                              (Unbound.Generics.LocallyNameless.Name.Name
                                 SEDEL.Source.Syntax.SType,
                               Unbound.Generics.LocallyNameless.Embed.Embed
                                 SEDEL.Source.Syntax.SType)
                              GHC.Types.Any)
                         -> f (Unbound.Generics.LocallyNameless.Name.Name
                                 SEDEL.Source.Syntax.SType,
                               Unbound.Generics.LocallyNameless.Embed.Embed
                                 SEDEL.Source.Syntax.SType)
                   = GHC.Base.fmap
                       @ f
                       $dFunctor
                       @ (GHC.Generics.Rep
                            (Unbound.Generics.LocallyNameless.Name.Name
                               SEDEL.Source.Syntax.SType,
                             Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Source.Syntax.SType)
                            GHC.Types.Any)
                       @ (Unbound.Generics.LocallyNameless.Name.Name
                            SEDEL.Source.Syntax.SType,
                          Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType)
                       (GHC.Generics.$fGeneric(,)_$cto
                          @ (Unbound.Generics.LocallyNameless.Name.Name
                               SEDEL.Source.Syntax.SType)
                          @ (Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Source.Syntax.SType)
                          @ GHC.Types.Any)
                 } in
                 let {
                   f2 :: f (GHC.Generics.M1
                              GHC.Generics.C
                              ('GHC.Generics.MetaCons
                                 "(,)" 'GHC.Generics.PrefixI 'GHC.Types.False)
                              (GHC.Generics.S1
                                 ('GHC.Generics.MetaSel
                                    'GHC.Base.Nothing
                                    'GHC.Generics.NoSourceUnpackedness
                                    'GHC.Generics.NoSourceStrictness
                                    'GHC.Generics.DecidedLazy)
                                 (GHC.Generics.Rec0
                                    (Unbound.Generics.LocallyNameless.Name.Name
                                       SEDEL.Source.Syntax.SType))
                               GHC.Generics.:*: GHC.Generics.S1
                                                  ('GHC.Generics.MetaSel
                                                     'GHC.Base.Nothing
                                                     'GHC.Generics.NoSourceUnpackedness
                                                     'GHC.Generics.NoSourceStrictness
                                                     'GHC.Generics.DecidedLazy)
                                                  (GHC.Generics.Rec0
                                                     (Unbound.Generics.LocallyNameless.Embed.Embed
                                                        SEDEL.Source.Syntax.SType)))
                              GHC.Types.Any)
                         -> f (GHC.Generics.M1
                                 GHC.Generics.D
                                 ('GHC.Generics.MetaData
                                    "(,)" "GHC.Tuple" "ghc-prim" 'GHC.Types.False)
                                 (GHC.Generics.M1
                                    GHC.Generics.C
                                    ('GHC.Generics.MetaCons
                                       "(,)" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                    (GHC.Generics.S1
                                       ('GHC.Generics.MetaSel
                                          'GHC.Base.Nothing
                                          'GHC.Generics.NoSourceUnpackedness
                                          'GHC.Generics.NoSourceStrictness
                                          'GHC.Generics.DecidedLazy)
                                       (GHC.Generics.Rec0
                                          (Unbound.Generics.LocallyNameless.Name.Name
                                             SEDEL.Source.Syntax.SType))
                                     GHC.Generics.:*: GHC.Generics.S1
                                                        ('GHC.Generics.MetaSel
                                                           'GHC.Base.Nothing
                                                           'GHC.Generics.NoSourceUnpackedness
                                                           'GHC.Generics.NoSourceStrictness
                                                           'GHC.Generics.DecidedLazy)
                                                        (GHC.Generics.Rec0
                                                           (Unbound.Generics.LocallyNameless.Embed.Embed
                                                              SEDEL.Source.Syntax.SType))))
                                 GHC.Types.Any)
                   = GHC.Base.fmap
                       @ f
                       (GHC.Base.$p1Applicative @ f $dApplicative)
                       @ (GHC.Generics.M1
                            GHC.Generics.C
                            ('GHC.Generics.MetaCons
                               "(,)" 'GHC.Generics.PrefixI 'GHC.Types.False)
                            (GHC.Generics.S1
                               ('GHC.Generics.MetaSel
                                  'GHC.Base.Nothing
                                  'GHC.Generics.NoSourceUnpackedness
                                  'GHC.Generics.NoSourceStrictness
                                  'GHC.Generics.DecidedLazy)
                               (GHC.Generics.Rec0
                                  (Unbound.Generics.LocallyNameless.Name.Name
                                     SEDEL.Source.Syntax.SType))
                             GHC.Generics.:*: GHC.Generics.S1
                                                ('GHC.Generics.MetaSel
                                                   'GHC.Base.Nothing
                                                   'GHC.Generics.NoSourceUnpackedness
                                                   'GHC.Generics.NoSourceStrictness
                                                   'GHC.Generics.DecidedLazy)
                                                (GHC.Generics.Rec0
                                                   (Unbound.Generics.LocallyNameless.Embed.Embed
                                                      SEDEL.Source.Syntax.SType)))
                            GHC.Types.Any)
                       @ (GHC.Generics.M1
                            GHC.Generics.D
                            ('GHC.Generics.MetaData
                               "(,)" "GHC.Tuple" "ghc-prim" 'GHC.Types.False)
                            (GHC.Generics.M1
                               GHC.Generics.C
                               ('GHC.Generics.MetaCons
                                  "(,)" 'GHC.Generics.PrefixI 'GHC.Types.False)
                               (GHC.Generics.S1
                                  ('GHC.Generics.MetaSel
                                     'GHC.Base.Nothing
                                     'GHC.Generics.NoSourceUnpackedness
                                     'GHC.Generics.NoSourceStrictness
                                     'GHC.Generics.DecidedLazy)
                                  (GHC.Generics.Rec0
                                     (Unbound.Generics.LocallyNameless.Name.Name
                                        SEDEL.Source.Syntax.SType))
                                GHC.Generics.:*: GHC.Generics.S1
                                                   ('GHC.Generics.MetaSel
                                                      'GHC.Base.Nothing
                                                      'GHC.Generics.NoSourceUnpackedness
                                                      'GHC.Generics.NoSourceStrictness
                                                      'GHC.Generics.DecidedLazy)
                                                   (GHC.Generics.Rec0
                                                      (Unbound.Generics.LocallyNameless.Embed.Embed
                                                         SEDEL.Source.Syntax.SType))))
                            GHC.Types.Any)
                       (\ (v :: GHC.Generics.M1
                                  GHC.Generics.C
                                  ('GHC.Generics.MetaCons
                                     "(,)" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                  (GHC.Generics.S1
                                     ('GHC.Generics.MetaSel
                                        'GHC.Base.Nothing
                                        'GHC.Generics.NoSourceUnpackedness
                                        'GHC.Generics.NoSourceStrictness
                                        'GHC.Generics.DecidedLazy)
                                     (GHC.Generics.Rec0
                                        (Unbound.Generics.LocallyNameless.Name.Name
                                           SEDEL.Source.Syntax.SType))
                                   GHC.Generics.:*: GHC.Generics.S1
                                                      ('GHC.Generics.MetaSel
                                                         'GHC.Base.Nothing
                                                         'GHC.Generics.NoSourceUnpackedness
                                                         'GHC.Generics.NoSourceStrictness
                                                         'GHC.Generics.DecidedLazy)
                                                      (GHC.Generics.Rec0
                                                         (Unbound.Generics.LocallyNameless.Embed.Embed
                                                            SEDEL.Source.Syntax.SType)))
                                  GHC.Types.Any) ->
                        v)
                         `cast`
                       (<GHC.Generics.M1
                           GHC.Generics.C
                           ('GHC.Generics.MetaCons
                              "(,)" 'GHC.Generics.PrefixI 'GHC.Types.False)
                           (GHC.Generics.S1
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.NoSourceStrictness
                                 'GHC.Generics.DecidedLazy)
                              (GHC.Generics.Rec0
                                 (Unbound.Generics.LocallyNameless.Name.Name
                                    SEDEL.Source.Syntax.SType))
                            GHC.Generics.:*: GHC.Generics.S1
                                               ('GHC.Generics.MetaSel
                                                  'GHC.Base.Nothing
                                                  'GHC.Generics.NoSourceUnpackedness
                                                  'GHC.Generics.NoSourceStrictness
                                                  'GHC.Generics.DecidedLazy)
                                               (GHC.Generics.Rec0
                                                  (Unbound.Generics.LocallyNameless.Embed.Embed
                                                     SEDEL.Source.Syntax.SType)))
                           GHC.Types.Any>_R
                        ->_R Sym (GHC.Generics.N:M1[0]
                                      <*>_N
                                      <GHC.Generics.D>_P
                                      <'GHC.Generics.MetaData
                                         "(,)" "GHC.Tuple" "ghc-prim" 'GHC.Types.False>_P
                                      <GHC.Generics.M1
                                         GHC.Generics.C
                                         ('GHC.Generics.MetaCons
                                            "(,)" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                         (GHC.Generics.S1
                                            ('GHC.Generics.MetaSel
                                               'GHC.Base.Nothing
                                               'GHC.Generics.NoSourceUnpackedness
                                               'GHC.Generics.NoSourceStrictness
                                               'GHC.Generics.DecidedLazy)
                                            (GHC.Generics.Rec0
                                               (Unbound.Generics.LocallyNameless.Name.Name
                                                  SEDEL.Source.Syntax.SType))
                                          GHC.Generics.:*: GHC.Generics.S1
                                                             ('GHC.Generics.MetaSel
                                                                'GHC.Base.Nothing
                                                                'GHC.Generics.NoSourceUnpackedness
                                                                'GHC.Generics.NoSourceStrictness
                                                                'GHC.Generics.DecidedLazy)
                                                             (GHC.Generics.Rec0
                                                                (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                   SEDEL.Source.Syntax.SType)))>_R) <GHC.Types.Any>_N)
                 } in
                 let {
                   f3 :: f ((GHC.Generics.:*:)
                              (GHC.Generics.S1
                                 ('GHC.Generics.MetaSel
                                    'GHC.Base.Nothing
                                    'GHC.Generics.NoSourceUnpackedness
                                    'GHC.Generics.NoSourceStrictness
                                    'GHC.Generics.DecidedLazy)
                                 (GHC.Generics.Rec0
                                    (Unbound.Generics.LocallyNameless.Name.Name
                                       SEDEL.Source.Syntax.SType)))
                              (GHC.Generics.S1
                                 ('GHC.Generics.MetaSel
                                    'GHC.Base.Nothing
                                    'GHC.Generics.NoSourceUnpackedness
                                    'GHC.Generics.NoSourceStrictness
                                    'GHC.Generics.DecidedLazy)
                                 (GHC.Generics.Rec0
                                    (Unbound.Generics.LocallyNameless.Embed.Embed
                                       SEDEL.Source.Syntax.SType)))
                              GHC.Types.Any)
                         -> f (GHC.Generics.M1
                                 GHC.Generics.C
                                 ('GHC.Generics.MetaCons
                                    "(,)" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                 (GHC.Generics.S1
                                    ('GHC.Generics.MetaSel
                                       'GHC.Base.Nothing
                                       'GHC.Generics.NoSourceUnpackedness
                                       'GHC.Generics.NoSourceStrictness
                                       'GHC.Generics.DecidedLazy)
                                    (GHC.Generics.Rec0
                                       (Unbound.Generics.LocallyNameless.Name.Name
                                          SEDEL.Source.Syntax.SType))
                                  GHC.Generics.:*: GHC.Generics.S1
                                                     ('GHC.Generics.MetaSel
                                                        'GHC.Base.Nothing
                                                        'GHC.Generics.NoSourceUnpackedness
                                                        'GHC.Generics.NoSourceStrictness
                                                        'GHC.Generics.DecidedLazy)
                                                     (GHC.Generics.Rec0
                                                        (Unbound.Generics.LocallyNameless.Embed.Embed
                                                           SEDEL.Source.Syntax.SType)))
                                 GHC.Types.Any)
                   = GHC.Base.fmap
                       @ f
                       (GHC.Base.$p1Applicative @ f $dApplicative)
                       @ ((GHC.Generics.:*:)
                            (GHC.Generics.S1
                               ('GHC.Generics.MetaSel
                                  'GHC.Base.Nothing
                                  'GHC.Generics.NoSourceUnpackedness
                                  'GHC.Generics.NoSourceStrictness
                                  'GHC.Generics.DecidedLazy)
                               (GHC.Generics.Rec0
                                  (Unbound.Generics.LocallyNameless.Name.Name
                                     SEDEL.Source.Syntax.SType)))
                            (GHC.Generics.S1
                               ('GHC.Generics.MetaSel
                                  'GHC.Base.Nothing
                                  'GHC.Generics.NoSourceUnpackedness
                                  'GHC.Generics.NoSourceStrictness
                                  'GHC.Generics.DecidedLazy)
                               (GHC.Generics.Rec0
                                  (Unbound.Generics.LocallyNameless.Embed.Embed
                                     SEDEL.Source.Syntax.SType)))
                            GHC.Types.Any)
                       @ (GHC.Generics.M1
                            GHC.Generics.C
                            ('GHC.Generics.MetaCons
                               "(,)" 'GHC.Generics.PrefixI 'GHC.Types.False)
                            (GHC.Generics.S1
                               ('GHC.Generics.MetaSel
                                  'GHC.Base.Nothing
                                  'GHC.Generics.NoSourceUnpackedness
                                  'GHC.Generics.NoSourceStrictness
                                  'GHC.Generics.DecidedLazy)
                               (GHC.Generics.Rec0
                                  (Unbound.Generics.LocallyNameless.Name.Name
                                     SEDEL.Source.Syntax.SType))
                             GHC.Generics.:*: GHC.Generics.S1
                                                ('GHC.Generics.MetaSel
                                                   'GHC.Base.Nothing
                                                   'GHC.Generics.NoSourceUnpackedness
                                                   'GHC.Generics.NoSourceStrictness
                                                   'GHC.Generics.DecidedLazy)
                                                (GHC.Generics.Rec0
                                                   (Unbound.Generics.LocallyNameless.Embed.Embed
                                                      SEDEL.Source.Syntax.SType)))
                            GHC.Types.Any)
                       (\ (v :: (GHC.Generics.:*:)
                                  (GHC.Generics.S1
                                     ('GHC.Generics.MetaSel
                                        'GHC.Base.Nothing
                                        'GHC.Generics.NoSourceUnpackedness
                                        'GHC.Generics.NoSourceStrictness
                                        'GHC.Generics.DecidedLazy)
                                     (GHC.Generics.Rec0
                                        (Unbound.Generics.LocallyNameless.Name.Name
                                           SEDEL.Source.Syntax.SType)))
                                  (GHC.Generics.S1
                                     ('GHC.Generics.MetaSel
                                        'GHC.Base.Nothing
                                        'GHC.Generics.NoSourceUnpackedness
                                        'GHC.Generics.NoSourceStrictness
                                        'GHC.Generics.DecidedLazy)
                                     (GHC.Generics.Rec0
                                        (Unbound.Generics.LocallyNameless.Embed.Embed
                                           SEDEL.Source.Syntax.SType)))
                                  GHC.Types.Any) ->
                        v)
                         `cast`
                       (<(GHC.Generics.:*:)
                           (GHC.Generics.S1
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.NoSourceStrictness
                                 'GHC.Generics.DecidedLazy)
                              (GHC.Generics.Rec0
                                 (Unbound.Generics.LocallyNameless.Name.Name
                                    SEDEL.Source.Syntax.SType)))
                           (GHC.Generics.S1
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.NoSourceStrictness
                                 'GHC.Generics.DecidedLazy)
                              (GHC.Generics.Rec0
                                 (Unbound.Generics.LocallyNameless.Embed.Embed
                                    SEDEL.Source.Syntax.SType)))
                           GHC.Types.Any>_R
                        ->_R Sym (GHC.Generics.N:M1[0]
                                      <*>_N
                                      <GHC.Generics.C>_P
                                      <'GHC.Generics.MetaCons
                                         "(,)" 'GHC.Generics.PrefixI 'GHC.Types.False>_P
                                      <GHC.Generics.S1
                                         ('GHC.Generics.MetaSel
                                            'GHC.Base.Nothing
                                            'GHC.Generics.NoSourceUnpackedness
                                            'GHC.Generics.NoSourceStrictness
                                            'GHC.Generics.DecidedLazy)
                                         (GHC.Generics.Rec0
                                            (Unbound.Generics.LocallyNameless.Name.Name
                                               SEDEL.Source.Syntax.SType))
                                       GHC.Generics.:*: GHC.Generics.S1
                                                          ('GHC.Generics.MetaSel
                                                             'GHC.Base.Nothing
                                                             'GHC.Generics.NoSourceUnpackedness
                                                             'GHC.Generics.NoSourceStrictness
                                                             'GHC.Generics.DecidedLazy)
                                                          (GHC.Generics.Rec0
                                                             (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                SEDEL.Source.Syntax.SType))>_R) <GHC.Types.Any>_N)
                 } in
                 let {
                   $dFunctor1 :: GHC.Base.Functor f
                   = GHC.Base.$p1Applicative @ f $dApplicative
                 } in
                 \ (x :: (Unbound.Generics.LocallyNameless.Name.Name
                            SEDEL.Source.Syntax.SType,
                          Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType)) ->
                 f1
                   (f2
                      (f3
                         (case x of wild { (,) g1 g2 ->
                          GHC.Base.<*>
                            @ f
                            $dApplicative
                            @ (GHC.Generics.M1
                                 GHC.Generics.S
                                 ('GHC.Generics.MetaSel
                                    'GHC.Base.Nothing
                                    'GHC.Generics.NoSourceUnpackedness
                                    'GHC.Generics.NoSourceStrictness
                                    'GHC.Generics.DecidedLazy)
                                 (GHC.Generics.Rec0
                                    (Unbound.Generics.LocallyNameless.Embed.Embed
                                       SEDEL.Source.Syntax.SType))
                                 GHC.Types.Any)
                            @ ((GHC.Generics.:*:)
                                 (GHC.Generics.M1
                                    GHC.Generics.S
                                    ('GHC.Generics.MetaSel
                                       'GHC.Base.Nothing
                                       'GHC.Generics.NoSourceUnpackedness
                                       'GHC.Generics.NoSourceStrictness
                                       'GHC.Generics.DecidedLazy)
                                    (GHC.Generics.Rec0
                                       (Unbound.Generics.LocallyNameless.Name.Name
                                          SEDEL.Source.Syntax.SType)))
                                 (GHC.Generics.M1
                                    GHC.Generics.S
                                    ('GHC.Generics.MetaSel
                                       'GHC.Base.Nothing
                                       'GHC.Generics.NoSourceUnpackedness
                                       'GHC.Generics.NoSourceStrictness
                                       'GHC.Generics.DecidedLazy)
                                    (GHC.Generics.Rec0
                                       (Unbound.Generics.LocallyNameless.Embed.Embed
                                          SEDEL.Source.Syntax.SType)))
                                 GHC.Types.Any)
                            (GHC.Base.fmap
                               @ f
                               $dFunctor1
                               @ (GHC.Generics.M1
                                    GHC.Generics.S
                                    ('GHC.Generics.MetaSel
                                       'GHC.Base.Nothing
                                       'GHC.Generics.NoSourceUnpackedness
                                       'GHC.Generics.NoSourceStrictness
                                       'GHC.Generics.DecidedLazy)
                                    (GHC.Generics.Rec0
                                       (Unbound.Generics.LocallyNameless.Name.Name
                                          SEDEL.Source.Syntax.SType))
                                    GHC.Types.Any)
                               @ (GHC.Generics.M1
                                    GHC.Generics.S
                                    ('GHC.Generics.MetaSel
                                       'GHC.Base.Nothing
                                       'GHC.Generics.NoSourceUnpackedness
                                       'GHC.Generics.NoSourceStrictness
                                       'GHC.Generics.DecidedLazy)
                                    (GHC.Generics.Rec0
                                       (Unbound.Generics.LocallyNameless.Embed.Embed
                                          SEDEL.Source.Syntax.SType))
                                    GHC.Types.Any
                                  -> (GHC.Generics.:*:)
                                       (GHC.Generics.M1
                                          GHC.Generics.S
                                          ('GHC.Generics.MetaSel
                                             'GHC.Base.Nothing
                                             'GHC.Generics.NoSourceUnpackedness
                                             'GHC.Generics.NoSourceStrictness
                                             'GHC.Generics.DecidedLazy)
                                          (GHC.Generics.Rec0
                                             (Unbound.Generics.LocallyNameless.Name.Name
                                                SEDEL.Source.Syntax.SType)))
                                       (GHC.Generics.M1
                                          GHC.Generics.S
                                          ('GHC.Generics.MetaSel
                                             'GHC.Base.Nothing
                                             'GHC.Generics.NoSourceUnpackedness
                                             'GHC.Generics.NoSourceStrictness
                                             'GHC.Generics.DecidedLazy)
                                          (GHC.Generics.Rec0
                                             (Unbound.Generics.LocallyNameless.Embed.Embed
                                                SEDEL.Source.Syntax.SType)))
                                       GHC.Types.Any)
                               (GHC.Generics.:*:
                                  @ *
                                  @ (GHC.Generics.M1
                                       GHC.Generics.S
                                       ('GHC.Generics.MetaSel
                                          'GHC.Base.Nothing
                                          'GHC.Generics.NoSourceUnpackedness
                                          'GHC.Generics.NoSourceStrictness
                                          'GHC.Generics.DecidedLazy)
                                       (GHC.Generics.Rec0
                                          (Unbound.Generics.LocallyNameless.Name.Name
                                             SEDEL.Source.Syntax.SType)))
                                  @ (GHC.Generics.M1
                                       GHC.Generics.S
                                       ('GHC.Generics.MetaSel
                                          'GHC.Base.Nothing
                                          'GHC.Generics.NoSourceUnpackedness
                                          'GHC.Generics.NoSourceStrictness
                                          'GHC.Generics.DecidedLazy)
                                       (GHC.Generics.Rec0
                                          (Unbound.Generics.LocallyNameless.Embed.Embed
                                             SEDEL.Source.Syntax.SType)))
                                  @ GHC.Types.Any)
                               (GHC.Base.fmap
                                  @ f
                                  (GHC.Base.$p1Applicative @ f $dApplicative)
                                  @ (GHC.Generics.K1
                                       GHC.Generics.R
                                       (Unbound.Generics.LocallyNameless.Name.Name
                                          SEDEL.Source.Syntax.SType)
                                       GHC.Types.Any)
                                  @ (GHC.Generics.M1
                                       GHC.Generics.S
                                       ('GHC.Generics.MetaSel
                                          'GHC.Base.Nothing
                                          'GHC.Generics.NoSourceUnpackedness
                                          'GHC.Generics.NoSourceStrictness
                                          'GHC.Generics.DecidedLazy)
                                       (GHC.Generics.K1
                                          GHC.Generics.R
                                          (Unbound.Generics.LocallyNameless.Name.Name
                                             SEDEL.Source.Syntax.SType))
                                       GHC.Types.Any)
                                  (\ (v :: GHC.Generics.K1
                                             GHC.Generics.R
                                             (Unbound.Generics.LocallyNameless.Name.Name
                                                SEDEL.Source.Syntax.SType)
                                             GHC.Types.Any) ->
                                   v)
                                    `cast`
                                  (<GHC.Generics.K1
                                      GHC.Generics.R
                                      (Unbound.Generics.LocallyNameless.Name.Name
                                         SEDEL.Source.Syntax.SType)
                                      GHC.Types.Any>_R
                                   ->_R Sym (GHC.Generics.N:M1[0]
                                                 <*>_N
                                                 <GHC.Generics.S>_P
                                                 <'GHC.Generics.MetaSel
                                                    'GHC.Base.Nothing
                                                    'GHC.Generics.NoSourceUnpackedness
                                                    'GHC.Generics.NoSourceStrictness
                                                    'GHC.Generics.DecidedLazy>_P
                                                 <GHC.Generics.K1
                                                    GHC.Generics.R
                                                    (Unbound.Generics.LocallyNameless.Name.Name
                                                       SEDEL.Source.Syntax.SType)>_R) <GHC.Types.Any>_N)
                                  (GHC.Base.fmap
                                     @ f
                                     (GHC.Base.$p1Applicative @ f $dApplicative)
                                     @ (Unbound.Generics.LocallyNameless.Name.Name
                                          SEDEL.Source.Syntax.SType)
                                     @ (GHC.Generics.K1
                                          GHC.Generics.R
                                          (Unbound.Generics.LocallyNameless.Name.Name
                                             SEDEL.Source.Syntax.SType)
                                          GHC.Types.Any)
                                     (\ (v :: Unbound.Generics.LocallyNameless.Name.Name
                                                SEDEL.Source.Syntax.SType) ->
                                      v)
                                       `cast`
                                     (<Unbound.Generics.LocallyNameless.Name.Name
                                         SEDEL.Source.Syntax.SType>_R
                                      ->_R Sym (GHC.Generics.N:K1[0]
                                                    <*>_N
                                                    <GHC.Generics.R>_P
                                                    <Unbound.Generics.LocallyNameless.Name.Name
                                                       SEDEL.Source.Syntax.SType>_R
                                                    <GHC.Types.Any>_P))
                                     (Unbound.Generics.LocallyNameless.Alpha.$fAlphaName_$cfvAny'
                                        @ SEDEL.Source.Syntax.SType
                                        SEDEL.Source.Syntax.$fAlphaSType16
                                          `cast`
                                        (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <SEDEL.Source.Syntax.SType>_N)
                                        @ f
                                        $dContravariant
                                        $dApplicative
                                        c
                                        nfn
                                        g1))))
                            (GHC.Base.fmap
                               @ f
                               (GHC.Base.$p1Applicative @ f $dApplicative)
                               @ (GHC.Generics.K1
                                    GHC.Generics.R
                                    (Unbound.Generics.LocallyNameless.Embed.Embed
                                       SEDEL.Source.Syntax.SType)
                                    GHC.Types.Any)
                               @ (GHC.Generics.M1
                                    GHC.Generics.S
                                    ('GHC.Generics.MetaSel
                                       'GHC.Base.Nothing
                                       'GHC.Generics.NoSourceUnpackedness
                                       'GHC.Generics.NoSourceStrictness
                                       'GHC.Generics.DecidedLazy)
                                    (GHC.Generics.K1
                                       GHC.Generics.R
                                       (Unbound.Generics.LocallyNameless.Embed.Embed
                                          SEDEL.Source.Syntax.SType))
                                    GHC.Types.Any)
                               (\ (v :: GHC.Generics.K1
                                          GHC.Generics.R
                                          (Unbound.Generics.LocallyNameless.Embed.Embed
                                             SEDEL.Source.Syntax.SType)
                                          GHC.Types.Any) ->
                                v)
                                 `cast`
                               (<GHC.Generics.K1
                                   GHC.Generics.R
                                   (Unbound.Generics.LocallyNameless.Embed.Embed
                                      SEDEL.Source.Syntax.SType)
                                   GHC.Types.Any>_R
                                ->_R Sym (GHC.Generics.N:M1[0]
                                              <*>_N
                                              <GHC.Generics.S>_P
                                              <'GHC.Generics.MetaSel
                                                 'GHC.Base.Nothing
                                                 'GHC.Generics.NoSourceUnpackedness
                                                 'GHC.Generics.NoSourceStrictness
                                                 'GHC.Generics.DecidedLazy>_P
                                              <GHC.Generics.K1
                                                 GHC.Generics.R
                                                 (Unbound.Generics.LocallyNameless.Embed.Embed
                                                    SEDEL.Source.Syntax.SType)>_R) <GHC.Types.Any>_N)
                               (GHC.Base.fmap
                                  @ f
                                  (GHC.Base.$p1Applicative @ f $dApplicative)
                                  @ (Unbound.Generics.LocallyNameless.Embed.Embed
                                       SEDEL.Source.Syntax.SType)
                                  @ (GHC.Generics.K1
                                       GHC.Generics.R
                                       (Unbound.Generics.LocallyNameless.Embed.Embed
                                          SEDEL.Source.Syntax.SType)
                                       GHC.Types.Any)
                                  (\ (v :: Unbound.Generics.LocallyNameless.Embed.Embed
                                             SEDEL.Source.Syntax.SType) ->
                                   v)
                                    `cast`
                                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                                      SEDEL.Source.Syntax.SType>_R
                                   ->_R Sym (GHC.Generics.N:K1[0]
                                                 <*>_N
                                                 <GHC.Generics.R>_P
                                                 <Unbound.Generics.LocallyNameless.Embed.Embed
                                                    SEDEL.Source.Syntax.SType>_R
                                                 <GHC.Types.Any>_P))
                                  (Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cfvAny'
                                     @ SEDEL.Source.Syntax.SType
                                     SEDEL.Source.Syntax.$fAlphaSType
                                     @ f
                                     $dContravariant
                                     $dApplicative
                                     c
                                     nfn
                                     g2))) })))
                     `cast`
                   (<f>_R (Sym (GHC.Generics.Rep_(,)[0]
                                    <Unbound.Generics.LocallyNameless.Name.Name
                                       SEDEL.Source.Syntax.SType>_N
                                    <Unbound.Generics.LocallyNameless.Embed.Embed
                                       SEDEL.Source.Syntax.SType>_N) <GHC.Types.Any>_N))) -}
bb4acf129ab1c7e28a80890a9def0793
  $s$fAlpha(,)_$s$fAlpha(,)_$cisEmbed3 ::
    (Unbound.Generics.LocallyNameless.Name.Name
       SEDEL.Source.Syntax.SType,
     Unbound.Generics.LocallyNameless.Embed.Embed
       SEDEL.Source.Syntax.SType)
    -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (ds :: (Unbound.Generics.LocallyNameless.Name.Name
                             SEDEL.Source.Syntax.SType,
                           Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Source.Syntax.SType)) ->
                 GHC.Types.False) -}
c7019b311c733177264ef93d8bde3254
  $s$fAlpha(,)_$s$fAlpha(,)_$clfreshen'3 ::
    Unbound.Generics.LocallyNameless.LFresh.LFresh m =>
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> (Unbound.Generics.LocallyNameless.Name.Name
          SEDEL.Source.Syntax.SType,
        Unbound.Generics.LocallyNameless.Embed.Embed
          SEDEL.Source.Syntax.SType)
    -> ((Unbound.Generics.LocallyNameless.Name.Name
           SEDEL.Source.Syntax.SType,
         Unbound.Generics.LocallyNameless.Embed.Embed
           SEDEL.Source.Syntax.SType)
        -> Unbound.Generics.PermM.Perm
             Unbound.Generics.LocallyNameless.Name.AnyName
        -> m b1)
    -> m b1
  {- Arity: 4,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(U(A,C(C1(U)),A,A,A),C(C1(U)),C(C1(U)),A)><S(SL),1*U(U,A)><S,1*U(U,U)><L,C(C1(U))>,
     Inline: (sat-args=3),
     Unfolding: InlineRule (3, False, False)
                (\ @ m :: * -> *
                   @ b1
                   ($dLFresh :: Unbound.Generics.LocallyNameless.LFresh.LFresh m)
                   (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (m1 :: (Unbound.Generics.LocallyNameless.Name.Name
                             SEDEL.Source.Syntax.SType,
                           Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Source.Syntax.SType))
                   (cont :: (Unbound.Generics.LocallyNameless.Name.Name
                               SEDEL.Source.Syntax.SType,
                             Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Source.Syntax.SType)
                            -> Unbound.Generics.PermM.Perm
                                 Unbound.Generics.LocallyNameless.Name.AnyName
                            -> m b1) ->
                 case m1 of wild { (,) g1 g2 ->
                 case ctx of wild1 { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                 case ds1 of wild2 {
                   Unbound.Generics.LocallyNameless.Alpha.Term
                   -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed3 @ m @ b1
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> Unbound.Generics.LocallyNameless.Alpha.$fAlphaName_$clfreshen'
                        @ SEDEL.Source.Syntax.SType
                        SEDEL.Source.Syntax.$fAlphaSType16
                          `cast`
                        (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <SEDEL.Source.Syntax.SType>_N)
                        @ m
                        @ b1
                        $dLFresh
                        wild1
                        (Unbound.Generics.LocallyNameless.Alpha.$fAlphaName_$cswaps'
                           @ SEDEL.Source.Syntax.SType
                           SEDEL.Source.Syntax.$fAlphaSType16
                             `cast`
                           (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <SEDEL.Source.Syntax.SType>_N)
                           wild1
                           (Data.Map.Internal.Tip
                              @ Unbound.Generics.LocallyNameless.Name.AnyName
                              @ Unbound.Generics.LocallyNameless.Name.AnyName)
                             `cast`
                           (Sym (Unbound.Generics.PermM.N:Perm[0]
                                     <Unbound.Generics.LocallyNameless.Name.AnyName>_N))
                           g1)
                        (\ (x1 :: Unbound.Generics.LocallyNameless.Name.Name
                                    SEDEL.Source.Syntax.SType)
                           (perm1 :: Unbound.Generics.PermM.Perm
                                       Unbound.Generics.LocallyNameless.Name.AnyName)[OneShot] ->
                         cont
                           (x1, g2)
                           (Unbound.Generics.PermM.$fMonoidPerm1
                              @ Unbound.Generics.LocallyNameless.Name.AnyName
                              Unbound.Generics.LocallyNameless.Name.$fOrdAnyName
                              perm1
                              (Data.Map.Internal.Tip
                                 @ Unbound.Generics.LocallyNameless.Name.AnyName
                                 @ Unbound.Generics.LocallyNameless.Name.AnyName)
                                `cast`
                              (Sym (Unbound.Generics.PermM.N:Perm[0]
                                        <Unbound.Generics.LocallyNameless.Name.AnyName>_N)))
                             `cast`
                           (Sym (Unbound.Generics.PermM.N:Perm[0]
                                     <Unbound.Generics.LocallyNameless.Name.AnyName>_N))) } } }) -}
892dbfe9e766ed7c1670564d450a24cf
  $s$fAlpha(,)_$s$fAlpha(,)_$copen3 ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Alpha.NthPatFind
    -> (Unbound.Generics.LocallyNameless.Name.Name
          SEDEL.Source.Syntax.SType,
        Unbound.Generics.LocallyNameless.Embed.Embed
          SEDEL.Source.Syntax.SType)
    -> (Unbound.Generics.LocallyNameless.Name.Name
          SEDEL.Source.Syntax.SType,
        Unbound.Generics.LocallyNameless.Embed.Embed
          SEDEL.Source.Syntax.SType)
  {- Arity: 3, Strictness: <L,U(U,U)><L,U><S,1*U(1*U,1*U)>m,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (c :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (b1 :: Unbound.Generics.LocallyNameless.Alpha.NthPatFind)
                   (x :: (Unbound.Generics.LocallyNameless.Name.Name
                            SEDEL.Source.Syntax.SType,
                          Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType)) ->
                 case x of wild { (,) g1 g2 ->
                 (Unbound.Generics.LocallyNameless.Alpha.$fAlphaAnyName_$copen1
                    @ SEDEL.Source.Syntax.SType
                    SEDEL.Source.Syntax.$fAlphaSType16
                      `cast`
                    (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <SEDEL.Source.Syntax.SType>_N)
                    c
                    b1
                    g1,
                  case c of wild1 { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                  case ds1 of wild2 {
                    Unbound.Generics.LocallyNameless.Alpha.Term
                    -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed5
                         @ SEDEL.Source.Syntax.SType
                    Unbound.Generics.LocallyNameless.Alpha.Pat
                    -> (SEDEL.Source.Syntax.$fAlphaSType_$copen
                          (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                             Unbound.Generics.LocallyNameless.Alpha.Term
                             ds2)
                          b1
                          g2
                            `cast`
                          (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                               <SEDEL.Source.Syntax.SType>_R))
                         `cast`
                       (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                 <SEDEL.Source.Syntax.SType>_R)) } }) }) -}
1c47ce4b14743c161ac7ef726dfa1895
  $s$fAlpha(,)_$s$fAlpha(,)_$cswaps'3 ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.PermM.Perm
         Unbound.Generics.LocallyNameless.Name.AnyName
    -> (Unbound.Generics.LocallyNameless.Name.Name
          SEDEL.Source.Syntax.SType,
        Unbound.Generics.LocallyNameless.Embed.Embed
          SEDEL.Source.Syntax.SType)
    -> (Unbound.Generics.LocallyNameless.Name.Name
          SEDEL.Source.Syntax.SType,
        Unbound.Generics.LocallyNameless.Embed.Embed
          SEDEL.Source.Syntax.SType)
  {- Arity: 3, Strictness: <L,U(U,U)><L,U><S,1*U(U,1*U)>m,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (perm :: Unbound.Generics.PermM.Perm
                              Unbound.Generics.LocallyNameless.Name.AnyName)
                   (x :: (Unbound.Generics.LocallyNameless.Name.Name
                            SEDEL.Source.Syntax.SType,
                          Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType)) ->
                 case x of wild { (,) g1 g2 ->
                 (Unbound.Generics.LocallyNameless.Alpha.$fAlphaName_$cswaps'
                    @ SEDEL.Source.Syntax.SType
                    SEDEL.Source.Syntax.$fAlphaSType16
                      `cast`
                    (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <SEDEL.Source.Syntax.SType>_N)
                    ctx
                    perm
                    g1,
                  case ctx of wild1 { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                  case ds1 of wild2 {
                    Unbound.Generics.LocallyNameless.Alpha.Term -> g2
                    Unbound.Generics.LocallyNameless.Alpha.Pat
                    -> (SEDEL.Source.Syntax.$fAlphaSType_$cswaps'
                          (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                             Unbound.Generics.LocallyNameless.Alpha.Term
                             ds2)
                          perm
                          g2
                            `cast`
                          (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                               <SEDEL.Source.Syntax.SType>_R))
                         `cast`
                       (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                 <SEDEL.Source.Syntax.SType>_R)) } }) }) -}
6e3e7487f69f5a3ea141ea94fa000bd9
  $s$fAlpha(,)_$s$fAlphaEmbed ::
    Unbound.Generics.LocallyNameless.Alpha.Alpha
      (Unbound.Generics.LocallyNameless.Embed.Embed
         (GHC.Base.Maybe SEDEL.Source.Syntax.SType))
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Embed.Embed
                       (GHC.Base.Maybe SEDEL.Source.Syntax.SType))
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fShowEmbed
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              (GHC.Base.Maybe SEDEL.Source.Syntax.SType))
                     (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                               (GHC.Base.Maybe SEDEL.Source.Syntax.SType)) ->
                   case ds
                          `cast`
                        (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                             <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R) of wild {
                     GHC.Base.Nothing
                     -> case ds1
                               `cast`
                             (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R) of wild1 {
                          GHC.Base.Nothing -> GHC.Types.True
                          GHC.Base.Just g1 -> GHC.Types.False }
                     GHC.Base.Just g1
                     -> case ds1
                               `cast`
                             (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R) of wild1 {
                          GHC.Base.Nothing -> GHC.Types.False
                          GHC.Base.Just g2
                          -> SEDEL.Source.Syntax.$fAlphaSType_$caeq'
                               (case ctx of wild2 { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                                Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                                  Unbound.Generics.LocallyNameless.Alpha.Term
                                  ds3 })
                               g1
                               g2 } })
                  (Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cfvAny'
                     @ (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
                     SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlphaMaybe)
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (b :: Unbound.Generics.LocallyNameless.Alpha.NamePatFind)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              (GHC.Base.Maybe SEDEL.Source.Syntax.SType)) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed6
                          @ (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> case ds
                               `cast`
                             (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R) of wild2 {
                          GHC.Base.Nothing
                          -> (GHC.Base.Nothing @ SEDEL.Source.Syntax.SType)
                               `cast`
                             (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                       <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R))
                          GHC.Base.Just g1
                          -> (GHC.Base.Just
                                @ SEDEL.Source.Syntax.SType
                                (SEDEL.Source.Syntax.$fAlphaSType_$cclose
                                   (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                                      Unbound.Generics.LocallyNameless.Alpha.Term
                                      ds2)
                                   b
                                   g1))
                               `cast`
                             (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                       <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R)) } } })
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (b :: Unbound.Generics.LocallyNameless.Alpha.NthPatFind)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              (GHC.Base.Maybe SEDEL.Source.Syntax.SType)) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed5
                          @ (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> case ds
                               `cast`
                             (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R) of wild2 {
                          GHC.Base.Nothing
                          -> (GHC.Base.Nothing @ SEDEL.Source.Syntax.SType)
                               `cast`
                             (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                       <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R))
                          GHC.Base.Just g1
                          -> (GHC.Base.Just
                                @ SEDEL.Source.Syntax.SType
                                (SEDEL.Source.Syntax.$fAlphaSType_$copen
                                   (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                                      Unbound.Generics.LocallyNameless.Alpha.Term
                                      ds2)
                                   b
                                   g1))
                               `cast`
                             (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                       <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R)) } } })
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              (GHC.Base.Maybe SEDEL.Source.Syntax.SType)) ->
                   case ds
                          `cast`
                        (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                             <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R) of wild {
                     GHC.Base.Nothing
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed4
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                  <Unbound.Generics.LocallyNameless.Name.AnyName>_R))
                     GHC.Base.Just g1
                     -> case (SEDEL.Source.Syntax.$fAlphaSType_$cisTerm g1)
                               `cast`
                             (Data.Semigroup.Internal.N:All[0]) of wild1 {
                          GHC.Types.False
                          -> (GHC.Base.Nothing
                                @ [Unbound.Generics.LocallyNameless.Name.AnyName])
                               `cast`
                             (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                       <Unbound.Generics.LocallyNameless.Name.AnyName>_R))
                          GHC.Types.True
                          -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed4
                               `cast`
                             (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                       <Unbound.Generics.LocallyNameless.Name.AnyName>_R)) } })
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              (GHC.Base.Maybe SEDEL.Source.Syntax.SType)) ->
                   GHC.Types.False)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      (GHC.Base.Maybe SEDEL.Source.Syntax.SType)>_R
                   ->_R Sym (Data.Semigroup.Internal.N:All[0]))
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              (GHC.Base.Maybe SEDEL.Source.Syntax.SType)) ->
                   case ds
                          `cast`
                        (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                             <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R) of wild {
                     GHC.Base.Nothing
                     -> GHC.Types.True `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                     GHC.Base.Just g1 -> SEDEL.Source.Syntax.$fAlphaSType_$cisTerm g1 })
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      (GHC.Base.Maybe SEDEL.Source.Syntax.SType)>_R
                   ->_R Data.Semigroup.Internal.N:All[0])
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              (GHC.Base.Maybe SEDEL.Source.Syntax.SType)) ->
                   Data.Either.Left
                     @ GHC.Integer.Type.Integer
                     @ Unbound.Generics.LocallyNameless.Name.AnyName)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      (GHC.Base.Maybe SEDEL.Source.Syntax.SType)>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Alpha.N:NthPatFind[0]))
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              (GHC.Base.Maybe SEDEL.Source.Syntax.SType)) ->
                   Unbound.Generics.LocallyNameless.Alpha.$fAlpha()2)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      (GHC.Base.Maybe SEDEL.Source.Syntax.SType)>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Alpha.N:NamePatFind[0]))
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (perm :: Unbound.Generics.PermM.Perm
                                Unbound.Generics.LocallyNameless.Name.AnyName)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              (GHC.Base.Maybe SEDEL.Source.Syntax.SType)) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term -> ds
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> case ds
                               `cast`
                             (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R) of wild2 {
                          GHC.Base.Nothing
                          -> (GHC.Base.Nothing @ SEDEL.Source.Syntax.SType)
                               `cast`
                             (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                       <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R))
                          GHC.Base.Just g1
                          -> (GHC.Base.Just
                                @ SEDEL.Source.Syntax.SType
                                (SEDEL.Source.Syntax.$fAlphaSType_$cswaps'
                                   (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                                      Unbound.Generics.LocallyNameless.Alpha.Term
                                      ds2)
                                   perm
                                   g1))
                               `cast`
                             (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                       <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R)) } } })
                  (\ @ m :: * -> *
                     @ b
                     ($dLFresh :: Unbound.Generics.LocallyNameless.LFresh.LFresh m) ->
                   Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed2
                     @ (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
                     @ m
                     @ b)
                  (\ @ m :: * -> *
                     ($dFresh :: Unbound.Generics.LocallyNameless.Fresh.Fresh m)
                     (eta2 :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (eta3 :: Unbound.Generics.LocallyNameless.Embed.Embed
                                (GHC.Base.Maybe SEDEL.Source.Syntax.SType)) ->
                   case eta2 of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed1
                          @ m
                          @ (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> GHC.Base.return
                          @ m
                          (Unbound.Generics.LocallyNameless.Fresh.$p1Fresh @ m $dFresh)
                          @ (Unbound.Generics.LocallyNameless.Embed.Embed
                               (GHC.Base.Maybe SEDEL.Source.Syntax.SType),
                             Unbound.Generics.PermM.Perm
                               Unbound.Generics.LocallyNameless.Name.AnyName)
                          (eta3,
                           (Data.Map.Internal.Tip
                              @ Unbound.Generics.LocallyNameless.Name.AnyName
                              @ Unbound.Generics.LocallyNameless.Name.AnyName)
                             `cast`
                           (Sym (Unbound.Generics.PermM.N:Perm[0]
                                     <Unbound.Generics.LocallyNameless.Name.AnyName>_N))) } })
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              (GHC.Base.Maybe SEDEL.Source.Syntax.SType))
                     (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                               (GHC.Base.Maybe SEDEL.Source.Syntax.SType)) ->
                   case ds
                          `cast`
                        (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                             <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R) of wild {
                     GHC.Base.Nothing
                     -> case ds1
                               `cast`
                             (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R) of wild1 {
                          GHC.Base.Nothing -> GHC.Types.EQ GHC.Base.Just g1 -> GHC.Types.LT }
                     GHC.Base.Just g1
                     -> case ds1
                               `cast`
                             (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R) of wild1 {
                          GHC.Base.Nothing -> GHC.Types.GT
                          GHC.Base.Just g2
                          -> SEDEL.Source.Syntax.$fAlphaSType_$cacompare'
                               (case ctx of wild2 { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                                Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                                  Unbound.Generics.LocallyNameless.Alpha.Term
                                  ds3 })
                               g1
                               g2 } }) -}
d0def85b0d7744184cb9cc3546f66ade
  $s$fAlpha(,)_$s$fAlphaEmbed1 ::
    Unbound.Generics.LocallyNameless.Alpha.Alpha
      (Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType)
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Embed.Embed
                       SEDEL.Source.Syntax.SType)
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fShowEmbed1
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType)
                     (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Source.Syntax.SType) ->
                   SEDEL.Source.Syntax.$fAlphaSType_$caeq'
                     (case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                      Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                        Unbound.Generics.LocallyNameless.Alpha.Term
                        ds3 })
                     ds
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Source.Syntax.SType>_R)
                     ds1
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Source.Syntax.SType>_R))
                  (Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cfvAny'
                     @ SEDEL.Source.Syntax.SType
                     SEDEL.Source.Syntax.$fAlphaSType)
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (b :: Unbound.Generics.LocallyNameless.Alpha.NamePatFind)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed6
                          @ SEDEL.Source.Syntax.SType
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> (SEDEL.Source.Syntax.$fAlphaSType_$cclose
                           (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                              Unbound.Generics.LocallyNameless.Alpha.Term
                              ds2)
                           b
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R))
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <SEDEL.Source.Syntax.SType>_R)) } })
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (b :: Unbound.Generics.LocallyNameless.Alpha.NthPatFind)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed5
                          @ SEDEL.Source.Syntax.SType
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> (SEDEL.Source.Syntax.$fAlphaSType_$copen
                           (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                              Unbound.Generics.LocallyNameless.Alpha.Term
                              ds2)
                           b
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R))
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <SEDEL.Source.Syntax.SType>_R)) } })
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   case (SEDEL.Source.Syntax.$fAlphaSType_$cisTerm
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R))
                          `cast`
                        (Data.Semigroup.Internal.N:All[0]) of wild {
                     GHC.Types.False
                     -> (GHC.Base.Nothing
                           @ [Unbound.Generics.LocallyNameless.Name.AnyName])
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                  <Unbound.Generics.LocallyNameless.Name.AnyName>_R))
                     GHC.Types.True
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed4
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                  <Unbound.Generics.LocallyNameless.Name.AnyName>_R)) })
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   GHC.Types.False)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      SEDEL.Source.Syntax.SType>_R
                   ->_R Sym (Data.Semigroup.Internal.N:All[0]))
                  SEDEL.Source.Syntax.$fAlphaSType_$cisTerm
                    `cast`
                  (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                            <SEDEL.Source.Syntax.SType>_R)
                   ->_R Data.Semigroup.Internal.N:All[0])
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   Data.Either.Left
                     @ GHC.Integer.Type.Integer
                     @ Unbound.Generics.LocallyNameless.Name.AnyName)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      SEDEL.Source.Syntax.SType>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Alpha.N:NthPatFind[0]))
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   Unbound.Generics.LocallyNameless.Alpha.$fAlpha()2)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      SEDEL.Source.Syntax.SType>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Alpha.N:NamePatFind[0]))
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (perm :: Unbound.Generics.PermM.Perm
                                Unbound.Generics.LocallyNameless.Name.AnyName)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term -> ds
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> (SEDEL.Source.Syntax.$fAlphaSType_$cswaps'
                           (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                              Unbound.Generics.LocallyNameless.Alpha.Term
                              ds2)
                           perm
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R))
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <SEDEL.Source.Syntax.SType>_R)) } })
                  (\ @ m :: * -> *
                     @ b
                     ($dLFresh :: Unbound.Generics.LocallyNameless.LFresh.LFresh m) ->
                   Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed2
                     @ SEDEL.Source.Syntax.SType
                     @ m
                     @ b)
                  (\ @ m :: * -> *
                     ($dFresh :: Unbound.Generics.LocallyNameless.Fresh.Fresh m)
                     (eta2 :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (eta3 :: Unbound.Generics.LocallyNameless.Embed.Embed
                                SEDEL.Source.Syntax.SType) ->
                   case eta2 of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed1
                          @ m
                          @ SEDEL.Source.Syntax.SType
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> GHC.Base.return
                          @ m
                          (Unbound.Generics.LocallyNameless.Fresh.$p1Fresh @ m $dFresh)
                          @ (Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Source.Syntax.SType,
                             Unbound.Generics.PermM.Perm
                               Unbound.Generics.LocallyNameless.Name.AnyName)
                          (eta3,
                           (Data.Map.Internal.Tip
                              @ Unbound.Generics.LocallyNameless.Name.AnyName
                              @ Unbound.Generics.LocallyNameless.Name.AnyName)
                             `cast`
                           (Sym (Unbound.Generics.PermM.N:Perm[0]
                                     <Unbound.Generics.LocallyNameless.Name.AnyName>_N))) } })
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType)
                     (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Source.Syntax.SType) ->
                   SEDEL.Source.Syntax.$fAlphaSType_$cacompare'
                     (case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                      Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                        Unbound.Generics.LocallyNameless.Alpha.Term
                        ds3 })
                     ds
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Source.Syntax.SType>_R)
                     ds1
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Source.Syntax.SType>_R)) -}
ae56642439f4595bbc348e1fb4c081ac
  $s$fAlpha(,)_$s$fAlphaMaybe ::
    Unbound.Generics.LocallyNameless.Alpha.Alpha
      (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fShowMaybe
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlphaMaybe_$caeq'
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlphaMaybe_$cfvAny'
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlphaMaybe_$cclose
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlphaMaybe_$copen
                  (\ (x :: GHC.Base.Maybe SEDEL.Source.Syntax.SType) ->
                   case x of wild {
                     GHC.Base.Nothing
                     -> (GHC.Base.Just
                           @ [Unbound.Generics.LocallyNameless.Name.AnyName]
                           (GHC.Types.[] @ Unbound.Generics.LocallyNameless.Name.AnyName))
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                  <Unbound.Generics.LocallyNameless.Name.AnyName>_R))
                     GHC.Base.Just g1 -> SEDEL.Source.Syntax.$fAlphaSType_$cisPat g1 })
                  (\ (x :: GHC.Base.Maybe SEDEL.Source.Syntax.SType) ->
                   case x of wild {
                     GHC.Base.Nothing
                     -> GHC.Types.True `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                     GHC.Base.Just g1 -> SEDEL.Source.Syntax.$fAlphaSType_$cisTerm g1 })
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlphaMaybe_$cisEmbed
                  (\ (x :: GHC.Base.Maybe SEDEL.Source.Syntax.SType) ->
                   case x of wild {
                     GHC.Base.Nothing
                     -> (Data.Either.Left
                           @ GHC.Integer.Type.Integer
                           @ Unbound.Generics.LocallyNameless.Name.AnyName)
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Alpha.N:NthPatFind[0]))
                     GHC.Base.Just g1
                     -> SEDEL.Source.Syntax.$fAlphaSType_$cnthPatFind g1 })
                  (\ (x :: GHC.Base.Maybe SEDEL.Source.Syntax.SType) ->
                   case x of wild {
                     GHC.Base.Nothing
                     -> Unbound.Generics.LocallyNameless.Alpha.$fAlpha()2
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Alpha.N:NamePatFind[0]))
                     GHC.Base.Just g1
                     -> SEDEL.Source.Syntax.$fAlphaSType_$cnamePatFind g1 })
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlphaMaybe_$cswaps'
                  SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlphaMaybe_$clfreshen'
                  (Unbound.Generics.LocallyNameless.Alpha.$fAlphaMaybe_$cfreshen'
                     @ SEDEL.Source.Syntax.SType
                     SEDEL.Source.Syntax.$fAlphaSType)
                  (\ (c :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (eta2 :: GHC.Base.Maybe SEDEL.Source.Syntax.SType)
                     (eta3 :: GHC.Base.Maybe SEDEL.Source.Syntax.SType) ->
                   case eta2 of wild {
                     GHC.Base.Nothing
                     -> case eta3 of wild1 {
                          GHC.Base.Nothing -> GHC.Types.EQ GHC.Base.Just g1 -> GHC.Types.LT }
                     GHC.Base.Just g1
                     -> case eta3 of wild1 {
                          GHC.Base.Nothing -> GHC.Types.GT
                          GHC.Base.Just g2
                          -> SEDEL.Source.Syntax.$fAlphaSType_$cacompare' c g1 g2 } }) -}
b584fc36d52bc027142d4e0e6894318a
  $s$fAlpha(,)_$s$fAlphaMaybe_$caeq' ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> GHC.Base.Maybe SEDEL.Source.Syntax.SType
    -> GHC.Base.Maybe SEDEL.Source.Syntax.SType
    -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U(U,U)><S,1*U><S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ (c :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (x :: GHC.Base.Maybe SEDEL.Source.Syntax.SType)
                   (y :: GHC.Base.Maybe SEDEL.Source.Syntax.SType) ->
                 case x of wild {
                   GHC.Base.Nothing
                   -> case y of wild1 {
                        GHC.Base.Nothing -> GHC.Types.True
                        GHC.Base.Just g1 -> GHC.Types.False }
                   GHC.Base.Just g1
                   -> case y of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just g2
                        -> SEDEL.Source.Syntax.$fAlphaSType_$caeq' c g1 g2 } }) -}
e09bb7374cf20441d6d63e50dd7b28f8
  $s$fAlpha(,)_$s$fAlphaMaybe_$cclose ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Alpha.NamePatFind
    -> GHC.Base.Maybe SEDEL.Source.Syntax.SType
    -> GHC.Base.Maybe SEDEL.Source.Syntax.SType
  {- Arity: 3, Strictness: <L,U(U,U)><L,U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (c :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (b :: Unbound.Generics.LocallyNameless.Alpha.NamePatFind)
                   (x :: GHC.Base.Maybe SEDEL.Source.Syntax.SType) ->
                 case x of wild {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ SEDEL.Source.Syntax.SType
                   GHC.Base.Just g1
                   -> GHC.Base.Just
                        @ SEDEL.Source.Syntax.SType
                        (SEDEL.Source.Syntax.$fAlphaSType_$cclose c b g1) }) -}
d49600e4759e93d9ee3dae559af2e169
  $s$fAlpha(,)_$s$fAlphaMaybe_$cfvAny' ::
    (Data.Functor.Contravariant.Contravariant f,
     GHC.Base.Applicative f) =>
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> (Unbound.Generics.LocallyNameless.Name.AnyName
        -> f Unbound.Generics.LocallyNameless.Name.AnyName)
    -> GHC.Base.Maybe SEDEL.Source.Syntax.SType
    -> f (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
  {- Arity: 2, Strictness: <L,U(U,U)><L,U(U(U,U),U,U,U,U,U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ f :: * -> *
                   ($dContravariant :: Data.Functor.Contravariant.Contravariant f)
                   ($dApplicative :: GHC.Base.Applicative f) ->
                 let {
                   $dFunctor :: GHC.Base.Functor f
                   = GHC.Base.$p1Applicative @ f $dApplicative
                 } in
                 \ (c :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (nfn :: Unbound.Generics.LocallyNameless.Name.AnyName
                           -> f Unbound.Generics.LocallyNameless.Name.AnyName) ->
                 let {
                   f1 :: f (GHC.Generics.Rep
                              (GHC.Base.Maybe SEDEL.Source.Syntax.SType) GHC.Types.Any)
                         -> f (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
                   = GHC.Base.fmap
                       @ f
                       $dFunctor
                       @ (GHC.Generics.Rep
                            (GHC.Base.Maybe SEDEL.Source.Syntax.SType) GHC.Types.Any)
                       @ (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
                       (GHC.Generics.$fGenericMaybe_$cto
                          @ SEDEL.Source.Syntax.SType
                          @ GHC.Types.Any)
                 } in
                 let {
                   f2 :: f ((GHC.Generics.:+:)
                              (GHC.Generics.C1
                                 ('GHC.Generics.MetaCons
                                    "Nothing" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                 GHC.Generics.U1)
                              (GHC.Generics.C1
                                 ('GHC.Generics.MetaCons
                                    "Just" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                 (GHC.Generics.S1
                                    ('GHC.Generics.MetaSel
                                       'GHC.Base.Nothing
                                       'GHC.Generics.NoSourceUnpackedness
                                       'GHC.Generics.NoSourceStrictness
                                       'GHC.Generics.DecidedLazy)
                                    (GHC.Generics.Rec0 SEDEL.Source.Syntax.SType)))
                              GHC.Types.Any)
                         -> f (GHC.Generics.M1
                                 GHC.Generics.D
                                 ('GHC.Generics.MetaData "Maybe" "GHC.Base" "base" 'GHC.Types.False)
                                 (GHC.Generics.C1
                                    ('GHC.Generics.MetaCons
                                       "Nothing" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                    GHC.Generics.U1
                                  GHC.Generics.:+: GHC.Generics.C1
                                                     ('GHC.Generics.MetaCons
                                                        "Just"
                                                        'GHC.Generics.PrefixI
                                                        'GHC.Types.False)
                                                     (GHC.Generics.S1
                                                        ('GHC.Generics.MetaSel
                                                           'GHC.Base.Nothing
                                                           'GHC.Generics.NoSourceUnpackedness
                                                           'GHC.Generics.NoSourceStrictness
                                                           'GHC.Generics.DecidedLazy)
                                                        (GHC.Generics.Rec0
                                                           SEDEL.Source.Syntax.SType)))
                                 GHC.Types.Any)
                   = GHC.Base.fmap
                       @ f
                       (GHC.Base.$p1Applicative @ f $dApplicative)
                       @ ((GHC.Generics.:+:)
                            (GHC.Generics.C1
                               ('GHC.Generics.MetaCons
                                  "Nothing" 'GHC.Generics.PrefixI 'GHC.Types.False)
                               GHC.Generics.U1)
                            (GHC.Generics.C1
                               ('GHC.Generics.MetaCons
                                  "Just" 'GHC.Generics.PrefixI 'GHC.Types.False)
                               (GHC.Generics.S1
                                  ('GHC.Generics.MetaSel
                                     'GHC.Base.Nothing
                                     'GHC.Generics.NoSourceUnpackedness
                                     'GHC.Generics.NoSourceStrictness
                                     'GHC.Generics.DecidedLazy)
                                  (GHC.Generics.Rec0 SEDEL.Source.Syntax.SType)))
                            GHC.Types.Any)
                       @ (GHC.Generics.M1
                            GHC.Generics.D
                            ('GHC.Generics.MetaData "Maybe" "GHC.Base" "base" 'GHC.Types.False)
                            (GHC.Generics.C1
                               ('GHC.Generics.MetaCons
                                  "Nothing" 'GHC.Generics.PrefixI 'GHC.Types.False)
                               GHC.Generics.U1
                             GHC.Generics.:+: GHC.Generics.C1
                                                ('GHC.Generics.MetaCons
                                                   "Just" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                                (GHC.Generics.S1
                                                   ('GHC.Generics.MetaSel
                                                      'GHC.Base.Nothing
                                                      'GHC.Generics.NoSourceUnpackedness
                                                      'GHC.Generics.NoSourceStrictness
                                                      'GHC.Generics.DecidedLazy)
                                                   (GHC.Generics.Rec0 SEDEL.Source.Syntax.SType)))
                            GHC.Types.Any)
                       (\ (v :: (GHC.Generics.:+:)
                                  (GHC.Generics.C1
                                     ('GHC.Generics.MetaCons
                                        "Nothing" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                     GHC.Generics.U1)
                                  (GHC.Generics.C1
                                     ('GHC.Generics.MetaCons
                                        "Just" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                     (GHC.Generics.S1
                                        ('GHC.Generics.MetaSel
                                           'GHC.Base.Nothing
                                           'GHC.Generics.NoSourceUnpackedness
                                           'GHC.Generics.NoSourceStrictness
                                           'GHC.Generics.DecidedLazy)
                                        (GHC.Generics.Rec0 SEDEL.Source.Syntax.SType)))
                                  GHC.Types.Any) ->
                        v)
                         `cast`
                       (<(GHC.Generics.:+:)
                           (GHC.Generics.C1
                              ('GHC.Generics.MetaCons
                                 "Nothing" 'GHC.Generics.PrefixI 'GHC.Types.False)
                              GHC.Generics.U1)
                           (GHC.Generics.C1
                              ('GHC.Generics.MetaCons
                                 "Just" 'GHC.Generics.PrefixI 'GHC.Types.False)
                              (GHC.Generics.S1
                                 ('GHC.Generics.MetaSel
                                    'GHC.Base.Nothing
                                    'GHC.Generics.NoSourceUnpackedness
                                    'GHC.Generics.NoSourceStrictness
                                    'GHC.Generics.DecidedLazy)
                                 (GHC.Generics.Rec0 SEDEL.Source.Syntax.SType)))
                           GHC.Types.Any>_R
                        ->_R Sym (GHC.Generics.N:M1[0]
                                      <*>_N
                                      <GHC.Generics.D>_P
                                      <'GHC.Generics.MetaData
                                         "Maybe" "GHC.Base" "base" 'GHC.Types.False>_P
                                      <GHC.Generics.C1
                                         ('GHC.Generics.MetaCons
                                            "Nothing" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                         GHC.Generics.U1
                                       GHC.Generics.:+: GHC.Generics.C1
                                                          ('GHC.Generics.MetaCons
                                                             "Just"
                                                             'GHC.Generics.PrefixI
                                                             'GHC.Types.False)
                                                          (GHC.Generics.S1
                                                             ('GHC.Generics.MetaSel
                                                                'GHC.Base.Nothing
                                                                'GHC.Generics.NoSourceUnpackedness
                                                                'GHC.Generics.NoSourceStrictness
                                                                'GHC.Generics.DecidedLazy)
                                                             (GHC.Generics.Rec0
                                                                SEDEL.Source.Syntax.SType))>_R) <GHC.Types.Any>_N)
                 } in
                 let {
                   $dFunctor1 :: GHC.Base.Functor f
                   = GHC.Base.$p1Applicative @ f $dApplicative
                 } in
                 \ (x :: GHC.Base.Maybe SEDEL.Source.Syntax.SType) ->
                 f1
                   (f2
                      (case x of wild {
                         GHC.Base.Nothing
                         -> GHC.Base.fmap
                              @ f
                              $dFunctor1
                              @ (GHC.Generics.M1
                                   GHC.Generics.C
                                   ('GHC.Generics.MetaCons
                                      "Nothing" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                   GHC.Generics.U1
                                   GHC.Types.Any)
                              @ ((GHC.Generics.:+:)
                                   (GHC.Generics.M1
                                      GHC.Generics.C
                                      ('GHC.Generics.MetaCons
                                         "Nothing" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                      GHC.Generics.U1)
                                   (GHC.Generics.M1
                                      GHC.Generics.C
                                      ('GHC.Generics.MetaCons
                                         "Just" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                      (GHC.Generics.S1
                                         ('GHC.Generics.MetaSel
                                            'GHC.Base.Nothing
                                            'GHC.Generics.NoSourceUnpackedness
                                            'GHC.Generics.NoSourceStrictness
                                            'GHC.Generics.DecidedLazy)
                                         (GHC.Generics.Rec0 SEDEL.Source.Syntax.SType)))
                                   GHC.Types.Any)
                              (GHC.Generics.L1
                                 @ *
                                 @ (GHC.Generics.M1
                                      GHC.Generics.C
                                      ('GHC.Generics.MetaCons
                                         "Nothing" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                      GHC.Generics.U1)
                                 @ (GHC.Generics.M1
                                      GHC.Generics.C
                                      ('GHC.Generics.MetaCons
                                         "Just" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                      (GHC.Generics.S1
                                         ('GHC.Generics.MetaSel
                                            'GHC.Base.Nothing
                                            'GHC.Generics.NoSourceUnpackedness
                                            'GHC.Generics.NoSourceStrictness
                                            'GHC.Generics.DecidedLazy)
                                         (GHC.Generics.Rec0 SEDEL.Source.Syntax.SType)))
                                 @ GHC.Types.Any)
                              (GHC.Base.fmap
                                 @ f
                                 (GHC.Base.$p1Applicative @ f $dApplicative)
                                 @ (GHC.Generics.U1 GHC.Types.Any)
                                 @ (GHC.Generics.M1
                                      GHC.Generics.C
                                      ('GHC.Generics.MetaCons
                                         "Nothing" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                      GHC.Generics.U1
                                      GHC.Types.Any)
                                 (\ (v :: GHC.Generics.U1 GHC.Types.Any) -> v)
                                   `cast`
                                 (<GHC.Generics.U1 GHC.Types.Any>_R
                                  ->_R Sym (GHC.Generics.N:M1[0]
                                                <*>_N
                                                <GHC.Generics.C>_P
                                                <'GHC.Generics.MetaCons
                                                   "Nothing"
                                                   'GHC.Generics.PrefixI
                                                   'GHC.Types.False>_P
                                                <GHC.Generics.U1>_R) <GHC.Types.Any>_N)
                                 (GHC.Base.pure
                                    @ f
                                    $dApplicative
                                    @ (GHC.Generics.U1 GHC.Types.Any)
                                    (GHC.Generics.U1 @ * @ GHC.Types.Any)))
                         GHC.Base.Just g1
                         -> GHC.Base.fmap
                              @ f
                              $dFunctor1
                              @ (GHC.Generics.M1
                                   GHC.Generics.C
                                   ('GHC.Generics.MetaCons
                                      "Just" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                   (GHC.Generics.S1
                                      ('GHC.Generics.MetaSel
                                         'GHC.Base.Nothing
                                         'GHC.Generics.NoSourceUnpackedness
                                         'GHC.Generics.NoSourceStrictness
                                         'GHC.Generics.DecidedLazy)
                                      (GHC.Generics.Rec0 SEDEL.Source.Syntax.SType))
                                   GHC.Types.Any)
                              @ ((GHC.Generics.:+:)
                                   (GHC.Generics.M1
                                      GHC.Generics.C
                                      ('GHC.Generics.MetaCons
                                         "Nothing" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                      GHC.Generics.U1)
                                   (GHC.Generics.M1
                                      GHC.Generics.C
                                      ('GHC.Generics.MetaCons
                                         "Just" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                      (GHC.Generics.S1
                                         ('GHC.Generics.MetaSel
                                            'GHC.Base.Nothing
                                            'GHC.Generics.NoSourceUnpackedness
                                            'GHC.Generics.NoSourceStrictness
                                            'GHC.Generics.DecidedLazy)
                                         (GHC.Generics.Rec0 SEDEL.Source.Syntax.SType)))
                                   GHC.Types.Any)
                              (GHC.Generics.R1
                                 @ *
                                 @ (GHC.Generics.M1
                                      GHC.Generics.C
                                      ('GHC.Generics.MetaCons
                                         "Nothing" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                      GHC.Generics.U1)
                                 @ (GHC.Generics.M1
                                      GHC.Generics.C
                                      ('GHC.Generics.MetaCons
                                         "Just" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                      (GHC.Generics.S1
                                         ('GHC.Generics.MetaSel
                                            'GHC.Base.Nothing
                                            'GHC.Generics.NoSourceUnpackedness
                                            'GHC.Generics.NoSourceStrictness
                                            'GHC.Generics.DecidedLazy)
                                         (GHC.Generics.Rec0 SEDEL.Source.Syntax.SType)))
                                 @ GHC.Types.Any)
                              (GHC.Base.fmap
                                 @ f
                                 (GHC.Base.$p1Applicative @ f $dApplicative)
                                 @ (GHC.Generics.M1
                                      GHC.Generics.S
                                      ('GHC.Generics.MetaSel
                                         'GHC.Base.Nothing
                                         'GHC.Generics.NoSourceUnpackedness
                                         'GHC.Generics.NoSourceStrictness
                                         'GHC.Generics.DecidedLazy)
                                      (GHC.Generics.Rec0 SEDEL.Source.Syntax.SType)
                                      GHC.Types.Any)
                                 @ (GHC.Generics.M1
                                      GHC.Generics.C
                                      ('GHC.Generics.MetaCons
                                         "Just" 'GHC.Generics.PrefixI 'GHC.Types.False)
                                      (GHC.Generics.M1
                                         GHC.Generics.S
                                         ('GHC.Generics.MetaSel
                                            'GHC.Base.Nothing
                                            'GHC.Generics.NoSourceUnpackedness
                                            'GHC.Generics.NoSourceStrictness
                                            'GHC.Generics.DecidedLazy)
                                         (GHC.Generics.Rec0 SEDEL.Source.Syntax.SType))
                                      GHC.Types.Any)
                                 (\ (v :: GHC.Generics.M1
                                            GHC.Generics.S
                                            ('GHC.Generics.MetaSel
                                               'GHC.Base.Nothing
                                               'GHC.Generics.NoSourceUnpackedness
                                               'GHC.Generics.NoSourceStrictness
                                               'GHC.Generics.DecidedLazy)
                                            (GHC.Generics.Rec0 SEDEL.Source.Syntax.SType)
                                            GHC.Types.Any) ->
                                  v)
                                   `cast`
                                 (<GHC.Generics.M1
                                     GHC.Generics.S
                                     ('GHC.Generics.MetaSel
                                        'GHC.Base.Nothing
                                        'GHC.Generics.NoSourceUnpackedness
                                        'GHC.Generics.NoSourceStrictness
                                        'GHC.Generics.DecidedLazy)
                                     (GHC.Generics.Rec0 SEDEL.Source.Syntax.SType)
                                     GHC.Types.Any>_R
                                  ->_R Sym (GHC.Generics.N:M1[0]
                                                <*>_N
                                                <GHC.Generics.C>_P
                                                <'GHC.Generics.MetaCons
                                                   "Just" 'GHC.Generics.PrefixI 'GHC.Types.False>_P
                                                <GHC.Generics.M1
                                                   GHC.Generics.S
                                                   ('GHC.Generics.MetaSel
                                                      'GHC.Base.Nothing
                                                      'GHC.Generics.NoSourceUnpackedness
                                                      'GHC.Generics.NoSourceStrictness
                                                      'GHC.Generics.DecidedLazy)
                                                   (GHC.Generics.Rec0
                                                      SEDEL.Source.Syntax.SType)>_R) <GHC.Types.Any>_N)
                                 (GHC.Base.fmap
                                    @ f
                                    (GHC.Base.$p1Applicative @ f $dApplicative)
                                    @ (GHC.Generics.K1
                                         GHC.Generics.R SEDEL.Source.Syntax.SType GHC.Types.Any)
                                    @ (GHC.Generics.M1
                                         GHC.Generics.S
                                         ('GHC.Generics.MetaSel
                                            'GHC.Base.Nothing
                                            'GHC.Generics.NoSourceUnpackedness
                                            'GHC.Generics.NoSourceStrictness
                                            'GHC.Generics.DecidedLazy)
                                         (GHC.Generics.K1 GHC.Generics.R SEDEL.Source.Syntax.SType)
                                         GHC.Types.Any)
                                    (\ (v :: GHC.Generics.K1
                                               GHC.Generics.R
                                               SEDEL.Source.Syntax.SType
                                               GHC.Types.Any) ->
                                     v)
                                      `cast`
                                    (<GHC.Generics.K1
                                        GHC.Generics.R SEDEL.Source.Syntax.SType GHC.Types.Any>_R
                                     ->_R Sym (GHC.Generics.N:M1[0]
                                                   <*>_N
                                                   <GHC.Generics.S>_P
                                                   <'GHC.Generics.MetaSel
                                                      'GHC.Base.Nothing
                                                      'GHC.Generics.NoSourceUnpackedness
                                                      'GHC.Generics.NoSourceStrictness
                                                      'GHC.Generics.DecidedLazy>_P
                                                   <GHC.Generics.K1
                                                      GHC.Generics.R
                                                      SEDEL.Source.Syntax.SType>_R) <GHC.Types.Any>_N)
                                    (GHC.Base.fmap
                                       @ f
                                       (GHC.Base.$p1Applicative @ f $dApplicative)
                                       @ SEDEL.Source.Syntax.SType
                                       @ (GHC.Generics.K1
                                            GHC.Generics.R SEDEL.Source.Syntax.SType GHC.Types.Any)
                                       (\ (v :: SEDEL.Source.Syntax.SType) -> v)
                                         `cast`
                                       (<SEDEL.Source.Syntax.SType>_R
                                        ->_R Sym (GHC.Generics.N:K1[0]
                                                      <*>_N
                                                      <GHC.Generics.R>_P
                                                      <SEDEL.Source.Syntax.SType>_R
                                                      <GHC.Types.Any>_P))
                                       (SEDEL.Source.Syntax.$fAlphaSType_$cfvAny'
                                          @ f
                                          $dContravariant
                                          $dApplicative
                                          c
                                          nfn
                                          g1)))) }))
                     `cast`
                   (<f>_R (Sym (GHC.Generics.Rep_Maybe[0]
                                    <SEDEL.Source.Syntax.SType>_N) <GHC.Types.Any>_N))) -}
81315999fdc711e3b3298eb369d03781
  $s$fAlpha(,)_$s$fAlphaMaybe_$cisEmbed ::
    GHC.Base.Maybe SEDEL.Source.Syntax.SType -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (ds :: GHC.Base.Maybe SEDEL.Source.Syntax.SType) ->
                 GHC.Types.False) -}
dbf74ddb64505a2d0d6f202c18776505
  $s$fAlpha(,)_$s$fAlphaMaybe_$clfreshen' ::
    Unbound.Generics.LocallyNameless.LFresh.LFresh m =>
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> GHC.Base.Maybe SEDEL.Source.Syntax.SType
    -> (GHC.Base.Maybe SEDEL.Source.Syntax.SType
        -> Unbound.Generics.PermM.Perm
             Unbound.Generics.LocallyNameless.Name.AnyName
        -> m b)
    -> m b
  {- Arity: 4,
     Strictness: <L,U(U(U,U,U,U,U),U,U,U)><L,U(U,U)><S,1*U><L,C(C1(U))>,
     Inline: (sat-args=3),
     Unfolding: InlineRule (3, False, False)
                (\ @ m :: * -> *
                   @ b
                   ($dLFresh :: Unbound.Generics.LocallyNameless.LFresh.LFresh m)
                   (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (m1 :: GHC.Base.Maybe SEDEL.Source.Syntax.SType)
                   (cont :: GHC.Base.Maybe SEDEL.Source.Syntax.SType
                            -> Unbound.Generics.PermM.Perm
                                 Unbound.Generics.LocallyNameless.Name.AnyName
                            -> m b) ->
                 case m1 of wild {
                   GHC.Base.Nothing
                   -> cont
                        (GHC.Base.Nothing @ SEDEL.Source.Syntax.SType)
                        (Data.Map.Internal.Tip
                           @ Unbound.Generics.LocallyNameless.Name.AnyName
                           @ Unbound.Generics.LocallyNameless.Name.AnyName)
                          `cast`
                        (Sym (Unbound.Generics.PermM.N:Perm[0]
                                  <Unbound.Generics.LocallyNameless.Name.AnyName>_N))
                   GHC.Base.Just g1
                   -> SEDEL.Source.Syntax.$fAlphaSType_$clfreshen'
                        @ m
                        @ b
                        $dLFresh
                        ctx
                        g1
                        (\ (x :: SEDEL.Source.Syntax.SType) ->
                         cont (GHC.Base.Just @ SEDEL.Source.Syntax.SType x)) }) -}
0f2d4611688aca3ec697536b65f59356
  $s$fAlpha(,)_$s$fAlphaMaybe_$copen ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Alpha.NthPatFind
    -> GHC.Base.Maybe SEDEL.Source.Syntax.SType
    -> GHC.Base.Maybe SEDEL.Source.Syntax.SType
  {- Arity: 3, Strictness: <L,U(U,U)><L,U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (c :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (b :: Unbound.Generics.LocallyNameless.Alpha.NthPatFind)
                   (x :: GHC.Base.Maybe SEDEL.Source.Syntax.SType) ->
                 case x of wild {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ SEDEL.Source.Syntax.SType
                   GHC.Base.Just g1
                   -> GHC.Base.Just
                        @ SEDEL.Source.Syntax.SType
                        (SEDEL.Source.Syntax.$fAlphaSType_$copen c b g1) }) -}
398f75f495973dc7c08d4b9f7ff897e6
  $s$fAlpha(,)_$s$fAlphaMaybe_$cswaps' ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.PermM.Perm
         Unbound.Generics.LocallyNameless.Name.AnyName
    -> GHC.Base.Maybe SEDEL.Source.Syntax.SType
    -> GHC.Base.Maybe SEDEL.Source.Syntax.SType
  {- Arity: 3, Strictness: <L,U(U,U)><L,U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (perm :: Unbound.Generics.PermM.Perm
                              Unbound.Generics.LocallyNameless.Name.AnyName)
                   (x :: GHC.Base.Maybe SEDEL.Source.Syntax.SType) ->
                 case x of wild {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ SEDEL.Source.Syntax.SType
                   GHC.Base.Just g1
                   -> GHC.Base.Just
                        @ SEDEL.Source.Syntax.SType
                        (SEDEL.Source.Syntax.$fAlphaSType_$cswaps' ctx perm g1) }) -}
edc37005db16c734bc37fe12c3085ae2
  $s$fAlpha(,)_$s$fShow(,)3 ::
    GHC.Show.Show
      (Unbound.Generics.LocallyNameless.Name.Name
         SEDEL.Source.Syntax.SType,
       Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Name.Name
                       SEDEL.Source.Syntax.SType,
                     Unbound.Generics.LocallyNameless.Embed.Embed
                       SEDEL.Source.Syntax.SType)
                  (GHC.Show.$fShow(,)_$cshowsPrec
                     @ (Unbound.Generics.LocallyNameless.Name.Name
                          SEDEL.Source.Syntax.SType)
                     @ (Unbound.Generics.LocallyNameless.Embed.Embed
                          SEDEL.Source.Syntax.SType)
                     (Unbound.Generics.LocallyNameless.Name.$fShowName
                        @ SEDEL.Source.Syntax.SType)
                     SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fShowEmbed1)
                  (\ (x :: (Unbound.Generics.LocallyNameless.Name.Name
                              SEDEL.Source.Syntax.SType,
                            Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType)) ->
                   GHC.Show.$fShow(,)_$cshowsPrec
                     @ (Unbound.Generics.LocallyNameless.Name.Name
                          SEDEL.Source.Syntax.SType)
                     @ (Unbound.Generics.LocallyNameless.Embed.Embed
                          SEDEL.Source.Syntax.SType)
                     (Unbound.Generics.LocallyNameless.Name.$fShowName
                        @ SEDEL.Source.Syntax.SType)
                     SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fShowEmbed1
                     GHC.Show.$fShow(,)1
                     x
                     (GHC.Types.[] @ GHC.Types.Char))
                  (\ (ls :: [(Unbound.Generics.LocallyNameless.Name.Name
                                SEDEL.Source.Syntax.SType,
                              Unbound.Generics.LocallyNameless.Embed.Embed
                                SEDEL.Source.Syntax.SType)])
                     (s :: GHC.Base.String) ->
                   GHC.Show.showList__
                     @ (Unbound.Generics.LocallyNameless.Name.Name
                          SEDEL.Source.Syntax.SType,
                        Unbound.Generics.LocallyNameless.Embed.Embed
                          SEDEL.Source.Syntax.SType)
                     (GHC.Show.$fShow(,)_$cshowsPrec
                        @ (Unbound.Generics.LocallyNameless.Name.Name
                             SEDEL.Source.Syntax.SType)
                        @ (Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Source.Syntax.SType)
                        (Unbound.Generics.LocallyNameless.Name.$fShowName
                           @ SEDEL.Source.Syntax.SType)
                        SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fShowEmbed1
                        GHC.Show.$fShow(,)1)
                     ls
                     s) -}
2abf55eae3b6da37dc6d8be844f2c027
  $s$fAlpha(,)_$s$fShowEmbed ::
    GHC.Show.Show
      (Unbound.Generics.LocallyNameless.Embed.Embed
         (GHC.Base.Maybe SEDEL.Source.Syntax.SType))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Embed.Embed
                       (GHC.Base.Maybe SEDEL.Source.Syntax.SType))
                  (Unbound.Generics.LocallyNameless.Embed.$fShowEmbed_$cshowsPrec
                     @ (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
                     SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fShowMaybe)
                  (\ (x :: Unbound.Generics.LocallyNameless.Embed.Embed
                             (GHC.Base.Maybe SEDEL.Source.Syntax.SType)) ->
                   GHC.CString.unpackAppendCString#
                     Unbound.Generics.LocallyNameless.Embed.$fShowEmbed3
                     (case x `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R) of wild {
                        GHC.Base.Nothing
                        -> GHC.Base.augment
                             @ GHC.Types.Char
                             (\ @ b
                                (c :: GHC.Types.Char -> b -> b)[OneShot]
                                (n :: b)[OneShot] ->
                              GHC.Base.foldr @ GHC.Types.Char @ b c n GHC.Show.$fShowMaybe4)
                             Unbound.Generics.LocallyNameless.Embed.$fShowEmbed4
                        GHC.Base.Just b1
                        -> GHC.Base.augment
                             @ GHC.Types.Char
                             (\ @ b
                                (c :: GHC.Types.Char -> b -> b)[OneShot]
                                (n :: b)[OneShot] ->
                              GHC.Base.foldr @ GHC.Types.Char @ b c n GHC.Show.$fShowMaybe1)
                             (SEDEL.Source.Syntax.$fShowSType_$cshowsPrec
                                GHC.Show.appPrec1
                                b1
                                Unbound.Generics.LocallyNameless.Embed.$fShowEmbed4) }))
                  (Unbound.Generics.LocallyNameless.Embed.$fShowEmbed_$cshowList
                     @ (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
                     SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fShowMaybe) -}
fb05a2b08909106e8a1b0232706284fb
  $s$fAlpha(,)_$s$fShowEmbed1 ::
    GHC.Show.Show
      (Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Embed.Embed
                       SEDEL.Source.Syntax.SType)
                  (Unbound.Generics.LocallyNameless.Embed.$fShowEmbed_$cshowsPrec
                     @ SEDEL.Source.Syntax.SType
                     SEDEL.Source.Syntax.$fShowSType)
                  (\ (x :: Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Source.Syntax.SType) ->
                   GHC.CString.unpackAppendCString#
                     Unbound.Generics.LocallyNameless.Embed.$fShowEmbed3
                     (SEDEL.Source.Syntax.$fShowSType_$cshowsPrec
                        Unbound.Generics.LocallyNameless.Embed.$fShowEmbed2
                        x `cast`
                        (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                             <SEDEL.Source.Syntax.SType>_R)
                        Unbound.Generics.LocallyNameless.Embed.$fShowEmbed4))
                  (Unbound.Generics.LocallyNameless.Embed.$fShowEmbed_$cshowList
                     @ SEDEL.Source.Syntax.SType
                     SEDEL.Source.Syntax.$fShowSType) -}
ea9565afbcc37fbb359e50afb6e9fded
  $s$fAlpha(,)_$s$fShowMaybe ::
    GHC.Show.Show (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
                  (GHC.Show.$fShowMaybe_$cshowsPrec
                     @ SEDEL.Source.Syntax.SType
                     SEDEL.Source.Syntax.$fShowSType)
                  (\ (x :: GHC.Base.Maybe SEDEL.Source.Syntax.SType) ->
                   case x of wild {
                     GHC.Base.Nothing -> GHC.Show.$fShowMaybe4
                     GHC.Base.Just b1
                     -> GHC.Base.augment
                          @ GHC.Types.Char
                          (\ @ b
                             (c :: GHC.Types.Char -> b -> b)[OneShot]
                             (n :: b)[OneShot] ->
                           GHC.Base.foldr @ GHC.Types.Char @ b c n GHC.Show.$fShowMaybe1)
                          (SEDEL.Source.Syntax.$fShowSType_$cshowsPrec
                             GHC.Show.appPrec1
                             b1
                             (GHC.Types.[] @ GHC.Types.Char)) })
                  (\ (ls :: [GHC.Base.Maybe SEDEL.Source.Syntax.SType])
                     (s :: GHC.Base.String) ->
                   GHC.Show.showList__
                     @ (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
                     (GHC.Show.$fShowMaybe_$cshowsPrec
                        @ SEDEL.Source.Syntax.SType
                        SEDEL.Source.Syntax.$fShowSType
                        GHC.Show.$fShow(,)1)
                     ls
                     s) -}
5d35ca351a507cd5811fc20e181162a5
  $s$fAlphaEmbed_$cacompare'1 ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
    -> GHC.Types.Ordering
  {- Arity: 3, Strictness: <L,1*U(A,U)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            (GHC.Base.Maybe SEDEL.Source.Syntax.SType))
                   (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                             (GHC.Base.Maybe SEDEL.Source.Syntax.SType)) ->
                 case ds
                        `cast`
                      (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                           <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R) of wild {
                   GHC.Base.Nothing
                   -> case ds1
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R) of wild1 {
                        GHC.Base.Nothing -> GHC.Types.EQ GHC.Base.Just g1 -> GHC.Types.LT }
                   GHC.Base.Just g1
                   -> case ds1
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R) of wild1 {
                        GHC.Base.Nothing -> GHC.Types.GT
                        GHC.Base.Just g2
                        -> SEDEL.Source.Syntax.$fAlphaSType_$cacompare'
                             (case ctx of wild2 { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                              Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                                Unbound.Generics.LocallyNameless.Alpha.Term
                                ds3 })
                             g1
                             g2 } }) -}
8d514a6c3c3e265f08efb23a750bdad1
  $s$fAlphaEmbed_$caeq'1 ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
    -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,1*U(A,U)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            (GHC.Base.Maybe SEDEL.Source.Syntax.SType))
                   (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                             (GHC.Base.Maybe SEDEL.Source.Syntax.SType)) ->
                 case ds
                        `cast`
                      (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                           <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R) of wild {
                   GHC.Base.Nothing
                   -> case ds1
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R) of wild1 {
                        GHC.Base.Nothing -> GHC.Types.True
                        GHC.Base.Just g1 -> GHC.Types.False }
                   GHC.Base.Just g1
                   -> case ds1
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R) of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just g2
                        -> SEDEL.Source.Syntax.$fAlphaSType_$caeq'
                             (case ctx of wild2 { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                              Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                                Unbound.Generics.LocallyNameless.Alpha.Term
                                ds3 })
                             g1
                             g2 } }) -}
851d2b84b65bf09161087353797b2b90
  $s$fAlphaEmbed_$cclose1 ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Alpha.NamePatFind
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
  {- Arity: 3, Strictness: <S(SS),1*U(U,U)><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (b :: Unbound.Generics.LocallyNameless.Alpha.NamePatFind)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            (GHC.Base.Maybe SEDEL.Source.Syntax.SType)) ->
                 case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                 case ds1 of wild1 {
                   Unbound.Generics.LocallyNameless.Alpha.Term
                   -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed6
                        @ (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> case ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R) of wild2 {
                        GHC.Base.Nothing
                        -> (GHC.Base.Nothing @ SEDEL.Source.Syntax.SType)
                             `cast`
                           (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                     <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R))
                        GHC.Base.Just g1
                        -> (GHC.Base.Just
                              @ SEDEL.Source.Syntax.SType
                              (SEDEL.Source.Syntax.$fAlphaSType_$cclose
                                 (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                                    Unbound.Generics.LocallyNameless.Alpha.Term
                                    ds2)
                                 b
                                 g1))
                             `cast`
                           (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                     <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R)) } } }) -}
7662bb7c6bc9741db6e54959c3ea5fc1
  $s$fAlphaEmbed_$cfreshen'1 ::
    Unbound.Generics.LocallyNameless.Fresh.Fresh m =>
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
    -> m (Unbound.Generics.LocallyNameless.Embed.Embed
            (GHC.Base.Maybe SEDEL.Source.Syntax.SType),
          Unbound.Generics.PermM.Perm
            Unbound.Generics.LocallyNameless.Name.AnyName)
  {- Arity: 3,
     Strictness: <S(S(LLLC(S)L)L),1*U(1*U(A,A,A,1*C1(U),A),A)><S(SL),1*U(U,A)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   ($dFresh :: Unbound.Generics.LocallyNameless.Fresh.Fresh m)
                   (eta2 :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (eta3 :: Unbound.Generics.LocallyNameless.Embed.Embed
                              (GHC.Base.Maybe SEDEL.Source.Syntax.SType)) ->
                 case eta2 of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                 case ds1 of wild1 {
                   Unbound.Generics.LocallyNameless.Alpha.Term
                   -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed1
                        @ m
                        @ (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> GHC.Base.return
                        @ m
                        (Unbound.Generics.LocallyNameless.Fresh.$p1Fresh @ m $dFresh)
                        @ (Unbound.Generics.LocallyNameless.Embed.Embed
                             (GHC.Base.Maybe SEDEL.Source.Syntax.SType),
                           Unbound.Generics.PermM.Perm
                             Unbound.Generics.LocallyNameless.Name.AnyName)
                        (eta3,
                         (Data.Map.Internal.Tip
                            @ Unbound.Generics.LocallyNameless.Name.AnyName
                            @ Unbound.Generics.LocallyNameless.Name.AnyName)
                           `cast`
                         (Sym (Unbound.Generics.PermM.N:Perm[0]
                                   <Unbound.Generics.LocallyNameless.Name.AnyName>_N))) } }) -}
36445a53b8753a1cc811543a4ca5938d
  $s$fAlphaEmbed_$cisPat1 ::
    Unbound.Generics.LocallyNameless.Embed.Embed
      (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
    -> Unbound.Generics.LocallyNameless.Alpha.DisjointSet
         Unbound.Generics.LocallyNameless.Name.AnyName
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            (GHC.Base.Maybe SEDEL.Source.Syntax.SType)) ->
                 case ds
                        `cast`
                      (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                           <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R) of wild {
                   GHC.Base.Nothing
                   -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed4
                        `cast`
                      (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                <Unbound.Generics.LocallyNameless.Name.AnyName>_R))
                   GHC.Base.Just g1
                   -> case (SEDEL.Source.Syntax.$fAlphaSType_$cisTerm g1)
                             `cast`
                           (Data.Semigroup.Internal.N:All[0]) of wild1 {
                        GHC.Types.False
                        -> (GHC.Base.Nothing
                              @ [Unbound.Generics.LocallyNameless.Name.AnyName])
                             `cast`
                           (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                     <Unbound.Generics.LocallyNameless.Name.AnyName>_R))
                        GHC.Types.True
                        -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed4
                             `cast`
                           (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                     <Unbound.Generics.LocallyNameless.Name.AnyName>_R)) } }) -}
badf1bd5ef07052f9ad0c25864b619aa
  $s$fAlphaEmbed_$copen1 ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.LocallyNameless.Alpha.NthPatFind
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
  {- Arity: 3, Strictness: <S(SS),1*U(U,U)><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (b :: Unbound.Generics.LocallyNameless.Alpha.NthPatFind)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            (GHC.Base.Maybe SEDEL.Source.Syntax.SType)) ->
                 case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                 case ds1 of wild1 {
                   Unbound.Generics.LocallyNameless.Alpha.Term
                   -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed5
                        @ (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> case ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R) of wild2 {
                        GHC.Base.Nothing
                        -> (GHC.Base.Nothing @ SEDEL.Source.Syntax.SType)
                             `cast`
                           (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                     <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R))
                        GHC.Base.Just g1
                        -> (GHC.Base.Just
                              @ SEDEL.Source.Syntax.SType
                              (SEDEL.Source.Syntax.$fAlphaSType_$copen
                                 (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                                    Unbound.Generics.LocallyNameless.Alpha.Term
                                    ds2)
                                 b
                                 g1))
                             `cast`
                           (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                     <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R)) } } }) -}
659873deefacd29db93f28c533f8c07a
  $s$fAlphaEmbed_$cswaps'1 ::
    Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
    -> Unbound.Generics.PermM.Perm
         Unbound.Generics.LocallyNameless.Name.AnyName
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
  {- Arity: 3, Strictness: <S(SS),1*U(U,U)><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                   (perm :: Unbound.Generics.PermM.Perm
                              Unbound.Generics.LocallyNameless.Name.AnyName)
                   (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                            (GHC.Base.Maybe SEDEL.Source.Syntax.SType)) ->
                 case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                 case ds1 of wild1 {
                   Unbound.Generics.LocallyNameless.Alpha.Term -> ds
                   Unbound.Generics.LocallyNameless.Alpha.Pat
                   -> case ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R) of wild2 {
                        GHC.Base.Nothing
                        -> (GHC.Base.Nothing @ SEDEL.Source.Syntax.SType)
                             `cast`
                           (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                     <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R))
                        GHC.Base.Just g1
                        -> (GHC.Base.Just
                              @ SEDEL.Source.Syntax.SType
                              (SEDEL.Source.Syntax.$fAlphaSType_$cswaps'
                                 (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                                    Unbound.Generics.LocallyNameless.Alpha.Term
                                    ds2)
                                 perm
                                 g1))
                             `cast`
                           (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                     <GHC.Base.Maybe SEDEL.Source.Syntax.SType>_R)) } } }) -}
c9ead0d8e10db92aecc07a3f56f6d46e
  $s$fApplicativeExceptT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
                  (SEDEL.Source.TypeCheck.$s$fApplicativeExceptT_$s$fFunctorExceptT
                     @ e)
                  (SEDEL.Source.TypeCheck.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure
                     @ e)
                  (Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                     @ GHC.Types.IO
                     @ e
                     GHC.Base.$fFunctorIO
                     GHC.Base.$fMonadIO)
                  (\ @ a
                     @ b
                     @ c
                     (f1 :: a -> b -> c)
                     (x :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a) ->
                   Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                     @ GHC.Types.IO
                     @ e
                     GHC.Base.$fFunctorIO
                     GHC.Base.$fMonadIO
                     @ b
                     @ c
                     (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                      case x `cast`
                           (Control.Monad.Trans.Except.N:ExceptT[0]
                                <e>_N <GHC.Types.IO>_R <a>_N ; GHC.Types.N:IO[0]
                                                                   <Data.Either.Either e a>_R)
                             s of ds { (#,#) ipv ipv1 ->
                      (# ipv,
                         Data.Either.$fApplicativeEither_$cfmap
                           @ e
                           @ a
                           @ (b -> c)
                           f1
                           ipv1 #) })
                       `cast`
                     (Sym (GHC.Types.N:IO[0]
                               <Data.Either.Either
                                  e (b -> c)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                            <e>_N <GHC.Types.IO>_R <b -> c>_N)))
                  (SEDEL.Source.TypeCheck.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$c*>
                     @ e)
                  (\ @ a
                     @ b
                     (x :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a) ->
                   Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                     @ GHC.Types.IO
                     @ e
                     GHC.Base.$fFunctorIO
                     GHC.Base.$fMonadIO
                     @ b
                     @ a
                     (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                      case x `cast`
                           (Control.Monad.Trans.Except.N:ExceptT[0]
                                <e>_N <GHC.Types.IO>_R <a>_N ; GHC.Types.N:IO[0]
                                                                   <Data.Either.Either e a>_R)
                             s of ds { (#,#) ipv ipv1 ->
                      (# ipv,
                         Control.Monad.Trans.Except.$fApplicativeExceptT1
                           @ a
                           @ b
                           @ e
                           ipv1 #) })
                       `cast`
                     (Sym (GHC.Types.N:IO[0]
                               <Data.Either.Either
                                  e (b -> a)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                            <e>_N <GHC.Types.IO>_R <b -> a>_N))) -}
7aa46e2b28e67fda363f9ba9697e0c63
  $s$fApplicativeExceptT_$c<*>1 ::
    Control.Monad.Trans.Except.ExceptT e GHC.Types.IO (a -> b)
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Either.Either e b #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S(SS)),1*C1(U(U,1*U))><L,1*C1(U(U,1*U))><S,U>,
     Unfolding: (\ @ e
                   @ a
                   @ b
                   (w1 :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO (a -> b))
                   (w2 :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w1
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <GHC.Types.IO>_R <a -> b>_N ; GHC.Types.N:IO[0]
                                                                   <Data.Either.Either
                                                                      e (a -> b)>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   Data.Either.Left e1 -> (# ipv, Data.Either.Left @ e @ b e1 #)
                   Data.Either.Right k
                   -> case w2
                             `cast`
                           (Control.Monad.Trans.Except.N:ExceptT[0]
                                <e>_N <GHC.Types.IO>_R <a>_N ; GHC.Types.N:IO[0]
                                                                   <Data.Either.Either e a>_R)
                             ipv of ds2 { (#,#) ipv2 ipv3 ->
                      case ipv3 of wild1 {
                        Data.Either.Left e1 -> (# ipv2, Data.Either.Left @ e @ b e1 #)
                        Data.Either.Right x
                        -> (# ipv2, Data.Either.Right @ e @ b (k x) #) } } } }) -}
6959ae3d07ea195265ed65c1206a37b5
  $s$fApplicativeExceptT_$s$fApplicativeExceptT_$c*> ::
    Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S(SS)),1*C1(U(U,1*U))><L,1*C1(U(U,U))><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a)
                   (k :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case m1
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <GHC.Types.IO>_R <a>_N ; GHC.Types.N:IO[0]
                                                              <Data.Either.Either e a>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   Data.Either.Left e1 -> (# ipv, Data.Either.Left @ e @ b e1 #)
                   Data.Either.Right x
                   -> k `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <GHC.Types.IO>_R <b>_N ; GHC.Types.N:IO[0]
                                                              <Data.Either.Either e b>_R)
                        ipv } })
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a>_R
                 ->_R <Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <Data.Either.Either
                                  e b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                     <e>_N <GHC.Types.IO>_R <b>_N)) -}
d78e69d242132ec70306c5eecacddf4e
  $s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure ::
    a -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ e @ a (a1 :: a) (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 (# s, Data.Either.Right @ e @ a a1 #))
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N).
                 <a>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <Data.Either.Either
                                  e a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                     <e>_N <GHC.Types.IO>_R <a>_N)) -}
819709a70de0d43a650a29b2fc9ac30d
  $s$fApplicativeExceptT_$s$fFunctorExceptT ::
    GHC.Base.Functor
      (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
                  (Control.Monad.Trans.Except.$fFunctorExceptT_$cfmap
                     @ GHC.Types.IO
                     @ e
                     GHC.Base.$fFunctorIO)
                  (Control.Monad.Trans.Except.$fFunctorExceptT_$c<$
                     @ GHC.Types.IO
                     @ e
                     GHC.Base.$fFunctorIO) -}
cb9bd67e7409c70409cb064ce3ed1830
  $s$fFreshFreshMT ::
    Unbound.Generics.LocallyNameless.Fresh.Fresh
      (Unbound.Generics.LocallyNameless.Fresh.FreshMT
         (Control.Monad.Trans.Reader.ReaderT
            SEDEL.Environment.Ctx
            (Control.Monad.Trans.Except.ExceptT
               SEDEL.Environment.Err GHC.Types.IO)))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Fresh.FreshMT
                       (Control.Monad.Trans.Reader.ReaderT
                          SEDEL.Environment.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             SEDEL.Environment.Err GHC.Types.IO)))
                  (Unbound.Generics.LocallyNameless.Fresh.$fMonadFreshMT
                     @ (Control.Monad.Trans.Reader.ReaderT
                          SEDEL.Environment.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             SEDEL.Environment.Err GHC.Types.IO))
                     (SEDEL.Source.TypeCheck.$s$fFreshFreshMT_$s$fMonadReaderT
                        @ SEDEL.Environment.Ctx))
                  (Unbound.Generics.LocallyNameless.Fresh.$fFreshFreshMT1
                     @ (Control.Monad.Trans.Reader.ReaderT
                          SEDEL.Environment.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             SEDEL.Environment.Err GHC.Types.IO))
                     (SEDEL.Source.TypeCheck.$s$fFreshFreshMT_$s$fMonadReaderT
                        @ SEDEL.Environment.Ctx))
                    `cast`
                  (forall (a :: <*>_N).
                   <Unbound.Generics.LocallyNameless.Name.Name a>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Reader.ReaderT
                                    SEDEL.Environment.Ctx
                                    (Control.Monad.Trans.Except.ExceptT
                                       SEDEL.Environment.Err GHC.Types.IO)>_R
                                 <Unbound.Generics.LocallyNameless.Name.Name
                                    a>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                         SEDEL.Environment.Ctx
                                                                                                         (Control.Monad.Trans.Except.ExceptT
                                                                                                            SEDEL.Environment.Err
                                                                                                            GHC.Types.IO)>_N <Unbound.Generics.LocallyNameless.Name.Name
                                                                                                                                a>_N) -}
2363a08442a008b72af2fd3e30f9f0bb
  $s$fFreshFreshMT_$s$fMonadExceptT ::
    GHC.Base.Monad (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
                  (SEDEL.Source.TypeCheck.$s$fApplicativeExceptT @ e)
                  (SEDEL.Source.TypeCheck.$s$fFreshFreshMT_$s$fMonadExceptT_$c>>=
                     @ e)
                  (SEDEL.Source.TypeCheck.$s$fFreshFreshMT_$s$fMonadExceptT_$c>> @ e)
                  (\ @ a (eta2 :: a) (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   (# s, Data.Either.Right @ e @ a eta2 #))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <Data.Either.Either
                                    e a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                       <e>_N <GHC.Types.IO>_R <a>_N))
                  (\ @ a (x :: GHC.Base.String) ->
                   GHC.Magic.noinline
                     @ (forall a1. [GHC.Types.Char] -> GHC.Types.IO a1)
                     GHC.IO.failIO1
                       `cast`
                     (forall (a1 :: <*>_N).
                      <GHC.Base.String>_R ->_R Sym (GHC.Types.N:IO[0] <a1>_R))
                     @ (Data.Either.Either e a)
                     x)
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Base.String>_R
                   ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                 <e>_N <GHC.Types.IO>_R <a>_N)) -}
047c8780d0bf60c01f7061689962cd99
  $s$fFreshFreshMT_$s$fMonadExceptT_$c>> ::
    Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S(SS)),1*C1(U(U,1*U))><L,1*C1(U(U,U))><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a)
                   (k :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case m1
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <GHC.Types.IO>_R <a>_N ; GHC.Types.N:IO[0]
                                                              <Data.Either.Either e a>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   Data.Either.Left e1 -> (# ipv, Data.Either.Left @ e @ b e1 #)
                   Data.Either.Right x
                   -> k `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <GHC.Types.IO>_R <b>_N ; GHC.Types.N:IO[0]
                                                              <Data.Either.Either e b>_R)
                        ipv } })
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a>_R
                 ->_R <Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <Data.Either.Either
                                  e b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                     <e>_N <GHC.Types.IO>_R <b>_N)) -}
7f1fa52ec270447062d5f1b9f5f99e12
  $s$fFreshFreshMT_$s$fMonadExceptT_$c>>= ::
    Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a
    -> (a -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b)
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S(SS)),1*C1(U(U,1*U))><L,1*C1(C1(U(U,U)))><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a)
                   (k :: a -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case m1
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <GHC.Types.IO>_R <a>_N ; GHC.Types.N:IO[0]
                                                              <Data.Either.Either e a>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   Data.Either.Left e1 -> (# ipv, Data.Either.Left @ e @ b e1 #)
                   Data.Either.Right x
                   -> (k x)
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <GHC.Types.IO>_R <b>_N ; GHC.Types.N:IO[0]
                                                              <Data.Either.Either e b>_R)
                        ipv } })
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a>_R
                 ->_R <a -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <Data.Either.Either
                                  e b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                     <e>_N <GHC.Types.IO>_R <b>_N)) -}
e8a4e8a2a5310c57cf6732c9365c2548
  $s$fFreshFreshMT_$s$fMonadReaderT ::
    GHC.Base.Monad
      (Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ r.
                  @ (Control.Monad.Trans.Reader.ReaderT
                       r
                       (Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO))
                  (Control.Monad.Trans.Reader.$fApplicativeReaderT
                     @ (Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO)
                     @ r
                     (SEDEL.Source.TypeCheck.$s$fApplicativeExceptT
                        @ SEDEL.Environment.Err))
                  (Control.Monad.Trans.Reader.$fMonadReaderT_$c>>=
                     @ (Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO)
                     @ r
                     (SEDEL.Source.TypeCheck.$s$fFreshFreshMT_$s$fMonadExceptT
                        @ SEDEL.Environment.Err))
                  (\ @ a @ b ->
                   Control.Monad.Trans.Reader.$fApplicativeReaderT_$c*>
                     @ (Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO)
                     @ r
                     (SEDEL.Source.TypeCheck.$s$fApplicativeExceptT
                        @ SEDEL.Environment.Err)
                     @ a
                     @ b)
                  (\ @ a (eta2 :: a) ->
                   let {
                     m1 :: GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                 Data.Either.Either SEDEL.Environment.Err a #)
                       {- Arity: 1 -}
                     = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                       (# s, Data.Either.Right @ SEDEL.Environment.Err @ a eta2 #)
                   } in
                   (\ (ds :: r) -> m1)
                     `cast`
                   ((<r>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <Data.Either.Either
                                      SEDEL.Environment.Err
                                      a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                       <SEDEL.Environment.Err>_N
                                                       <GHC.Types.IO>_R
                                                       <a>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                          <*>_N
                                                                          <r>_R
                                                                          <Control.Monad.Trans.Except.ExceptT
                                                                             SEDEL.Environment.Err
                                                                             GHC.Types.IO>_R
                                                                          <a>_N)))
                  (Control.Monad.Trans.Reader.$fMonadReaderT_$cfail
                     @ (Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO)
                     @ r
                     (SEDEL.Source.TypeCheck.$s$fFreshFreshMT_$s$fMonadExceptT
                        @ SEDEL.Environment.Err)) -}
0ae4d063f20e7e022ff448443265a915
  $s$fMonadErroreFreshMT ::
    Control.Monad.Error.Class.MonadError
      SEDEL.Environment.Err
      (Unbound.Generics.LocallyNameless.Fresh.FreshMT
         (Control.Monad.Trans.Reader.ReaderT
            SEDEL.Environment.Ctx
            (Control.Monad.Trans.Except.ExceptT
               SEDEL.Environment.Err GHC.Types.IO)))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ SEDEL.Environment.Err
                  @ (Unbound.Generics.LocallyNameless.Fresh.FreshMT
                       (Control.Monad.Trans.Reader.ReaderT
                          SEDEL.Environment.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             SEDEL.Environment.Err GHC.Types.IO)))
                  (Unbound.Generics.LocallyNameless.Fresh.$fMonadFreshMT
                     @ (Control.Monad.Trans.Reader.ReaderT
                          SEDEL.Environment.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             SEDEL.Environment.Err GHC.Types.IO))
                     (SEDEL.Source.TypeCheck.$s$fFreshFreshMT_$s$fMonadReaderT
                        @ SEDEL.Environment.Ctx))
                  (\ @ a
                     (eta2 :: SEDEL.Environment.Err)
                     (eta3 :: GHC.Integer.Type.Integer)
                     (r1 :: SEDEL.Environment.Ctx)
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   (# s,
                      Data.Either.Left
                        @ SEDEL.Environment.Err
                        @ (a, GHC.Integer.Type.Integer)
                        eta2 #))
                    `cast`
                  (forall (a :: <*>_N).
                   <SEDEL.Environment.Err>_R
                   ->_R (<GHC.Integer.Type.Integer>_R
                         ->_R (<SEDEL.Environment.Ctx>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.Either.Either
                                                SEDEL.Environment.Err
                                                (a,
                                                 GHC.Integer.Type.Integer)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                          <SEDEL.Environment.Err>_N
                                                                                          <GHC.Types.IO>_R
                                                                                          <(a,
                                                                                            GHC.Integer.Type.Integer)>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                                      <*>_N
                                                                                                                                      <SEDEL.Environment.Ctx>_R
                                                                                                                                      <Control.Monad.Trans.Except.ExceptT
                                                                                                                                         SEDEL.Environment.Err
                                                                                                                                         GHC.Types.IO>_R
                                                                                                                                      <(a,
                                                                                                                                        GHC.Integer.Type.Integer)>_N)) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                   <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                   <Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                                      SEDEL.Environment.Ctx
                                                                                                                                                                                      (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                         SEDEL.Environment.Err
                                                                                                                                                                                         GHC.Types.IO)>_R
                                                                                                                                                                                   <a>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                                                                                                         SEDEL.Environment.Ctx
                                                                                                                                                                                                                                                         (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                            SEDEL.Environment.Err
                                                                                                                                                                                                                                                            GHC.Types.IO)>_N <a>_N))
                  (\ @ a
                     (m1 :: Unbound.Generics.LocallyNameless.Fresh.FreshMT
                              (Control.Monad.Trans.Reader.ReaderT
                                 SEDEL.Environment.Ctx
                                 (Control.Monad.Trans.Except.ExceptT
                                    SEDEL.Environment.Err GHC.Types.IO))
                              a)
                     (h :: SEDEL.Environment.Err
                           -> Unbound.Generics.LocallyNameless.Fresh.FreshMT
                                (Control.Monad.Trans.Reader.ReaderT
                                   SEDEL.Environment.Ctx
                                   (Control.Monad.Trans.Except.ExceptT
                                      SEDEL.Environment.Err GHC.Types.IO))
                                a)
                     (eta2 :: GHC.Integer.Type.Integer) ->
                   let {
                     eta3 :: Control.Monad.Trans.Reader.ReaderT
                               SEDEL.Environment.Ctx
                               (Control.Monad.Trans.Except.ExceptT
                                  SEDEL.Environment.Err GHC.Types.IO)
                               (a, GHC.Integer.Type.Integer)
                     = m1
                         `cast`
                       (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0] <Control.Monad.Trans.Reader.ReaderT
                                                                               SEDEL.Environment.Ctx
                                                                               (Control.Monad.Trans.Except.ExceptT
                                                                                  SEDEL.Environment.Err
                                                                                  GHC.Types.IO)>_N <a>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                               <GHC.Integer.Type.Integer>_N
                                                                                                               <Control.Monad.Trans.Reader.ReaderT
                                                                                                                  SEDEL.Environment.Ctx
                                                                                                                  (Control.Monad.Trans.Except.ExceptT
                                                                                                                     SEDEL.Environment.Err
                                                                                                                     GHC.Types.IO)>_R
                                                                                                               <a>_N)
                         eta2
                   } in
                   (\ (eta4 :: SEDEL.Environment.Ctx)
                      (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                    case (eta3
                            `cast`
                          (Control.Monad.Trans.Reader.N:ReaderT[0]
                               <*>_N
                               <SEDEL.Environment.Ctx>_R
                               <Control.Monad.Trans.Except.ExceptT
                                  SEDEL.Environment.Err GHC.Types.IO>_R
                               <(a, GHC.Integer.Type.Integer)>_N)
                            eta4)
                           `cast`
                         (Control.Monad.Trans.Except.N:ExceptT[0]
                              <SEDEL.Environment.Err>_N
                              <GHC.Types.IO>_R
                              <(a, GHC.Integer.Type.Integer)>_N ; GHC.Types.N:IO[0]
                                                                      <Data.Either.Either
                                                                         SEDEL.Environment.Err
                                                                         (a,
                                                                          GHC.Integer.Type.Integer)>_R)
                           s of ds1 { (#,#) ipv ipv1 ->
                    case ipv1 of wild {
                      Data.Either.Left l
                      -> (((h l)
                             `cast`
                           (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0] <Control.Monad.Trans.Reader.ReaderT
                                                                                   SEDEL.Environment.Ctx
                                                                                   (Control.Monad.Trans.Except.ExceptT
                                                                                      SEDEL.Environment.Err
                                                                                      GHC.Types.IO)>_N <a>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                   <GHC.Integer.Type.Integer>_N
                                                                                                                   <Control.Monad.Trans.Reader.ReaderT
                                                                                                                      SEDEL.Environment.Ctx
                                                                                                                      (Control.Monad.Trans.Except.ExceptT
                                                                                                                         SEDEL.Environment.Err
                                                                                                                         GHC.Types.IO)>_R
                                                                                                                   <a>_N)
                             eta2)
                            `cast`
                          (Control.Monad.Trans.Reader.N:ReaderT[0]
                               <*>_N
                               <SEDEL.Environment.Ctx>_R
                               <Control.Monad.Trans.Except.ExceptT
                                  SEDEL.Environment.Err GHC.Types.IO>_R
                               <(a, GHC.Integer.Type.Integer)>_N)
                            eta4)
                           `cast`
                         (Control.Monad.Trans.Except.N:ExceptT[0]
                              <SEDEL.Environment.Err>_N
                              <GHC.Types.IO>_R
                              <(a, GHC.Integer.Type.Integer)>_N ; GHC.Types.N:IO[0]
                                                                      <Data.Either.Either
                                                                         SEDEL.Environment.Err
                                                                         (a,
                                                                          GHC.Integer.Type.Integer)>_R)
                           ipv
                      Data.Either.Right r
                      -> (# ipv,
                            Data.Either.Right
                              @ SEDEL.Environment.Err
                              @ (a, GHC.Integer.Type.Integer)
                              r #) } })
                     `cast`
                   ((<SEDEL.Environment.Ctx>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <Data.Either.Either
                                      SEDEL.Environment.Err
                                      (a,
                                       GHC.Integer.Type.Integer)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <SEDEL.Environment.Err>_N
                                                                                <GHC.Types.IO>_R
                                                                                <(a,
                                                                                  GHC.Integer.Type.Integer)>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                            <*>_N
                                                                                                                            <SEDEL.Environment.Ctx>_R
                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                               SEDEL.Environment.Err
                                                                                                                               GHC.Types.IO>_R
                                                                                                                            <(a,
                                                                                                                              GHC.Integer.Type.Integer)>_N)))
                    `cast`
                  (forall (a :: <*>_N).
                   <Unbound.Generics.LocallyNameless.Fresh.FreshMT
                      (Control.Monad.Trans.Reader.ReaderT
                         SEDEL.Environment.Ctx
                         (Control.Monad.Trans.Except.ExceptT
                            SEDEL.Environment.Err GHC.Types.IO))
                      a>_R
                   ->_R <SEDEL.Environment.Err
                         -> Unbound.Generics.LocallyNameless.Fresh.FreshMT
                              (Control.Monad.Trans.Reader.ReaderT
                                 SEDEL.Environment.Ctx
                                 (Control.Monad.Trans.Except.ExceptT
                                    SEDEL.Environment.Err GHC.Types.IO))
                              a>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Reader.ReaderT
                                    SEDEL.Environment.Ctx
                                    (Control.Monad.Trans.Except.ExceptT
                                       SEDEL.Environment.Err GHC.Types.IO)>_R
                                 <a>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                       SEDEL.Environment.Ctx
                                                                                                       (Control.Monad.Trans.Except.ExceptT
                                                                                                          SEDEL.Environment.Err
                                                                                                          GHC.Types.IO)>_N <a>_N) -}
03329f2aa47f27ad6b16238041ee9b0f
  $s$fMonadReaderrFreshMT ::
    Control.Monad.Reader.Class.MonadReader
      SEDEL.Environment.Ctx
      (Unbound.Generics.LocallyNameless.Fresh.FreshMT
         (Control.Monad.Trans.Reader.ReaderT
            SEDEL.Environment.Ctx
            (Control.Monad.Trans.Except.ExceptT
               SEDEL.Environment.Err GHC.Types.IO)))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ SEDEL.Environment.Ctx
                  @ (Unbound.Generics.LocallyNameless.Fresh.FreshMT
                       (Control.Monad.Trans.Reader.ReaderT
                          SEDEL.Environment.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             SEDEL.Environment.Err GHC.Types.IO)))
                  (Unbound.Generics.LocallyNameless.Fresh.$fMonadFreshMT
                     @ (Control.Monad.Trans.Reader.ReaderT
                          SEDEL.Environment.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             SEDEL.Environment.Err GHC.Types.IO))
                     (SEDEL.Source.TypeCheck.$s$fFreshFreshMT_$s$fMonadReaderT
                        @ SEDEL.Environment.Ctx))
                  (\ (eta2 :: GHC.Integer.Type.Integer)
                     (r1 :: SEDEL.Environment.Ctx)
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   (# s,
                      Data.Either.Right
                        @ SEDEL.Environment.Err
                        @ (SEDEL.Environment.Ctx, GHC.Integer.Type.Integer)
                        (r1, eta2) #))
                    `cast`
                  ((<GHC.Integer.Type.Integer>_R
                    ->_R (<SEDEL.Environment.Ctx>_R
                          ->_R Sym (GHC.Types.N:IO[0]
                                        <Data.Either.Either
                                           SEDEL.Environment.Err
                                           (SEDEL.Environment.Ctx,
                                            GHC.Integer.Type.Integer)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                     <SEDEL.Environment.Err>_N
                                                                                     <GHC.Types.IO>_R
                                                                                     <(SEDEL.Environment.Ctx,
                                                                                       GHC.Integer.Type.Integer)>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                                 <*>_N
                                                                                                                                 <SEDEL.Environment.Ctx>_R
                                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                                    SEDEL.Environment.Err
                                                                                                                                    GHC.Types.IO>_R
                                                                                                                                 <(SEDEL.Environment.Ctx,
                                                                                                                                   GHC.Integer.Type.Integer)>_N)) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                              <GHC.Integer.Type.Integer>_N
                                                                                                                                                                              <Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                                 SEDEL.Environment.Ctx
                                                                                                                                                                                 (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                    SEDEL.Environment.Err
                                                                                                                                                                                    GHC.Types.IO)>_R
                                                                                                                                                                              <SEDEL.Environment.Ctx>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                                                                                                                        SEDEL.Environment.Ctx
                                                                                                                                                                                                                                                                        (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                           SEDEL.Environment.Err
                                                                                                                                                                                                                                                                           GHC.Types.IO)>_N <SEDEL.Environment.Ctx>_N))
                  (\ @ a
                     (f :: SEDEL.Environment.Ctx -> SEDEL.Environment.Ctx)
                     (x :: Unbound.Generics.LocallyNameless.Fresh.FreshMT
                             (Control.Monad.Trans.Reader.ReaderT
                                SEDEL.Environment.Ctx
                                (Control.Monad.Trans.Except.ExceptT
                                   SEDEL.Environment.Err GHC.Types.IO))
                             a)
                     (x1 :: GHC.Integer.Type.Integer) ->
                   let {
                     m1 :: Control.Monad.Trans.Reader.ReaderT
                             SEDEL.Environment.Ctx
                             (Control.Monad.Trans.Except.ExceptT
                                SEDEL.Environment.Err GHC.Types.IO)
                             (a, GHC.Integer.Type.Integer)
                     = x `cast`
                       (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0] <Control.Monad.Trans.Reader.ReaderT
                                                                               SEDEL.Environment.Ctx
                                                                               (Control.Monad.Trans.Except.ExceptT
                                                                                  SEDEL.Environment.Err
                                                                                  GHC.Types.IO)>_N <a>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                               <GHC.Integer.Type.Integer>_N
                                                                                                               <Control.Monad.Trans.Reader.ReaderT
                                                                                                                  SEDEL.Environment.Ctx
                                                                                                                  (Control.Monad.Trans.Except.ExceptT
                                                                                                                     SEDEL.Environment.Err
                                                                                                                     GHC.Types.IO)>_R
                                                                                                               <a>_N)
                         x1
                   } in
                   (\ (x2 :: SEDEL.Environment.Ctx) ->
                    m1
                      `cast`
                    (Control.Monad.Trans.Reader.N:ReaderT[0]
                         <*>_N
                         <SEDEL.Environment.Ctx>_R
                         <Control.Monad.Trans.Except.ExceptT
                            SEDEL.Environment.Err GHC.Types.IO>_R
                         <(a, GHC.Integer.Type.Integer)>_N)
                      (f x2))
                     `cast`
                   (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N
                             <SEDEL.Environment.Ctx>_R
                             <Control.Monad.Trans.Except.ExceptT
                                SEDEL.Environment.Err GHC.Types.IO>_R
                             <(a, GHC.Integer.Type.Integer)>_N)))
                    `cast`
                  (forall (a :: <*>_N).
                   <SEDEL.Environment.Ctx -> SEDEL.Environment.Ctx>_R
                   ->_R <Unbound.Generics.LocallyNameless.Fresh.FreshMT
                           (Control.Monad.Trans.Reader.ReaderT
                              SEDEL.Environment.Ctx
                              (Control.Monad.Trans.Except.ExceptT
                                 SEDEL.Environment.Err GHC.Types.IO))
                           a>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Reader.ReaderT
                                    SEDEL.Environment.Ctx
                                    (Control.Monad.Trans.Except.ExceptT
                                       SEDEL.Environment.Err GHC.Types.IO)>_R
                                 <a>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                       SEDEL.Environment.Ctx
                                                                                                       (Control.Monad.Trans.Except.ExceptT
                                                                                                          SEDEL.Environment.Err
                                                                                                          GHC.Types.IO)>_N <a>_N)
                  (Unbound.Generics.LocallyNameless.Fresh.$fMonadReaderrFreshMT1
                     @ SEDEL.Environment.Ctx
                     @ (Control.Monad.Trans.Reader.ReaderT
                          SEDEL.Environment.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             SEDEL.Environment.Err GHC.Types.IO))
                     (SEDEL.Source.TypeCheck.$s$fMonadReaderrFreshMT_$s$fMonadReaderrReaderT
                        @ SEDEL.Environment.Ctx))
                    `cast`
                  (forall (a :: <*>_N).
                   <SEDEL.Environment.Ctx -> a>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Reader.ReaderT
                                    SEDEL.Environment.Ctx
                                    (Control.Monad.Trans.Except.ExceptT
                                       SEDEL.Environment.Err GHC.Types.IO)>_R
                                 <a>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                       SEDEL.Environment.Ctx
                                                                                                       (Control.Monad.Trans.Except.ExceptT
                                                                                                          SEDEL.Environment.Err
                                                                                                          GHC.Types.IO)>_N <a>_N) -}
5af49a74fb819df0112ff0d69d51b039
  $s$fMonadReaderrFreshMT_$s$fMonadReaderrReaderT ::
    Control.Monad.Reader.Class.MonadReader
      r
      (Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ r.
                  @ r
                  @ (Control.Monad.Trans.Reader.ReaderT
                       r
                       (Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO))
                  (SEDEL.Source.TypeCheck.$s$fFreshFreshMT_$s$fMonadReaderT @ r)
                  (\ (eta2 :: r) (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   (# s, Data.Either.Right @ SEDEL.Environment.Err @ r eta2 #))
                    `cast`
                  ((<r>_R
                    ->_R Sym (GHC.Types.N:IO[0]
                                  <Data.Either.Either
                                     SEDEL.Environment.Err
                                     r>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                      <SEDEL.Environment.Err>_N
                                                      <GHC.Types.IO>_R
                                                      <r>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                         <*>_N
                                                                         <r>_R
                                                                         <Control.Monad.Trans.Except.ExceptT
                                                                            SEDEL.Environment.Err
                                                                            GHC.Types.IO>_R
                                                                         <r>_N))
                  (Control.Monad.Trans.Reader.withReaderT
                     @ *
                     @ r
                     @ r
                     @ (Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO))
                  (\ @ a ->
                   Control.Monad.Trans.Reader.reader
                     @ (Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO)
                     @ r
                     @ a
                     (SEDEL.Source.TypeCheck.$s$fFreshFreshMT_$s$fMonadExceptT
                        @ SEDEL.Environment.Err)) -}
e7d058a3fd4777d414088094064956db
  $s$fShowEmbed_$cshowsPrec ::
    GHC.Types.Int
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,A><L,U>, Inline: [0],
     Unfolding: InlineRule (2, True, True)
                (\ (w1 :: GHC.Types.Int)
                   (w2 :: Unbound.Generics.LocallyNameless.Embed.Embed
                            (GHC.Base.Maybe SEDEL.Source.Syntax.SType)) ->
                 Unbound.Generics.LocallyNameless.Embed.$w$cshowsPrec
                   @ (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
                   SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fShowMaybe
                   w2) -}
416dfd94664c7181ab31d20d46215703
  $s$fShowEmbed_$cshowsPrec1 ::
    GHC.Types.Int
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,A><L,U>, Inline: [0],
     Unfolding: InlineRule (2, True, True)
                (\ (w1 :: GHC.Types.Int)
                   (w2 :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType) ->
                 Unbound.Generics.LocallyNameless.Embed.$w$cshowsPrec
                   @ SEDEL.Source.Syntax.SType
                   SEDEL.Source.Syntax.$fShowSType
                   w2) -}
d8c6cc811e184778ef9f1cc6fd51f6ac
  $s$fShowMaybe_$cshowList ::
    [GHC.Base.Maybe SEDEL.Source.Syntax.SType] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [GHC.Base.Maybe SEDEL.Source.Syntax.SType])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (GHC.Base.Maybe SEDEL.Source.Syntax.SType)
                   (GHC.Show.$fShowMaybe_$cshowsPrec
                      @ SEDEL.Source.Syntax.SType
                      SEDEL.Source.Syntax.$fShowSType
                      GHC.Show.$fShow(,)1)
                   ls
                   s) -}
ca981edcf14d16323fe662375c624db0
  $sfromList ::
    [(SEDEL.Source.Syntax.Label, a)]
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: [(SEDEL.Source.Syntax.Label, a)]) ->
                 case ds of wild {
                   [] -> Data.Map.Internal.Tip @ SEDEL.Source.Syntax.Label @ a
                   : ds1 ds2
                   -> case ds1 of wild1 { (,) kx x ->
                      case ds2 of wild2 {
                        []
                        -> case kx of dt { DEFAULT ->
                           Data.Map.Internal.Bin
                             @ SEDEL.Source.Syntax.Label
                             @ a
                             1#
                             dt
                             x
                             (Data.Map.Internal.Tip @ SEDEL.Source.Syntax.Label @ a)
                             (Data.Map.Internal.Tip @ SEDEL.Source.Syntax.Label @ a) }
                        : ipv ipv1
                        -> case ipv of wild3 { (,) ky ds3 ->
                           case GHC.Classes.$fOrd[]_$s$ccompare1 kx ky of wild4 {
                             DEFAULT
                             -> case kx of dt { DEFAULT ->
                                SEDEL.Source.TypeCheck.$sfromList1
                                  @ a
                                  (Data.Map.Internal.Bin
                                     @ SEDEL.Source.Syntax.Label
                                     @ a
                                     1#
                                     dt
                                     x
                                     (Data.Map.Internal.Tip @ SEDEL.Source.Syntax.Label @ a)
                                     (Data.Map.Internal.Tip @ SEDEL.Source.Syntax.Label @ a))
                                  wild2 }
                             GHC.Types.LT
                             -> case kx of dt { DEFAULT ->
                                SEDEL.Source.TypeCheck.$wpoly_go13
                                  @ a
                                  1#
                                  (Data.Map.Internal.Bin
                                     @ SEDEL.Source.Syntax.Label
                                     @ a
                                     1#
                                     dt
                                     x
                                     (Data.Map.Internal.Tip @ SEDEL.Source.Syntax.Label @ a)
                                     (Data.Map.Internal.Tip @ SEDEL.Source.Syntax.Label @ a))
                                  wild2 } } } } } }) -}
1b24bbba09d10b59849e0e10a9e67ae7
  $sfromList1 ::
    Data.Map.Internal.Map SEDEL.Source.Syntax.Label a
    -> [(SEDEL.Source.Syntax.Label, a)]
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
896409a0d3c820c7e5237f8cf8a10228
  $sinsertWithR_$sgo13 ::
    (a1 -> a1 -> a1)
    -> SEDEL.Source.Syntax.Label
    -> a1
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a1
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a1
  {- Arity: 4, Strictness: <L,1*C1(C1(U))><S,1*U><L,U><S,1*U> -}
46990ee3a8590347e7b2e0922a96532f
  $sinsertWith_$sgo13 ::
    (a1 -> a1 -> a1)
    -> SEDEL.Source.Syntax.Label
    -> a1
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a1
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a1
  {- Arity: 4, Strictness: <L,1*C1(C1(U))><S,1*U><L,U><S,1*U> -}
7274bc4a694ad38fb1fa25662a066e94
  $sinsert_$sgo13 ::
    SEDEL.Source.Syntax.Label
    -> SEDEL.Source.Syntax.Label
    -> a1
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a1
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a1
  {- Arity: 4, Strictness: <L,U><S,1*U><L,U><S,1*U> -}
b4c270a9832803663e93318cc0bd7e7a
  $slookup1 ::
    SEDEL.Source.Syntax.Label
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a
    -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
40bee4975ed71d27506998519bbae311
  $sunionWith ::
    (a -> a -> a)
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a
  {- Arity: 3, Strictness: <L,C(C1(U))><S,1*U><S,1*U>, Inline: [~] -}
21dd5307e8d7b6928118008c345e9c2b
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   SEDEL.Source.TypeCheck.$trModule3
                   SEDEL.Source.TypeCheck.$trModule1) -}
85bba12ea19c198df3b3b817db1aac9d
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.TypeCheck.$trModule2) -}
fc32a8291d31079726add010c51a6170
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SEDEL.Source.TypeCheck"#) -}
c43ce31225787a2fc3f41448bafb0590
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.TypeCheck.$trModule4) -}
1ff5221b9232db6026b6c481f629114f
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("sedel-0.1.0.0-BGuUapfeRSQ3zXo3bqhidP"#) -}
7568b409e78e445c027e76a84c1f2fb2
  $w$sgo13 ::
    SEDEL.Source.Syntax.Label
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a1
    -> (# Data.Map.Internal.Map SEDEL.Source.Syntax.Label a1,
          GHC.Base.Maybe a1,
          Data.Map.Internal.Map SEDEL.Source.Syntax.Label a1 #)
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [0] -}
441b24e95af82fbe4baf3371ae557b34
  $wpoly_go13 ::
    GHC.Prim.Int#
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a
    -> [(SEDEL.Source.Syntax.Label, a)]
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.Label a
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U>, Inline: [0] -}
7dbcf6a1476f751251c31187be27c963
  tcModule ::
    SEDEL.Source.Syntax.Module
    -> SEDEL.Environment.TcMonad
         (SEDEL.Source.Syntax.SType, SEDEL.Target.Syntax.UExpr)
  {- Arity: 1, Strictness: <L,1*U(1*U,1*U)>,
     Unfolding: (\ (m :: SEDEL.Source.Syntax.Module) ->
                 let {
                   m1 :: SEDEL.Environment.TcMonad
                           (SEDEL.Source.Syntax.SType, SEDEL.Target.Syntax.UExpr)
                   = case m of wild { SEDEL.Source.Syntax.Module ds1 ds2 ->
                     SEDEL.Source.TypeCheck.tcModule_tcM
                       (GHC.Base.map
                          @ SEDEL.Source.Syntax.SDecl
                          @ SEDEL.Source.Syntax.SDecl
                          SEDEL.Source.Desugar.desugar1
                          ds1)
                       (case ds2 of wild1 {
                          SEDEL.Source.Syntax.DefDecl mainE
                          -> case mainE of wild2 { SEDEL.Source.Syntax.TmBind ds ds4 ds5 ds3 ds6 ds7 ->
                             SEDEL.Source.Syntax.TmBind
                               ds
                               ds4
                               ds5
                               (case SEDEL.Source.Desugar.$w$sgo
                                       ds3
                                       Unbound.Generics.LocallyNameless.Fresh.runFreshM1 of ww { (#,#) ww1 ww2 ->
                                ww1 })
                               ds6
                               ds7 }
                          SEDEL.Source.Syntax.TypeDecl ipv
                          -> case SEDEL.Source.TypeCheck.tcModule1
                             ret_ty SEDEL.Source.Syntax.TmBind
                             of {} }) }
                 } in
                 (\ (s1 :: GHC.Integer.Type.Integer) ->
                  let {
                    m2 :: Control.Monad.Trans.Reader.ReaderT
                            SEDEL.Environment.Ctx
                            (Control.Monad.Trans.Except.ExceptT
                               SEDEL.Environment.Err GHC.Types.IO)
                            ((SEDEL.Source.Syntax.SType, SEDEL.Target.Syntax.UExpr),
                             GHC.Integer.Type.Integer)
                    = m1
                        `cast`
                      (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0] <Control.Monad.Trans.Reader.ReaderT
                                                                              SEDEL.Environment.Ctx
                                                                              (Control.Monad.Trans.Except.ExceptT
                                                                                 SEDEL.Environment.Err
                                                                                 GHC.Types.IO)>_N <(SEDEL.Source.Syntax.SType,
                                                                                                    SEDEL.Target.Syntax.UExpr)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                        <GHC.Integer.Type.Integer>_N
                                                                                                                                        <Control.Monad.Trans.Reader.ReaderT
                                                                                                                                           SEDEL.Environment.Ctx
                                                                                                                                           (Control.Monad.Trans.Except.ExceptT
                                                                                                                                              SEDEL.Environment.Err
                                                                                                                                              GHC.Types.IO)>_R
                                                                                                                                        <(SEDEL.Source.Syntax.SType,
                                                                                                                                          SEDEL.Target.Syntax.UExpr)>_N)
                        s1
                  } in
                  (\ (r1 :: SEDEL.Environment.Ctx)
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (m2
                           `cast`
                         (Control.Monad.Trans.Reader.N:ReaderT[0]
                              <*>_N
                              <SEDEL.Environment.Ctx>_R
                              <Control.Monad.Trans.Except.ExceptT
                                 SEDEL.Environment.Err GHC.Types.IO>_R
                              <((SEDEL.Source.Syntax.SType, SEDEL.Target.Syntax.UExpr),
                                GHC.Integer.Type.Integer)>_N)
                           r1)
                          `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <SEDEL.Environment.Err>_N
                             <GHC.Types.IO>_R
                             <((SEDEL.Source.Syntax.SType, SEDEL.Target.Syntax.UExpr),
                               GHC.Integer.Type.Integer)>_N ; GHC.Types.N:IO[0]
                                                                  <Data.Either.Either
                                                                     SEDEL.Environment.Err
                                                                     ((SEDEL.Source.Syntax.SType,
                                                                       SEDEL.Target.Syntax.UExpr),
                                                                      GHC.Integer.Type.Integer)>_R)
                          s of ds1 { (#,#) ipv ipv1 ->
                   case ipv1 of wild {
                     Data.Either.Left e1 -> ds1
                     Data.Either.Right x
                     -> case x of wild1 { (,) a1 s' ->
                        case a1 of wild2 { (,) ty target -> ds1 } } } })
                    `cast`
                  ((<SEDEL.Environment.Ctx>_R
                    ->_R Sym (GHC.Types.N:IO[0]
                                  <Data.Either.Either
                                     SEDEL.Environment.Err
                                     ((SEDEL.Source.Syntax.SType, SEDEL.Target.Syntax.UExpr),
                                      GHC.Integer.Type.Integer)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                               <SEDEL.Environment.Err>_N
                                                                               <GHC.Types.IO>_R
                                                                               <((SEDEL.Source.Syntax.SType,
                                                                                  SEDEL.Target.Syntax.UExpr),
                                                                                 GHC.Integer.Type.Integer)>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                           <*>_N
                                                                                                                           <SEDEL.Environment.Ctx>_R
                                                                                                                           <Control.Monad.Trans.Except.ExceptT
                                                                                                                              SEDEL.Environment.Err
                                                                                                                              GHC.Types.IO>_R
                                                                                                                           <((SEDEL.Source.Syntax.SType,
                                                                                                                              SEDEL.Target.Syntax.UExpr),
                                                                                                                             GHC.Integer.Type.Integer)>_N)))
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <GHC.Integer.Type.Integer>_N
                           <Control.Monad.Trans.Reader.ReaderT
                              SEDEL.Environment.Ctx
                              (Control.Monad.Trans.Except.ExceptT
                                 SEDEL.Environment.Err GHC.Types.IO)>_R
                           <(SEDEL.Source.Syntax.SType,
                             SEDEL.Target.Syntax.UExpr)>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                                           SEDEL.Environment.Ctx
                                                                                                                           (Control.Monad.Trans.Except.ExceptT
                                                                                                                              SEDEL.Environment.Err
                                                                                                                              GHC.Types.IO)>_N <(SEDEL.Source.Syntax.SType,
                                                                                                                                                 SEDEL.Target.Syntax.UExpr)>_N)) -}
9dc8b4b5cc07cd2bc8849ed250ee060c
  tcModule1 :: (SEDEL.Source.Syntax.TmBind)
  {- Strictness: x -}
d158c920b011cec4b3630d3f1f6a2db1
  tcModule_tcM ::
    [SEDEL.Source.Syntax.SDecl]
    -> SEDEL.Source.Syntax.TmBind
    -> SEDEL.Environment.TcMonad
         (SEDEL.Source.Syntax.SType, SEDEL.Target.Syntax.UExpr)
  {- Arity: 2, Strictness: <S,1*U><L,U(U,A,U,U,A,A)> -}
"SPEC/SEDEL.Source.TypeCheck $fAlpha(,) @ (Name SType) @ (Embed
                                                           SType)" [orphan] forall (v1 :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                            (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                                                                                                               SEDEL.Source.Syntax.SType))
                                                                                                                                                   (v :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                           (Unbound.Generics.LocallyNameless.Name.Name
                                                                                                                                                              SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Alpha.$fAlpha(,) @ (Unbound.Generics.LocallyNameless.Name.Name
                                                         SEDEL.Source.Syntax.SType)
                                                    @ (Unbound.Generics.LocallyNameless.Embed.Embed
                                                         SEDEL.Source.Syntax.SType)
                                                    v
                                                    v1
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)3
"SPEC/SEDEL.Source.TypeCheck $fAlpha(,)_$caeq' @ (Name
                                                   SType) @ (Embed SType)" [orphan] forall ($dAlpha1 :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                 (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                                                                                                                    SEDEL.Source.Syntax.SType))
                                                                                                                                                  ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                (Unbound.Generics.LocallyNameless.Name.Name
                                                                                                                                                                   SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Alpha.$fAlpha(,)_$caeq' @ (Unbound.Generics.LocallyNameless.Name.Name
                                                                SEDEL.Source.Syntax.SType)
                                                           @ (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                SEDEL.Source.Syntax.SType)
                                                           $dAlpha
                                                           $dAlpha1
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$caeq'3
"SPEC/SEDEL.Source.TypeCheck $fAlpha(,)_$cclose @ (Name
                                                    SType) @ (Embed SType)" [orphan] forall ($dAlpha1 :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                   (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                                                                                                                      SEDEL.Source.Syntax.SType))
                                                                                                                                                    ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                  (Unbound.Generics.LocallyNameless.Name.Name
                                                                                                                                                                     SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Alpha.$fAlpha(,)_$cclose @ (Unbound.Generics.LocallyNameless.Name.Name
                                                                 SEDEL.Source.Syntax.SType)
                                                            @ (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                 SEDEL.Source.Syntax.SType)
                                                            $dAlpha
                                                            $dAlpha1
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$cclose3
"SPEC/SEDEL.Source.TypeCheck $fAlpha(,)_$cfreshen' @ (Name
                                                       SType) @ (Embed SType)" [orphan] [0] forall (w1 :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                       (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                                                                                                                          SEDEL.Source.Syntax.SType))
                                                                                                                                                              (w :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                      (Unbound.Generics.LocallyNameless.Name.Name
                                                                                                                                                                         SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Alpha.$fAlpha(,)_$cfreshen' @ (Unbound.Generics.LocallyNameless.Name.Name
                                                                    SEDEL.Source.Syntax.SType)
                                                               @ (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                    SEDEL.Source.Syntax.SType)
                                                               w
                                                               w1
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$cfreshen'1
"SPEC/SEDEL.Source.TypeCheck $fAlpha(,)_$cfvAny' @ (Name
                                                     SType) @ (Embed SType)" [orphan] forall ($dAlpha1 :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                     (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                                                                                                                        SEDEL.Source.Syntax.SType))
                                                                                                                                                      ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                    (Unbound.Generics.LocallyNameless.Name.Name
                                                                                                                                                                       SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Alpha.$fAlpha(,)_$cfvAny' @ (Unbound.Generics.LocallyNameless.Name.Name
                                                                  SEDEL.Source.Syntax.SType)
                                                             @ (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                  SEDEL.Source.Syntax.SType)
                                                             $dAlpha
                                                             $dAlpha1
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$cfvAny'3
"SPEC/SEDEL.Source.TypeCheck $fAlpha(,)_$cisEmbed @ (Name
                                                      SType) @ (Embed SType)" [orphan] forall ($dAlpha1 :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                       (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                                                                                                                          SEDEL.Source.Syntax.SType))
                                                                                                                                                        ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                      (Unbound.Generics.LocallyNameless.Name.Name
                                                                                                                                                                         SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Alpha.$fAlpha(,)_$cisEmbed @ (Unbound.Generics.LocallyNameless.Name.Name
                                                                   SEDEL.Source.Syntax.SType)
                                                              @ (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                   SEDEL.Source.Syntax.SType)
                                                              $dAlpha
                                                              $dAlpha1
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$cisEmbed3
"SPEC/SEDEL.Source.TypeCheck $fAlpha(,)_$clfreshen' @ (Name
                                                        SType) @ (Embed SType)" [orphan] forall ($dAlpha1 :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                           (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                                                                                                                              SEDEL.Source.Syntax.SType))
                                                                                                                                                            ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                          (Unbound.Generics.LocallyNameless.Name.Name
                                                                                                                                                                             SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Alpha.$fAlpha(,)_$clfreshen' @ (Unbound.Generics.LocallyNameless.Name.Name
                                                                     SEDEL.Source.Syntax.SType)
                                                                @ (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                     SEDEL.Source.Syntax.SType)
                                                                $dAlpha
                                                                $dAlpha1
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$clfreshen'3
"SPEC/SEDEL.Source.TypeCheck $fAlpha(,)_$copen @ (Name
                                                   SType) @ (Embed SType)" [orphan] forall ($dAlpha1 :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                 (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                                                                                                                    SEDEL.Source.Syntax.SType))
                                                                                                                                                  ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                (Unbound.Generics.LocallyNameless.Name.Name
                                                                                                                                                                   SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Alpha.$fAlpha(,)_$copen @ (Unbound.Generics.LocallyNameless.Name.Name
                                                                SEDEL.Source.Syntax.SType)
                                                           @ (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                SEDEL.Source.Syntax.SType)
                                                           $dAlpha
                                                           $dAlpha1
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$copen3
"SPEC/SEDEL.Source.TypeCheck $fAlpha(,)_$cswaps' @ (Name
                                                     SType) @ (Embed SType)" [orphan] forall ($dAlpha1 :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                     (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                                                                                                                        SEDEL.Source.Syntax.SType))
                                                                                                                                                      ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                                    (Unbound.Generics.LocallyNameless.Name.Name
                                                                                                                                                                       SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Alpha.$fAlpha(,)_$cswaps' @ (Unbound.Generics.LocallyNameless.Name.Name
                                                                  SEDEL.Source.Syntax.SType)
                                                             @ (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                  SEDEL.Source.Syntax.SType)
                                                             $dAlpha
                                                             $dAlpha1
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlpha(,)_$cswaps'3
"SPEC/SEDEL.Source.TypeCheck $fAlphaEmbed @ (Maybe SType)" [orphan] forall (v :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                   (GHC.Base.Maybe
                                                                                      SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed @ (GHC.Base.Maybe
                                                           SEDEL.Source.Syntax.SType)
                                                      v
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlphaEmbed
"SPEC/SEDEL.Source.TypeCheck $fAlphaEmbed @ SType" [orphan] forall (v :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                           SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed @ SEDEL.Source.Syntax.SType
                                                      v
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlphaEmbed1
"SPEC/SEDEL.Source.TypeCheck $fAlphaEmbed_$cacompare' @ (Maybe
                                                          SType)" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                                                                               (GHC.Base.Maybe
                                                                                                                                                                  SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cacompare' @ (GHC.Base.Maybe
                                                                       SEDEL.Source.Syntax.SType)
                                                                  $dAlpha
  = SEDEL.Source.TypeCheck.$s$fAlphaEmbed_$cacompare'1
"SPEC/SEDEL.Source.TypeCheck $fAlphaEmbed_$caeq' @ (Maybe SType)" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                (GHC.Base.Maybe
                                                                                                   SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$caeq' @ (GHC.Base.Maybe
                                                                  SEDEL.Source.Syntax.SType)
                                                             $dAlpha
  = SEDEL.Source.TypeCheck.$s$fAlphaEmbed_$caeq'1
"SPEC/SEDEL.Source.TypeCheck $fAlphaEmbed_$cclose @ (Maybe SType)" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                 (GHC.Base.Maybe
                                                                                                    SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cclose @ (GHC.Base.Maybe
                                                                   SEDEL.Source.Syntax.SType)
                                                              $dAlpha
  = SEDEL.Source.TypeCheck.$s$fAlphaEmbed_$cclose1
"SPEC/SEDEL.Source.TypeCheck $fAlphaEmbed_$cfreshen' @ (Maybe SType)" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                    (GHC.Base.Maybe
                                                                                                       SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cfreshen' @ (GHC.Base.Maybe
                                                                      SEDEL.Source.Syntax.SType)
                                                                 $dAlpha
  = SEDEL.Source.TypeCheck.$s$fAlphaEmbed_$cfreshen'1
"SPEC/SEDEL.Source.TypeCheck $fAlphaEmbed_$cisPat @ (Maybe SType)" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                 (GHC.Base.Maybe
                                                                                                    SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cisPat @ (GHC.Base.Maybe
                                                                   SEDEL.Source.Syntax.SType)
                                                              $dAlpha
  = SEDEL.Source.TypeCheck.$s$fAlphaEmbed_$cisPat1
"SPEC/SEDEL.Source.TypeCheck $fAlphaEmbed_$copen @ (Maybe SType)" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                (GHC.Base.Maybe
                                                                                                   SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$copen @ (GHC.Base.Maybe
                                                                  SEDEL.Source.Syntax.SType)
                                                             $dAlpha
  = SEDEL.Source.TypeCheck.$s$fAlphaEmbed_$copen1
"SPEC/SEDEL.Source.TypeCheck $fAlphaEmbed_$cswaps' @ (Maybe SType)" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                                  (GHC.Base.Maybe
                                                                                                     SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cswaps' @ (GHC.Base.Maybe
                                                                    SEDEL.Source.Syntax.SType)
                                                               $dAlpha
  = SEDEL.Source.TypeCheck.$s$fAlphaEmbed_$cswaps'1
"SPEC/SEDEL.Source.TypeCheck $fAlphaMaybe @ SType" [orphan] forall (v :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                           SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Alpha.$fAlphaMaybe @ SEDEL.Source.Syntax.SType
                                                      v
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlphaMaybe
"SPEC/SEDEL.Source.TypeCheck $fAlphaMaybe_$caeq' @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                        SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Alpha.$fAlphaMaybe_$caeq' @ SEDEL.Source.Syntax.SType
                                                             $dAlpha
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlphaMaybe_$caeq'
"SPEC/SEDEL.Source.TypeCheck $fAlphaMaybe_$cclose @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                         SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Alpha.$fAlphaMaybe_$cclose @ SEDEL.Source.Syntax.SType
                                                              $dAlpha
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlphaMaybe_$cclose
"SPEC/SEDEL.Source.TypeCheck $fAlphaMaybe_$cfvAny' @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                          SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Alpha.$fAlphaMaybe_$cfvAny' @ SEDEL.Source.Syntax.SType
                                                               $dAlpha
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlphaMaybe_$cfvAny'
"SPEC/SEDEL.Source.TypeCheck $fAlphaMaybe_$cisEmbed @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                           SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Alpha.$fAlphaMaybe_$cisEmbed @ SEDEL.Source.Syntax.SType
                                                                $dAlpha
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlphaMaybe_$cisEmbed
"SPEC/SEDEL.Source.TypeCheck $fAlphaMaybe_$clfreshen' @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                             SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Alpha.$fAlphaMaybe_$clfreshen' @ SEDEL.Source.Syntax.SType
                                                                  $dAlpha
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlphaMaybe_$clfreshen'
"SPEC/SEDEL.Source.TypeCheck $fAlphaMaybe_$copen @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                        SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Alpha.$fAlphaMaybe_$copen @ SEDEL.Source.Syntax.SType
                                                             $dAlpha
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlphaMaybe_$copen
"SPEC/SEDEL.Source.TypeCheck $fAlphaMaybe_$cswaps' @ SType" [orphan] forall ($dAlpha :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                                          SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Alpha.$fAlphaMaybe_$cswaps' @ SEDEL.Source.Syntax.SType
                                                               $dAlpha
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fAlphaMaybe_$cswaps'
"SPEC/SEDEL.Source.TypeCheck $fApplicativeExceptT @ IO _" [orphan] forall @ e
                                                                          (v1 :: GHC.Base.Monad
                                                                                   GHC.Types.IO)
                                                                          (v :: GHC.Base.Functor
                                                                                  GHC.Types.IO)
  Control.Monad.Trans.Except.$fApplicativeExceptT @ GHC.Types.IO
                                                  @ e
                                                  v
                                                  v1
  = SEDEL.Source.TypeCheck.$s$fApplicativeExceptT @ e
"SPEC/SEDEL.Source.TypeCheck $fApplicativeExceptT_$c*> @ IO _" [orphan] forall @ e
                                                                               ($dMonad :: GHC.Base.Monad
                                                                                             GHC.Types.IO)
                                                                               ($dFunctor :: GHC.Base.Functor
                                                                                               GHC.Types.IO)
  Control.Monad.Trans.Except.$fApplicativeExceptT_$c*> @ GHC.Types.IO
                                                       @ e
                                                       $dFunctor
                                                       $dMonad
  = SEDEL.Source.TypeCheck.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$c*>
      @ e
"SPEC/SEDEL.Source.TypeCheck $fApplicativeExceptT_$cpure @ IO _" [orphan] forall @ e
                                                                                 ($dMonad :: GHC.Base.Monad
                                                                                               GHC.Types.IO)
                                                                                 ($dFunctor :: GHC.Base.Functor
                                                                                                 GHC.Types.IO)
  Control.Monad.Trans.Except.$fApplicativeExceptT_$cpure @ GHC.Types.IO
                                                         @ e
                                                         $dFunctor
                                                         $dMonad
  = SEDEL.Source.TypeCheck.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure
      @ e
"SPEC/SEDEL.Source.TypeCheck $fFreshFreshMT @ (ReaderT
                                                Ctx (ExceptT Err IO))" [orphan] forall (v :: GHC.Base.Monad
                                                                                                                                                      (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                         SEDEL.Environment.Ctx
                                                                                                                                                         (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                            SEDEL.Environment.Err
                                                                                                                                                            GHC.Types.IO)))
  Unbound.Generics.LocallyNameless.Fresh.$fFreshFreshMT @ (Control.Monad.Trans.Reader.ReaderT
                                                             SEDEL.Environment.Ctx
                                                             (Control.Monad.Trans.Except.ExceptT
                                                                SEDEL.Environment.Err GHC.Types.IO))
                                                        v
  = SEDEL.Source.TypeCheck.$s$fFreshFreshMT
"SPEC/SEDEL.Source.TypeCheck $fFunctorExceptT @ IO _" [orphan] forall @ e
                                                                      (v :: GHC.Base.Functor
                                                                              GHC.Types.IO)
  Control.Monad.Trans.Except.$fFunctorExceptT @ GHC.Types.IO @ e v
  = SEDEL.Source.TypeCheck.$s$fApplicativeExceptT_$s$fFunctorExceptT
      @ e
"SPEC/SEDEL.Source.TypeCheck $fMonadErroreFreshMT @ Err @ (ReaderT
                                                            Ctx (ExceptT Err IO))" [orphan] forall (v :: Control.Monad.Error.Class.MonadError
                                                                                                                                                                              SEDEL.Environment.Err
                                                                                                                                                                              (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                                 SEDEL.Environment.Ctx
                                                                                                                                                                                 (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                    SEDEL.Environment.Err
                                                                                                                                                                                    GHC.Types.IO)))
  Unbound.Generics.LocallyNameless.Fresh.$fMonadErroreFreshMT @ SEDEL.Environment.Err
                                                              @ (Control.Monad.Trans.Reader.ReaderT
                                                                   SEDEL.Environment.Ctx
                                                                   (Control.Monad.Trans.Except.ExceptT
                                                                      SEDEL.Environment.Err
                                                                      GHC.Types.IO))
                                                              v
  = SEDEL.Source.TypeCheck.$s$fMonadErroreFreshMT
"SPEC/SEDEL.Source.TypeCheck $fMonadExceptT @ IO _" [orphan] forall @ e
                                                                    (v :: GHC.Base.Monad
                                                                            GHC.Types.IO)
  Control.Monad.Trans.Except.$fMonadExceptT @ GHC.Types.IO @ e v
  = SEDEL.Source.TypeCheck.$s$fFreshFreshMT_$s$fMonadExceptT @ e
"SPEC/SEDEL.Source.TypeCheck $fMonadExceptT_$c>> @ IO _" [orphan] forall @ e
                                                                         ($dMonad :: GHC.Base.Monad
                                                                                       GHC.Types.IO)
  Control.Monad.Trans.Except.$fMonadExceptT_$c>> @ GHC.Types.IO
                                                 @ e
                                                 $dMonad
  = SEDEL.Source.TypeCheck.$s$fFreshFreshMT_$s$fMonadExceptT_$c>> @ e
"SPEC/SEDEL.Source.TypeCheck $fMonadExceptT_$c>>= @ IO _" [orphan] forall @ e
                                                                          ($dMonad :: GHC.Base.Monad
                                                                                        GHC.Types.IO)
  Control.Monad.Trans.Except.$fMonadExceptT_$c>>= @ GHC.Types.IO
                                                  @ e
                                                  $dMonad
  = SEDEL.Source.TypeCheck.$s$fFreshFreshMT_$s$fMonadExceptT_$c>>=
      @ e
"SPEC/SEDEL.Source.TypeCheck $fMonadReaderT @ (ExceptT Err IO) _" [orphan] forall @ r
                                                                                  (v :: GHC.Base.Monad
                                                                                          (Control.Monad.Trans.Except.ExceptT
                                                                                             SEDEL.Environment.Err
                                                                                             GHC.Types.IO))
  Control.Monad.Trans.Reader.$fMonadReaderT @ (Control.Monad.Trans.Except.ExceptT
                                                 SEDEL.Environment.Err GHC.Types.IO)
                                            @ r
                                            v
  = SEDEL.Source.TypeCheck.$s$fFreshFreshMT_$s$fMonadReaderT @ r
"SPEC/SEDEL.Source.TypeCheck $fMonadReaderrFreshMT @ Ctx @ (ReaderT
                                                             Ctx (ExceptT Err IO))" [orphan] forall (v :: Control.Monad.Reader.Class.MonadReader
                                                                                                                                                                                SEDEL.Environment.Ctx
                                                                                                                                                                                (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                                   SEDEL.Environment.Ctx
                                                                                                                                                                                   (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                      SEDEL.Environment.Err
                                                                                                                                                                                      GHC.Types.IO)))
  Unbound.Generics.LocallyNameless.Fresh.$fMonadReaderrFreshMT @ SEDEL.Environment.Ctx
                                                               @ (Control.Monad.Trans.Reader.ReaderT
                                                                    SEDEL.Environment.Ctx
                                                                    (Control.Monad.Trans.Except.ExceptT
                                                                       SEDEL.Environment.Err
                                                                       GHC.Types.IO))
                                                               v
  = SEDEL.Source.TypeCheck.$s$fMonadReaderrFreshMT
"SPEC/SEDEL.Source.TypeCheck $fMonadReaderrReaderT @ (ExceptT
                                                       Err IO) _" [orphan] forall @ r
                                                                                                                                                (v :: GHC.Base.Monad
                                                                                                                                                        (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                           SEDEL.Environment.Err
                                                                                                                                                           GHC.Types.IO))
  Control.Monad.Reader.Class.$fMonadReaderrReaderT @ (Control.Monad.Trans.Except.ExceptT
                                                        SEDEL.Environment.Err GHC.Types.IO)
                                                   @ r
                                                   v
  = SEDEL.Source.TypeCheck.$s$fMonadReaderrFreshMT_$s$fMonadReaderrReaderT
      @ r
"SPEC/SEDEL.Source.TypeCheck $fShow(,) @ (Name SType) @ (Embed
                                                          SType)" [orphan] forall (v1 :: GHC.Show.Show
                                                                                                                                                          (Unbound.Generics.LocallyNameless.Embed.Embed
                                                                                                                                                             SEDEL.Source.Syntax.SType))
                                                                                                                                                 (v :: GHC.Show.Show
                                                                                                                                                         (Unbound.Generics.LocallyNameless.Name.Name
                                                                                                                                                            SEDEL.Source.Syntax.SType))
  GHC.Show.$fShow(,) @ (Unbound.Generics.LocallyNameless.Name.Name
                          SEDEL.Source.Syntax.SType)
                     @ (Unbound.Generics.LocallyNameless.Embed.Embed
                          SEDEL.Source.Syntax.SType)
                     v
                     v1
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fShow(,)3
"SPEC/SEDEL.Source.TypeCheck $fShowEmbed @ (Maybe SType)" [orphan] forall (v :: GHC.Show.Show
                                                                                  (GHC.Base.Maybe
                                                                                     SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Embed.$fShowEmbed @ (GHC.Base.Maybe
                                                          SEDEL.Source.Syntax.SType)
                                                     v
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fShowEmbed
"SPEC/SEDEL.Source.TypeCheck $fShowEmbed @ SType" [orphan] forall (v :: GHC.Show.Show
                                                                          SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fShowEmbed @ SEDEL.Source.Syntax.SType
                                                     v
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fShowEmbed1
"SPEC/SEDEL.Source.TypeCheck $fShowEmbed_$cshowsPrec @ (Maybe SType)" [orphan] [0] forall (w :: GHC.Show.Show
                                                                                                  (GHC.Base.Maybe
                                                                                                     SEDEL.Source.Syntax.SType))
  Unbound.Generics.LocallyNameless.Embed.$fShowEmbed_$cshowsPrec @ (GHC.Base.Maybe
                                                                      SEDEL.Source.Syntax.SType)
                                                                 w
  = SEDEL.Source.TypeCheck.$s$fShowEmbed_$cshowsPrec
"SPEC/SEDEL.Source.TypeCheck $fShowEmbed_$cshowsPrec @ SType" [orphan] [0] forall (w :: GHC.Show.Show
                                                                                          SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fShowEmbed_$cshowsPrec @ SEDEL.Source.Syntax.SType
                                                                 w
  = SEDEL.Source.TypeCheck.$s$fShowEmbed_$cshowsPrec1
"SPEC/SEDEL.Source.TypeCheck $fShowMaybe @ SType" [orphan] forall (v :: GHC.Show.Show
                                                                          SEDEL.Source.Syntax.SType)
  GHC.Show.$fShowMaybe @ SEDEL.Source.Syntax.SType v
  = SEDEL.Source.TypeCheck.$s$fAlpha(,)_$s$fShowMaybe
"SPEC/SEDEL.Source.TypeCheck $fShowMaybe_$cshowList @ SType" [orphan] forall ($dShow :: GHC.Show.Show
                                                                                          SEDEL.Source.Syntax.SType)
  GHC.Show.$fShowMaybe_$cshowList @ SEDEL.Source.Syntax.SType $dShow
  = SEDEL.Source.TypeCheck.$s$fShowMaybe_$cshowList
"SPEC/SEDEL.Source.TypeCheck fromList @ Label _" [orphan] forall @ a
                                                                 ($dOrd :: GHC.Classes.Ord
                                                                             SEDEL.Source.Syntax.Label)
  Data.Map.Internal.fromList @ [GHC.Types.Char] @ a $dOrd
  = SEDEL.Source.TypeCheck.$sfromList @ a
"SPEC/SEDEL.Source.TypeCheck unionWith @ Label _" [orphan] forall @ a
                                                                  ($dOrd :: GHC.Classes.Ord
                                                                              SEDEL.Source.Syntax.Label)
  Data.Map.Internal.unionWith @ [GHC.Types.Char] @ a $dOrd
  = SEDEL.Source.TypeCheck.$sunionWith @ a
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

