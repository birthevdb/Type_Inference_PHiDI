
==================== FINAL INTERFACE ====================
2019-02-26 08:26:50.443772 UTC

interface sedel-0.1.0.0-BGuUapfeRSQ3zXo3bqhidP:SEDEL.Source.Subtyping 8044
  interface hash: 92a7028944fcffdd111e38358f58a343
  ABI hash: 1be88ae1a52440846bd02698b682de86
  export-list hash: ec840d81bd352504060d0a1bc9f8b012
  orphan hash: 951278e7029160d383ba85ba79a5fee8
  flag hash: fa67ea70dba7e914bff57c77dba85494
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  SEDEL.Source.Subtyping.subtype
module dependencies: SEDEL.Common SEDEL.Environment
                     SEDEL.PrettyPrint SEDEL.Source.Desugar SEDEL.Source.Syntax
                     SEDEL.Target.Syntax SEDEL.Util
package dependencies: StateVar-1.1.1.1 array-0.5.2.0 async-2.2.1
                      base-4.11.1.0 base-orphans-0.7 bifunctors-5.5.3 binary-0.8.5.1
                      bytestring-0.10.8.2 comonad-5.0.4 containers-0.5.11.0
                      contravariant-1.4.1 deepseq-1.4.3.0 distributive-0.5.3
                      exceptions-0.10.0 ghc-boot-th-8.4.4 ghc-prim-0.5.2.0
                      hashable-1.2.7.0 integer-gmp-1.0.2.0 megaparsec-6.5.0 mtl-2.2.2
                      parser-combinators-1.0.0 pretty-1.1.3.6 prettyprinter-1.2.1
                      profunctors-5.2.2 protolude-0.2.2 stm-2.4.5.1 tagged-0.8.5
                      template-haskell-2.13.0.0 text-1.2.3.1 transformers-0.5.5.0
                      unbound-generics-0.3.4
orphans: sedel-0.1.0.0-BGuUapfeRSQ3zXo3bqhidP:SEDEL.PrettyPrint
         sedel-0.1.0.0-BGuUapfeRSQ3zXo3bqhidP:SEDEL.Source.Syntax
         transformers-0.5.5.0:Control.Monad.Trans.Error
         stm-2.4.5.1:Control.Monad.STM
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.1:Data.Text.Lazy
         text-1.2.3.1:Data.Text binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show base-4.11.1.0:GHC.Float
         base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Complex base-4.11.1.0:Data.Functor.Compose
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         bifunctors-5.5.3:Data.Bifunctor.Biff
                         bifunctors-5.5.3:Data.Bifunctor.Clown
                         bifunctors-5.5.3:Data.Bifunctor.Joker
                         bifunctors-5.5.3:Data.Bifunctor.Product
                         bifunctors-5.5.3:Data.Bifunctor.Sum
                         bifunctors-5.5.3:Data.Bifunctor.Tannen
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         ghc-boot-th-8.4.4:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.4:GHC.LanguageExtensions.Type
                         megaparsec-6.5.0:Text.Megaparsec.Error
                         megaparsec-6.5.0:Text.Megaparsec.Pos
                         megaparsec-6.5.0:Text.Megaparsec.State
                         megaparsec-6.5.0:Text.Megaparsec.Stream
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         prettyprinter-1.2.1:Data.Text.Prettyprint.Doc.Internal
                         sedel-0.1.0.0-BGuUapfeRSQ3zXo3bqhidP:SEDEL.Common
                         sedel-0.1.0.0-BGuUapfeRSQ3zXo3bqhidP:SEDEL.Source.Syntax
                         sedel-0.1.0.0-BGuUapfeRSQ3zXo3bqhidP:SEDEL.Target.Syntax
                         tagged-0.8.5:Data.Tagged
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.1:Data.Text text-1.2.3.1:Data.Text.Lazy
                         unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Bind
                         unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Embed
                         unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Name
                         unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Rebind
                         unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Rec
                         unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Shift
import  -/  base-4.11.1.0:Data.Either 39d922b371c4c52d426e9ee66de8371a
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  containers-0.5.11.0:Data.Sequence 21c58838329d44e2dc13db7c04e3a8d8
import  -/  containers-0.5.11.0:Data.Sequence.Internal a2eae372f67713826bf16d410fc6cd8f
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  mtl-2.2.2:Control.Monad.Error.Class df146c18e27154b8df4c8637c59fd61b
import  -/  prettyprinter-1.2.1:Data.Text.Prettyprint.Doc 04e8924fa6b26857d25f7e89f331b3ec
import  -/  prettyprinter-1.2.1:Data.Text.Prettyprint.Doc.Internal 4dbff1ffd6a8a023b5e8586c0275223e
import  -/  prettyprinter-1.2.1:Data.Text.Prettyprint.Doc.Symbols.Ascii e965189d3854891aaef2f95b81655ee5
import  -/  protolude-0.2.2:Protolude ec8c9f1921240ba85c2826100dc947ec
import  -/  SEDEL.Environment 58bb2a9dac114da6febda68e6bcab706
  exports: 9b596c30b7faa0d674ead96b5fbae4e0
  Ctx 4d40b76497431ab3e2b46fb381d29825
import  -/  SEDEL.PrettyPrint 49a6e7b74cbc1b9f5143d39fe1ec859b
  exports: 19ba40565495f539d4becea748f89418
  FDoc ab8ab7aa25d70732bf916014464558a6
  pprint 49a1ae40012cb52312ba8f259909743d
import  -/  SEDEL.Source.Desugar e0fff59af80c6d3af0cc3f4186d67c8c
  exports: e58276cebab59c57ad9f74a548b02afd
  expandType 4060b21e2cef634273a57ce6ee606ea6
import  -/  SEDEL.Source.Syntax 0548d3668eda4620fc3ff3e6cf2368fb
  exports: 6168fc739a7e41a0b25e4ca6cc08e10c
  And d67643cb17880b1abddc6abf91d4f8a5
  Arr 397e828962dfd176efed92f2c56bc256
  BoolT b4482118f31960df2ddce6c8690c9ecd
  BotT a3a7b862a4bceb4a662ac6984df90188
  DForall 2b7a02b818deac1f73f2f3a86bff1b86
  Label 48063cbab0cf231dc589db9acdc7a78c
  NumT 3904495283f24212d1d2fea38e0c7b6b
  SRecT b2e8745a356f68d4ee38e06d46be62f9
  SType e82999745a2326527e020a915d2988cd
  TVar 8a2dafe14d3e9f11f76bcae45d3021c4
  TopT 37aa61935fae500ca4d2904f9fa8d48b
  TyName e82999745a2326527e020a915d2988cd
import  -/  SEDEL.Target.Syntax c6622e5f9abe8f28e85d7c0c0a6e79a5
  exports: d7a64829c71f2f04f965636abc6b48e6
  Bot d6fcfc701cc924cb7d915a892c92e9d7
  UExpr 9bfcea255d0153a0de696df7d2ee637a
  UP1 c799fcc7b660c15cef276903d934962f
  UP2 902a5585480b9b4128ba53215ad6a2cd
  UPair 3edbd9516fc6a64a3db1538a6f2cd0d4
  UUnit 21b0fe465af1ff42966a8df3370fd172
  eapp 6b5bcfd00c5cab1091f5d54d9e5de142
  elam 6c8ec9e83c515c6322298605466a765f
  evar ce3174e8c8ad72030bb8db8723b589f8
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Except 1cac4acbba7f36bd732fcc993d3cc20d
import  -/  unbound-generics-0.3.4:Unbound.Generics.LocallyNameless 8dd357a9d9fbbcf23f41fb39ba00f4e4
import  -/  unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Embed a6d67338db1f14cf42fb5b5b69a561d5
import  -/  unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Fresh 6f0bdf2414300284a1d43f913bee508e
import  -/  unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Operations 86bd0dbc8cb450c4ba4e75dad5d99714
import  -/  unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Subst b4db5320d525eedceba0cad470b93e32
c3543fd116882f6efca3cf96be675f8d
  $s$fAlpha(,)_$s$fAlphaEmbed ::
    Unbound.Generics.LocallyNameless.Alpha.Alpha
      (Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType)
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Embed.Embed
                       SEDEL.Source.Syntax.SType)
                  SEDEL.Source.Subtyping.$s$fAlpha(,)_$s$fShowEmbed
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType)
                     (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Source.Syntax.SType) ->
                   SEDEL.Source.Syntax.$fAlphaSType_$caeq'
                     (case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                      Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                        Unbound.Generics.LocallyNameless.Alpha.Term
                        ds3 })
                     ds
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Source.Syntax.SType>_R)
                     ds1
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Source.Syntax.SType>_R))
                  (Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed_$cfvAny'
                     @ SEDEL.Source.Syntax.SType
                     SEDEL.Source.Syntax.$fAlphaSType)
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (b :: Unbound.Generics.LocallyNameless.Alpha.NamePatFind)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed6
                          @ SEDEL.Source.Syntax.SType
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> (SEDEL.Source.Syntax.$fAlphaSType_$cclose
                           (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                              Unbound.Generics.LocallyNameless.Alpha.Term
                              ds2)
                           b
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R))
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <SEDEL.Source.Syntax.SType>_R)) } })
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (b :: Unbound.Generics.LocallyNameless.Alpha.NthPatFind)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed5
                          @ SEDEL.Source.Syntax.SType
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> (SEDEL.Source.Syntax.$fAlphaSType_$copen
                           (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                              Unbound.Generics.LocallyNameless.Alpha.Term
                              ds2)
                           b
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R))
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <SEDEL.Source.Syntax.SType>_R)) } })
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   case (SEDEL.Source.Syntax.$fAlphaSType_$cisTerm
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R))
                          `cast`
                        (Data.Semigroup.Internal.N:All[0]) of wild {
                     GHC.Types.False
                     -> (GHC.Base.Nothing
                           @ [Unbound.Generics.LocallyNameless.Name.AnyName])
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                  <Unbound.Generics.LocallyNameless.Name.AnyName>_R))
                     GHC.Types.True
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed4
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Alpha.N:DisjointSet[0]
                                  <Unbound.Generics.LocallyNameless.Name.AnyName>_R)) })
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   GHC.Types.False)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      SEDEL.Source.Syntax.SType>_R
                   ->_R Sym (Data.Semigroup.Internal.N:All[0]))
                  SEDEL.Source.Syntax.$fAlphaSType_$cisTerm
                    `cast`
                  (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                            <SEDEL.Source.Syntax.SType>_R)
                   ->_R Data.Semigroup.Internal.N:All[0])
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   Data.Either.Left
                     @ GHC.Integer.Type.Integer
                     @ Unbound.Generics.LocallyNameless.Name.AnyName)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      SEDEL.Source.Syntax.SType>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Alpha.N:NthPatFind[0]))
                  (\ (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   Unbound.Generics.LocallyNameless.Alpha.$fAlpha()2)
                    `cast`
                  (<Unbound.Generics.LocallyNameless.Embed.Embed
                      SEDEL.Source.Syntax.SType>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Alpha.N:NamePatFind[0]))
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (perm :: Unbound.Generics.PermM.Perm
                                Unbound.Generics.LocallyNameless.Name.AnyName)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType) ->
                   case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term -> ds
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> (SEDEL.Source.Syntax.$fAlphaSType_$cswaps'
                           (Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                              Unbound.Generics.LocallyNameless.Alpha.Term
                              ds2)
                           perm
                           ds
                             `cast`
                           (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                <SEDEL.Source.Syntax.SType>_R))
                          `cast`
                        (Sym (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                                  <SEDEL.Source.Syntax.SType>_R)) } })
                  (\ @ m :: * -> *
                     @ b
                     ($dLFresh :: Unbound.Generics.LocallyNameless.LFresh.LFresh m) ->
                   Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed2
                     @ SEDEL.Source.Syntax.SType
                     @ m
                     @ b)
                  (\ @ m :: * -> *
                     ($dFresh :: Unbound.Generics.LocallyNameless.Fresh.Fresh m)
                     (eta :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (eta8 :: Unbound.Generics.LocallyNameless.Embed.Embed
                                SEDEL.Source.Syntax.SType) ->
                   case eta of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds1 ds2 ->
                   case ds1 of wild1 {
                     Unbound.Generics.LocallyNameless.Alpha.Term
                     -> Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed1
                          @ m
                          @ SEDEL.Source.Syntax.SType
                     Unbound.Generics.LocallyNameless.Alpha.Pat
                     -> GHC.Base.return
                          @ m
                          (Unbound.Generics.LocallyNameless.Fresh.$p1Fresh @ m $dFresh)
                          @ (Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Source.Syntax.SType,
                             Unbound.Generics.PermM.Perm
                               Unbound.Generics.LocallyNameless.Name.AnyName)
                          (eta8,
                           (Data.Map.Internal.Tip
                              @ Unbound.Generics.LocallyNameless.Name.AnyName
                              @ Unbound.Generics.LocallyNameless.Name.AnyName)
                             `cast`
                           (Sym (Unbound.Generics.PermM.N:Perm[0]
                                     <Unbound.Generics.LocallyNameless.Name.AnyName>_N))) } })
                  (\ (ctx :: Unbound.Generics.LocallyNameless.Alpha.AlphaCtx)
                     (ds :: Unbound.Generics.LocallyNameless.Embed.Embed
                              SEDEL.Source.Syntax.SType)
                     (ds1 :: Unbound.Generics.LocallyNameless.Embed.Embed
                               SEDEL.Source.Syntax.SType) ->
                   SEDEL.Source.Syntax.$fAlphaSType_$cacompare'
                     (case ctx of wild { Unbound.Generics.LocallyNameless.Alpha.AlphaCtx ds2 ds3 ->
                      Unbound.Generics.LocallyNameless.Alpha.AlphaCtx
                        Unbound.Generics.LocallyNameless.Alpha.Term
                        ds3 })
                     ds
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Source.Syntax.SType>_R)
                     ds1
                       `cast`
                     (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                          <SEDEL.Source.Syntax.SType>_R)) -}
01000917cb848ff85a979a5162e1255b
  $s$fAlpha(,)_$s$fShowEmbed ::
    GHC.Show.Show
      (Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Embed.Embed
                       SEDEL.Source.Syntax.SType)
                  (Unbound.Generics.LocallyNameless.Embed.$fShowEmbed_$cshowsPrec
                     @ SEDEL.Source.Syntax.SType
                     SEDEL.Source.Syntax.$fShowSType)
                  (\ (x :: Unbound.Generics.LocallyNameless.Embed.Embed
                             SEDEL.Source.Syntax.SType) ->
                   GHC.CString.unpackAppendCString#
                     Unbound.Generics.LocallyNameless.Embed.$fShowEmbed3
                     (SEDEL.Source.Syntax.$fShowSType_$cshowsPrec
                        Unbound.Generics.LocallyNameless.Embed.$fShowEmbed2
                        x `cast`
                        (Unbound.Generics.LocallyNameless.Embed.N:Embed[0]
                             <SEDEL.Source.Syntax.SType>_R)
                        Unbound.Generics.LocallyNameless.Embed.$fShowEmbed4))
                  (Unbound.Generics.LocallyNameless.Embed.$fShowEmbed_$cshowList
                     @ SEDEL.Source.Syntax.SType
                     SEDEL.Source.Syntax.$fShowSType) -}
b73366aa040ad9ab2e2ac46b44cba3f2
  $s$fApplicativeExceptT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ (Control.Monad.Trans.Except.ExceptT
                       e Data.Functor.Identity.Identity)
                  (SEDEL.Source.Subtyping.$s$fApplicativeExceptT_$s$fFunctorExceptT
                     @ e)
                  (SEDEL.Source.Subtyping.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure
                     @ e)
                  (Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                     @ Data.Functor.Identity.Identity
                     @ e
                     Data.Functor.Identity.$fFunctorIdentity
                     Data.Functor.Identity.$fMonadIdentity)
                  (\ @ a
                     @ b
                     @ c
                     (f1 :: a -> b -> c)
                     (x :: Control.Monad.Trans.Except.ExceptT
                             e Data.Functor.Identity.Identity a) ->
                   Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                     @ Data.Functor.Identity.Identity
                     @ e
                     Data.Functor.Identity.$fFunctorIdentity
                     Data.Functor.Identity.$fMonadIdentity
                     @ b
                     @ c
                     (Data.Either.$fApplicativeEither_$cfmap
                        @ e
                        @ a
                        @ (b -> c)
                        f1
                        x `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <e>_N
                             <Data.Functor.Identity.Identity>_R
                             <a>_N ; Data.Functor.Identity.N:Identity[0]
                                         <Data.Either.Either e a>_R))
                       `cast`
                     (Sym (Data.Functor.Identity.N:Identity[0]
                               <Data.Either.Either
                                  e (b -> c)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                            <e>_N
                                                            <Data.Functor.Identity.Identity>_R
                                                            <b -> c>_N)))
                  (SEDEL.Source.Subtyping.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$c*>
                     @ e)
                  (\ @ a
                     @ b
                     (x :: Control.Monad.Trans.Except.ExceptT
                             e Data.Functor.Identity.Identity a) ->
                   Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                     @ Data.Functor.Identity.Identity
                     @ e
                     Data.Functor.Identity.$fFunctorIdentity
                     Data.Functor.Identity.$fMonadIdentity
                     @ b
                     @ a
                     (Control.Monad.Trans.Except.$fApplicativeExceptT1
                        @ a
                        @ b
                        @ e
                        x `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <e>_N
                             <Data.Functor.Identity.Identity>_R
                             <a>_N ; Data.Functor.Identity.N:Identity[0]
                                         <Data.Either.Either e a>_R))
                       `cast`
                     (Sym (Data.Functor.Identity.N:Identity[0]
                               <Data.Either.Either
                                  e (b -> a)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                            <e>_N
                                                            <Data.Functor.Identity.Identity>_R
                                                            <b -> a>_N))) -}
3ed923d47d768867fa3cfb5006f47b3a
  $s$fApplicativeExceptT_$c<* ::
    Control.Monad.Trans.Except.ExceptT
      e Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity b
    -> Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ e
                   @ a
                   @ b
                   (x :: Control.Monad.Trans.Except.ExceptT
                           e Data.Functor.Identity.Identity a) ->
                 Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                   @ Data.Functor.Identity.Identity
                   @ e
                   Data.Functor.Identity.$fFunctorIdentity
                   Data.Functor.Identity.$fMonadIdentity
                   @ b
                   @ a
                   (Control.Monad.Trans.Except.$fApplicativeExceptT1
                      @ a
                      @ b
                      @ e
                      x `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N
                           <Data.Functor.Identity.Identity>_R
                           <a>_N ; Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either e a>_R))
                     `cast`
                   (Sym (Data.Functor.Identity.N:Identity[0]
                             <Data.Either.Either
                                e (b -> a)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                          <e>_N
                                                          <Data.Functor.Identity.Identity>_R
                                                          <b -> a>_N))) -}
486de382a5e4eaffa8c3edd509f2638c
  $s$fApplicativeExceptT_$c<*>_$s$w$c<*> ::
    Control.Monad.Trans.Except.ExceptT
      e Data.Functor.Identity.Identity (a -> b)
    -> Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ e
                   @ a
                   @ b
                   (w4 :: Control.Monad.Trans.Except.ExceptT
                            e Data.Functor.Identity.Identity (a -> b))
                   (w5 :: Control.Monad.Trans.Except.ExceptT
                            e Data.Functor.Identity.Identity a) ->
                 case w4
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N
                           <Data.Functor.Identity.Identity>_R
                           <a -> b>_N ; Data.Functor.Identity.N:Identity[0]
                                            <Data.Either.Either e (a -> b)>_R) of wild {
                   Data.Either.Left e1
                   -> (Data.Either.Left @ e @ b e1)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   e b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                      <e>_N
                                                      <Data.Functor.Identity.Identity>_R
                                                      <b>_N))
                   Data.Either.Right k
                   -> case w5
                             `cast`
                           (Control.Monad.Trans.Except.N:ExceptT[0]
                                <e>_N
                                <Data.Functor.Identity.Identity>_R
                                <a>_N ; Data.Functor.Identity.N:Identity[0]
                                            <Data.Either.Either e a>_R) of wild1 {
                        Data.Either.Left e1
                        -> (Data.Either.Left @ e @ b e1)
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        e b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                           <e>_N
                                                           <Data.Functor.Identity.Identity>_R
                                                           <b>_N))
                        Data.Either.Right x
                        -> (Data.Either.Right @ e @ b (k x))
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        e b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                           <e>_N
                                                           <Data.Functor.Identity.Identity>_R
                                                           <b>_N)) } }) -}
c2a15a85f244d022aa52cb6f202124a4
  $s$fApplicativeExceptT_$s$fApplicativeExceptT_$c*> ::
    Control.Monad.Trans.Except.ExceptT
      e Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity b
    -> Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Except.ExceptT
                            e Data.Functor.Identity.Identity a)
                   (k :: Control.Monad.Trans.Except.ExceptT
                           e Data.Functor.Identity.Identity b) ->
                 case m1
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N
                           <Data.Functor.Identity.Identity>_R
                           <a>_N ; Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either e a>_R) of wild {
                   Data.Either.Left e1
                   -> (Data.Either.Left @ e @ b e1)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either e b>_R))
                   Data.Either.Right x
                   -> k `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <Data.Functor.Identity.Identity>_R <b>_N) })
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Except.ExceptT
                    e Data.Functor.Identity.Identity a>_R
                 ->_R <Control.Monad.Trans.Except.ExceptT
                         e Data.Functor.Identity.Identity b>_R
                 ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                               <e>_N <Data.Functor.Identity.Identity>_R <b>_N)) -}
8bb79796f9dd28f4331fa99fff8cc90c
  $s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure ::
    a
    -> Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                Data.Either.Right
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N).
                 <a>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0]
                               <Data.Either.Either
                                  e a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                     <e>_N
                                                     <Data.Functor.Identity.Identity>_R
                                                     <a>_N)) -}
b0f6bf3101dda14bc6c9aafe671b9c05
  $s$fApplicativeExceptT_$s$fFunctorExceptT ::
    GHC.Base.Functor
      (Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ (Control.Monad.Trans.Except.ExceptT
                       e Data.Functor.Identity.Identity)
                  (Control.Monad.Trans.Except.$fFunctorExceptT_$cfmap
                     @ Data.Functor.Identity.Identity
                     @ e
                     Data.Functor.Identity.$fFunctorIdentity)
                  (Control.Monad.Trans.Except.$fFunctorExceptT_$c<$
                     @ Data.Functor.Identity.Identity
                     @ e
                     Data.Functor.Identity.$fFunctorIdentity) -}
da39eb64f8c9899d782daacea52d6cfb
  $s$fApplicativeFreshMT ::
    GHC.Base.Applicative
      (Unbound.Generics.LocallyNameless.Fresh.FreshMT
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Fresh.FreshMT
                       (Control.Monad.Trans.Except.ExceptT
                          SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity))
                  SEDEL.Source.Subtyping.$s$fApplicativeFreshMT_$s$fFunctorFreshMT
                  (\ @ a (eta :: a) (eta8 :: GHC.Integer.Type.Integer) ->
                   Data.Either.Right
                     @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                     @ (a, GHC.Integer.Type.Integer)
                     (eta, eta8))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R (<GHC.Integer.Type.Integer>_R
                         ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either
                                          (Data.Text.Prettyprint.Doc.Internal.Doc
                                             SEDEL.PrettyPrint.FAnn)
                                          (a,
                                           GHC.Integer.Type.Integer)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                    <Data.Text.Prettyprint.Doc.Internal.Doc
                                                                                       SEDEL.PrettyPrint.FAnn>_N
                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                    <(a,
                                                                                      GHC.Integer.Type.Integer)>_N)) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                 <GHC.Integer.Type.Integer>_N
                                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                                    SEDEL.PrettyPrint.FDoc
                                                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                                                 <a>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                       SEDEL.PrettyPrint.FDoc
                                                                                                                                                                                                       Data.Functor.Identity.Identity>_N <a>_N))
                  (Unbound.Generics.LocallyNameless.Fresh.$fApplicativeFreshMT4
                     @ (Control.Monad.Trans.Except.ExceptT
                          SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                     (SEDEL.Source.Subtyping.$s$fApplicativeFreshMT_$s$fMonadExceptT
                        @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)))
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Except.ExceptT
                                                                                SEDEL.PrettyPrint.FDoc
                                                                                Data.Functor.Identity.Identity>_N <a
                                                                                                                   -> b>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Except.ExceptT
                                                                                     SEDEL.PrettyPrint.FDoc
                                                                                     Data.Functor.Identity.Identity>_N <a>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Except.ExceptT
                                    SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity>_R
                                 <b>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Except.ExceptT
                                                                                                       SEDEL.PrettyPrint.FDoc
                                                                                                       Data.Functor.Identity.Identity>_N <b>_N)
                  (\ @ a
                     @ b
                     @ c
                     (eta :: a -> b -> c)
                     (eta8 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer
                                (Control.Monad.Trans.Except.ExceptT
                                   SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                                a)
                     (eta9 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer
                                (Control.Monad.Trans.Except.ExceptT
                                   SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                                b)
                     (eta10 :: GHC.Integer.Type.Integer) ->
                   Control.Monad.Trans.State.Lazy.$fAlternativeStateT2
                     @ (Control.Monad.Trans.Except.ExceptT
                          SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                     @ GHC.Integer.Type.Integer
                     (SEDEL.Source.Subtyping.$s$fApplicativeExceptT_$s$fFunctorExceptT
                        @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn))
                     (SEDEL.Source.Subtyping.$s$fApplicativeFreshMT_$s$fMonadExceptT
                        @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn))
                     @ a
                     @ b
                     @ c
                     eta
                     eta8
                     eta9
                     eta10)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Except.ExceptT
                                                                                     SEDEL.PrettyPrint.FDoc
                                                                                     Data.Functor.Identity.Identity>_N <a>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Except.ExceptT
                                                                                     SEDEL.PrettyPrint.FDoc
                                                                                     Data.Functor.Identity.Identity>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Except.ExceptT
                                    SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity>_R
                                 <c>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Except.ExceptT
                                                                                                       SEDEL.PrettyPrint.FDoc
                                                                                                       Data.Functor.Identity.Identity>_N <c>_N)
                  (\ @ a
                     @ b
                     (eta :: Control.Monad.Trans.State.Lazy.StateT
                               GHC.Integer.Type.Integer
                               (Control.Monad.Trans.Except.ExceptT
                                  SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                               a)
                     (eta8 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer
                                (Control.Monad.Trans.Except.ExceptT
                                   SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                                b)
                     (eta9 :: GHC.Integer.Type.Integer) ->
                   case (eta
                           `cast`
                         (Control.Monad.Trans.State.Lazy.N:StateT[0]
                              <GHC.Integer.Type.Integer>_N
                              <Control.Monad.Trans.Except.ExceptT
                                 SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity>_R
                              <a>_N)
                           eta9)
                          `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn>_N
                             <Data.Functor.Identity.Identity>_R
                             <(a,
                               GHC.Integer.Type.Integer)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                  <Data.Either.Either
                                                                     (Data.Text.Prettyprint.Doc.Internal.Doc
                                                                        SEDEL.PrettyPrint.FAnn)
                                                                     (a,
                                                                      GHC.Integer.Type.Integer)>_R) of wild {
                     Data.Either.Left e1
                     -> (Data.Either.Left
                           @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                           @ (b, GHC.Integer.Type.Integer)
                           e1)
                          `cast`
                        (Sym (Data.Functor.Identity.N:Identity[0]
                                  <Data.Either.Either
                                     (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                                     (b,
                                      GHC.Integer.Type.Integer)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                               <Data.Text.Prettyprint.Doc.Internal.Doc
                                                                                  SEDEL.PrettyPrint.FAnn>_N
                                                                               <Data.Functor.Identity.Identity>_R
                                                                               <(b,
                                                                                 GHC.Integer.Type.Integer)>_N))
                     Data.Either.Right x
                     -> eta8
                          `cast`
                        (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <GHC.Integer.Type.Integer>_N
                             <Control.Monad.Trans.Except.ExceptT
                                SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity>_R
                             <b>_N)
                          (case x of wild1 { (,) a1 s' -> s' }) })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Except.ExceptT
                                                                                SEDEL.PrettyPrint.FDoc
                                                                                Data.Functor.Identity.Identity>_N <a>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Except.ExceptT
                                                                                     SEDEL.PrettyPrint.FDoc
                                                                                     Data.Functor.Identity.Identity>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Except.ExceptT
                                    SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity>_R
                                 <b>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Except.ExceptT
                                                                                                       SEDEL.PrettyPrint.FDoc
                                                                                                       Data.Functor.Identity.Identity>_N <b>_N)
                  (\ @ a
                     @ b
                     (eta :: Control.Monad.Trans.State.Lazy.StateT
                               GHC.Integer.Type.Integer
                               (Control.Monad.Trans.Except.ExceptT
                                  SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                               a)
                     (eta8 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer
                                (Control.Monad.Trans.Except.ExceptT
                                   SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                                b)
                     (eta9 :: GHC.Integer.Type.Integer) ->
                   case (eta
                           `cast`
                         (Control.Monad.Trans.State.Lazy.N:StateT[0]
                              <GHC.Integer.Type.Integer>_N
                              <Control.Monad.Trans.Except.ExceptT
                                 SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity>_R
                              <a>_N)
                           eta9)
                          `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn>_N
                             <Data.Functor.Identity.Identity>_R
                             <(a,
                               GHC.Integer.Type.Integer)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                  <Data.Either.Either
                                                                     (Data.Text.Prettyprint.Doc.Internal.Doc
                                                                        SEDEL.PrettyPrint.FAnn)
                                                                     (a,
                                                                      GHC.Integer.Type.Integer)>_R) of wild {
                     Data.Either.Left x
                     -> (Data.Either.Left
                           @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                           @ (a, GHC.Integer.Type.Integer)
                           x)
                          `cast`
                        (Sym (Data.Functor.Identity.N:Identity[0]
                                  <Data.Either.Either
                                     (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                                     (a,
                                      GHC.Integer.Type.Integer)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                               <Data.Text.Prettyprint.Doc.Internal.Doc
                                                                                  SEDEL.PrettyPrint.FAnn>_N
                                                                               <Data.Functor.Identity.Identity>_R
                                                                               <(a,
                                                                                 GHC.Integer.Type.Integer)>_N))
                     Data.Either.Right y
                     -> case (eta8
                                `cast`
                              (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                   <GHC.Integer.Type.Integer>_N
                                   <Control.Monad.Trans.Except.ExceptT
                                      SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity>_R
                                   <b>_N)
                                (case y of wild1 { (,) a1 s' -> s' }))
                               `cast`
                             (Control.Monad.Trans.Except.N:ExceptT[0]
                                  <Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn>_N
                                  <Data.Functor.Identity.Identity>_R
                                  <(b,
                                    GHC.Integer.Type.Integer)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                       <Data.Either.Either
                                                                          (Data.Text.Prettyprint.Doc.Internal.Doc
                                                                             SEDEL.PrettyPrint.FAnn)
                                                                          (b,
                                                                           GHC.Integer.Type.Integer)>_R) of wild1 {
                          Data.Either.Left e1
                          -> (Data.Either.Left
                                @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                                @ (a, GHC.Integer.Type.Integer)
                                e1)
                               `cast`
                             (Sym (Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either
                                          (Data.Text.Prettyprint.Doc.Internal.Doc
                                             SEDEL.PrettyPrint.FAnn)
                                          (a,
                                           GHC.Integer.Type.Integer)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                    <Data.Text.Prettyprint.Doc.Internal.Doc
                                                                                       SEDEL.PrettyPrint.FAnn>_N
                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                    <(a,
                                                                                      GHC.Integer.Type.Integer)>_N))
                          Data.Either.Right x
                          -> (Data.Either.Right
                                @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                                @ (a, GHC.Integer.Type.Integer)
                                (case y of wild2 { (,) a1 s' -> a1 },
                                 case x of wild2 { (,) x1 s'' -> s'' }))
                               `cast`
                             (Sym (Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either
                                          (Data.Text.Prettyprint.Doc.Internal.Doc
                                             SEDEL.PrettyPrint.FAnn)
                                          (a,
                                           GHC.Integer.Type.Integer)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                    <Data.Text.Prettyprint.Doc.Internal.Doc
                                                                                       SEDEL.PrettyPrint.FAnn>_N
                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                    <(a,
                                                                                      GHC.Integer.Type.Integer)>_N)) } })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Except.ExceptT
                                                                                SEDEL.PrettyPrint.FDoc
                                                                                Data.Functor.Identity.Identity>_N <a>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Except.ExceptT
                                                                                     SEDEL.PrettyPrint.FDoc
                                                                                     Data.Functor.Identity.Identity>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Except.ExceptT
                                    SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity>_R
                                 <a>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Except.ExceptT
                                                                                                       SEDEL.PrettyPrint.FDoc
                                                                                                       Data.Functor.Identity.Identity>_N <a>_N) -}
b3134ce6c8b93045a956efba3b9955fe
  $s$fApplicativeFreshMT1 ::
    Control.Monad.Trans.State.Lazy.StateT
      GHC.Integer.Type.Integer
      (Control.Monad.Trans.Except.ExceptT
         SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
      a
    -> Control.Monad.Trans.State.Lazy.StateT
         GHC.Integer.Type.Integer
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
         b
    -> GHC.Integer.Type.Integer
    -> Control.Monad.Trans.Except.ExceptT
         SEDEL.PrettyPrint.FDoc
         Data.Functor.Identity.Identity
         (a, GHC.Integer.Type.Integer)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (eta :: Control.Monad.Trans.State.Lazy.StateT
                             GHC.Integer.Type.Integer
                             (Control.Monad.Trans.Except.ExceptT
                                SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                             a)
                   (eta8 :: Control.Monad.Trans.State.Lazy.StateT
                              GHC.Integer.Type.Integer
                              (Control.Monad.Trans.Except.ExceptT
                                 SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                              b)
                   (eta9 :: GHC.Integer.Type.Integer) ->
                 case (eta
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <GHC.Integer.Type.Integer>_N
                            <Control.Monad.Trans.Except.ExceptT
                               SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity>_R
                            <a>_N)
                         eta9)
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn>_N
                           <Data.Functor.Identity.Identity>_R
                           <(a,
                             GHC.Integer.Type.Integer)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                <Data.Either.Either
                                                                   (Data.Text.Prettyprint.Doc.Internal.Doc
                                                                      SEDEL.PrettyPrint.FAnn)
                                                                   (a,
                                                                    GHC.Integer.Type.Integer)>_R) of wild {
                   Data.Either.Left x
                   -> (Data.Either.Left
                         @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                         @ (a, GHC.Integer.Type.Integer)
                         x)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                                   (a,
                                    GHC.Integer.Type.Integer)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                             <Data.Text.Prettyprint.Doc.Internal.Doc
                                                                                SEDEL.PrettyPrint.FAnn>_N
                                                                             <Data.Functor.Identity.Identity>_R
                                                                             <(a,
                                                                               GHC.Integer.Type.Integer)>_N))
                   Data.Either.Right y
                   -> case (eta8
                              `cast`
                            (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Except.ExceptT
                                    SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity>_R
                                 <b>_N)
                              (case y of wild1 { (,) a1 s' -> s' }))
                             `cast`
                           (Control.Monad.Trans.Except.N:ExceptT[0]
                                <Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn>_N
                                <Data.Functor.Identity.Identity>_R
                                <(b,
                                  GHC.Integer.Type.Integer)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                     <Data.Either.Either
                                                                        (Data.Text.Prettyprint.Doc.Internal.Doc
                                                                           SEDEL.PrettyPrint.FAnn)
                                                                        (b,
                                                                         GHC.Integer.Type.Integer)>_R) of wild1 {
                        Data.Either.Left e1
                        -> (Data.Either.Left
                              @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                              @ (a, GHC.Integer.Type.Integer)
                              e1)
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        (Data.Text.Prettyprint.Doc.Internal.Doc
                                           SEDEL.PrettyPrint.FAnn)
                                        (a,
                                         GHC.Integer.Type.Integer)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                  <Data.Text.Prettyprint.Doc.Internal.Doc
                                                                                     SEDEL.PrettyPrint.FAnn>_N
                                                                                  <Data.Functor.Identity.Identity>_R
                                                                                  <(a,
                                                                                    GHC.Integer.Type.Integer)>_N))
                        Data.Either.Right x
                        -> (Data.Either.Right
                              @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                              @ (a, GHC.Integer.Type.Integer)
                              (case y of wild2 { (,) a1 s' -> a1 },
                               case x of wild2 { (,) x1 s'' -> s'' }))
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        (Data.Text.Prettyprint.Doc.Internal.Doc
                                           SEDEL.PrettyPrint.FAnn)
                                        (a,
                                         GHC.Integer.Type.Integer)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                  <Data.Text.Prettyprint.Doc.Internal.Doc
                                                                                     SEDEL.PrettyPrint.FAnn>_N
                                                                                  <Data.Functor.Identity.Identity>_R
                                                                                  <(a,
                                                                                    GHC.Integer.Type.Integer)>_N)) } }) -}
0b8f0a866b473d1282ccb10fa296f085
  $s$fApplicativeFreshMT2 ::
    Control.Monad.Trans.State.Lazy.StateT
      GHC.Integer.Type.Integer
      (Control.Monad.Trans.Except.ExceptT
         SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
      a
    -> Control.Monad.Trans.State.Lazy.StateT
         GHC.Integer.Type.Integer
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
         b
    -> GHC.Integer.Type.Integer
    -> Control.Monad.Trans.Except.ExceptT
         SEDEL.PrettyPrint.FDoc
         Data.Functor.Identity.Identity
         (b, GHC.Integer.Type.Integer)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (eta :: Control.Monad.Trans.State.Lazy.StateT
                             GHC.Integer.Type.Integer
                             (Control.Monad.Trans.Except.ExceptT
                                SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                             a)
                   (eta8 :: Control.Monad.Trans.State.Lazy.StateT
                              GHC.Integer.Type.Integer
                              (Control.Monad.Trans.Except.ExceptT
                                 SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                              b)
                   (eta9 :: GHC.Integer.Type.Integer) ->
                 case (eta
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <GHC.Integer.Type.Integer>_N
                            <Control.Monad.Trans.Except.ExceptT
                               SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity>_R
                            <a>_N)
                         eta9)
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn>_N
                           <Data.Functor.Identity.Identity>_R
                           <(a,
                             GHC.Integer.Type.Integer)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                <Data.Either.Either
                                                                   (Data.Text.Prettyprint.Doc.Internal.Doc
                                                                      SEDEL.PrettyPrint.FAnn)
                                                                   (a,
                                                                    GHC.Integer.Type.Integer)>_R) of wild {
                   Data.Either.Left e1
                   -> (Data.Either.Left
                         @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                         @ (b, GHC.Integer.Type.Integer)
                         e1)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                                   (b,
                                    GHC.Integer.Type.Integer)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                             <Data.Text.Prettyprint.Doc.Internal.Doc
                                                                                SEDEL.PrettyPrint.FAnn>_N
                                                                             <Data.Functor.Identity.Identity>_R
                                                                             <(b,
                                                                               GHC.Integer.Type.Integer)>_N))
                   Data.Either.Right x
                   -> eta8
                        `cast`
                      (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <GHC.Integer.Type.Integer>_N
                           <Control.Monad.Trans.Except.ExceptT
                              SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity>_R
                           <b>_N)
                        (case x of wild1 { (,) a1 s' -> s' }) }) -}
5d0c0c8b6df8254d5d14caeffa0941d5
  $s$fApplicativeFreshMT3 ::
    (a -> b -> c)
    -> Control.Monad.Trans.State.Lazy.StateT
         GHC.Integer.Type.Integer
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
         a
    -> Control.Monad.Trans.State.Lazy.StateT
         GHC.Integer.Type.Integer
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
         b
    -> GHC.Integer.Type.Integer
    -> Control.Monad.Trans.Except.ExceptT
         SEDEL.PrettyPrint.FDoc
         Data.Functor.Identity.Identity
         (c, GHC.Integer.Type.Integer)
  {- Arity: 4, Strictness: <L,C(U)><L,1*C1(U)><L,C(U)><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   @ c
                   (eta :: a -> b -> c)
                   (eta8 :: Control.Monad.Trans.State.Lazy.StateT
                              GHC.Integer.Type.Integer
                              (Control.Monad.Trans.Except.ExceptT
                                 SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                              a)
                   (eta9 :: Control.Monad.Trans.State.Lazy.StateT
                              GHC.Integer.Type.Integer
                              (Control.Monad.Trans.Except.ExceptT
                                 SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                              b)
                   (eta10 :: GHC.Integer.Type.Integer) ->
                 Control.Monad.Trans.State.Lazy.$fAlternativeStateT2
                   @ (Control.Monad.Trans.Except.ExceptT
                        SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                   @ GHC.Integer.Type.Integer
                   (SEDEL.Source.Subtyping.$s$fApplicativeExceptT_$s$fFunctorExceptT
                      @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn))
                   (SEDEL.Source.Subtyping.$s$fApplicativeFreshMT_$s$fMonadExceptT
                      @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn))
                   @ a
                   @ b
                   @ c
                   eta
                   eta8
                   eta9
                   eta10) -}
b90869b3c1df2dd14172a4948f2ae0a3
  $s$fApplicativeFreshMT_$s$fFunctorFreshMT ::
    GHC.Base.Functor
      (Unbound.Generics.LocallyNameless.Fresh.FreshMT
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Fresh.FreshMT
                       (Control.Monad.Trans.Except.ExceptT
                          SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity))
                  (SEDEL.Source.Subtyping.$s$fApplicativeFreshMT_$s$fFunctorStateT_$cfmap
                     @ GHC.Integer.Type.Integer)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a -> b>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Except.ExceptT
                                                                                     SEDEL.PrettyPrint.FDoc
                                                                                     Data.Functor.Identity.Identity>_N <a>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Except.ExceptT
                                                                                     SEDEL.PrettyPrint.FDoc
                                                                                     Data.Functor.Identity.Identity>_N <b>_N)
                  (\ @ a
                     @ b
                     (x :: a)
                     (eta :: Control.Monad.Trans.State.Lazy.StateT
                               GHC.Integer.Type.Integer
                               (Control.Monad.Trans.Except.ExceptT
                                  SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                               b)
                     (eta8 :: GHC.Integer.Type.Integer) ->
                   case (eta
                           `cast`
                         (Control.Monad.Trans.State.Lazy.N:StateT[0]
                              <GHC.Integer.Type.Integer>_N
                              <Control.Monad.Trans.Except.ExceptT
                                 SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity>_R
                              <b>_N)
                           eta8)
                          `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn>_N
                             <Data.Functor.Identity.Identity>_R
                             <(b,
                               GHC.Integer.Type.Integer)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                  <Data.Either.Either
                                                                     (Data.Text.Prettyprint.Doc.Internal.Doc
                                                                        SEDEL.PrettyPrint.FAnn)
                                                                     (b,
                                                                      GHC.Integer.Type.Integer)>_R) of wild {
                     Data.Either.Left x1
                     -> (Data.Either.Left
                           @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                           @ (a, GHC.Integer.Type.Integer)
                           x1)
                          `cast`
                        (Sym (Data.Functor.Identity.N:Identity[0]
                                  <Data.Either.Either
                                     (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                                     (a,
                                      GHC.Integer.Type.Integer)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                               <Data.Text.Prettyprint.Doc.Internal.Doc
                                                                                  SEDEL.PrettyPrint.FAnn>_N
                                                                               <Data.Functor.Identity.Identity>_R
                                                                               <(a,
                                                                                 GHC.Integer.Type.Integer)>_N))
                     Data.Either.Right y
                     -> (Data.Either.Right
                           @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                           @ (a, GHC.Integer.Type.Integer)
                           (x, case y of wild1 { (,) a1 s' -> s' }))
                          `cast`
                        (Sym (Data.Functor.Identity.N:Identity[0]
                                  <Data.Either.Either
                                     (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                                     (a,
                                      GHC.Integer.Type.Integer)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                               <Data.Text.Prettyprint.Doc.Internal.Doc
                                                                                  SEDEL.PrettyPrint.FAnn>_N
                                                                               <Data.Functor.Identity.Identity>_R
                                                                               <(a,
                                                                                 GHC.Integer.Type.Integer)>_N)) })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Except.ExceptT
                                                                                     SEDEL.PrettyPrint.FDoc
                                                                                     Data.Functor.Identity.Identity>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Except.ExceptT
                                    SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity>_R
                                 <a>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Except.ExceptT
                                                                                                       SEDEL.PrettyPrint.FDoc
                                                                                                       Data.Functor.Identity.Identity>_N <a>_N) -}
5bdc2f396bfc210dce3517de33fabdf3
  $s$fApplicativeFreshMT_$s$fFunctorStateT_$cfmap ::
    (a -> b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
         a
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U)><C(S),1*C1(U)><L,U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (f :: a -> b)
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Trans.Except.ExceptT
                               SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                            a)
                   (s1 :: s) ->
                 case (m1
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <s>_N
                            <Control.Monad.Trans.Except.ExceptT
                               SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity>_R
                            <a>_N)
                         s1)
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn>_N
                           <Data.Functor.Identity.Identity>_R
                           <(a, s)>_N ; Data.Functor.Identity.N:Identity[0]
                                            <Data.Either.Either
                                               (Data.Text.Prettyprint.Doc.Internal.Doc
                                                  SEDEL.PrettyPrint.FAnn)
                                               (a, s)>_R) of wild {
                   Data.Either.Left x
                   -> (Data.Either.Left
                         @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                         @ (b, s)
                         x)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                                   (b, s)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                         <Data.Text.Prettyprint.Doc.Internal.Doc
                                                            SEDEL.PrettyPrint.FAnn>_N
                                                         <Data.Functor.Identity.Identity>_R
                                                         <(b, s)>_N))
                   Data.Either.Right y
                   -> (Data.Either.Right
                         @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                         @ (b, s)
                         (f (case y of wild1 { (,) a1 s' -> a1 }),
                          case y of wild1 { (,) a1 s' -> s' }))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                                   (b, s)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                         <Data.Text.Prettyprint.Doc.Internal.Doc
                                                            SEDEL.PrettyPrint.FAnn>_N
                                                         <Data.Functor.Identity.Identity>_R
                                                         <(b, s)>_N)) })
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s
                         (Control.Monad.Trans.Except.ExceptT
                            SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                         a>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Trans.Except.ExceptT
                                  SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity>_R
                               <b>_N)) -}
36e7f147bc3861ffa50952b866770240
  $s$fApplicativeFreshMT_$s$fMonadExceptT ::
    GHC.Base.Monad
      (Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ (Control.Monad.Trans.Except.ExceptT
                       e Data.Functor.Identity.Identity)
                  (SEDEL.Source.Subtyping.$s$fApplicativeExceptT @ e)
                  (SEDEL.Source.Subtyping.$s$fApplicativeFreshMT_$s$fMonadExceptT_$c>>=
                     @ e)
                  (SEDEL.Source.Subtyping.$s$fApplicativeFreshMT_$s$fMonadExceptT_$c>>
                     @ e)
                  (Data.Either.Right @ e)
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                 <Data.Either.Either
                                    e a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                       <e>_N
                                                       <Data.Functor.Identity.Identity>_R
                                                       <a>_N))
                  (\ @ a ->
                   GHC.Err.errorWithoutStackTrace
                     @ 'GHC.Types.LiftedRep
                     @ (Data.Functor.Identity.Identity (Data.Either.Either e a)))
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Base.String>_R
                   ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                 <e>_N <Data.Functor.Identity.Identity>_R <a>_N)) -}
12966f183d5f7264d9f467100e32e9ea
  $s$fApplicativeFreshMT_$s$fMonadExceptT_$c>> ::
    Control.Monad.Trans.Except.ExceptT
      e Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity b
    -> Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Except.ExceptT
                            e Data.Functor.Identity.Identity a)
                   (k :: Control.Monad.Trans.Except.ExceptT
                           e Data.Functor.Identity.Identity b) ->
                 case m1
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N
                           <Data.Functor.Identity.Identity>_R
                           <a>_N ; Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either e a>_R) of wild {
                   Data.Either.Left e1
                   -> (Data.Either.Left @ e @ b e1)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either e b>_R))
                   Data.Either.Right x
                   -> k `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <Data.Functor.Identity.Identity>_R <b>_N) })
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Except.ExceptT
                    e Data.Functor.Identity.Identity a>_R
                 ->_R <Control.Monad.Trans.Except.ExceptT
                         e Data.Functor.Identity.Identity b>_R
                 ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                               <e>_N <Data.Functor.Identity.Identity>_R <b>_N)) -}
d1b66603e05293b8c882ef45c9b313f4
  $s$fApplicativeFreshMT_$s$fMonadExceptT_$c>>= ::
    Control.Monad.Trans.Except.ExceptT
      e Data.Functor.Identity.Identity a
    -> (a
        -> Control.Monad.Trans.Except.ExceptT
             e Data.Functor.Identity.Identity b)
    -> Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*C1(U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Except.ExceptT
                            e Data.Functor.Identity.Identity a)
                   (k :: a
                         -> Control.Monad.Trans.Except.ExceptT
                              e Data.Functor.Identity.Identity b) ->
                 case m1
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N
                           <Data.Functor.Identity.Identity>_R
                           <a>_N ; Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either e a>_R) of wild {
                   Data.Either.Left e1
                   -> (Data.Either.Left @ e @ b e1)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either e b>_R))
                   Data.Either.Right x
                   -> (k x)
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <Data.Functor.Identity.Identity>_R <b>_N) })
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Except.ExceptT
                    e Data.Functor.Identity.Identity a>_R
                 ->_R <a
                       -> Control.Monad.Trans.Except.ExceptT
                            e Data.Functor.Identity.Identity b>_R
                 ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                               <e>_N <Data.Functor.Identity.Identity>_R <b>_N)) -}
4b93fd7d9bcdab980de8b71216afee42
  $s$fFreshFreshMT ::
    Unbound.Generics.LocallyNameless.Fresh.Fresh
      (Unbound.Generics.LocallyNameless.Fresh.FreshMT
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Fresh.FreshMT
                       (Control.Monad.Trans.Except.ExceptT
                          SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity))
                  SEDEL.Source.Subtyping.$s$fFreshFreshMT_$s$fMonadFreshMT
                  (Unbound.Generics.LocallyNameless.Fresh.$fFreshFreshMT1
                     @ (Control.Monad.Trans.Except.ExceptT
                          SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                     (SEDEL.Source.Subtyping.$s$fApplicativeFreshMT_$s$fMonadExceptT
                        @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)))
                    `cast`
                  (forall (a :: <*>_N).
                   <Unbound.Generics.LocallyNameless.Name.Name a>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Except.ExceptT
                                    SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity>_R
                                 <Unbound.Generics.LocallyNameless.Name.Name
                                    a>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Except.ExceptT
                                                                                                         SEDEL.PrettyPrint.FDoc
                                                                                                         Data.Functor.Identity.Identity>_N <Unbound.Generics.LocallyNameless.Name.Name
                                                                                                                                              a>_N) -}
f707dfee1065fb04e5d2893ea623c025
  $s$fFreshFreshMT_$s$fMonadFreshMT ::
    GHC.Base.Monad
      (Unbound.Generics.LocallyNameless.Fresh.FreshMT
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Fresh.FreshMT
                       (Control.Monad.Trans.Except.ExceptT
                          SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity))
                  SEDEL.Source.Subtyping.$s$fApplicativeFreshMT
                  (SEDEL.Source.Subtyping.$s$fFreshFreshMT_$s$fMonadStateT_$c>>=
                     @ GHC.Integer.Type.Integer)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Except.ExceptT
                                                                                SEDEL.PrettyPrint.FDoc
                                                                                Data.Functor.Identity.Identity>_N <a>_N
                   ->_R (<a>_R
                         ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Except.ExceptT
                                                                                           SEDEL.PrettyPrint.FDoc
                                                                                           Data.Functor.Identity.Identity>_N <b>_N)
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Except.ExceptT
                                                                                     SEDEL.PrettyPrint.FDoc
                                                                                     Data.Functor.Identity.Identity>_N <b>_N)
                  (SEDEL.Source.Subtyping.$s$fFreshFreshMT_$s$fMonadStateT_$c>>
                     @ GHC.Integer.Type.Integer)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Except.ExceptT
                                                                                SEDEL.PrettyPrint.FDoc
                                                                                Data.Functor.Identity.Identity>_N <a>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Except.ExceptT
                                                                                     SEDEL.PrettyPrint.FDoc
                                                                                     Data.Functor.Identity.Identity>_N <b>_N
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Except.ExceptT
                                                                                     SEDEL.PrettyPrint.FDoc
                                                                                     Data.Functor.Identity.Identity>_N <b>_N)
                  (\ @ a (eta :: a) (eta8 :: GHC.Integer.Type.Integer) ->
                   Data.Either.Right
                     @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                     @ (a, GHC.Integer.Type.Integer)
                     (eta, eta8))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R (<GHC.Integer.Type.Integer>_R
                         ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either
                                          (Data.Text.Prettyprint.Doc.Internal.Doc
                                             SEDEL.PrettyPrint.FAnn)
                                          (a,
                                           GHC.Integer.Type.Integer)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                    <Data.Text.Prettyprint.Doc.Internal.Doc
                                                                                       SEDEL.PrettyPrint.FAnn>_N
                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                    <(a,
                                                                                      GHC.Integer.Type.Integer)>_N)) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                 <GHC.Integer.Type.Integer>_N
                                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                                    SEDEL.PrettyPrint.FDoc
                                                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                                                 <a>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                       SEDEL.PrettyPrint.FDoc
                                                                                                                                                                                                       Data.Functor.Identity.Identity>_N <a>_N))
                  (SEDEL.Source.Subtyping.$s$fFreshFreshMT_$s$fMonadStateT_$cfail
                     @ GHC.Integer.Type.Integer)
                    `cast`
                  (forall (a :: <*>_N).
                   <[GHC.Types.Char]>_R
                   ->_R Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Except.ExceptT
                                                                                     SEDEL.PrettyPrint.FDoc
                                                                                     Data.Functor.Identity.Identity>_N <a>_N) -}
bb9d306394d357f622307ffde0ff7278
  $s$fFreshFreshMT_$s$fMonadStateT_$c>> ::
    Control.Monad.Trans.State.Lazy.StateT
      s
      (Control.Monad.Trans.Except.ExceptT
         SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
      a
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
         b
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Trans.Except.ExceptT
                               SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                            a)
                   (k :: Control.Monad.Trans.State.Lazy.StateT
                           s
                           (Control.Monad.Trans.Except.ExceptT
                              SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                           b)
                   (s1 :: s) ->
                 case (m1
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <s>_N
                            <Control.Monad.Trans.Except.ExceptT
                               SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity>_R
                            <a>_N)
                         s1)
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn>_N
                           <Data.Functor.Identity.Identity>_R
                           <(a, s)>_N ; Data.Functor.Identity.N:Identity[0]
                                            <Data.Either.Either
                                               (Data.Text.Prettyprint.Doc.Internal.Doc
                                                  SEDEL.PrettyPrint.FAnn)
                                               (a, s)>_R) of wild {
                   Data.Either.Left e1
                   -> (Data.Either.Left
                         @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                         @ (b, s)
                         e1)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                                   (b, s)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                         <Data.Text.Prettyprint.Doc.Internal.Doc
                                                            SEDEL.PrettyPrint.FAnn>_N
                                                         <Data.Functor.Identity.Identity>_R
                                                         <(b, s)>_N))
                   Data.Either.Right x
                   -> k `cast`
                      (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <s>_N
                           <Control.Monad.Trans.Except.ExceptT
                              SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity>_R
                           <b>_N)
                        (case x of wild1 { (,) a1 s' -> s' }) })
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s
                    (Control.Monad.Trans.Except.ExceptT
                       SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                    a>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s
                         (Control.Monad.Trans.Except.ExceptT
                            SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                         b>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Trans.Except.ExceptT
                                  SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity>_R
                               <b>_N)) -}
6ee921f2ff25e90d3a47046be86a6428
  $s$fFreshFreshMT_$s$fMonadStateT_$c>>= ::
    Control.Monad.Trans.State.Lazy.StateT
      s
      (Control.Monad.Trans.Except.ExceptT
         SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
      a
    -> (a
        -> Control.Monad.Trans.State.Lazy.StateT
             s
             (Control.Monad.Trans.Except.ExceptT
                SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
             b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(C1(U))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Trans.Except.ExceptT
                               SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                            a)
                   (k :: a
                         -> Control.Monad.Trans.State.Lazy.StateT
                              s
                              (Control.Monad.Trans.Except.ExceptT
                                 SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                              b)
                   (s1 :: s) ->
                 case (m1
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <s>_N
                            <Control.Monad.Trans.Except.ExceptT
                               SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity>_R
                            <a>_N)
                         s1)
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn>_N
                           <Data.Functor.Identity.Identity>_R
                           <(a, s)>_N ; Data.Functor.Identity.N:Identity[0]
                                            <Data.Either.Either
                                               (Data.Text.Prettyprint.Doc.Internal.Doc
                                                  SEDEL.PrettyPrint.FAnn)
                                               (a, s)>_R) of wild {
                   Data.Either.Left e1
                   -> (Data.Either.Left
                         @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                         @ (b, s)
                         e1)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                                   (b, s)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                         <Data.Text.Prettyprint.Doc.Internal.Doc
                                                            SEDEL.PrettyPrint.FAnn>_N
                                                         <Data.Functor.Identity.Identity>_R
                                                         <(b, s)>_N))
                   Data.Either.Right x
                   -> (k (case x of wild1 { (,) a1 s' -> a1 }))
                        `cast`
                      (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <s>_N
                           <Control.Monad.Trans.Except.ExceptT
                              SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity>_R
                           <b>_N)
                        (case x of wild1 { (,) a1 s' -> s' }) })
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s
                    (Control.Monad.Trans.Except.ExceptT
                       SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                    a>_R
                 ->_R <a
                       -> Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Trans.Except.ExceptT
                               SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
                            b>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Trans.Except.ExceptT
                                  SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity>_R
                               <b>_N)) -}
e915fab8a09d8fb92f147b56b3e86b82
  $s$fFreshFreshMT_$s$fMonadStateT_$cfail ::
    GHC.Base.String
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.PrettyPrint.FDoc Data.Functor.Identity.Identity)
         a
  {- Arity: 2, Strictness: <B,U><B,A>x, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ s @ a (str :: GHC.Base.String) (ds :: s) ->
                 GHC.Err.errorWithoutStackTrace
                   @ 'GHC.Types.LiftedRep
                   @ (Data.Functor.Identity.Identity
                        (Data.Either.Either
                           (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                           (a, s)))
                   str)
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <GHC.Base.String>_R
                 ->_R (<s>_R
                       ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                     <Data.Text.Prettyprint.Doc.Internal.Doc
                                        SEDEL.PrettyPrint.FAnn>_N
                                     <Data.Functor.Identity.Identity>_R
                                     <(a, s)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                             <s>_N
                                                             <Control.Monad.Trans.Except.ExceptT
                                                                SEDEL.PrettyPrint.FDoc
                                                                Data.Functor.Identity.Identity>_R
                                                             <a>_N)) -}
cff57d69d2b6d4bd9769034b8e1107da
  $s$fShowEmbed_$cshowsPrec ::
    GHC.Types.Int
    -> Unbound.Generics.LocallyNameless.Embed.Embed
         SEDEL.Source.Syntax.SType
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,A><L,U>, Inline: [0],
     Unfolding: InlineRule (2, True, True)
                (\ (w4 :: GHC.Types.Int)
                   (w5 :: Unbound.Generics.LocallyNameless.Embed.Embed
                            SEDEL.Source.Syntax.SType) ->
                 Unbound.Generics.LocallyNameless.Embed.$w$cshowsPrec
                   @ SEDEL.Source.Syntax.SType
                   SEDEL.Source.Syntax.$fShowSType
                   w5) -}
76393a1e39708bc6371be3d489e6c91f
  $tc'LAll :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7229411598035079795##
                   132420449948306884##
                   SEDEL.Source.Subtyping.$trModule
                   SEDEL.Source.Subtyping.$tc'LAll2
                   0#
                   SEDEL.Source.Subtyping.$tc'LAll1) -}
c58081489116d87bc72e1c536d6926b2
  $tc'LAll1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
752b218a69e4d157d7a05b9cacf98874
  $tc'LAll2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Subtyping.$tc'LAll3) -}
b1eafb723338fa727792c6ec16a8a111
  $tc'LAll3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LAll"#) -}
3ba88fe76dd82e9ac2ede8c569396b27
  $tc'LLa :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13564326657937247284##
                   17289536278895770142##
                   SEDEL.Source.Subtyping.$trModule
                   SEDEL.Source.Subtyping.$tc'LLa2
                   0#
                   SEDEL.Source.Subtyping.$tc'LLa1) -}
6b64e8245886f3924920be9e45db447c
  $tc'LLa1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
551c1801ac07ab138d89cc774258224b
  $tc'LLa2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Subtyping.$tc'LLa3) -}
2c52bd307178987abb31efc579fbc260
  $tc'LLa3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LLa"#) -}
90a17b6174e06c7eb07bde3ef7877386
  $tc'LTy :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5179597344710325783##
                   12180426721538197632##
                   SEDEL.Source.Subtyping.$trModule
                   SEDEL.Source.Subtyping.$tc'LTy2
                   0#
                   SEDEL.Source.Subtyping.$tc'LTy1) -}
1ea28e39345900136c6d043bda2e8bfe
  $tc'LTy1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
544c12bb72cde22c09e44751ba8a276e
  $tc'LTy2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Subtyping.$tc'LTy3) -}
bfdbea080ccad67eca5717e1a0fe700d
  $tc'LTy3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LTy"#) -}
4401fceb0ab2c79ba5a08e9846e98246
  $tcL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15462666653687771128##
                   1341316412960002318##
                   SEDEL.Source.Subtyping.$trModule
                   SEDEL.Source.Subtyping.$tcL1
                   0#
                   GHC.Types.krep$*) -}
7abe75137c2ee4cd208d3b4906945b0c
  $tcL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Subtyping.$tcL2) -}
7e95e18bd023a919f6c8e93a410428ad
  $tcL2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("L"#) -}
627efbb325afcfc0a0fd717db11341da
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   SEDEL.Source.Subtyping.$trModule3
                   SEDEL.Source.Subtyping.$trModule1) -}
73cf2b3132ba108f45e9f0214d37291d
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Subtyping.$trModule2) -}
65c42b8f64b56869ad1bdbf2bd26405f
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SEDEL.Source.Subtyping"#) -}
4dc242ca0ce67ca159de8c48d3e13d7a
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Source.Subtyping.$trModule4) -}
cb643c2bd6ed21f8fa2f2b9a8fb0ff87
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("sedel-0.1.0.0-BGuUapfeRSQ3zXo3bqhidP"#) -}
27fd6c62872a031fa2e3cf45596f2ac2
  type Co = SEDEL.Target.Syntax.UExpr
e1ba0c470938b692d7201d688a431c79
  data L
    = LTy SEDEL.Source.Syntax.SType
    | LLa SEDEL.Source.Syntax.Label
    | LAll SEDEL.Source.Syntax.TyName SEDEL.Source.Syntax.SType
cff08958466fec617a1f346f949cca42
  subtype ::
    SEDEL.Environment.Ctx
    -> SEDEL.Source.Syntax.SType
    -> SEDEL.Source.Syntax.SType
    -> Data.Either.Either
         SEDEL.PrettyPrint.FDoc SEDEL.Target.Syntax.UExpr
  {- Arity: 3, Strictness: <L,U(A,U,A,A)><L,1*U><S,1*U>,
     Unfolding: (\ (ctx :: SEDEL.Environment.Ctx)
                   (st :: SEDEL.Source.Syntax.SType)
                   (tt :: SEDEL.Source.Syntax.SType) ->
                 case SEDEL.Source.Desugar.$wgo
                        ctx
                        tt
                        Unbound.Generics.LocallyNameless.Fresh.runFreshM1 of ww { (#,#) ww1 ww2 ->
                 case (SEDEL.Source.Subtyping.subtype1
                         (Data.Sequence.Internal.EmptyT
                            @ (Data.Sequence.Internal.Elem SEDEL.Source.Subtyping.L))
                           `cast`
                         (Sym (Data.Sequence.Internal.N:Seq[0]
                                   <SEDEL.Source.Subtyping.L>_R))
                         (SEDEL.Source.Desugar.expandType ctx st)
                         ww1
                         Unbound.Generics.LocallyNameless.Fresh.runFreshM1)
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn>_N
                           <Data.Functor.Identity.Identity>_R
                           <(SEDEL.Target.Syntax.UExpr,
                             GHC.Integer.Type.Integer)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                <Data.Either.Either
                                                                   (Data.Text.Prettyprint.Doc.Internal.Doc
                                                                      SEDEL.PrettyPrint.FAnn)
                                                                   (SEDEL.Target.Syntax.UExpr,
                                                                    GHC.Integer.Type.Integer)>_R) of wild {
                   Data.Either.Left e1
                   -> Data.Either.Left
                        @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                        @ SEDEL.Target.Syntax.UExpr
                        e1
                   Data.Either.Right x
                   -> Data.Either.Right
                        @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                        @ SEDEL.Target.Syntax.UExpr
                        (case x of wild1 { (,) a1 ds1 -> a1 }) } }) -}
715d37ee59e02804a2ccef73b56dbe54
  subtype1 ::
    Data.Sequence.Internal.Seq SEDEL.Source.Subtyping.L
    -> SEDEL.Source.Syntax.SType
    -> SEDEL.Source.Syntax.SType
    -> GHC.Integer.Type.Integer
    -> Control.Monad.Trans.Except.Except
         SEDEL.PrettyPrint.FDoc
         (SEDEL.Target.Syntax.UExpr, GHC.Integer.Type.Integer)
  {- Arity: 4, Strictness: <S,U><L,U><S,U><L,U> -}
"SPEC/SEDEL.Source.Subtyping $fAlphaEmbed @ SType" [orphan] forall (v :: Unbound.Generics.LocallyNameless.Alpha.Alpha
                                                                           SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fAlphaEmbed @ SEDEL.Source.Syntax.SType
                                                      v
  = SEDEL.Source.Subtyping.$s$fAlpha(,)_$s$fAlphaEmbed
"SPEC/SEDEL.Source.Subtyping $fApplicativeExceptT @ Identity _" [orphan] forall @ e
                                                                                (v1 :: GHC.Base.Monad
                                                                                         Data.Functor.Identity.Identity)
                                                                                (v :: GHC.Base.Functor
                                                                                        Data.Functor.Identity.Identity)
  Control.Monad.Trans.Except.$fApplicativeExceptT @ Data.Functor.Identity.Identity
                                                  @ e
                                                  v
                                                  v1
  = SEDEL.Source.Subtyping.$s$fApplicativeExceptT @ e
"SPEC/SEDEL.Source.Subtyping $fApplicativeExceptT_$c*> @ Identity _" [orphan] forall @ e
                                                                                     ($dMonad :: GHC.Base.Monad
                                                                                                   Data.Functor.Identity.Identity)
                                                                                     ($dFunctor :: GHC.Base.Functor
                                                                                                     Data.Functor.Identity.Identity)
  Control.Monad.Trans.Except.$fApplicativeExceptT_$c*> @ Data.Functor.Identity.Identity
                                                       @ e
                                                       $dFunctor
                                                       $dMonad
  = SEDEL.Source.Subtyping.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$c*>
      @ e
"SPEC/SEDEL.Source.Subtyping $fApplicativeExceptT_$c<* @ Identity _" [orphan] forall @ e
                                                                                     ($dMonad :: GHC.Base.Monad
                                                                                                   Data.Functor.Identity.Identity)
                                                                                     ($dFunctor :: GHC.Base.Functor
                                                                                                     Data.Functor.Identity.Identity)
  Control.Monad.Trans.Except.$fApplicativeExceptT_$c<* @ Data.Functor.Identity.Identity
                                                       @ e
                                                       $dFunctor
                                                       $dMonad
  = SEDEL.Source.Subtyping.$s$fApplicativeExceptT_$c<* @ e
"SPEC/SEDEL.Source.Subtyping $fApplicativeExceptT_$cpure @ Identity _" [orphan] forall @ e
                                                                                       ($dMonad :: GHC.Base.Monad
                                                                                                     Data.Functor.Identity.Identity)
                                                                                       ($dFunctor :: GHC.Base.Functor
                                                                                                       Data.Functor.Identity.Identity)
  Control.Monad.Trans.Except.$fApplicativeExceptT_$cpure @ Data.Functor.Identity.Identity
                                                         @ e
                                                         $dFunctor
                                                         $dMonad
  = SEDEL.Source.Subtyping.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure
      @ e
"SPEC/SEDEL.Source.Subtyping $fApplicativeFreshMT @ (ExceptT
                                                      FDoc Identity)" [orphan] forall (v :: GHC.Base.Monad
                                                                                                                                                           (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                              SEDEL.PrettyPrint.FDoc
                                                                                                                                                              Data.Functor.Identity.Identity))
  Unbound.Generics.LocallyNameless.Fresh.$fApplicativeFreshMT @ (Control.Monad.Trans.Except.ExceptT
                                                                   SEDEL.PrettyPrint.FDoc
                                                                   Data.Functor.Identity.Identity)
                                                              v
  = SEDEL.Source.Subtyping.$s$fApplicativeFreshMT
"SPEC/SEDEL.Source.Subtyping $fApplicativeFreshMT1 @ (ExceptT
                                                       FDoc Identity)" [orphan] forall ($dMonad :: GHC.Base.Monad
                                                                                                                                                                   (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                      SEDEL.PrettyPrint.FDoc
                                                                                                                                                                      Data.Functor.Identity.Identity))
  Unbound.Generics.LocallyNameless.Fresh.$fApplicativeFreshMT1 @ (Control.Monad.Trans.Except.ExceptT
                                                                    SEDEL.PrettyPrint.FDoc
                                                                    Data.Functor.Identity.Identity)
                                                               $dMonad
  = SEDEL.Source.Subtyping.$s$fApplicativeFreshMT1
"SPEC/SEDEL.Source.Subtyping $fApplicativeFreshMT2 @ (ExceptT
                                                       FDoc Identity)" [orphan] forall ($dMonad :: GHC.Base.Monad
                                                                                                                                                                   (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                      SEDEL.PrettyPrint.FDoc
                                                                                                                                                                      Data.Functor.Identity.Identity))
  Unbound.Generics.LocallyNameless.Fresh.$fApplicativeFreshMT2 @ (Control.Monad.Trans.Except.ExceptT
                                                                    SEDEL.PrettyPrint.FDoc
                                                                    Data.Functor.Identity.Identity)
                                                               $dMonad
  = SEDEL.Source.Subtyping.$s$fApplicativeFreshMT2
"SPEC/SEDEL.Source.Subtyping $fApplicativeFreshMT3 @ (ExceptT
                                                       FDoc Identity)" [orphan] forall ($dMonad :: GHC.Base.Monad
                                                                                                                                                                   (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                      SEDEL.PrettyPrint.FDoc
                                                                                                                                                                      Data.Functor.Identity.Identity))
  Unbound.Generics.LocallyNameless.Fresh.$fApplicativeFreshMT3 @ (Control.Monad.Trans.Except.ExceptT
                                                                    SEDEL.PrettyPrint.FDoc
                                                                    Data.Functor.Identity.Identity)
                                                               $dMonad
  = SEDEL.Source.Subtyping.$s$fApplicativeFreshMT3
"SPEC/SEDEL.Source.Subtyping $fFreshFreshMT @ (ExceptT
                                                FDoc Identity)" [orphan] forall (v :: GHC.Base.Monad
                                                                                                                                               (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                  SEDEL.PrettyPrint.FDoc
                                                                                                                                                  Data.Functor.Identity.Identity))
  Unbound.Generics.LocallyNameless.Fresh.$fFreshFreshMT @ (Control.Monad.Trans.Except.ExceptT
                                                             SEDEL.PrettyPrint.FDoc
                                                             Data.Functor.Identity.Identity)
                                                        v
  = SEDEL.Source.Subtyping.$s$fFreshFreshMT
"SPEC/SEDEL.Source.Subtyping $fFunctorExceptT @ Identity _" [orphan] forall @ e
                                                                            (v :: GHC.Base.Functor
                                                                                    Data.Functor.Identity.Identity)
  Control.Monad.Trans.Except.$fFunctorExceptT @ Data.Functor.Identity.Identity
                                              @ e
                                              v
  = SEDEL.Source.Subtyping.$s$fApplicativeExceptT_$s$fFunctorExceptT
      @ e
"SPEC/SEDEL.Source.Subtyping $fFunctorFreshMT @ (ExceptT
                                                  FDoc Identity)" [orphan] forall (v :: GHC.Base.Functor
                                                                                                                                                   (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                      SEDEL.PrettyPrint.FDoc
                                                                                                                                                      Data.Functor.Identity.Identity))
  Unbound.Generics.LocallyNameless.Fresh.$fFunctorFreshMT @ (Control.Monad.Trans.Except.ExceptT
                                                               SEDEL.PrettyPrint.FDoc
                                                               Data.Functor.Identity.Identity)
                                                          v
  = SEDEL.Source.Subtyping.$s$fApplicativeFreshMT_$s$fFunctorFreshMT
"SPEC/SEDEL.Source.Subtyping $fFunctorStateT_$cfmap @ (ExceptT
                                                        FDoc Identity) _" [orphan] forall @ s
                                                                                                                                                         ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                         (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                            SEDEL.PrettyPrint.FDoc
                                                                                                                                                                            Data.Functor.Identity.Identity))
  Control.Monad.Trans.State.Lazy.$fFunctorStateT_$cfmap @ (Control.Monad.Trans.Except.ExceptT
                                                             SEDEL.PrettyPrint.FDoc
                                                             Data.Functor.Identity.Identity)
                                                        @ s
                                                        $dFunctor
  = SEDEL.Source.Subtyping.$s$fApplicativeFreshMT_$s$fFunctorStateT_$cfmap
      @ s
"SPEC/SEDEL.Source.Subtyping $fMonadExceptT @ Identity _" [orphan] forall @ e
                                                                          (v :: GHC.Base.Monad
                                                                                  Data.Functor.Identity.Identity)
  Control.Monad.Trans.Except.$fMonadExceptT @ Data.Functor.Identity.Identity
                                            @ e
                                            v
  = SEDEL.Source.Subtyping.$s$fApplicativeFreshMT_$s$fMonadExceptT
      @ e
"SPEC/SEDEL.Source.Subtyping $fMonadExceptT_$c>> @ Identity _" [orphan] forall @ e
                                                                               ($dMonad :: GHC.Base.Monad
                                                                                             Data.Functor.Identity.Identity)
  Control.Monad.Trans.Except.$fMonadExceptT_$c>> @ Data.Functor.Identity.Identity
                                                 @ e
                                                 $dMonad
  = SEDEL.Source.Subtyping.$s$fApplicativeFreshMT_$s$fMonadExceptT_$c>>
      @ e
"SPEC/SEDEL.Source.Subtyping $fMonadExceptT_$c>>= @ Identity _" [orphan] forall @ e
                                                                                ($dMonad :: GHC.Base.Monad
                                                                                              Data.Functor.Identity.Identity)
  Control.Monad.Trans.Except.$fMonadExceptT_$c>>= @ Data.Functor.Identity.Identity
                                                  @ e
                                                  $dMonad
  = SEDEL.Source.Subtyping.$s$fApplicativeFreshMT_$s$fMonadExceptT_$c>>=
      @ e
"SPEC/SEDEL.Source.Subtyping $fMonadFreshMT @ (ExceptT
                                                FDoc Identity)" [orphan] forall (v :: GHC.Base.Monad
                                                                                                                                               (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                  SEDEL.PrettyPrint.FDoc
                                                                                                                                                  Data.Functor.Identity.Identity))
  Unbound.Generics.LocallyNameless.Fresh.$fMonadFreshMT @ (Control.Monad.Trans.Except.ExceptT
                                                             SEDEL.PrettyPrint.FDoc
                                                             Data.Functor.Identity.Identity)
                                                        v
  = SEDEL.Source.Subtyping.$s$fFreshFreshMT_$s$fMonadFreshMT
"SPEC/SEDEL.Source.Subtyping $fMonadStateT_$c>> @ (ExceptT
                                                    FDoc Identity) _" [orphan] forall @ s
                                                                                                                                                 ($dMonad :: GHC.Base.Monad
                                                                                                                                                               (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                  SEDEL.PrettyPrint.FDoc
                                                                                                                                                                  Data.Functor.Identity.Identity))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>> @ (Control.Monad.Trans.Except.ExceptT
                                                         SEDEL.PrettyPrint.FDoc
                                                         Data.Functor.Identity.Identity)
                                                    @ s
                                                    $dMonad
  = SEDEL.Source.Subtyping.$s$fFreshFreshMT_$s$fMonadStateT_$c>> @ s
"SPEC/SEDEL.Source.Subtyping $fMonadStateT_$c>>= @ (ExceptT
                                                     FDoc Identity) _" [orphan] forall @ s
                                                                                                                                                   ($dMonad :: GHC.Base.Monad
                                                                                                                                                                 (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                    SEDEL.PrettyPrint.FDoc
                                                                                                                                                                    Data.Functor.Identity.Identity))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>>= @ (Control.Monad.Trans.Except.ExceptT
                                                          SEDEL.PrettyPrint.FDoc
                                                          Data.Functor.Identity.Identity)
                                                     @ s
                                                     $dMonad
  = SEDEL.Source.Subtyping.$s$fFreshFreshMT_$s$fMonadStateT_$c>>= @ s
"SPEC/SEDEL.Source.Subtyping $fMonadStateT_$cfail @ (ExceptT
                                                      FDoc Identity) _" [orphan] forall @ s
                                                                                                                                                     ($dMonad :: GHC.Base.Monad
                                                                                                                                                                   (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                      SEDEL.PrettyPrint.FDoc
                                                                                                                                                                      Data.Functor.Identity.Identity))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$cfail @ (Control.Monad.Trans.Except.ExceptT
                                                           SEDEL.PrettyPrint.FDoc
                                                           Data.Functor.Identity.Identity)
                                                      @ s
                                                      $dMonad
  = SEDEL.Source.Subtyping.$s$fFreshFreshMT_$s$fMonadStateT_$cfail
      @ s
"SPEC/SEDEL.Source.Subtyping $fShowEmbed @ SType" [orphan] forall (v :: GHC.Show.Show
                                                                          SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fShowEmbed @ SEDEL.Source.Syntax.SType
                                                     v
  = SEDEL.Source.Subtyping.$s$fAlpha(,)_$s$fShowEmbed
"SPEC/SEDEL.Source.Subtyping $fShowEmbed_$cshowsPrec @ SType" [orphan] [0] forall (w4 :: GHC.Show.Show
                                                                                           SEDEL.Source.Syntax.SType)
  Unbound.Generics.LocallyNameless.Embed.$fShowEmbed_$cshowsPrec @ SEDEL.Source.Syntax.SType
                                                                 w4
  = SEDEL.Source.Subtyping.$s$fShowEmbed_$cshowsPrec
"SPEC/SEDEL.Source.Subtyping $w$c<*> @ Identity _" [orphan] [0] forall @ e
                                                                       (w4 :: GHC.Base.Monad
                                                                                Data.Functor.Identity.Identity)
  Control.Monad.Trans.Except.$w$c<*> @ Data.Functor.Identity.Identity
                                     @ e
                                     w4
  = SEDEL.Source.Subtyping.$s$fApplicativeExceptT_$c<*>_$s$w$c<*> @ e
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

