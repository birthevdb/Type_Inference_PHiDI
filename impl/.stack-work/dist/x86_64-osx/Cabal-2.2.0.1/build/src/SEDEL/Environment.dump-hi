
==================== FINAL INTERFACE ====================
2019-02-26 08:26:45.82644 UTC

interface sedel-0.1.0.0-BGuUapfeRSQ3zXo3bqhidP:SEDEL.Environment 8044
  interface hash: 7b4991247bc02ba3b3a9e40970a90d29
  ABI hash: 58bb2a9dac114da6febda68e6bcab706
  export-list hash: 9b596c30b7faa0d674ead96b5fbae4e0
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 5b9149dec39fe7285c1530d9f3164d17
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  SEDEL.Environment.addTypeSynonym
  SEDEL.Environment.addTypeSynonyms
  SEDEL.Environment.askCtx
  SEDEL.Environment.emptyCtx
  SEDEL.Environment.errThrow
  SEDEL.Environment.extendConstrainedTVarCtx
  SEDEL.Environment.extendSourceLocation
  SEDEL.Environment.extendTVarCtx
  SEDEL.Environment.extendVarCtx
  SEDEL.Environment.extendVarCtxs
  SEDEL.Environment.localCtx
  SEDEL.Environment.lookupTVarConstraint
  SEDEL.Environment.lookupTVarConstraintMaybe
  SEDEL.Environment.lookupTVarKindMaybe
  SEDEL.Environment.lookupTVarSynMaybe
  SEDEL.Environment.lookupTmDef
  SEDEL.Environment.lookupVarTy
  SEDEL.Environment.runTcMonad
  SEDEL.Environment.Ctx{SEDEL.Environment.Ctx bndCtx sourceLocation tyCtx varCtx}
  SEDEL.Environment.Err{SEDEL.Environment.Err}
  SEDEL.Environment.TcMonad
module dependencies: SEDEL.Common SEDEL.PrettyPrint
                     SEDEL.Source.Syntax
package dependencies: StateVar-1.1.1.1 array-0.5.2.0 async-2.2.1
                      base-4.11.1.0 base-orphans-0.7 bifunctors-5.5.3 binary-0.8.5.1
                      bytestring-0.10.8.2 comonad-5.0.4 containers-0.5.11.0
                      contravariant-1.4.1 deepseq-1.4.3.0 distributive-0.5.3
                      exceptions-0.10.0 ghc-boot-th-8.4.4 ghc-prim-0.5.2.0
                      hashable-1.2.7.0 integer-gmp-1.0.2.0 megaparsec-6.5.0 mtl-2.2.2
                      parser-combinators-1.0.0 pretty-1.1.3.6 prettyprinter-1.2.1
                      profunctors-5.2.2 protolude-0.2.2 stm-2.4.5.1 tagged-0.8.5
                      template-haskell-2.13.0.0 text-1.2.3.1 transformers-0.5.5.0
                      unbound-generics-0.3.4
orphans: sedel-0.1.0.0-BGuUapfeRSQ3zXo3bqhidP:SEDEL.PrettyPrint
         sedel-0.1.0.0-BGuUapfeRSQ3zXo3bqhidP:SEDEL.Source.Syntax
         transformers-0.5.5.0:Control.Monad.Trans.Error
         stm-2.4.5.1:Control.Monad.STM
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.1:Data.Text.Lazy
         text-1.2.3.1:Data.Text binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show base-4.11.1.0:GHC.Float
         base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Complex base-4.11.1.0:Data.Functor.Compose
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         bifunctors-5.5.3:Data.Bifunctor.Biff
                         bifunctors-5.5.3:Data.Bifunctor.Clown
                         bifunctors-5.5.3:Data.Bifunctor.Joker
                         bifunctors-5.5.3:Data.Bifunctor.Product
                         bifunctors-5.5.3:Data.Bifunctor.Sum
                         bifunctors-5.5.3:Data.Bifunctor.Tannen
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         ghc-boot-th-8.4.4:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.4:GHC.LanguageExtensions.Type
                         megaparsec-6.5.0:Text.Megaparsec.Error
                         megaparsec-6.5.0:Text.Megaparsec.Pos
                         megaparsec-6.5.0:Text.Megaparsec.State
                         megaparsec-6.5.0:Text.Megaparsec.Stream
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         prettyprinter-1.2.1:Data.Text.Prettyprint.Doc.Internal
                         sedel-0.1.0.0-BGuUapfeRSQ3zXo3bqhidP:SEDEL.Common
                         sedel-0.1.0.0-BGuUapfeRSQ3zXo3bqhidP:SEDEL.Source.Syntax
                         tagged-0.8.5:Data.Tagged
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.1:Data.Text text-1.2.3.1:Data.Text.Lazy
                         unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Bind
                         unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Embed
                         unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Name
                         unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Rebind
                         unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Rec
                         unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Shift
import  -/  base-4.11.1.0:Data.Either 39d922b371c4c52d426e9ee66de8371a
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.Functor f522c3501272159820fd6f242510732f
import  -/  base-4.11.1.0:Data.Tuple 3af66f3ac61ed95ba8a3a3f68ebc5003
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  containers-0.5.11.0:Data.Map.Internal 0150e210d0ae8df0f3a0669d5e32d8fa
import  -/  containers-0.5.11.0:Data.Map.Strict 40ac55e8c7db7b7f0f7e3d9769233909
import  -/  containers-0.5.11.0:Data.Map.Strict.Internal 372117aaabc2f1ff2039eaf324fdb5c6
import  -/  ghc-prim-0.5.2.0:GHC.Types d9b3023de7feae4a5308d643da5543f7
import  -/  megaparsec-6.5.0:Text.Megaparsec dad9a4aeb1f0e270a9bf949fd5479956
import  -/  megaparsec-6.5.0:Text.Megaparsec.Pos 76cd1fedff8946eefd2fe94baaeadf5f
import  -/  mtl-2.2.2:Control.Monad.Error.Class df146c18e27154b8df4c8637c59fd61b
import  -/  mtl-2.2.2:Control.Monad.Reader.Class a5ac59953d953ab8532b5c11f5e8e0b0
import  -/  prettyprinter-1.2.1:Data.Text.Prettyprint.Doc 04e8924fa6b26857d25f7e89f331b3ec
import  -/  prettyprinter-1.2.1:Data.Text.Prettyprint.Doc.Internal 4dbff1ffd6a8a023b5e8586c0275223e
import  -/  protolude-0.2.2:Protolude ec8c9f1921240ba85c2826100dc947ec
import  -/  SEDEL.PrettyPrint 49a6e7b74cbc1b9f5143d39fe1ec859b
  exports: 19ba40565495f539d4becea748f89418
  DS 7fc8fd265f83868515a063f3b34deaec
  FDoc ab8ab7aa25d70732bf916014464558a6
  FPretty 47e3f8fd9d3b528400a8d505db89f651
  ppr 661a34acef6b16f3be7a1cb6e8b61361
  pprint 49a1ae40012cb52312ba8f259909743d
import  -/  SEDEL.Source.Syntax 0548d3668eda4620fc3ff3e6cf2368fb
  exports: 6168fc739a7e41a0b25e4ca6cc08e10c
  Expr e82999745a2326527e020a915d2988cd
  Kind e82999745a2326527e020a915d2988cd
  SType e82999745a2326527e020a915d2988cd
  Star 91d4a7c25ef46a369bec0ba8c24d5fbe
  TmName e82999745a2326527e020a915d2988cd
  TopT 37aa61935fae500ca4d2904f9fa8d48b
  TyName e82999745a2326527e020a915d2988cd
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Except 1cac4acbba7f36bd732fcc993d3cc20d
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Reader 42962052353a5a0f766912058b765b5d
import  -/  unbound-generics-0.3.4:Unbound.Generics.LocallyNameless 8dd357a9d9fbbcf23f41fb39ba00f4e4
import  -/  unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Fresh 6f0bdf2414300284a1d43f913bee508e
88a7fa89a1348de0aae7d6d5f1542721
  $fFPrettyErr :: SEDEL.PrettyPrint.FPretty SEDEL.Environment.Err
  DFunId
  {- Arity: 3,
     Strictness: <L,A><S(SLLL),U(U(U,U,U,U,U),U,U,U)><S(SL),1*U(1*U,U)>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                SEDEL.Environment.$fFPrettyErr_$cppr
                  `cast`
                (Sym (SEDEL.PrettyPrint.N:FPretty[0] <SEDEL.Environment.Err>_N)) -}
4936f1dd6162ce83db9710dfeeb7b0fc
  $fFPrettyErr1 ::
    Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn
  {- Unfolding: (Data.Text.Prettyprint.Doc.Internal.$fIsStringDoc_$cfromString
                   @ SEDEL.PrettyPrint.FAnn
                   (GHC.CString.unpackCString# SEDEL.Environment.$fFPrettyErr2)) -}
1ba5e66578bf4d4411231230b9fb1406
  $fFPrettyErr2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("In the expression:"#) -}
88a7fa89a1348de0aae7d6d5f1542721
  $fFPrettyErr_$cppr ::
    (GHC.Base.Applicative m,
     Unbound.Generics.LocallyNameless.LFresh.LFresh m) =>
    SEDEL.Environment.Err -> m SEDEL.PrettyPrint.FDoc
  {- Arity: 3,
     Strictness: <L,A><S(SLLL),U(U(U,U,U,U,U),U,U,U)><S(SL),1*U(1*U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   (w :: GHC.Base.Applicative m)
                   (w1 :: Unbound.Generics.LocallyNameless.LFresh.LFresh m)
                   (w2 :: SEDEL.Environment.Err) ->
                 case w2 of ww { SEDEL.Environment.Err ww1 ww2 ->
                 SEDEL.Environment.$w$cppr @ m w1 ww1 ww2 }) -}
88a7fa89a1348de0aae7d6d5f1542721
  $fMonoidErr :: GHC.Base.Monoid SEDEL.Environment.Err
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ SEDEL.Environment.Err
                  SEDEL.Environment.$fSemigroupErr
                  SEDEL.Environment.$fMonoidErr_$cmempty
                  SEDEL.Environment.$fMonoidErr_$c<>
                  SEDEL.Environment.$fMonoidErr_go -}
88a7fa89a1348de0aae7d6d5f1542721
  $fMonoidErr_$c<> ::
    SEDEL.Environment.Err
    -> SEDEL.Environment.Err -> SEDEL.Environment.Err
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(1*U,U)><S,1*U(1*U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: SEDEL.Environment.Err) (ds1 :: SEDEL.Environment.Err) ->
                 case ds of wild { SEDEL.Environment.Err src1 d1 ->
                 case ds1 of wild1 { SEDEL.Environment.Err src2 d2 ->
                 SEDEL.Environment.Err
                   (GHC.Base.augment
                      @ SEDEL.Environment.SourceLocation
                      (\ @ b
                         (c :: SEDEL.Environment.SourceLocation -> b -> b)[OneShot]
                         (n :: b)[OneShot] ->
                       GHC.Base.foldr @ SEDEL.Environment.SourceLocation @ b c n src1)
                      src2)
                   (Data.Text.Prettyprint.Doc.Internal.Cat
                      @ SEDEL.PrettyPrint.FAnn
                      d1
                      d2) } }) -}
88a7fa89a1348de0aae7d6d5f1542721
  $fMonoidErr_$cmempty :: SEDEL.Environment.Err
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (SEDEL.Environment.Err
                   (GHC.Types.[] @ SEDEL.Environment.SourceLocation)
                   (Data.Text.Prettyprint.Doc.Internal.Empty
                      @ SEDEL.PrettyPrint.FAnn)) -}
88a7fa89a1348de0aae7d6d5f1542721
  $fMonoidErr_go :: [SEDEL.Environment.Err] -> SEDEL.Environment.Err
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [SEDEL.Environment.Err]) ->
                 case SEDEL.Environment.$wgo w of ww { (#,#) ww1 ww2 ->
                 SEDEL.Environment.Err ww1 ww2 }) -}
88a7fa89a1348de0aae7d6d5f1542721
  $fSemigroupErr :: GHC.Base.Semigroup SEDEL.Environment.Err
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ SEDEL.Environment.Err
                  SEDEL.Environment.$fMonoidErr_$c<>
                  SEDEL.Environment.$fSemigroupErr_$csconcat
                  SEDEL.Environment.$fSemigroupErr_$cstimes -}
88a7fa89a1348de0aae7d6d5f1542721
  $fSemigroupErr_$csconcat ::
    GHC.Base.NonEmpty SEDEL.Environment.Err -> SEDEL.Environment.Err
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SS),1*U(1*U(U,U),1*U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Base.NonEmpty SEDEL.Environment.Err) ->
                 case ds of wild { GHC.Base.:| a1 as ->
                 SEDEL.Environment.$fSemigroupErr_go a1 as }) -}
88a7fa89a1348de0aae7d6d5f1542721
  $fSemigroupErr_$cstimes ::
    GHC.Real.Integral b =>
    b -> SEDEL.Environment.Err -> SEDEL.Environment.Err
  {- Arity: 1, Strictness: <L,U> -}
88a7fa89a1348de0aae7d6d5f1542721
  $fSemigroupErr_go ::
    SEDEL.Environment.Err
    -> [SEDEL.Environment.Err] -> SEDEL.Environment.Err
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U,U)><S,1*U>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: SEDEL.Environment.Err) (w1 :: [SEDEL.Environment.Err]) ->
                 case w of ww { SEDEL.Environment.Err ww1 ww2 ->
                 case SEDEL.Environment.$wgo1 ww1 ww2 w1 of ww3 { (#,#) ww4 ww5 ->
                 SEDEL.Environment.Err ww4 ww5 } }) -}
0952f731997e4b60298c6da01a1e83ac
  $sinsert_$sgo1 ::
    SEDEL.Source.Syntax.TmName
    -> a1
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.TmName a1
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.TmName a1
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
f752a541e7c8048014d777dc348a0b04
  $sinsert_$sgo8 ::
    SEDEL.Source.Syntax.TyName
    -> a1
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.TyName a1
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.TyName a1
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
198248238e7d8c177005a1a422e9111f
  $slookup1 ::
    SEDEL.Source.Syntax.TyName
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.TyName a
    -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
12dfc7f60756334bf9d4b193c752e73a
  $slookup3 ::
    SEDEL.Source.Syntax.TmName
    -> Data.Map.Internal.Map SEDEL.Source.Syntax.TmName a
    -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
3e347e16cfa867bef1edf46f60f7a105
  $tc'Ctx :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5485890530881523074##
                   4643267350555236760##
                   SEDEL.Environment.$trModule
                   SEDEL.Environment.$tc'Ctx2
                   0#
                   SEDEL.Environment.$tc'Ctx1) -}
1c66de0ed99a01a9b3fc699f7d679429
  $tc'Ctx1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
cba079f3dab4f5341dac0009f204417f
  $tc'Ctx2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Environment.$tc'Ctx3) -}
7933df29c8a4772e13fd7614e057297f
  $tc'Ctx3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Ctx"#) -}
66c76f747da1ef8fdd72c0e0ed66f37d
  $tc'Err :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4330631923254039874##
                   1940666145248479711##
                   SEDEL.Environment.$trModule
                   SEDEL.Environment.$tc'Err2
                   0#
                   SEDEL.Environment.$tc'Err1) -}
813abaa64b257ca8adf832bfee2e1915
  $tc'Err1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
d68e673dc40bc9579dbaafd9fa464358
  $tc'Err2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Environment.$tc'Err3) -}
e55ba836b9b2851980e7a03c1797ba0c
  $tc'Err3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Err"#) -}
5c393838fa3655b8e1755d44c54e359c
  $tc'NonTerminalType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11268108679978919893##
                   8722959911011972653##
                   SEDEL.Environment.$trModule
                   SEDEL.Environment.$tc'NonTerminalType2
                   0#
                   SEDEL.Environment.$tc'NonTerminalType1) -}
796cf080ba9d9655edc995eea06abe9c
  $tc'NonTerminalType1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
73de249962238b6f41858072a9ae1afe
  $tc'NonTerminalType2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   SEDEL.Environment.$tc'NonTerminalType3) -}
4448279b224d7097016af6843c2b73a8
  $tc'NonTerminalType3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NonTerminalType"#) -}
a19ef192c1f6e1e2bdbe96981469e3b2
  $tc'SourceLocation :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11694108590300834907##
                   343104753311745593##
                   SEDEL.Environment.$trModule
                   SEDEL.Environment.$tc'SourceLocation2
                   1#
                   SEDEL.Environment.$tc'SourceLocation1) -}
c71baa0cd044b3f1119b7282a478c09b
  $tc'SourceLocation1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
d79d099925751426f85062486c26b673
  $tc'SourceLocation2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   SEDEL.Environment.$tc'SourceLocation3) -}
a49948995759fb4dbc9f7de4db855861
  $tc'SourceLocation3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'SourceLocation"#) -}
bad92e9abc8b91df4f6bcd143e11ce6a
  $tc'TerminalType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8107452440643046807##
                   9791928840857131659##
                   SEDEL.Environment.$trModule
                   SEDEL.Environment.$tc'TerminalType2
                   0#
                   SEDEL.Environment.$tc'TerminalType1) -}
f88ca562e75b7dcd1df936e920cdd747
  $tc'TerminalType1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
72e2d42a4032c2e8fc572c52bbd4d4b8
  $tc'TerminalType2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   SEDEL.Environment.$tc'TerminalType3) -}
f3e60c2a0fbd056a8b18c0ba83deb208
  $tc'TerminalType3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'TerminalType"#) -}
0cd3d7d27a2722b1836c787fd0e80199
  $tcCtx :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2518994863471249773##
                   7089157299481409822##
                   SEDEL.Environment.$trModule
                   SEDEL.Environment.$tcCtx1
                   0#
                   GHC.Types.krep$*) -}
eefbc3e8b2d40750c86b071f51329111
  $tcCtx1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Environment.$tcCtx2) -}
3337943849f498cb99cd7975cb4a3cd3
  $tcCtx2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Ctx"#) -}
8143cd61c81257b95a892d142d5db854
  $tcErr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1463056916073462708##
                   12126317404487718915##
                   SEDEL.Environment.$trModule
                   SEDEL.Environment.$tcErr1
                   0#
                   GHC.Types.krep$*) -}
215c2b4c8d52c8f08a8df76b04ac43ed
  $tcErr1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Environment.$tcErr2) -}
6aae9e05ec73a793fc15c412c5121e7b
  $tcErr2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Err"#) -}
b1c9ce3a1b6a4226968c80a911249baf
  $tcSourceLocation :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6703369659934496352##
                   6866782403985266328##
                   SEDEL.Environment.$trModule
                   SEDEL.Environment.$tcSourceLocation1
                   0#
                   GHC.Types.krep$*) -}
0ef4d736b7d691139543bffaab842f21
  $tcSourceLocation1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   SEDEL.Environment.$tcSourceLocation2) -}
c71666659d928047ea46a80c751b2b5e
  $tcSourceLocation2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SourceLocation"#) -}
fcc2e81e7ddfe4c1720c9facdce09696
  $tcTypeValue :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3914333686723072425##
                   6542521218664028762##
                   SEDEL.Environment.$trModule
                   SEDEL.Environment.$tcTypeValue1
                   0#
                   GHC.Types.krep$*) -}
8f5820b9feaef30da8f805d920613179
  $tcTypeValue1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Environment.$tcTypeValue2) -}
0c50d41012bb701bc44403132560d9f0
  $tcTypeValue2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("TypeValue"#) -}
59996d22d94ca91a75e339b8fc7ef421
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   SEDEL.Environment.$trModule3
                   SEDEL.Environment.$trModule1) -}
9513f4e7e3f9aa642e1313f1fab594fa
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Environment.$trModule2) -}
5ceeed995c50c5c701bd51f0505f9430
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SEDEL.Environment"#) -}
204d99a592c0a0ae43ba7c813f965cc4
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Environment.$trModule4) -}
145c05982a6ac67efd4e77e9e4e97036
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("sedel-0.1.0.0-BGuUapfeRSQ3zXo3bqhidP"#) -}
4ad3e3ad92a95596e3b32dc8ccdd04ac
  $w$cppr ::
    Unbound.Generics.LocallyNameless.LFresh.LFresh m =>
    [SEDEL.Environment.SourceLocation]
    -> SEDEL.PrettyPrint.FDoc -> m SEDEL.PrettyPrint.FDoc
  {- Arity: 3,
     Strictness: <S(SLLL),U(U(U,U,U,U,U),U,U,U)><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ @ m :: * -> *
                   (w :: Unbound.Generics.LocallyNameless.LFresh.LFresh m)
                   (ww :: [SEDEL.Environment.SourceLocation])
                   (ww1 :: SEDEL.PrettyPrint.FDoc) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Unbound.Generics.LocallyNameless.LFresh.$p1LFresh @ m w
                 } in
                 case ww of wild {
                   [] -> GHC.Base.return @ m $dMonad @ SEDEL.PrettyPrint.FDoc ww1
                   : ds ds1
                   -> case ds of wild1 { SEDEL.Environment.SourceLocation a $dFPretty p term ->
                      let {
                        lvl :: Data.Text.Prettyprint.Doc.Internal.Doc
                                 SEDEL.PrettyPrint.FAnn
                        = case p of wild2 { Text.Megaparsec.Pos.SourcePos ds2 dt dt1 ->
                          Data.Text.Prettyprint.Doc.Internal.Cat
                            @ SEDEL.PrettyPrint.FAnn
                            (Data.Text.Prettyprint.Doc.Internal.$w$cpretty5
                               @ SEDEL.PrettyPrint.FAnn
                               dt)
                            (Data.Text.Prettyprint.Doc.Internal.Cat
                               @ SEDEL.PrettyPrint.FAnn
                               (Data.Text.Prettyprint.Doc.Symbols.Ascii.colon
                                  @ SEDEL.PrettyPrint.FAnn)
                               (Data.Text.Prettyprint.Doc.Internal.Cat
                                  @ SEDEL.PrettyPrint.FAnn
                                  (Data.Text.Prettyprint.Doc.Internal.$w$cpretty5
                                     @ SEDEL.PrettyPrint.FAnn
                                     dt1)
                                  (Data.Text.Prettyprint.Doc.Symbols.Ascii.colon
                                     @ SEDEL.PrettyPrint.FAnn))) }
                      } in
                      GHC.Base.>>=
                        @ m
                        $dMonad
                        @ SEDEL.PrettyPrint.FDoc
                        @ SEDEL.PrettyPrint.FDoc
                        ($dFPretty `cast` (SEDEL.PrettyPrint.N:FPretty[0] <a>_N)
                           @ m
                           (GHC.Base.$p1Monad @ m $dMonad)
                           w
                           term)
                        (\ (trm :: SEDEL.PrettyPrint.FDoc) ->
                         GHC.Base.return
                           @ m
                           $dMonad
                           @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                           (Data.Text.Prettyprint.Doc.Internal.vsep1
                              @ SEDEL.PrettyPrint.FAnn
                              (GHC.Types.:
                                 @ (Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn)
                                 lvl
                                 (GHC.Types.:
                                    @ (Data.Text.Prettyprint.Doc.Internal.Doc
                                         SEDEL.PrettyPrint.FAnn)
                                    ww1
                                    (GHC.Types.:
                                       @ (Data.Text.Prettyprint.Doc.Internal.Doc
                                            SEDEL.PrettyPrint.FAnn)
                                       SEDEL.Environment.$fFPrettyErr1
                                       (GHC.Types.:
                                          @ (Data.Text.Prettyprint.Doc.Internal.Doc
                                               SEDEL.PrettyPrint.FAnn)
                                          trm
                                          (GHC.Types.[]
                                             @ (Data.Text.Prettyprint.Doc.Internal.Doc
                                                  SEDEL.PrettyPrint.FAnn)))))))) } }) -}
88a7fa89a1348de0aae7d6d5f1542721
  $wgo ::
    [SEDEL.Environment.Err]
    -> (# [SEDEL.Environment.SourceLocation], SEDEL.PrettyPrint.FDoc #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
88a7fa89a1348de0aae7d6d5f1542721
  $wgo1 ::
    [SEDEL.Environment.SourceLocation]
    -> SEDEL.PrettyPrint.FDoc
    -> [SEDEL.Environment.Err]
    -> (# [SEDEL.Environment.SourceLocation], SEDEL.PrettyPrint.FDoc #)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><S,1*U>,
     Inline: [0] -}
f50e0af6f153058ceb48dc23029264d5
  $wlookupTVarSynMaybe ::
    SEDEL.Environment.TyCtx
    -> SEDEL.Source.Syntax.TyName
    -> GHC.Base.Maybe SEDEL.Source.Syntax.SType
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: SEDEL.Environment.TyCtx)
                   (w :: SEDEL.Source.Syntax.TyName) ->
                 case SEDEL.Environment.$slookup1
                        @ (SEDEL.Source.Syntax.Kind, SEDEL.Source.Syntax.SType,
                           SEDEL.Environment.TypeValue)
                        w
                        ww of wild {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ SEDEL.Source.Syntax.SType
                   GHC.Base.Just a1
                   -> case a1 of wild1 { (,,) ds ds1 t ->
                      case t of wild2 {
                        SEDEL.Environment.TerminalType
                        -> GHC.Base.Nothing @ SEDEL.Source.Syntax.SType
                        SEDEL.Environment.NonTerminalType t1
                        -> GHC.Base.Just @ SEDEL.Source.Syntax.SType t1 } } }) -}
0b8b6393544d3a2a8acf42378c033bf6
  type BndCtx =
    Data.Map.Internal.Map
      SEDEL.Source.Syntax.TmName SEDEL.Source.Syntax.Expr
4d40b76497431ab3e2b46fb381d29825
  data Ctx
    = Ctx {varCtx :: SEDEL.Environment.VarCtx,
           tyCtx :: SEDEL.Environment.TyCtx,
           bndCtx :: SEDEL.Environment.BndCtx,
           sourceLocation :: [SEDEL.Environment.SourceLocation]}
88a7fa89a1348de0aae7d6d5f1542721
  data Err
    = Err [SEDEL.Environment.SourceLocation] SEDEL.PrettyPrint.FDoc
bdf72690ea2741bf8aa2ed195dc5cf4f
  data SourceLocation where
    SourceLocation :: SEDEL.PrettyPrint.FPretty a =>
                      Text.Megaparsec.Pos.SourcePos -> a -> SourceLocation
2993bda6ca1aa509196cffef0897dad2
  type TcMonad =
    Unbound.Generics.LocallyNameless.Fresh.FreshMT
      (Control.Monad.Trans.Reader.ReaderT
         SEDEL.Environment.Ctx
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO))
    :: * -> *
4f270a1dead6d4f4c7e383ae9a522c0b
  type TyCtx =
    Data.Map.Internal.Map
      SEDEL.Source.Syntax.TyName
      (SEDEL.Source.Syntax.Kind, SEDEL.Source.Syntax.SType,
       SEDEL.Environment.TypeValue)
f801c233d981eb364e566cb7e6375ea3
  data TypeValue
    = TerminalType | NonTerminalType SEDEL.Source.Syntax.SType
f3a450b5854944fe84c79297ab1f3547
  type VarCtx =
    Data.Map.Internal.Map
      SEDEL.Source.Syntax.TmName SEDEL.Source.Syntax.SType
0ae5e3642c44b1a295db22696bab8b5e
  addTypeSynonym ::
    SEDEL.Source.Syntax.TyName
    -> SEDEL.Source.Syntax.SType
    -> SEDEL.Source.Syntax.Kind
    -> SEDEL.Environment.Ctx
    -> SEDEL.Environment.Ctx
  {- Arity: 4, Strictness: <L,1*U><L,U><L,U><L,U(1*U,1*U,1*U,1*U)>m,
     Unfolding: InlineRule (4, True, False)
                (\ (v :: SEDEL.Source.Syntax.TyName)
                   (t :: SEDEL.Source.Syntax.SType)
                   (k :: SEDEL.Source.Syntax.Kind)
                   (eta :: SEDEL.Environment.Ctx) ->
                 SEDEL.Environment.Ctx
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 -> ds })
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 ->
                    SEDEL.Environment.$sinsert_$sgo8
                      @ (SEDEL.Source.Syntax.Kind, SEDEL.Source.Syntax.SType,
                         SEDEL.Environment.TypeValue)
                      v
                      (k, t, SEDEL.Environment.NonTerminalType t)
                      ds1 })
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 -> ds2 })
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 ->
                    ds3 })) -}
c5958b7842f731c5ce674aa0caf2ac2f
  addTypeSynonyms ::
    [(SEDEL.Source.Syntax.TyName, SEDEL.Source.Syntax.SType,
      SEDEL.Source.Syntax.Kind)]
    -> SEDEL.Environment.Ctx -> SEDEL.Environment.Ctx
  {- Arity: 2, Strictness: <S,1*U><L,U(U,U,U,U)>,
     Unfolding: (\ (x :: [(SEDEL.Source.Syntax.TyName,
                           SEDEL.Source.Syntax.SType, SEDEL.Source.Syntax.Kind)])
                   (y :: SEDEL.Environment.Ctx) ->
                 letrec {
                   go :: [(SEDEL.Source.Syntax.TyName, SEDEL.Source.Syntax.SType,
                           SEDEL.Source.Syntax.Kind)]
                         -> SEDEL.Environment.Ctx
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [(SEDEL.Source.Syntax.TyName, SEDEL.Source.Syntax.SType,
                                SEDEL.Source.Syntax.Kind)]) ->
                     case ds of wild {
                       [] -> y
                       : y1 ys
                       -> case y1 of wild1 { (,,) v t k ->
                          let {
                            eta :: SEDEL.Environment.Ctx = go ys
                          } in
                          SEDEL.Environment.Ctx
                            (case eta of wild2 { SEDEL.Environment.Ctx ds1 ds2 ds3 ds4 ->
                             ds1 })
                            (case eta of wild2 { SEDEL.Environment.Ctx ds1 ds2 ds3 ds4 ->
                             SEDEL.Environment.$sinsert_$sgo8
                               @ (SEDEL.Source.Syntax.Kind, SEDEL.Source.Syntax.SType,
                                  SEDEL.Environment.TypeValue)
                               v
                               (k, t, SEDEL.Environment.NonTerminalType t)
                               ds2 })
                            (case eta of wild2 { SEDEL.Environment.Ctx ds1 ds2 ds3 ds4 ->
                             ds3 })
                            (case eta of wild2 { SEDEL.Environment.Ctx ds1 ds2 ds3 ds4 ->
                             ds4 }) } }
                 } in
                 go x) -}
3726505e5c41e2fb9b997967293a315a
  askCtx :: SEDEL.Environment.TcMonad SEDEL.Environment.Ctx
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                SEDEL.Environment.askCtx1
                  `cast`
                ((<GHC.Integer.Type.Integer>_R
                  ->_R (<SEDEL.Environment.Ctx>_R
                        ->_R Sym (GHC.Types.N:IO[0]
                                      <Data.Either.Either
                                         SEDEL.Environment.Err
                                         (SEDEL.Environment.Ctx,
                                          GHC.Integer.Type.Integer)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                   <SEDEL.Environment.Err>_N
                                                                                   <GHC.Types.IO>_R
                                                                                   <(SEDEL.Environment.Ctx,
                                                                                     GHC.Integer.Type.Integer)>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                               <*>_N
                                                                                                                               <SEDEL.Environment.Ctx>_R
                                                                                                                               <Control.Monad.Trans.Except.ExceptT
                                                                                                                                  SEDEL.Environment.Err
                                                                                                                                  GHC.Types.IO>_R
                                                                                                                               <(SEDEL.Environment.Ctx,
                                                                                                                                 GHC.Integer.Type.Integer)>_N)) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                            <GHC.Integer.Type.Integer>_N
                                                                                                                                                                            <Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                               SEDEL.Environment.Ctx
                                                                                                                                                                               (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                  SEDEL.Environment.Err
                                                                                                                                                                                  GHC.Types.IO)>_R
                                                                                                                                                                            <SEDEL.Environment.Ctx>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                                                                                                                      SEDEL.Environment.Ctx
                                                                                                                                                                                                                                                                      (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                         SEDEL.Environment.Err
                                                                                                                                                                                                                                                                         GHC.Types.IO)>_N <SEDEL.Environment.Ctx>_N)) -}
d3fc4d811c2f0832fed65b3928b49101
  askCtx1 ::
    GHC.Integer.Type.Integer
    -> SEDEL.Environment.Ctx
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either
            SEDEL.Environment.Err
            (SEDEL.Environment.Ctx, GHC.Integer.Type.Integer) #)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ (eta :: GHC.Integer.Type.Integer)
                   (r1 :: SEDEL.Environment.Ctx)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 (# s,
                    Data.Either.Right
                      @ SEDEL.Environment.Err
                      @ (SEDEL.Environment.Ctx, GHC.Integer.Type.Integer)
                      (r1, eta) #)) -}
4d40b76497431ab3e2b46fb381d29825
  bndCtx :: SEDEL.Environment.Ctx -> SEDEL.Environment.BndCtx
  RecSel Left SEDEL.Environment.Ctx
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLSL),1*U(A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: SEDEL.Environment.Ctx) ->
                 case ds of wild { SEDEL.Environment.Ctx ds1 ds2 ds3 ds4 ->
                 ds3 }) -}
9f86003c09c597483f0becd8e25c5a7d
  emptyCtx :: SEDEL.Environment.Ctx
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (SEDEL.Environment.Ctx
                   (Data.Map.Internal.Tip
                      @ SEDEL.Source.Syntax.TmName
                      @ SEDEL.Source.Syntax.SType)
                   (Data.Map.Internal.Tip
                      @ SEDEL.Source.Syntax.TyName
                      @ (SEDEL.Source.Syntax.Kind, SEDEL.Source.Syntax.SType,
                         SEDEL.Environment.TypeValue))
                   (Data.Map.Internal.Tip
                      @ SEDEL.Source.Syntax.TmName
                      @ SEDEL.Source.Syntax.Expr)
                   (GHC.Types.[] @ SEDEL.Environment.SourceLocation)) -}
cc71f8a413ca264032e5a44caa583457
  errThrow ::
    (SEDEL.PrettyPrint.FPretty a,
     Control.Monad.Error.Class.MonadError SEDEL.Environment.Err m,
     Control.Monad.Reader.Class.MonadReader SEDEL.Environment.Ctx m) =>
    a -> m b
  {- Arity: 4,
     Strictness: <L,1*C1(C1(C1(U)))><S(S(LC(C(S))LLL)LL),U(1*U(A,1*C1(C1(U)),A,A,A),C(U),A)><L,1*U(A,A,A,1*C1(U))><L,U>,
     Unfolding: (\ @ a
                   @ m :: * -> *
                   @ b
                   ($dFPretty :: SEDEL.PrettyPrint.FPretty a)
                   ($dMonadError :: Control.Monad.Error.Class.MonadError
                                      SEDEL.Environment.Err m)
                   ($dMonadReader :: Control.Monad.Reader.Class.MonadReader
                                       SEDEL.Environment.Ctx m)
                   (eta :: a) ->
                 let {
                   lvl :: Data.Functor.Identity.Identity SEDEL.PrettyPrint.FDoc
                   = ($dFPretty `cast` (SEDEL.PrettyPrint.N:FPretty[0] <a>_N)
                        @ (Unbound.Generics.LocallyNameless.LFresh.LFreshMT
                             Data.Functor.Identity.Identity)
                        SEDEL.PrettyPrint.$s$fApplicativeLFreshMT
                        SEDEL.PrettyPrint.$s$fLFreshLFreshMT
                        eta)
                       `cast`
                     (Unbound.Generics.LocallyNameless.LFresh.N:LFreshMT[0] <Data.Functor.Identity.Identity>_N <SEDEL.PrettyPrint.FDoc>_N ; Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                                                <*>_N
                                                                                                                                                <Data.Set.Internal.Set
                                                                                                                                                   Unbound.Generics.LocallyNameless.Name.AnyName>_R
                                                                                                                                                <Data.Functor.Identity.Identity>_R
                                                                                                                                                <SEDEL.PrettyPrint.FDoc>_N)
                       (Data.Set.Internal.Tip
                          @ Unbound.Generics.LocallyNameless.Name.AnyName)
                 } in
                 GHC.Base.>>=
                   @ m
                   (Control.Monad.Error.Class.$p1MonadError
                      @ SEDEL.Environment.Err
                      @ m
                      $dMonadError)
                   @ [SEDEL.Environment.SourceLocation]
                   @ b
                   (Control.Monad.Reader.Class.reader
                      @ SEDEL.Environment.Ctx
                      @ m
                      $dMonadReader
                      @ [SEDEL.Environment.SourceLocation]
                      SEDEL.Environment.sourceLocation)
                   (\ (loc :: [SEDEL.Environment.SourceLocation]) ->
                    Control.Monad.Error.Class.throwError
                      @ SEDEL.Environment.Err
                      @ m
                      $dMonadError
                      @ b
                      (SEDEL.Environment.Err
                         loc
                         lvl
                           `cast`
                         (Data.Functor.Identity.N:Identity[0]
                              <SEDEL.PrettyPrint.FDoc>_R)))) -}
26c0f00eb485887313683fb5132d1873
  extendConstrainedTVarCtx ::
    SEDEL.Source.Syntax.TyName
    -> SEDEL.Source.Syntax.SType
    -> SEDEL.Environment.Ctx
    -> SEDEL.Environment.Ctx
  {- Arity: 3, Strictness: <L,1*U><L,U><L,U(1*U,1*U,1*U,1*U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ (v :: SEDEL.Source.Syntax.TyName)
                   (t :: SEDEL.Source.Syntax.SType)
                   (eta :: SEDEL.Environment.Ctx) ->
                 SEDEL.Environment.Ctx
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 -> ds })
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 ->
                    SEDEL.Environment.$sinsert_$sgo8
                      @ (SEDEL.Source.Syntax.Kind, SEDEL.Source.Syntax.SType,
                         SEDEL.Environment.TypeValue)
                      v
                      (SEDEL.Source.Syntax.Star, t, SEDEL.Environment.TerminalType)
                      ds1 })
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 -> ds2 })
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 ->
                    ds3 })) -}
14af75c061e5c8aa0125aa04bc2a91dc
  extendSourceLocation ::
    (Control.Monad.Reader.Class.MonadReader SEDEL.Environment.Ctx m,
     SEDEL.PrettyPrint.FPretty t) =>
    Text.Megaparsec.Pos.SourcePos -> t -> m a -> m a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LLC(S)L),1*U(A,A,1*C1(U),A)><L,U><L,U><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ m :: * -> *
                   @ t
                   @ a
                   ($dMonadReader :: Control.Monad.Reader.Class.MonadReader
                                       SEDEL.Environment.Ctx m)
                   ($dFPretty :: SEDEL.PrettyPrint.FPretty t)
                   (p :: Text.Megaparsec.Pos.SourcePos)
                   (t1 :: t) ->
                 let {
                   lvl :: SEDEL.Environment.SourceLocation
                   = SEDEL.Environment.SourceLocation @ t $dFPretty p t1
                 } in
                 Control.Monad.Reader.Class.local
                   @ SEDEL.Environment.Ctx
                   @ m
                   $dMonadReader
                   @ a
                   (\ (e :: SEDEL.Environment.Ctx) ->
                    case e of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 ->
                    SEDEL.Environment.Ctx
                      ds
                      ds1
                      ds2
                      (GHC.Types.: @ SEDEL.Environment.SourceLocation lvl ds3) })) -}
e336ab63c868471604a9e43bd4b5c3f4
  extendTVarCtx ::
    SEDEL.Source.Syntax.TyName
    -> SEDEL.Source.Syntax.Kind
    -> SEDEL.Environment.Ctx
    -> SEDEL.Environment.Ctx
  {- Arity: 3, Strictness: <L,1*U><L,U><L,U(1*U,1*U,1*U,1*U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ (v :: SEDEL.Source.Syntax.TyName)
                   (k :: SEDEL.Source.Syntax.Kind)
                   (eta :: SEDEL.Environment.Ctx) ->
                 SEDEL.Environment.Ctx
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 -> ds })
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 ->
                    SEDEL.Environment.$sinsert_$sgo8
                      @ (SEDEL.Source.Syntax.Kind, SEDEL.Source.Syntax.SType,
                         SEDEL.Environment.TypeValue)
                      v
                      (k, SEDEL.Source.Syntax.TopT, SEDEL.Environment.TerminalType)
                      ds1 })
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 -> ds2 })
                   (case eta of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 ->
                    ds3 })) -}
7a1c812da1af8d35d7821e1c6a1353ed
  extendVarCtx ::
    SEDEL.Source.Syntax.TmName
    -> SEDEL.Source.Syntax.SType
    -> SEDEL.Environment.Ctx
    -> SEDEL.Environment.Ctx
  {- Arity: 3, Strictness: <L,1*U><L,1*U><L,U(1*U,1*U,1*U,1*U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ (v :: SEDEL.Source.Syntax.TmName)
                   (t :: SEDEL.Source.Syntax.SType)
                   (ctx :: SEDEL.Environment.Ctx) ->
                 SEDEL.Environment.Ctx
                   (case ctx of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 ->
                    SEDEL.Environment.$sinsert_$sgo1
                      @ SEDEL.Source.Syntax.SType
                      v
                      t
                      ds })
                   (case ctx of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 -> ds1 })
                   (case ctx of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 -> ds2 })
                   (case ctx of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 ->
                    ds3 })) -}
931b874984ac9d08465366d11633c1b6
  extendVarCtxs ::
    [(SEDEL.Source.Syntax.TmName, SEDEL.Source.Syntax.SType)]
    -> SEDEL.Environment.Ctx -> SEDEL.Environment.Ctx
  {- Arity: 2, Strictness: <S,1*U><L,U(U,U,U,U)>,
     Unfolding: (\ (x :: [(SEDEL.Source.Syntax.TmName,
                           SEDEL.Source.Syntax.SType)])
                   (y :: SEDEL.Environment.Ctx) ->
                 letrec {
                   go :: [(SEDEL.Source.Syntax.TmName, SEDEL.Source.Syntax.SType)]
                         -> SEDEL.Environment.Ctx
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [(SEDEL.Source.Syntax.TmName,
                                SEDEL.Source.Syntax.SType)]) ->
                     case ds of wild {
                       [] -> y
                       : y1 ys
                       -> let {
                            eta :: SEDEL.Environment.Ctx = go ys
                          } in
                          SEDEL.Environment.Ctx
                            (case y1 of wild1 { (,) x1 ds1 ->
                             case eta of wild2 { SEDEL.Environment.Ctx ds2 ds3 ds4 ds5 ->
                             SEDEL.Environment.$sinsert_$sgo1
                               @ SEDEL.Source.Syntax.SType
                               x1
                               ds1
                               ds2 } })
                            (case eta of wild1 { SEDEL.Environment.Ctx ds1 ds2 ds3 ds4 ->
                             ds2 })
                            (case eta of wild1 { SEDEL.Environment.Ctx ds1 ds2 ds3 ds4 ->
                             ds3 })
                            (case eta of wild1 { SEDEL.Environment.Ctx ds1 ds2 ds3 ds4 ->
                             ds4 }) }
                 } in
                 go x) -}
38ae9f97ee1f98c8eb1e209f64a14748
  localCtx ::
    (SEDEL.Environment.Ctx -> SEDEL.Environment.Ctx)
    -> SEDEL.Environment.TcMonad a -> SEDEL.Environment.TcMonad a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(U)><L,1*C1(C(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                SEDEL.Environment.localCtx1
                  `cast`
                (forall (a :: <*>_N).
                 <SEDEL.Environment.Ctx -> SEDEL.Environment.Ctx>_R
                 ->_R <Unbound.Generics.LocallyNameless.Fresh.FreshMT
                         (Control.Monad.Trans.Reader.ReaderT
                            SEDEL.Environment.Ctx
                            (Control.Monad.Trans.Except.ExceptT
                               SEDEL.Environment.Err GHC.Types.IO))
                         a>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <GHC.Integer.Type.Integer>_N
                               <Control.Monad.Trans.Reader.ReaderT
                                  SEDEL.Environment.Ctx
                                  (Control.Monad.Trans.Except.ExceptT
                                     SEDEL.Environment.Err GHC.Types.IO)>_R
                               <a>_N) ; Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                                     SEDEL.Environment.Ctx
                                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                                        SEDEL.Environment.Err
                                                                                                        GHC.Types.IO)>_N <a>_N) -}
c476219944bd330f4f48be87ec4ba252
  localCtx1 ::
    (SEDEL.Environment.Ctx -> SEDEL.Environment.Ctx)
    -> Unbound.Generics.LocallyNameless.Fresh.FreshMT
         (Control.Monad.Trans.Reader.ReaderT
            SEDEL.Environment.Ctx
            (Control.Monad.Trans.Except.ExceptT
               SEDEL.Environment.Err GHC.Types.IO))
         a
    -> GHC.Integer.Type.Integer
    -> Control.Monad.Trans.Reader.ReaderT
         SEDEL.Environment.Ctx
         (Control.Monad.Trans.Except.ExceptT
            SEDEL.Environment.Err GHC.Types.IO)
         (a, GHC.Integer.Type.Integer)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(U)><L,1*C1(C(U))><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (f :: SEDEL.Environment.Ctx -> SEDEL.Environment.Ctx)
                   (x :: Unbound.Generics.LocallyNameless.Fresh.FreshMT
                           (Control.Monad.Trans.Reader.ReaderT
                              SEDEL.Environment.Ctx
                              (Control.Monad.Trans.Except.ExceptT
                                 SEDEL.Environment.Err GHC.Types.IO))
                           a)
                   (x1 :: GHC.Integer.Type.Integer) ->
                 let {
                   m1 :: Control.Monad.Trans.Reader.ReaderT
                           SEDEL.Environment.Ctx
                           (Control.Monad.Trans.Except.ExceptT
                              SEDEL.Environment.Err GHC.Types.IO)
                           (a, GHC.Integer.Type.Integer)
                   = x `cast`
                     (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0] <Control.Monad.Trans.Reader.ReaderT
                                                                             SEDEL.Environment.Ctx
                                                                             (Control.Monad.Trans.Except.ExceptT
                                                                                SEDEL.Environment.Err
                                                                                GHC.Types.IO)>_N <a>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                             <GHC.Integer.Type.Integer>_N
                                                                                                             <Control.Monad.Trans.Reader.ReaderT
                                                                                                                SEDEL.Environment.Ctx
                                                                                                                (Control.Monad.Trans.Except.ExceptT
                                                                                                                   SEDEL.Environment.Err
                                                                                                                   GHC.Types.IO)>_R
                                                                                                             <a>_N)
                       x1
                 } in
                 (\ (x2 :: SEDEL.Environment.Ctx) ->
                  m1
                    `cast`
                  (Control.Monad.Trans.Reader.N:ReaderT[0]
                       <*>_N
                       <SEDEL.Environment.Ctx>_R
                       <Control.Monad.Trans.Except.ExceptT
                          SEDEL.Environment.Err GHC.Types.IO>_R
                       <(a, GHC.Integer.Type.Integer)>_N)
                    (f x2))
                   `cast`
                 (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                           <*>_N
                           <SEDEL.Environment.Ctx>_R
                           <Control.Monad.Trans.Except.ExceptT
                              SEDEL.Environment.Err GHC.Types.IO>_R
                           <(a, GHC.Integer.Type.Integer)>_N))) -}
f02758182b337510dd97b0ac5868c941
  lookupTVarConstraint ::
    (Control.Monad.Reader.Class.MonadReader SEDEL.Environment.Ctx m,
     Control.Monad.Error.Class.MonadError SEDEL.Environment.Err m) =>
    SEDEL.Source.Syntax.TyName -> m SEDEL.Source.Syntax.SType
  {- Arity: 3,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(1*U(A,1*C1(C1(U)),A,C(U),A),A,A,C(U))><L,U(1*U(A,1*C1(C1(U)),A,A,A),C(U),A)><L,U>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadReader :: Control.Monad.Reader.Class.MonadReader
                                       SEDEL.Environment.Ctx m)
                   ($dMonadError :: Control.Monad.Error.Class.MonadError
                                      SEDEL.Environment.Err m)
                   (eta :: SEDEL.Source.Syntax.TyName) ->
                 let {
                   lvl :: m SEDEL.Source.Syntax.SType
                   = let {
                       lvl1 :: Data.Functor.Identity.Identity SEDEL.PrettyPrint.FDoc
                       = let {
                           eta1 :: Data.Text.Prettyprint.Doc.Internal.Doc
                                     SEDEL.PrettyPrint.FAnn
                           = case eta of wild {
                               Unbound.Generics.LocallyNameless.Name.Fn s ds1
                               -> Data.Text.Prettyprint.Doc.Internal.$fIsStringDoc_$cfromString
                                    @ SEDEL.PrettyPrint.FAnn
                                    s
                               Unbound.Generics.LocallyNameless.Name.Bn ds1 ds2
                               -> case Unbound.Generics.LocallyNameless.Name.name2String1
                                  ret_ty (Data.Text.Prettyprint.Doc.Internal.Doc
                                            SEDEL.PrettyPrint.FAnn)
                                  of {} }
                         } in
                         let {
                           eta2 :: Data.Text.Prettyprint.Doc.Internal.Doc
                                     SEDEL.PrettyPrint.FAnn
                           = Data.Text.Prettyprint.Doc.Internal.Cat
                               @ SEDEL.PrettyPrint.FAnn
                               (Data.Text.Prettyprint.Doc.Internal.line1 @ SEDEL.PrettyPrint.FAnn)
                               eta1
                         } in
                         let {
                           eta3 :: Data.Text.Prettyprint.Doc.Internal.Doc
                                     SEDEL.PrettyPrint.FAnn
                           = Data.Text.Prettyprint.Doc.Internal.Cat
                               @ SEDEL.PrettyPrint.FAnn
                               SEDEL.Environment.lookupTVarConstraint1
                               eta2
                         } in
                         (SEDEL.PrettyPrint.$fFPretty[]_$cppr
                            @ (Unbound.Generics.LocallyNameless.LFresh.LFreshMT
                                 Data.Functor.Identity.Identity)
                            SEDEL.PrettyPrint.$s$fApplicativeLFreshMT
                            SEDEL.PrettyPrint.$s$fLFreshLFreshMT
                            (GHC.Types.:
                               @ SEDEL.PrettyPrint.D
                               (SEDEL.PrettyPrint.DS eta3)
                               (GHC.Types.[] @ SEDEL.PrettyPrint.D)))
                           `cast`
                         (Unbound.Generics.LocallyNameless.LFresh.N:LFreshMT[0] <Data.Functor.Identity.Identity>_N <SEDEL.PrettyPrint.FDoc>_N ; Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                                                    <*>_N
                                                                                                                                                    <Data.Set.Internal.Set
                                                                                                                                                       Unbound.Generics.LocallyNameless.Name.AnyName>_R
                                                                                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                                                                                    <SEDEL.PrettyPrint.FDoc>_N)
                           (Data.Set.Internal.Tip
                              @ Unbound.Generics.LocallyNameless.Name.AnyName)
                     } in
                     GHC.Base.>>=
                       @ m
                       (Control.Monad.Error.Class.$p1MonadError
                          @ SEDEL.Environment.Err
                          @ m
                          $dMonadError)
                       @ [SEDEL.Environment.SourceLocation]
                       @ SEDEL.Source.Syntax.SType
                       (Control.Monad.Reader.Class.reader
                          @ SEDEL.Environment.Ctx
                          @ m
                          $dMonadReader
                          @ [SEDEL.Environment.SourceLocation]
                          SEDEL.Environment.sourceLocation)
                       (\ (loc :: [SEDEL.Environment.SourceLocation]) ->
                        Control.Monad.Error.Class.throwError
                          @ SEDEL.Environment.Err
                          @ m
                          $dMonadError
                          @ SEDEL.Source.Syntax.SType
                          (SEDEL.Environment.Err
                             loc
                             lvl1
                               `cast`
                             (Data.Functor.Identity.N:Identity[0] <SEDEL.PrettyPrint.FDoc>_R)))
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.Reader.Class.$p1MonadReader
                       @ SEDEL.Environment.Ctx
                       @ m
                       $dMonadReader
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ SEDEL.Environment.TyCtx
                   @ SEDEL.Source.Syntax.SType
                   (Control.Monad.Reader.Class.reader
                      @ SEDEL.Environment.Ctx
                      @ m
                      $dMonadReader
                      @ SEDEL.Environment.TyCtx
                      SEDEL.Environment.tyCtx)
                   (\ (env :: SEDEL.Environment.TyCtx) ->
                    case SEDEL.Environment.$slookup1
                           @ (SEDEL.Source.Syntax.Kind, SEDEL.Source.Syntax.SType,
                              SEDEL.Environment.TypeValue)
                           eta
                           env of wild {
                      GHC.Base.Nothing -> lvl
                      GHC.Base.Just ds
                      -> case ds of wild1 { (,,) ds1 c ds2 ->
                         GHC.Base.return @ m $dMonad @ SEDEL.Source.Syntax.SType c } })) -}
d680e861f10cce2418b7614573105223
  lookupTVarConstraint1 ::
    Data.Text.Prettyprint.Doc.Internal.Doc SEDEL.PrettyPrint.FAnn
  {- Unfolding: (Data.Text.Prettyprint.Doc.Internal.$fIsStringDoc_$cfromString
                   @ SEDEL.PrettyPrint.FAnn
                   (GHC.CString.unpackCString#
                      SEDEL.Environment.lookupTVarConstraint2)) -}
dcb35bc3f38faee7d91b4ede3f31e84d
  lookupTVarConstraint2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Not in scope:"#) -}
e3b4f6d247d8429f01222f133b109a71
  lookupTVarConstraintMaybe ::
    SEDEL.Environment.Ctx
    -> SEDEL.Source.Syntax.TyName
    -> GHC.Base.Maybe SEDEL.Source.Syntax.SType
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LSLL),1*U(A,1*U,A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ctx :: SEDEL.Environment.Ctx)
                   (v :: SEDEL.Source.Syntax.TyName) ->
                 case ctx of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 ->
                 case SEDEL.Environment.$slookup1
                        @ (SEDEL.Source.Syntax.Kind, SEDEL.Source.Syntax.SType,
                           SEDEL.Environment.TypeValue)
                        v
                        ds1 of wild1 {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ SEDEL.Source.Syntax.SType
                   GHC.Base.Just a1
                   -> GHC.Base.Just
                        @ SEDEL.Source.Syntax.SType
                        (case a1 of wild2 { (,,) ds4 t ds5 -> t }) } }) -}
ca80196cfc2952a70aa15fa52a5a0030
  lookupTVarKindMaybe ::
    SEDEL.Environment.Ctx
    -> SEDEL.Source.Syntax.TyName
    -> GHC.Base.Maybe SEDEL.Source.Syntax.Kind
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LSLL),1*U(A,1*U,A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ctx :: SEDEL.Environment.Ctx)
                   (v :: SEDEL.Source.Syntax.TyName) ->
                 case ctx of wild { SEDEL.Environment.Ctx ds ds1 ds2 ds3 ->
                 case SEDEL.Environment.$slookup1
                        @ (SEDEL.Source.Syntax.Kind, SEDEL.Source.Syntax.SType,
                           SEDEL.Environment.TypeValue)
                        v
                        ds1 of wild1 {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ SEDEL.Source.Syntax.Kind
                   GHC.Base.Just a1
                   -> GHC.Base.Just
                        @ SEDEL.Source.Syntax.Kind
                        (case a1 of wild2 { (,,) k ds4 ds5 -> k }) } }) -}
7b0854f9a87edc097a27b2facb4edd4d
  lookupTVarSynMaybe ::
    SEDEL.Environment.Ctx
    -> SEDEL.Source.Syntax.TyName
    -> GHC.Base.Maybe SEDEL.Source.Syntax.SType
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LSLL),1*U(A,1*U,A,A)><S,1*U>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: SEDEL.Environment.Ctx)
                   (w1 :: SEDEL.Source.Syntax.TyName) ->
                 case w of ww { SEDEL.Environment.Ctx ww1 ww2 ww3 ww4 ->
                 SEDEL.Environment.$wlookupTVarSynMaybe ww2 w1 }) -}
aa52003bd432162b87b3a75bddc5d1dd
  lookupTmDef ::
    Control.Monad.Reader.Class.MonadReader SEDEL.Environment.Ctx m =>
    SEDEL.Source.Syntax.TmName
    -> m (GHC.Base.Maybe SEDEL.Source.Syntax.Expr)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S(S(C(C(S))L)LLLLL)LLLL)LLL),U(1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A),A,A,1*C1(U))><L,U>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadReader :: Control.Monad.Reader.Class.MonadReader
                                       SEDEL.Environment.Ctx m)
                   (eta :: SEDEL.Source.Syntax.TmName) ->
                 GHC.Base.fmap
                   @ m
                   (GHC.Base.$p1Applicative
                      @ m
                      (GHC.Base.$p1Monad
                         @ m
                         (Control.Monad.Reader.Class.$p1MonadReader
                            @ SEDEL.Environment.Ctx
                            @ m
                            $dMonadReader)))
                   @ (Data.Map.Internal.Map
                        SEDEL.Source.Syntax.TmName SEDEL.Source.Syntax.Expr)
                   @ (GHC.Base.Maybe SEDEL.Source.Syntax.Expr)
                   (SEDEL.Environment.$slookup3 @ SEDEL.Source.Syntax.Expr eta)
                   (Control.Monad.Reader.Class.reader
                      @ SEDEL.Environment.Ctx
                      @ m
                      $dMonadReader
                      @ SEDEL.Environment.BndCtx
                      SEDEL.Environment.bndCtx)) -}
1b00ade681667ac2466e8c062893c5fb
  lookupVarTy ::
    (Control.Monad.Reader.Class.MonadReader SEDEL.Environment.Ctx m,
     Control.Monad.Error.Class.MonadError SEDEL.Environment.Err m) =>
    SEDEL.Source.Syntax.TmName -> m SEDEL.Source.Syntax.SType
  {- Arity: 3,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(1*U(A,1*C1(C1(U)),A,C(U),A),A,A,C(U))><L,U(1*U(A,1*C1(C1(U)),A,A,A),C(U),A)><L,U>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadReader :: Control.Monad.Reader.Class.MonadReader
                                       SEDEL.Environment.Ctx m)
                   ($dMonadError :: Control.Monad.Error.Class.MonadError
                                      SEDEL.Environment.Err m)
                   (eta :: SEDEL.Source.Syntax.TmName) ->
                 let {
                   lvl :: m SEDEL.Source.Syntax.SType
                   = let {
                       lvl1 :: Data.Functor.Identity.Identity SEDEL.PrettyPrint.FDoc
                       = let {
                           eta1 :: Data.Text.Prettyprint.Doc.Internal.Doc
                                     SEDEL.PrettyPrint.FAnn
                           = case eta of wild {
                               Unbound.Generics.LocallyNameless.Name.Fn s ds1
                               -> Data.Text.Prettyprint.Doc.Internal.$fIsStringDoc_$cfromString
                                    @ SEDEL.PrettyPrint.FAnn
                                    s
                               Unbound.Generics.LocallyNameless.Name.Bn ds1 ds2
                               -> case Unbound.Generics.LocallyNameless.Name.name2String1
                                  ret_ty (Data.Text.Prettyprint.Doc.Internal.Doc
                                            SEDEL.PrettyPrint.FAnn)
                                  of {} }
                         } in
                         let {
                           eta2 :: Data.Text.Prettyprint.Doc.Internal.Doc
                                     SEDEL.PrettyPrint.FAnn
                           = Data.Text.Prettyprint.Doc.Internal.Cat
                               @ SEDEL.PrettyPrint.FAnn
                               (Data.Text.Prettyprint.Doc.Internal.line1 @ SEDEL.PrettyPrint.FAnn)
                               eta1
                         } in
                         let {
                           eta3 :: Data.Text.Prettyprint.Doc.Internal.Doc
                                     SEDEL.PrettyPrint.FAnn
                           = Data.Text.Prettyprint.Doc.Internal.Cat
                               @ SEDEL.PrettyPrint.FAnn
                               SEDEL.Environment.lookupTVarConstraint1
                               eta2
                         } in
                         (SEDEL.PrettyPrint.$fFPretty[]_$cppr
                            @ (Unbound.Generics.LocallyNameless.LFresh.LFreshMT
                                 Data.Functor.Identity.Identity)
                            SEDEL.PrettyPrint.$s$fApplicativeLFreshMT
                            SEDEL.PrettyPrint.$s$fLFreshLFreshMT
                            (GHC.Types.:
                               @ SEDEL.PrettyPrint.D
                               (SEDEL.PrettyPrint.DS eta3)
                               (GHC.Types.[] @ SEDEL.PrettyPrint.D)))
                           `cast`
                         (Unbound.Generics.LocallyNameless.LFresh.N:LFreshMT[0] <Data.Functor.Identity.Identity>_N <SEDEL.PrettyPrint.FDoc>_N ; Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                                                    <*>_N
                                                                                                                                                    <Data.Set.Internal.Set
                                                                                                                                                       Unbound.Generics.LocallyNameless.Name.AnyName>_R
                                                                                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                                                                                    <SEDEL.PrettyPrint.FDoc>_N)
                           (Data.Set.Internal.Tip
                              @ Unbound.Generics.LocallyNameless.Name.AnyName)
                     } in
                     GHC.Base.>>=
                       @ m
                       (Control.Monad.Error.Class.$p1MonadError
                          @ SEDEL.Environment.Err
                          @ m
                          $dMonadError)
                       @ [SEDEL.Environment.SourceLocation]
                       @ SEDEL.Source.Syntax.SType
                       (Control.Monad.Reader.Class.reader
                          @ SEDEL.Environment.Ctx
                          @ m
                          $dMonadReader
                          @ [SEDEL.Environment.SourceLocation]
                          SEDEL.Environment.sourceLocation)
                       (\ (loc :: [SEDEL.Environment.SourceLocation]) ->
                        Control.Monad.Error.Class.throwError
                          @ SEDEL.Environment.Err
                          @ m
                          $dMonadError
                          @ SEDEL.Source.Syntax.SType
                          (SEDEL.Environment.Err
                             loc
                             lvl1
                               `cast`
                             (Data.Functor.Identity.N:Identity[0] <SEDEL.PrettyPrint.FDoc>_R)))
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.Reader.Class.$p1MonadReader
                       @ SEDEL.Environment.Ctx
                       @ m
                       $dMonadReader
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ SEDEL.Environment.VarCtx
                   @ SEDEL.Source.Syntax.SType
                   (Control.Monad.Reader.Class.reader
                      @ SEDEL.Environment.Ctx
                      @ m
                      $dMonadReader
                      @ SEDEL.Environment.VarCtx
                      SEDEL.Environment.varCtx)
                   (\ (env :: SEDEL.Environment.VarCtx) ->
                    case SEDEL.Environment.$slookup3
                           @ SEDEL.Source.Syntax.SType
                           eta
                           env of wild {
                      GHC.Base.Nothing -> lvl
                      GHC.Base.Just res
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ SEDEL.Source.Syntax.SType
                           res })) -}
bae2f86b8c17a07bc69806e2277e58ba
  runTcMonad ::
    SEDEL.Environment.Ctx
    -> SEDEL.Environment.TcMonad a
    -> GHC.Types.IO (Data.Either.Either SEDEL.Environment.Err a)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><C(C(C(S(SS)))),1*C1(C1(C1(U(U,1*U))))><S,U>,
     Unfolding: InlineRule (0, True, True)
                SEDEL.Environment.runTcMonad1
                  `cast`
                (forall (a :: <*>_N).
                 <SEDEL.Environment.Ctx>_R
                 ->_R <SEDEL.Environment.TcMonad a>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <Data.Either.Either SEDEL.Environment.Err a>_R)) -}
9eb696135baaebfb0721ed8f6005ae64
  runTcMonad1 ::
    SEDEL.Environment.Ctx
    -> SEDEL.Environment.TcMonad a
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either SEDEL.Environment.Err a #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><C(C(C(S(SS)))),1*C1(C1(C1(U(U,1*U))))><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (env :: SEDEL.Environment.Ctx)
                   (m :: SEDEL.Environment.TcMonad a)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case ((m `cast`
                        (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0] <Control.Monad.Trans.Reader.ReaderT
                                                                                SEDEL.Environment.Ctx
                                                                                (Control.Monad.Trans.Except.ExceptT
                                                                                   SEDEL.Environment.Err
                                                                                   GHC.Types.IO)>_N <a>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                <GHC.Integer.Type.Integer>_N
                                                                                                                <Control.Monad.Trans.Reader.ReaderT
                                                                                                                   SEDEL.Environment.Ctx
                                                                                                                   (Control.Monad.Trans.Except.ExceptT
                                                                                                                      SEDEL.Environment.Err
                                                                                                                      GHC.Types.IO)>_R
                                                                                                                <a>_N)
                          Unbound.Generics.LocallyNameless.Fresh.runFreshM1)
                         `cast`
                       (Control.Monad.Trans.Reader.N:ReaderT[0]
                            <*>_N
                            <SEDEL.Environment.Ctx>_R
                            <Control.Monad.Trans.Except.ExceptT
                               SEDEL.Environment.Err GHC.Types.IO>_R
                            <(a, GHC.Integer.Type.Integer)>_N)
                         env)
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <SEDEL.Environment.Err>_N
                           <GHC.Types.IO>_R
                           <(a, GHC.Integer.Type.Integer)>_N ; GHC.Types.N:IO[0]
                                                                   <Data.Either.Either
                                                                      SEDEL.Environment.Err
                                                                      (a,
                                                                       GHC.Integer.Type.Integer)>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   Data.Either.Left e1
                   -> (# ipv, Data.Either.Left @ SEDEL.Environment.Err @ a e1 #)
                   Data.Either.Right x
                   -> (# ipv,
                         Data.Either.Right
                           @ SEDEL.Environment.Err
                           @ a
                           (case x of wild1 { (,) a1 ds2 -> a1 }) #) } }) -}
4d40b76497431ab3e2b46fb381d29825
  sourceLocation ::
    SEDEL.Environment.Ctx -> [SEDEL.Environment.SourceLocation]
  RecSel Left SEDEL.Environment.Ctx
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLS),1*U(A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: SEDEL.Environment.Ctx) ->
                 case ds of wild { SEDEL.Environment.Ctx ds1 ds2 ds3 ds4 ->
                 ds4 }) -}
4d40b76497431ab3e2b46fb381d29825
  tyCtx :: SEDEL.Environment.Ctx -> SEDEL.Environment.TyCtx
  RecSel Left SEDEL.Environment.Ctx
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSLL),1*U(A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: SEDEL.Environment.Ctx) ->
                 case ds of wild { SEDEL.Environment.Ctx ds1 ds2 ds3 ds4 ->
                 ds2 }) -}
4d40b76497431ab3e2b46fb381d29825
  varCtx :: SEDEL.Environment.Ctx -> SEDEL.Environment.VarCtx
  RecSel Left SEDEL.Environment.Ctx
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLLL),1*U(1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: SEDEL.Environment.Ctx) ->
                 case ds of wild { SEDEL.Environment.Ctx ds1 ds2 ds3 ds4 ->
                 ds1 }) -}
instance SEDEL.PrettyPrint.FPretty [SEDEL.Environment.Err]
  = SEDEL.Environment.$fFPrettyErr
instance GHC.Base.Monoid [SEDEL.Environment.Err]
  = SEDEL.Environment.$fMonoidErr
instance GHC.Base.Semigroup [SEDEL.Environment.Err]
  = SEDEL.Environment.$fSemigroupErr
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

