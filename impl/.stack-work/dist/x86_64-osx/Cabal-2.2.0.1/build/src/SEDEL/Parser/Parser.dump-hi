
==================== FINAL INTERFACE ====================
2019-01-06 15:41:05.742024 UTC

interface sedel-0.1.0.0-DuOee9DhvYx7Duo7SFFYX4:SEDEL.Parser.Parser 8044
  interface hash: cc77f3e1a6a3a9ec57045a8ae2361e89
  ABI hash: a5867fff13a1fefb9cdb380b1eab2670
  export-list hash: 7ff276fc44ebebc8fa0c170780ae9850
  orphan hash: 5dace6d12a379513ea0d6f9dd4ae7b2e
  flag hash: cadc0bb73505cadd143871a861cbbe03
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  SEDEL.Parser.Parser.parseModule
module dependencies: SEDEL.Common SEDEL.Source.Syntax SEDEL.Util
package dependencies: StateVar-1.1.1.1 array-0.5.2.0 async-2.2.1
                      base-4.11.1.0 base-orphans-0.7 bifunctors-5.5.3 binary-0.8.5.1
                      bytestring-0.10.8.2 case-insensitive-1.2.0.11 comonad-5.0.4
                      containers-0.5.11.0 contravariant-1.4.1 deepseq-1.4.3.0
                      distributive-0.5.3 exceptions-0.10.0 ghc-boot-th-8.4.4
                      ghc-prim-0.5.2.0 hashable-1.2.7.0 integer-gmp-1.0.2.0
                      integer-logarithms-1.0.2.2 megaparsec-6.5.0 mtl-2.2.2
                      parser-combinators-1.0.0 pretty-1.1.3.6 prettyprinter-1.2.1
                      primitive-0.6.3.0 profunctors-5.2.2 protolude-0.2.2
                      scientific-0.3.6.2 stm-2.4.5.1 tagged-0.8.5
                      template-haskell-2.13.0.0 text-1.2.3.1 transformers-0.5.5.0
                      unbound-generics-0.3.4
orphans: sedel-0.1.0.0-DuOee9DhvYx7Duo7SFFYX4:SEDEL.Source.Syntax
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.1:Data.Text.Lazy
         text-1.2.3.1:Data.Text binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show stm-2.4.5.1:Control.Monad.STM
         transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Complex base-4.11.1.0:Data.Functor.Compose
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         bifunctors-5.5.3:Data.Bifunctor.Biff
                         bifunctors-5.5.3:Data.Bifunctor.Clown
                         bifunctors-5.5.3:Data.Bifunctor.Joker
                         bifunctors-5.5.3:Data.Bifunctor.Product
                         bifunctors-5.5.3:Data.Bifunctor.Sum
                         bifunctors-5.5.3:Data.Bifunctor.Tannen
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         ghc-boot-th-8.4.4:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.4:GHC.LanguageExtensions.Type
                         megaparsec-6.5.0:Text.Megaparsec.Error
                         megaparsec-6.5.0:Text.Megaparsec.Pos
                         megaparsec-6.5.0:Text.Megaparsec.State
                         megaparsec-6.5.0:Text.Megaparsec.Stream
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         prettyprinter-1.2.1:Data.Text.Prettyprint.Doc.Internal
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.Array
                         sedel-0.1.0.0-DuOee9DhvYx7Duo7SFFYX4:SEDEL.Common
                         sedel-0.1.0.0-DuOee9DhvYx7Duo7SFFYX4:SEDEL.Source.Syntax
                         tagged-0.8.5:Data.Tagged
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.1:Data.Text text-1.2.3.1:Data.Text.Lazy
                         unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Bind
                         unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Embed
                         unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Name
                         unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Rebind
                         unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Rec
                         unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Shift
import  -/  base-4.11.1.0:Control.Applicative 55d9b3a7491623b0362290e162d67308
import  -/  base-4.11.1.0:Control.Arrow ce43199b5356a11ee2a8317f0ec30aee
import  -/  base-4.11.1.0:Data.Either 39d922b371c4c52d426e9ee66de8371a
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.Functor f522c3501272159820fd6f242510732f
import  -/  base-4.11.1.0:Data.List 83dc843e47bfc0c5af51e19c6f3476d5
import  -/  base-4.11.1.0:Data.Maybe 409c3da2b142470b68be39ce1d97a9f7
import  -/  base-4.11.1.0:Data.Tuple 3af66f3ac61ed95ba8a3a3f68ebc5003
import  -/  base-4.11.1.0:Data.Void 4c9c07b3e8b1059587733a690d1fbc93
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  megaparsec-6.5.0:Text.Megaparsec dad9a4aeb1f0e270a9bf949fd5479956
import  -/  megaparsec-6.5.0:Text.Megaparsec.Char be8e2425751b346e1b7cffa29be1ba76
import  -/  megaparsec-6.5.0:Text.Megaparsec.Char.Lexer 0d2881b86884d659788c3900ae8c3058
import  -/  megaparsec-6.5.0:Text.Megaparsec.Class 94cd67ba0a6c02d4e81b16ba170c434a
import  -/  megaparsec-6.5.0:Text.Megaparsec.Error 01d865ce46338440b5a3d15285ffce43
import  -/  megaparsec-6.5.0:Text.Megaparsec.Expr 967041f11967d5a4b3f443e7c0ec74fa
import  -/  parser-combinators-1.0.0:Control.Applicative.Combinators ac617ce95d7f22da1975b0cb171c6660
import  -/  parser-combinators-1.0.0:Control.Monad.Combinators fddfdf717d76f788520dac71131cb54e
import  -/  scientific-0.3.6.2:Data.Scientific bd9645fb22c211310387a6537e016069
import  -/  SEDEL.Common 6eca6974f68891b23029f7fea9c0aa43
  exports: 5fc6116fbbf8eeebe49551baed0a65d2
  Add b7b626a35261bb0c7e18ba46414d5ad4
  Append f3c19f9ccec3594847e613a5e55244a3
  Arith 644b6b6bcb4e1bf98de5683e8571df5c
  Comp 9c3b2e657ada9116baf424d3af9b3bd9
  Div 4d253662c2c5e310660c080d28bfd13c
  Equ b90a3819ef4e62027cf7ab9b96f26b9a
  Gt 254db6e4dc0b0b7f7f75ab90cb61a4d2
  LAnd 3900cc1a081a3792e194eaf25a28b859
  LOr 5cc92e5a6eb31dc627e0bead80b2d056
  Logical b783ea8a360dd94eeed0e406b5339afe
  Lt 9dbb1fbb1370a936bdd7b706156a351d
  Mul 7828fec82f46a6c1c83daf61676288bf
  Neq daad26c28f2d8be23fa9db5870653734
  Sub 6b05e8df2e06a35d49adb48981b847a1
import  -/  SEDEL.Source.Syntax c6851d369824d5b2d3a7e5400a3e8895
  exports: cabfe3b04d2f999f33a8aa4c6138d737
  Acc bc0f8f5cfb62f48851eec57e8c9719b2
  And 7ac8c536b0055c4944992b99f8189710
  Anno 196d3c0eb00893506972e777c8686357
  AnonyTrait 816e1b77b36b8a1697eca8cbf9627aab
  App 389b1b3eb44b3f08b69a3d6171233789
  Arr 7b7b72ddb80dee15a1ceb978b6ce8f52
  BoolT 1aa700eacd4e31c8127671c4be09422e
  BoolV 5fbf9085b7561513a57a44c59b5a5c60
  Bot ac91b27a713f7c8440cc83d624e494c6
  BotT 59b7cb4c660c6997838d74f81c00778b
  DefDecl c19116c8a815fea9b9a33602fad067ed
  Expr 25c2500e15597d4f4006aa39bdab089a
  If 7a894baf12188417a3e4642dc5b2175b
  Kind 25c2500e15597d4f4006aa39bdab089a
  Label fc5fe540b83a48c28a7f7fc366395383
  LitV d10288d28c209d9924bfd900436f63c2
  Merge 4532903785f1db72fed7c6383259e9a4
  Module 5f3a10c35880d347117820949e2a963a
  Module ee48d31af8cdf4c66155ef3d8df4f23b
  NumT 85730080728f0df382512e19163959e5
  OpApp 469919f2badd98533a46e0cc7b8c9f8d
  Pos 970912a2497ffa9ccb707a2fe00e1f1f
  PrimOp ac633712dd596900795e2292656882b7
  Remove 3c9d7fd0f1e91d29b3704bcf26c3ef85
  SDecl 25c2500e15597d4f4006aa39bdab089a
  SType 25c2500e15597d4f4006aa39bdab089a
  Star 2d70438a5d932d59729fdfa5e45de509
  StrV c81980335f9ab195f0d4d1748596b25c
  StringT 8a843eef857795030ca76365627499f9
  TApp 068a511dbf4f653eb6c1e0f1b8a2172b
  TmBind dc9428c414e2f78b968270411939dc25
  TmBind 25c2500e15597d4f4006aa39bdab089a
  Top 9456a53a8231f986ca4b75375cf98767
  TopT d33ac184844415d74b8018e6ca7ccf9f
  TraitDef 39c057622619fa0bf188d14618e8252d
  TyName 25c2500e15597d4f4006aa39bdab089a
  TypeBind 5d40239337787bb26306a7dc33509136
  TypeBind 25c2500e15597d4f4006aa39bdab089a
  TypeDecl 87246ad11b4e63f86a4572a75eb438cd
import  -/  SEDEL.Util 8b1ac2059ce740dddc07232750c145e9
  exports: f908859a79e4f312794ac1d97a0322bc
  dlam 0569a710ea96b64b7b51e9fdaf92981e
  elam ebdca052498a095bfee7008edcbd4666
  elam2 5f7f7f5167511812e0b2b9c419ce8b8f
  elet 4bcd152b6c05a68171b87d7acc238295
  eletr 9b49d509644df50d108bd95aa93168eb
  evar 8c8709c7229567480450de8c2d13c1f7
  mkRecds' 037c5a9e7e05136c6dacec3883208957
  mkRecdsT 9d76ef11e4883563e498c1e97a7e3423
  tforall 58763bdaaface34bd117d05ca882029e
  transNew 0eaf7828d02da74b10158370f5ceade8
  tvar b14af4fd2b830e33aa498bc60401b2c0
import  -/  unbound-generics-0.3.4:Unbound.Generics.LocallyNameless 8dd357a9d9fbbcf23f41fb39ba00f4e4
import  -/  unbound-generics-0.3.4:Unbound.Generics.LocallyNameless.Name 34633dd5588f50a53bac3c657a64a3ac
f693eec6a4415f404940ab607d7de99a
  $s$fAlternativeParsecT ::
    GHC.Base.Alternative
      (Text.Megaparsec.Internal.ParsecT
         Data.Void.Void [GHC.Types.Char] m)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *.
                  @ (Text.Megaparsec.Internal.ParsecT
                       Data.Void.Void [GHC.Types.Char] m)
                  (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$s$fApplicativeParsecT
                     @ Data.Void.Void
                     @ m)
                  (Text.Megaparsec.Internal.pZero
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$spPlus @ m)
                  (Text.Megaparsec.Internal.$fAlternativeParsecT3
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m
                     Data.Void.$fOrdVoid
                     Text.Megaparsec.Stream.$fStream[])
                    `cast`
                  (forall (a :: <*>_N).
                   <Text.Megaparsec.Internal.ParsecT
                      Data.Void.Void [GHC.Types.Char] m a>_R
                   ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                                 <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <[a]>_R))
                  (Text.Megaparsec.Internal.$fAlternativeParsecT1
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m
                     Data.Void.$fOrdVoid
                     Text.Megaparsec.Stream.$fStream[])
                    `cast`
                  (forall (a :: <*>_N).
                   <Text.Megaparsec.Internal.ParsecT
                      Data.Void.Void [GHC.Types.Char] m a>_R
                   ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                                 <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <[a]>_R)) -}
5b502706ca71666fb6eb268e1f57173e
  $s$fAlternativeParsecT1 ::
    Text.Megaparsec.Internal.ParsecT
      Data.Void.Void [GHC.Types.Char] m a
    -> forall b.
       Text.Megaparsec.State.State [GHC.Types.Char]
       -> ([a]
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> m b)
       -> (Text.Megaparsec.Error.ParseError
             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
       -> ([a]
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> m b)
       -> (Text.Megaparsec.Error.ParseError
             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
       -> m b
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U(U,U(U(U,U,U),U),U,U)><L,C(U)><L,U><L,C(U)><L,A>,
     Inline: [0],
     Unfolding: InlineRule (6, True, True)
                (\ @ m :: * -> *
                   @ a
                   (w2 :: Text.Megaparsec.Internal.ParsecT
                            Data.Void.Void [GHC.Types.Char] m a)
                   @ b
                   (w3 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (w4 :: [a]
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> m b)
                   (w5 :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (w6 :: [a]
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> m b)
                   (w7 :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 Text.Megaparsec.Internal.$w$cmany
                   @ Data.Void.Void
                   @ [GHC.Types.Char]
                   @ m
                   Text.Megaparsec.Stream.$fStream[]
                   @ a
                   w2
                   @ b
                   w3
                   w4
                   w5
                   w6) -}
f526ff2f7615be80650b646b4dce33d4
  $s$fAlternativeParsecT3 ::
    Text.Megaparsec.Internal.ParsecT
      Data.Void.Void [GHC.Types.Char] m a
    -> forall b.
       Text.Megaparsec.State.State [GHC.Types.Char]
       -> ([a]
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> m b)
       -> (Text.Megaparsec.Error.ParseError
             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
       -> ([a]
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> m b)
       -> (Text.Megaparsec.Error.ParseError
             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
       -> m b
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U><L,C(U)><L,U><L,C(U)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (6, True, False)
                (\ @ m :: * -> *
                   @ a
                   (w2 :: Text.Megaparsec.Internal.ParsecT
                            Data.Void.Void [GHC.Types.Char] m a)
                   @ b
                   (w3 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (w4 :: [a]
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> m b)
                   (w5 :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (w6 :: [a]
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> m b)
                   (w7 :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 Text.Megaparsec.Internal.$w$csome
                   @ Data.Void.Void
                   @ [GHC.Types.Char]
                   @ m
                   Text.Megaparsec.Stream.$fStream[]
                   @ a
                   w2
                   @ b
                   w3
                   w4
                   w5
                   w6
                   w7) -}
ffd253b36c1414eb0fa1c75637fced13
  $s$fAlternativeParsecT_$s$fApplicativeParsecT ::
    GHC.Base.Applicative
      (Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e @ m :: * -> *.
                  @ (Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m)
                  (Text.Megaparsec.Internal.$fFunctorParsecT
                     @ e
                     @ [GHC.Types.Char]
                     @ m)
                  (\ @ a ->
                   Text.Megaparsec.Internal.pPure @ a @ e @ [GHC.Types.Char] @ m)
                  (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$spAp @ e @ m)
                  (Text.Megaparsec.Internal.$fAlternativeParsecT2
                     @ [GHC.Types.Char]
                     @ e
                     @ m
                     Text.Megaparsec.Stream.$fStream[])
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                   ->_R <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b>_R
                   ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                                 <e>_N <[GHC.Types.Char]>_N <m>_R <c>_R))
                  (Text.Megaparsec.Internal.$fApplicativeParsecT2
                     @ [GHC.Types.Char]
                     @ e
                     @ m
                     Text.Megaparsec.Stream.$fStream[])
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                   ->_R <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b>_R
                   ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                                 <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R))
                  (Text.Megaparsec.Internal.$fApplicativeParsecT1
                     @ [GHC.Types.Char]
                     @ e
                     @ m
                     Text.Megaparsec.Stream.$fStream[])
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                   ->_R <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b>_R
                   ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                                 <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)) -}
022e7e2521e435eb949358f0cc778af2
  $s$fAlternativeParsecT_$spAp ::
    Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m (a -> b)
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b
  {- Arity: 7,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,U><L,C(U)><L,U><L,C(U)><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   @ b
                   (m53 :: Text.Megaparsec.Internal.ParsecT
                             e [GHC.Types.Char] m (a -> b))
                   (k30 :: Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a)
                   @ b1
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: b
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (cerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b1)
                   (eok :: b
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b1) ->
                 m53
                   `cast`
                 (Text.Megaparsec.Internal.N:ParsecT[0]
                      <e>_N <[GHC.Types.Char]>_N <m>_R <a -> b>_R)
                   @ b1
                   s1
                   (\ (x23 :: a -> b)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    k30
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                      @ b1
                      s'
                      (GHC.Base..
                         @ b
                         @ (Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Text.Megaparsec.Internal.Hints
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            -> m b1)
                         @ a
                         cok
                         x23)
                      cerr
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ a
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs
                         (GHC.Base..
                            @ b
                            @ (Text.Megaparsec.State.State [GHC.Types.Char]
                               -> Text.Megaparsec.Internal.Hints
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                               -> m b1)
                            @ a
                            cok
                            x23))
                      (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$swithHints
                         @ e
                         @ m
                         @ b1
                         hs
                         cerr))
                   cerr
                   (\ (x23 :: a -> b)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    k30
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                      @ b1
                      s'
                      (GHC.Base..
                         @ b
                         @ (Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Text.Megaparsec.Internal.Hints
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            -> m b1)
                         @ a
                         cok
                         x23)
                      cerr
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ a
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs
                         (GHC.Base..
                            @ b
                            @ (Text.Megaparsec.State.State [GHC.Types.Char]
                               -> Text.Megaparsec.Internal.Hints
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                               -> m b1)
                            @ a
                            eok
                            x23))
                      (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$swithHints
                         @ e
                         @ m
                         @ b1
                         hs
                         eerr))
                   eerr)
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N) (b :: <*>_N).
                 <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m (a -> b)>_R
                 ->_R <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)) -}
3418a8276934502b19b7691bdb20aa9a
  $s$fAlternativeParsecT_$spPlus ::
    Text.Megaparsec.Internal.ParsecT
      Data.Void.Void [GHC.Types.Char] m a
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void [GHC.Types.Char] m a
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void [GHC.Types.Char] m a
  {- Arity: 7,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,U><L,C(C1(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ m :: * -> *
                   @ a
                   (m53 :: Text.Megaparsec.Internal.ParsecT
                             Data.Void.Void [GHC.Types.Char] m a)
                   (n2 :: Text.Megaparsec.Internal.ParsecT
                            Data.Void.Void [GHC.Types.Char] m a)
                   @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: a
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (cerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (eok :: a
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 m53
                   `cast`
                 (Text.Megaparsec.Internal.N:ParsecT[0]
                      <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                   @ b
                   s1
                   cok
                   cerr
                   eok
                   (\ (err :: Text.Megaparsec.Error.ParseError
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void)
                      (ms :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                    n2
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                      @ b
                      s1
                      cok
                      (\ (err' :: Text.Megaparsec.Error.ParseError
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void)
                         (s' :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                       cerr
                         (let {
                            $j :: Text.Megaparsec.Error.ParseError
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                              <join 0>
                            = case err' of wild {
                                Text.Megaparsec.Error.TrivialError s2 u1 p6
                                -> case err of wild1 {
                                     Text.Megaparsec.Error.TrivialError ds u2 p7
                                     -> Text.Megaparsec.Error.TrivialError
                                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                          @ Data.Void.Void
                                          s2
                                          (case u1 of wild2 {
                                             GHC.Base.Nothing -> u2
                                             GHC.Base.Just x23
                                             -> case u2 of wild3 {
                                                  GHC.Base.Nothing
                                                  -> GHC.Base.Just
                                                       @ (Text.Megaparsec.Error.ErrorItem
                                                            (Text.Megaparsec.Stream.Token
                                                               [GHC.Types.Char]))
                                                       x23
                                                  GHC.Base.Just y
                                                  -> GHC.Base.Just
                                                       @ (Text.Megaparsec.Error.ErrorItem
                                                            (Text.Megaparsec.Stream.Token
                                                               [GHC.Types.Char]))
                                                       (case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                                                               @ (Text.Megaparsec.Stream.Token
                                                                    [GHC.Types.Char])
                                                               GHC.Classes.$fOrdChar
                                                                 `cast`
                                                               (GHC.Classes.Ord
                                                                  (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                                                               y
                                                               x23 of wild4 {
                                                          GHC.Types.False -> y
                                                          GHC.Types.True -> x23 }) } })
                                          (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$sunion1
                                             p6
                                             p7)
                                     Text.Megaparsec.Error.FancyError ds ds1 -> wild1 }
                                Text.Megaparsec.Error.FancyError ds ds1
                                -> case err of wild1 {
                                     Text.Megaparsec.Error.TrivialError ds2 ds3 ds4 -> wild
                                     Text.Megaparsec.Error.FancyError ds2 x23
                                     -> Text.Megaparsec.Error.FancyError
                                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                          @ Data.Void.Void
                                          ds
                                          (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$sunion
                                             ds1
                                             x23) } }
                          } in
                          case err' of wild {
                            Text.Megaparsec.Error.TrivialError p6 ds ds1
                            -> case err of wild1 {
                                 Text.Megaparsec.Error.TrivialError p7 ds2 ds3
                                 -> case GHC.Base.$fOrdNonEmpty_$ccompare
                                           @ Text.Megaparsec.Pos.SourcePos
                                           Text.Megaparsec.Pos.$fOrdSourcePos
                                           p6
                                           p7 of wild2 {
                                      GHC.Types.LT -> wild1
                                      GHC.Types.EQ -> $j
                                      GHC.Types.GT -> wild }
                                 Text.Megaparsec.Error.FancyError p7 ds2
                                 -> case GHC.Base.$fOrdNonEmpty_$ccompare
                                           @ Text.Megaparsec.Pos.SourcePos
                                           Text.Megaparsec.Pos.$fOrdSourcePos
                                           p6
                                           p7 of wild2 {
                                      GHC.Types.LT -> wild1
                                      GHC.Types.EQ -> $j
                                      GHC.Types.GT -> wild } }
                            Text.Megaparsec.Error.FancyError p6 ds
                            -> case err of wild1 {
                                 Text.Megaparsec.Error.TrivialError p7 ds1 ds2
                                 -> case GHC.Base.$fOrdNonEmpty_$ccompare
                                           @ Text.Megaparsec.Pos.SourcePos
                                           Text.Megaparsec.Pos.$fOrdSourcePos
                                           p6
                                           p7 of wild2 {
                                      GHC.Types.LT -> wild1
                                      GHC.Types.EQ -> $j
                                      GHC.Types.GT -> wild }
                                 Text.Megaparsec.Error.FancyError p7 ds1
                                 -> case GHC.Base.$fOrdNonEmpty_$ccompare
                                           @ Text.Megaparsec.Pos.SourcePos
                                           Text.Megaparsec.Pos.$fOrdSourcePos
                                           p6
                                           p7 of wild2 {
                                      GHC.Types.LT -> wild1
                                      GHC.Types.EQ -> $j
                                      GHC.Types.GT -> wild } } })
                         (Text.Megaparsec.Internal.longestMatch @ [GHC.Types.Char] ms s'))
                      (\ (x23 :: a)
                         (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                         (hs :: Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                       eok
                         x23
                         s'
                         (GHC.Base.augment
                            @ (Data.Set.Internal.Set
                                 (Text.Megaparsec.Error.ErrorItem
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                            (\ @ b1
                               (c :: Data.Set.Internal.Set
                                       (Text.Megaparsec.Error.ErrorItem
                                          (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                     -> b1 -> b1)[OneShot]
                               (n3 :: b1)[OneShot] ->
                             case err of wild {
                               Text.Megaparsec.Error.TrivialError errPos ds ps
                               -> case s' of wild1 { Text.Megaparsec.State.State ds1 ds2 dt9 ds3 ->
                                  case GHC.Base.$fEqNonEmpty_$c==
                                         @ Text.Megaparsec.Pos.SourcePos
                                         Text.Megaparsec.Pos.$fEqSourcePos
                                         ds2
                                         errPos of wild2 {
                                    GHC.Types.False -> n3
                                    GHC.Types.True
                                    -> case ps of wild3 {
                                         Data.Set.Internal.Bin dt10 ds4 ds5 ds6 -> c wild3 n3
                                         Data.Set.Internal.Tip -> n3 } } }
                               Text.Megaparsec.Error.FancyError ds ds1 -> n3 })
                            hs
                              `cast`
                            (Text.Megaparsec.Internal.N:Hints[0]
                                 <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                           `cast`
                         (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                   <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)))
                      (\ (err' :: Text.Megaparsec.Error.ParseError
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void)
                         (s' :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                       eerr
                         (let {
                            $j :: Text.Megaparsec.Error.ParseError
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                              <join 0>
                            = case err' of wild {
                                Text.Megaparsec.Error.TrivialError s2 u1 p6
                                -> case err of wild1 {
                                     Text.Megaparsec.Error.TrivialError ds u2 p7
                                     -> Text.Megaparsec.Error.TrivialError
                                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                          @ Data.Void.Void
                                          s2
                                          (case u1 of wild2 {
                                             GHC.Base.Nothing -> u2
                                             GHC.Base.Just x23
                                             -> case u2 of wild3 {
                                                  GHC.Base.Nothing
                                                  -> GHC.Base.Just
                                                       @ (Text.Megaparsec.Error.ErrorItem
                                                            (Text.Megaparsec.Stream.Token
                                                               [GHC.Types.Char]))
                                                       x23
                                                  GHC.Base.Just y
                                                  -> GHC.Base.Just
                                                       @ (Text.Megaparsec.Error.ErrorItem
                                                            (Text.Megaparsec.Stream.Token
                                                               [GHC.Types.Char]))
                                                       (case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                                                               @ (Text.Megaparsec.Stream.Token
                                                                    [GHC.Types.Char])
                                                               GHC.Classes.$fOrdChar
                                                                 `cast`
                                                               (GHC.Classes.Ord
                                                                  (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                                                               y
                                                               x23 of wild4 {
                                                          GHC.Types.False -> y
                                                          GHC.Types.True -> x23 }) } })
                                          (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$sunion1
                                             p6
                                             p7)
                                     Text.Megaparsec.Error.FancyError ds ds1 -> wild1 }
                                Text.Megaparsec.Error.FancyError ds ds1
                                -> case err of wild1 {
                                     Text.Megaparsec.Error.TrivialError ds2 ds3 ds4 -> wild
                                     Text.Megaparsec.Error.FancyError ds2 x23
                                     -> Text.Megaparsec.Error.FancyError
                                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                          @ Data.Void.Void
                                          ds
                                          (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$sunion
                                             ds1
                                             x23) } }
                          } in
                          case err' of wild {
                            Text.Megaparsec.Error.TrivialError p6 ds ds1
                            -> case err of wild1 {
                                 Text.Megaparsec.Error.TrivialError p7 ds2 ds3
                                 -> case GHC.Base.$fOrdNonEmpty_$ccompare
                                           @ Text.Megaparsec.Pos.SourcePos
                                           Text.Megaparsec.Pos.$fOrdSourcePos
                                           p6
                                           p7 of wild2 {
                                      GHC.Types.LT -> wild1
                                      GHC.Types.EQ -> $j
                                      GHC.Types.GT -> wild }
                                 Text.Megaparsec.Error.FancyError p7 ds2
                                 -> case GHC.Base.$fOrdNonEmpty_$ccompare
                                           @ Text.Megaparsec.Pos.SourcePos
                                           Text.Megaparsec.Pos.$fOrdSourcePos
                                           p6
                                           p7 of wild2 {
                                      GHC.Types.LT -> wild1
                                      GHC.Types.EQ -> $j
                                      GHC.Types.GT -> wild } }
                            Text.Megaparsec.Error.FancyError p6 ds
                            -> case err of wild1 {
                                 Text.Megaparsec.Error.TrivialError p7 ds1 ds2
                                 -> case GHC.Base.$fOrdNonEmpty_$ccompare
                                           @ Text.Megaparsec.Pos.SourcePos
                                           Text.Megaparsec.Pos.$fOrdSourcePos
                                           p6
                                           p7 of wild2 {
                                      GHC.Types.LT -> wild1
                                      GHC.Types.EQ -> $j
                                      GHC.Types.GT -> wild }
                                 Text.Megaparsec.Error.FancyError p7 ds1
                                 -> case GHC.Base.$fOrdNonEmpty_$ccompare
                                           @ Text.Megaparsec.Pos.SourcePos
                                           Text.Megaparsec.Pos.$fOrdSourcePos
                                           p6
                                           p7 of wild2 {
                                      GHC.Types.LT -> wild1
                                      GHC.Types.EQ -> $j
                                      GHC.Types.GT -> wild } } })
                         (Text.Megaparsec.Internal.longestMatch @ [GHC.Types.Char] ms s'))))
                  `cast`
                (forall (m :: <* -> *>_N) (a :: <*>_N).
                 <Text.Megaparsec.Internal.ParsecT
                    Data.Void.Void [GHC.Types.Char] m a>_R
                 ->_R <Text.Megaparsec.Internal.ParsecT
                         Data.Void.Void [GHC.Types.Char] m a>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <a>_R)) -}
222f5f347aef8e2989ebe6e46846de23
  $s$fAlternativeParsecT_$sunion ::
    Data.Set.Internal.Set
      (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
    -> Data.Set.Internal.Set
         (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
    -> Data.Set.Internal.Set
         (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [~] -}
beef3ea90c96c01d0c25a7a7d6e60732
  $s$fAlternativeParsecT_$sunion1 ::
    Data.Set.Internal.Set
      (Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
    -> Data.Set.Internal.Set
         (Text.Megaparsec.Error.ErrorItem
            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
    -> Data.Set.Internal.Set
         (Text.Megaparsec.Error.ErrorItem
            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [~] -}
4e67468efd159add94aebbb7db272b5f
  $s$fAlternativeParsecT_$swithHints ::
    Text.Megaparsec.Internal.Hints
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
        -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
    -> Text.Megaparsec.Error.ParseError
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
    -> Text.Megaparsec.State.State [GHC.Types.Char]
    -> m b
  {- Arity: 3, Strictness: <L,U><C(S),1*C1(U)><S,1*U>,
     Inline: (sat-args=3),
     Unfolding: InlineRule (3, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ b
                   (ds :: Text.Megaparsec.Internal.Hints
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (c :: Text.Megaparsec.Error.ParseError
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                         -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (e1 :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e) ->
                 case e1 of wild {
                   Text.Megaparsec.Error.TrivialError pos us ps
                   -> c (Text.Megaparsec.Error.TrivialError
                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           @ e
                           pos
                           us
                           (SEDEL.Parser.Parser.$s$fAlternativeParsecT_go3
                              (Data.Set.Internal.Tip
                                 @ (Text.Megaparsec.Error.ErrorItem
                                      (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                              (GHC.Types.:
                                 @ (Data.Set.Internal.Set
                                      (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                 ps
                                 ds
                                   `cast`
                                 (Text.Megaparsec.Internal.N:Hints[0]
                                      <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))))
                   Text.Megaparsec.Error.FancyError ipv ipv1 -> c wild }) -}
c397e4bb785c1fc7e87e34938ac0baf2
  $s$fAlternativeParsecT_go3 ::
    Data.Set.Internal.Set
      (Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
    -> [Data.Set.Internal.Set
          (Text.Megaparsec.Error.ErrorItem
             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))]
    -> Data.Set.Internal.Set
         (Text.Megaparsec.Error.ErrorItem
            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
55c3a5e6580a498e313d274089e3ef8f
  $s$fEqErrorFancy ::
    GHC.Classes.Eq (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                  (Text.Megaparsec.Error.$fEqErrorFancy_$c==
                     @ Data.Void.Void
                     Data.Void.$fEqVoid)
                  SEDEL.Parser.Parser.$s$fEqErrorFancy_$s$fEqErrorFancy_$c/= -}
2265204ce5111fb034203ee79c482c0a
  $s$fEqErrorFancy_$s$fEqErrorFancy_$c/= ::
    Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x23 :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                   (y :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                 case Text.Megaparsec.Error.$fEqErrorFancy_$c==
                        @ Data.Void.Void
                        Data.Void.$fEqVoid
                        x23
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
5fcb027ff347c0f3f7fd544f5432959e
  $s$fEqErrorItem ::
    GHC.Classes.Eq
      (Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Text.Megaparsec.Error.ErrorItem
                       (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                  (Text.Megaparsec.Error.$fEqErrorItem_$c==
                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                     GHC.Classes.$fEqChar
                       `cast`
                     (GHC.Classes.Eq (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R)
                  SEDEL.Parser.Parser.$s$fEqErrorItem_$s$fEqErrorItem_$c/= -}
801f66c8989935c7ab9fa780ba8757db
  $s$fEqErrorItem_$s$fEqErrorItem_$c/= ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x23 :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (y :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                 case Text.Megaparsec.Error.$fEqErrorItem_$c==
                        @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                        GHC.Classes.$fEqChar
                          `cast`
                        (GHC.Classes.Eq (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                        x23
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
b01b430d350bf2bc5dabf2a5631f28ea
  $s$fMonadParsecT ::
    GHC.Base.Monad
      (Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e @ m :: * -> *.
                  @ (Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m)
                  (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$s$fApplicativeParsecT
                     @ e
                     @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecT_$spBind @ e @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecT_$s$fMonadParsecT_$c>>
                     @ e
                     @ m)
                  (\ @ a ->
                   Text.Megaparsec.Internal.pPure @ a @ e @ [GHC.Types.Char] @ m)
                  (Text.Megaparsec.Internal.pFail @ e @ [GHC.Types.Char] @ m) -}
b3f9c9663aff9680e8a7119deb2c76bd
  $s$fMonadParsecT_$s$fMonadParsecT_$c>> ::
    Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b
  {- Arity: 7,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,C(C1(C1(U)))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   @ b
                   (m53 :: Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a)
                   (k30 :: Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b)
                   @ b1
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: b
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (cerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b1)
                   (eok :: b
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b1) ->
                 m53
                   `cast`
                 (Text.Megaparsec.Internal.N:ParsecT[0]
                      <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                   @ b1
                   s1
                   (\ (x23 :: a)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    k30
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)
                      @ b1
                      s'
                      cok
                      cerr
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ b
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs
                         cok)
                      (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$swithHints
                         @ e
                         @ m
                         @ b1
                         hs
                         cerr))
                   cerr
                   (\ (x23 :: a)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    k30
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)
                      @ b1
                      s'
                      cok
                      cerr
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ b
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs
                         eok)
                      (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$swithHints
                         @ e
                         @ m
                         @ b1
                         hs
                         eerr))
                   eerr)
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N) (b :: <*>_N).
                 <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                 ->_R <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)) -}
885ed3ea748e4c05d3e0f016d596fbfa
  $s$fMonadParsecT_$spBind ::
    Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a
    -> (a -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b)
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b
  {- Arity: 7,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(C1(U))))))><L,U><L,U><L,U><L,C(C1(C1(U)))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   @ b
                   (m53 :: Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a)
                   (k30 :: a
                           -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b)
                   @ b1
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: b
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (cerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b1)
                   (eok :: b
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b1) ->
                 m53
                   `cast`
                 (Text.Megaparsec.Internal.N:ParsecT[0]
                      <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                   @ b1
                   s1
                   (\ (x23 :: a)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    (k30 x23)
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)
                      @ b1
                      s'
                      cok
                      cerr
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ b
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs
                         cok)
                      (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$swithHints
                         @ e
                         @ m
                         @ b1
                         hs
                         cerr))
                   cerr
                   (\ (x23 :: a)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    (k30 x23)
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)
                      @ b1
                      s'
                      cok
                      cerr
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ b
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs
                         eok)
                      (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$swithHints
                         @ e
                         @ m
                         @ b1
                         hs
                         eerr))
                   eerr)
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N) (b :: <*>_N).
                 <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                 ->_R <a
                       -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)) -}
bc04c208d381e8a2ba306bfc4824456b
  $s$fMonadParsecesParsecT ::
    Text.Megaparsec.Class.MonadParsec
      Data.Void.Void
      [GHC.Types.Char]
      (Text.Megaparsec.Internal.ParsecT
         Data.Void.Void [GHC.Types.Char] m)
  {- Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *.
                  @ Data.Void.Void
                  @ [GHC.Types.Char]
                  @ (Text.Megaparsec.Internal.ParsecT
                       Data.Void.Void [GHC.Types.Char] m)
                  Text.Megaparsec.Stream.$fStream[]
                  (SEDEL.Parser.Parser.$s$fAlternativeParsecT @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$s$fMonadPlusParsecT
                     @ m)
                  (Text.Megaparsec.Internal.pFailure
                     @ [GHC.Types.Char]
                     @ Data.Void.Void
                     @ m)
                  (Text.Megaparsec.Internal.pFancyFailure
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (Text.Megaparsec.Internal.pLabel
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (\ @ a ->
                   Text.Megaparsec.Internal.pLabel
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m
                     @ a
                     (GHC.Types.[] @ GHC.Types.Char))
                  (Text.Megaparsec.Internal.pTry
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (Text.Megaparsec.Internal.pLookAhead
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spNotFollowedBy
                     @ Data.Void.Void
                     @ m)
                  (Text.Megaparsec.Internal.pWithRecovery
                     @ [GHC.Types.Char]
                     @ Data.Void.Void
                     @ m)
                  (Text.Megaparsec.Internal.pObserving
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (\ @ b
                     (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                     (ds :: ()
                            -> Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Text.Megaparsec.Internal.Hints
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            -> m b)
                     (ds1 :: Text.Megaparsec.Error.ParseError
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                             -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                     (eok :: ()
                             -> Text.Megaparsec.State.State [GHC.Types.Char]
                             -> Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                             -> m b)
                     (eerr :: Text.Megaparsec.Error.ParseError
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                              -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                   case s1 of wild { Text.Megaparsec.State.State input ds2 dt9 w ->
                   case ds2 of wild1 { GHC.Base.:| pos z ->
                   case input of wild2 {
                     []
                     -> eok
                          GHC.Tuple.()
                          wild
                          (GHC.Types.[]
                             @ (Data.Set.Internal.Set
                                  (Text.Megaparsec.Error.ErrorItem
                                     (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                            `cast`
                          (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                    <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                     : t ts
                     -> case pos of apos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                        eerr
                          (Text.Megaparsec.Error.TrivialError
                             @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                             @ Data.Void.Void
                             (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos apos z)
                             (GHC.Base.Just
                                @ (Text.Megaparsec.Error.ErrorItem
                                     (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                (Text.Megaparsec.Error.Tokens
                                   @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                   (Text.Megaparsec.Internal.nes
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                      t `cast`
                                      (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))))))
                             (Data.Set.Internal.$WBin
                                @ (Text.Megaparsec.Error.ErrorItem
                                     (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                (GHC.Types.I# 1#)
                                (Text.Megaparsec.Error.EndOfInput
                                   @ (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                (Data.Set.Internal.Tip
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                (Data.Set.Internal.Tip
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char])))))
                          (Text.Megaparsec.State.$WState
                             @ [GHC.Types.Char]
                             wild2
                             (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos apos z)
                             (GHC.Types.I# dt9)
                             w) } } } })
                    `cast`
                  (Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                            <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <()>_R))
                  (SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spToken
                     @ Data.Void.Void
                     @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spTokens
                     @ Data.Void.Void
                     @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spTakeWhileP
                     @ Data.Void.Void
                     @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spTakeWhile1P
                     @ Data.Void.Void
                     @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spTakeP
                     @ Data.Void.Void
                     @ m)
                  (\ @ b
                     (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                     (ds :: Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Text.Megaparsec.Internal.Hints
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            -> m b)
                     (ds1 :: Text.Megaparsec.Error.ParseError
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                             -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                     (eok :: Text.Megaparsec.State.State [GHC.Types.Char]
                             -> Text.Megaparsec.State.State [GHC.Types.Char]
                             -> Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                             -> m b)
                     (ds2 :: Text.Megaparsec.Error.ParseError
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                             -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                   eok
                     s1
                     s1
                     (GHC.Types.[]
                        @ (Data.Set.Internal.Set
                             (Text.Megaparsec.Error.ErrorItem
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                       `cast`
                     (Sym (Text.Megaparsec.Internal.N:Hints[0]
                               <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)))
                    `cast`
                  (Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                            <Data.Void.Void>_N
                            <[GHC.Types.Char]>_N
                            <m>_R
                            <Text.Megaparsec.State.State [GHC.Types.Char]>_R))
                  (Text.Megaparsec.Internal.pUpdateParserState
                     @ [GHC.Types.Char]
                     @ Data.Void.Void
                     @ m) -}
a971948e09d9132619a4f4df0cf79963
  $s$fMonadParsecesParsecT_$s$fMonadPlusParsecT ::
    GHC.Base.MonadPlus
      (Text.Megaparsec.Internal.ParsecT
         Data.Void.Void [GHC.Types.Char] m)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *.
                  @ (Text.Megaparsec.Internal.ParsecT
                       Data.Void.Void [GHC.Types.Char] m)
                  (SEDEL.Parser.Parser.$s$fAlternativeParsecT @ m)
                  (SEDEL.Parser.Parser.$s$fMonadParsecT @ Data.Void.Void @ m)
                  (Text.Megaparsec.Internal.pZero
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (SEDEL.Parser.Parser.$s$fAlternativeParsecT_$spPlus @ m) -}
ef48b53d75ddd4044410a0a7b876a922
  $s$fMonadParsecesParsecT_$spNotFollowedBy ::
    Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m ()
  {- Arity: 6, HasNoCafRefs,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><S(LLSL),1*U(U,U,U,U)><L,A><L,A><L,1*C1(C1(C1(U)))><L,1*C1(C1(U))>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   (p6 :: Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a)
                   @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (ds :: ()
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> m b)
                   (ds1 :: Text.Megaparsec.Error.ParseError
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (eok :: ()
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 case s1 of wild { Text.Megaparsec.State.State input pos dt9 ds2 ->
                 let {
                   what :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                   = case input of wild1 {
                       []
                       -> Text.Megaparsec.Error.EndOfInput
                            @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                       : t ts
                       -> Text.Megaparsec.Error.Tokens
                            @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            (GHC.Base.:|
                               @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                               t `cast` (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))
                               (GHC.Types.[] @ (Text.Megaparsec.Stream.Token [GHC.Types.Char]))) }
                 } in
                 p6
                   `cast`
                 (Text.Megaparsec.Internal.N:ParsecT[0]
                      <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                   @ b
                   wild
                   (\ (ds3 :: a)
                      (ds4 :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (ds5 :: Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    eerr
                      (Text.Megaparsec.Error.TrivialError
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ e
                         pos
                         (GHC.Base.Just
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                            what)
                         (Data.Set.Internal.Tip
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                      wild)
                   (\ (ds3 :: Text.Megaparsec.Error.ParseError
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e)
                      (ds4 :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                    eok
                      GHC.Tuple.()
                      wild
                      (GHC.Types.[]
                         @ (Data.Set.Internal.Set
                              (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                        `cast`
                      (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)))
                   (\ (ds3 :: a)
                      (ds4 :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (ds5 :: Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    eerr
                      (Text.Megaparsec.Error.TrivialError
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ e
                         pos
                         (GHC.Base.Just
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                            what)
                         (Data.Set.Internal.Tip
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                      wild)
                   (\ (ds3 :: Text.Megaparsec.Error.ParseError
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e)
                      (ds4 :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                    eok
                      GHC.Tuple.()
                      wild
                      (GHC.Types.[]
                         @ (Data.Set.Internal.Set
                              (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                        `cast`
                      (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))) })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N).
                 <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <()>_R)) -}
0205b129a62ed721d302e168bafb879f
  $s$fMonadParsecesParsecT_$spTakeP ::
    GHC.Base.Maybe GHC.Base.String
    -> GHC.Types.Int
    -> Text.Megaparsec.Internal.ParsecT
         e
         [GHC.Types.Char]
         m
         (Text.Megaparsec.Stream.Tokens [GHC.Types.Char])
  {- Arity: 7,
     Strictness: <L,1*U><S(S),1*U(U)><S(LSSL),1*U(U,1*U(U(U,U,U),U),U,U(U))><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(C1(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   (ml :: GHC.Base.Maybe GHC.Base.String)
                   (n2 :: GHC.Types.Int)
                   @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (ds1 :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 case s1 of wild { Text.Megaparsec.State.State input ds2 dt9 w ->
                 case ds2 of wild1 { GHC.Base.:| pos z ->
                 let {
                   ps :: Data.Set.Internal.Set
                           (Text.Megaparsec.Error.ErrorItem
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   = case ml of wild2 {
                       GHC.Base.Nothing
                       -> Data.Set.Internal.Tip
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                       GHC.Base.Just x23
                       -> case x23 of wild3 {
                            []
                            -> Data.Set.Internal.Tip
                                 @ (Text.Megaparsec.Error.ErrorItem
                                      (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                            : a1 as4
                            -> Data.Set.Internal.$WBin
                                 @ (Text.Megaparsec.Error.ErrorItem
                                      (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                 (GHC.Types.I# 1#)
                                 (Text.Megaparsec.Error.Label
                                    @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                    (GHC.Base.:| @ GHC.Types.Char a1 as4))
                                 (Data.Set.Internal.Tip
                                    @ (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                 (Data.Set.Internal.Tip
                                    @ (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))) } }
                 } in
                 case Text.Megaparsec.Stream.$fStream[]_$ctakeN_ n2 input of wild2 {
                   GHC.Base.Nothing
                   -> eerr
                        (Text.Megaparsec.Error.TrivialError
                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           @ e
                           (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos pos z)
                           (GHC.Base.Just
                              @ (Text.Megaparsec.Error.ErrorItem
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              (Text.Megaparsec.Error.EndOfInput
                                 @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                           ps)
                        wild
                   GHC.Base.Just ds3
                   -> case ds3 of wild3 { (,) ts input' ->
                      case Text.Megaparsec.Stream.$fStream[]_$cadvanceN
                             (Data.Proxy.Proxy @ * @ [GHC.Types.Char])
                             w
                             pos
                             ts of npos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                      case pos of apos { Text.Megaparsec.Pos.SourcePos ipv3 ipv4 ipv5 ->
                      let {
                        len :: GHC.Types.Int
                        = case GHC.List.$wlenAcc
                                 @ GHC.Types.Char
                                 ts `cast` (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                                 0# of ww2 { DEFAULT ->
                          GHC.Types.I# ww2 }
                      } in
                      case GHC.Classes.neInt len n2 of wild4 {
                        GHC.Types.False
                        -> cok
                             ts
                             (case len of wild5 { GHC.Types.I# y ->
                              Text.Megaparsec.State.$WState
                                @ [GHC.Types.Char]
                                input'
                                (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos npos z)
                                (GHC.Types.I# (GHC.Prim.+# dt9 y))
                                w })
                             (GHC.Types.[]
                                @ (Data.Set.Internal.Set
                                     (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                               `cast`
                             (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                       <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                        GHC.Types.True
                        -> eerr
                             (Text.Megaparsec.Error.TrivialError
                                @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                @ e
                                (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos npos z)
                                (GHC.Base.Just
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                   (Text.Megaparsec.Error.EndOfInput
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                ps)
                             (Text.Megaparsec.State.$WState
                                @ [GHC.Types.Char]
                                input
                                (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos apos z)
                                (GHC.Types.I# dt9)
                                w) } } } } } } })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Base.Maybe GHC.Base.String>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N
                               <[GHC.Types.Char]>_N
                               <m>_R
                               <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]>_R)) -}
67fbdda1ce2345449c6fd27c3a9bc73a
  $s$fMonadParsecesParsecT_$spTakeWhile1P ::
    GHC.Base.Maybe GHC.Base.String
    -> (Text.Megaparsec.Stream.Token [GHC.Types.Char]
        -> GHC.Types.Bool)
    -> Text.Megaparsec.Internal.ParsecT
         e
         [GHC.Types.Char]
         m
         (Text.Megaparsec.Stream.Tokens [GHC.Types.Char])
  {- Arity: 2, Strictness: <L,1*U><L,C(U)>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   (ml :: GHC.Base.Maybe GHC.Base.String)
                   (f1 :: Text.Megaparsec.Stream.Token [GHC.Types.Char]
                          -> GHC.Types.Bool)
                   @ b
                   (ds :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds1 :: Text.Megaparsec.Error.ParseError
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (ds2 :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 case ds of wild { Text.Megaparsec.State.State input ds3 dt9 w ->
                 case ds3 of wild1 { GHC.Base.:| pos z ->
                 let {
                   el3 :: GHC.Base.Maybe
                            (Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   = case ml of wild2 {
                       GHC.Base.Nothing
                       -> GHC.Base.Nothing
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                       GHC.Base.Just x23
                       -> case x23 of wild3 {
                            []
                            -> GHC.Base.Nothing
                                 @ (Text.Megaparsec.Error.ErrorItem
                                      (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                            : a1 as4
                            -> GHC.Base.Just
                                 @ (Text.Megaparsec.Error.ErrorItem
                                      (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                 (Text.Megaparsec.Error.Label
                                    @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                    (GHC.Base.:| @ GHC.Types.Char a1 as4)) } }
                 } in
                 let {
                   ds4 :: ([GHC.Types.Char], [GHC.Types.Char])
                   = GHC.List.span
                       @ GHC.Types.Char
                       f1
                         `cast`
                       (Sub (Text.Megaparsec.Stream.D:R:Token[][0])
                        ->_R <GHC.Types.Bool>_R)
                       input
                 } in
                 let {
                   ts :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                   = case ds4
                            `cast`
                          ((,)
                             (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))
                             <[GHC.Types.Char]>_R)_R of wild2 { (,) ts1 input' ->
                     ts1 }
                 } in
                 case ds4
                        `cast`
                      ((,)
                         (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))
                         <[GHC.Types.Char]>_R)_R of wild2 { (,) ts1 input' ->
                 case ts1
                        `cast`
                      (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0])) of wild4 {
                   []
                   -> case pos of apos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                      eerr
                        (Text.Megaparsec.Error.TrivialError
                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           @ e
                           (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos apos z)
                           (GHC.Base.Just
                              @ (Text.Megaparsec.Error.ErrorItem
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              (case input of wild5 {
                                 []
                                 -> Text.Megaparsec.Error.EndOfInput
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                 : t ts2
                                 -> Text.Megaparsec.Error.Tokens
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                      (Text.Megaparsec.Internal.nes
                                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                         t `cast`
                                         (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))) }))
                           (case el3 of wild3 {
                              GHC.Base.Nothing
                              -> Data.Set.Internal.Tip
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              GHC.Base.Just x23
                              -> Data.Set.Internal.singleton
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                   x23 }))
                        (Text.Megaparsec.State.$WState
                           @ [GHC.Types.Char]
                           input
                           (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos apos z)
                           (GHC.Types.I# dt9)
                           w) }
                   : ds7 ds8
                   -> case Text.Megaparsec.Stream.$fStream[]_$cadvanceN
                             (Data.Proxy.Proxy @ * @ [GHC.Types.Char])
                             w
                             pos
                             ts of npos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                      cok
                        ts
                        (case GHC.List.$wlenAcc
                                @ GHC.Types.Char
                                ts `cast` (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                                0# of ww2 { DEFAULT ->
                         Text.Megaparsec.State.$WState
                           @ [GHC.Types.Char]
                           input'
                           (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos npos z)
                           (GHC.Types.I# (GHC.Prim.+# dt9 ww2))
                           w })
                        (case el3 of wild3 {
                           GHC.Base.Nothing
                           -> (GHC.Types.[]
                                 @ (Data.Set.Internal.Set
                                      (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                `cast`
                              (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                        <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                           GHC.Base.Just l
                           -> (GHC.Base.build
                                 @ (Data.Set.Internal.Set
                                      (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                 (\ @ a1
                                    (c :: Data.Set.Internal.Set
                                            (Text.Megaparsec.Error.ErrorItem
                                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                          -> a1 -> a1)[OneShot]
                                    (n2 :: a1)[OneShot] ->
                                  c (Data.Set.Internal.singleton
                                       @ (Text.Megaparsec.Error.ErrorItem
                                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                       l)
                                    n2))
                                `cast`
                              (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                        <Text.Megaparsec.Stream.Token
                                           [GHC.Types.Char]>_N)) }) } } } } })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Base.Maybe GHC.Base.String>_R
                 ->_R <Text.Megaparsec.Stream.Token [GHC.Types.Char]
                       -> GHC.Types.Bool>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N
                               <[GHC.Types.Char]>_N
                               <m>_R
                               <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]>_R)) -}
e6f4d987cbba9eee0e7d26cd4a3362b7
  $s$fMonadParsecesParsecT_$spTakeWhileP ::
    GHC.Base.Maybe GHC.Base.String
    -> (Text.Megaparsec.Stream.Token [GHC.Types.Char]
        -> GHC.Types.Bool)
    -> Text.Megaparsec.Internal.ParsecT
         e
         [GHC.Types.Char]
         m
         (Text.Megaparsec.Stream.Tokens [GHC.Types.Char])
  {- Arity: 7,
     Strictness: <L,1*U><L,C(U)><S(SS(S(LSS)L)LL),1*U(1*U,1*U(1*U(U,U,U),U),U,U(U))><L,1*C1(C1(C1(U)))><L,A><L,1*C1(C1(C1(U)))><L,A>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   (ml :: GHC.Base.Maybe GHC.Base.String)
                   (f1 :: Text.Megaparsec.Stream.Token [GHC.Types.Char]
                          -> GHC.Types.Bool)
                   @ b
                   (ds :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds1 :: Text.Megaparsec.Error.ParseError
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (eok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds2 :: Text.Megaparsec.Error.ParseError
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 case ds of wild { Text.Megaparsec.State.State input ds3 dt9 w ->
                 case ds3 of wild1 { GHC.Base.:| pos z ->
                 let {
                   hs :: Text.Megaparsec.Internal.Hints
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                   = case ml of wild2 {
                       GHC.Base.Nothing
                       -> (GHC.Types.[]
                             @ (Data.Set.Internal.Set
                                  (Text.Megaparsec.Error.ErrorItem
                                     (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                            `cast`
                          (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                    <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                       GHC.Base.Just x23
                       -> case x23 of wild3 {
                            []
                            -> (GHC.Types.[]
                                  @ (Data.Set.Internal.Set
                                       (Text.Megaparsec.Error.ErrorItem
                                          (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                 `cast`
                               (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                         <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                            : a1 as4
                            -> (GHC.Base.build
                                  @ (Data.Set.Internal.Set
                                       (Text.Megaparsec.Error.ErrorItem
                                          (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                  (\ @ a2
                                     (c :: Data.Set.Internal.Set
                                             (Text.Megaparsec.Error.ErrorItem
                                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                           -> a2 -> a2)[OneShot]
                                     (n2 :: a2)[OneShot] ->
                                   c (Data.Set.Internal.$WBin
                                        @ (Text.Megaparsec.Error.ErrorItem
                                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                        (GHC.Types.I# 1#)
                                        (Text.Megaparsec.Error.Label
                                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                           (GHC.Base.:| @ GHC.Types.Char a1 as4))
                                        (Data.Set.Internal.Tip
                                           @ (Text.Megaparsec.Error.ErrorItem
                                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                        (Data.Set.Internal.Tip
                                           @ (Text.Megaparsec.Error.ErrorItem
                                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                     n2))
                                 `cast`
                               (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                         <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)) } }
                 } in
                 let {
                   ds4 :: ([GHC.Types.Char], [GHC.Types.Char])
                   = GHC.List.span
                       @ GHC.Types.Char
                       f1
                         `cast`
                       (Sub (Text.Megaparsec.Stream.D:R:Token[][0])
                        ->_R <GHC.Types.Bool>_R)
                       input
                 } in
                 let {
                   ts :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                   = case ds4
                            `cast`
                          ((,)
                             (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))
                             <[GHC.Types.Char]>_R)_R of wild2 { (,) ts1 input' ->
                     ts1 }
                 } in
                 case Text.Megaparsec.Stream.$fStream[]_$cadvanceN
                        (Data.Proxy.Proxy @ * @ [GHC.Types.Char])
                        w
                        pos
                        ts of npos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                 case ds4
                        `cast`
                      ((,)
                         (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))
                         <[GHC.Types.Char]>_R)_R of wild2 { (,) ts1 input' ->
                 case ts1
                        `cast`
                      (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0])) of wild4 {
                   []
                   -> eok
                        ts
                        (case GHC.List.$wlenAcc
                                @ GHC.Types.Char
                                ts `cast` (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                                0# of ww2 { DEFAULT ->
                         Text.Megaparsec.State.$WState
                           @ [GHC.Types.Char]
                           input'
                           (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos npos z)
                           (GHC.Types.I# (GHC.Prim.+# dt9 ww2))
                           w })
                        hs
                   : ds7 ds8
                   -> cok
                        ts
                        (case GHC.List.$wlenAcc
                                @ GHC.Types.Char
                                ts `cast` (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                                0# of ww2 { DEFAULT ->
                         Text.Megaparsec.State.$WState
                           @ [GHC.Types.Char]
                           input'
                           (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos npos z)
                           (GHC.Types.I# (GHC.Prim.+# dt9 ww2))
                           w })
                        hs } } } } })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Base.Maybe GHC.Base.String>_R
                 ->_R <Text.Megaparsec.Stream.Token [GHC.Types.Char]
                       -> GHC.Types.Bool>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N
                               <[GHC.Types.Char]>_N
                               <m>_R
                               <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]>_R)) -}
8e828ad8d2ed81de1a78314b235cff8e
  $s$fMonadParsecesParsecT_$spToken ::
    (Text.Megaparsec.Stream.Token [GHC.Types.Char]
     -> Data.Either.Either
          (GHC.Base.Maybe
             (Text.Megaparsec.Error.ErrorItem
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])),
           Data.Set.Internal.Set
             (Text.Megaparsec.Error.ErrorItem
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
          a)
    -> GHC.Base.Maybe (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a
  {- Arity: 2, Strictness: <L,C(U)><L,1*U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   (test :: Text.Megaparsec.Stream.Token [GHC.Types.Char]
                            -> Data.Either.Either
                                 (GHC.Base.Maybe
                                    (Text.Megaparsec.Error.ErrorItem
                                       (Text.Megaparsec.Stream.Token [GHC.Types.Char])),
                                  Data.Set.Internal.Set
                                    (Text.Megaparsec.Error.ErrorItem
                                       (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                 a)
                   (mtoken :: GHC.Base.Maybe
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: a
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (ds1 :: a
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 case s1 of wild { Text.Megaparsec.State.State input ds2 dt9 w ->
                 case ds2 of wild1 { GHC.Base.:| pos z ->
                 case input of wild2 {
                   []
                   -> eerr
                        (Text.Megaparsec.Error.TrivialError
                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           @ e
                           (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos pos z)
                           (GHC.Base.Just
                              @ (Text.Megaparsec.Error.ErrorItem
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              (Text.Megaparsec.Error.EndOfInput
                                 @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                           (case mtoken of wild3 {
                              GHC.Base.Nothing
                              -> Data.Set.Internal.Tip
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              GHC.Base.Just x23
                              -> Data.Set.Internal.$WBin
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                   (GHC.Types.I# 1#)
                                   (Text.Megaparsec.Error.Tokens
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                      (Text.Megaparsec.Internal.nes
                                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                         x23))
                                   (Data.Set.Internal.Tip
                                      @ (Text.Megaparsec.Error.ErrorItem
                                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                   (Data.Set.Internal.Tip
                                      @ (Text.Megaparsec.Error.ErrorItem
                                           (Text.Megaparsec.Stream.Token [GHC.Types.Char]))) }))
                        wild
                   : t ts
                   -> case test
                             t `cast`
                             (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))) of wild4 {
                        Data.Either.Left ds4
                        -> case ds4 of wild5 { (,) us ps ->
                           case pos of apos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                           eerr
                             (Text.Megaparsec.Error.TrivialError
                                @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                @ e
                                (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos apos z)
                                us
                                ps)
                             (Text.Megaparsec.State.$WState
                                @ [GHC.Types.Char]
                                wild2
                                (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos apos z)
                                (GHC.Types.I# dt9)
                                w) } }
                        Data.Either.Right x23
                        -> case Text.Megaparsec.Stream.$fStream[]_$cadvance1
                                  (Data.Proxy.Proxy @ * @ [GHC.Types.Char])
                                  w
                                  pos
                                  t `cast`
                                  (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))) of npos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                           cok
                             x23
                             (Text.Megaparsec.State.$WState
                                @ [GHC.Types.Char]
                                ts
                                (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos npos z)
                                (GHC.Types.I# (GHC.Prim.+# dt9 1#))
                                w)
                             (GHC.Types.[]
                                @ (Data.Set.Internal.Set
                                     (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                               `cast`
                             (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                       <Text.Megaparsec.Stream.Token
                                          [GHC.Types.Char]>_N)) } } } } })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N).
                 <Text.Megaparsec.Stream.Token [GHC.Types.Char]
                  -> Data.Either.Either
                       (GHC.Base.Maybe
                          (Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])),
                        Data.Set.Internal.Set
                          (Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                       a>_R
                 ->_R <GHC.Base.Maybe
                         (Text.Megaparsec.Stream.Token [GHC.Types.Char])>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)) -}
241d7eec5a8dd5719afa47b3fcf164d0
  $s$fMonadParsecesParsecT_$spTokens ::
    (Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
     -> Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
     -> GHC.Types.Bool)
    -> Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
    -> Text.Megaparsec.Internal.ParsecT
         e
         [GHC.Types.Char]
         m
         (Text.Megaparsec.Stream.Tokens [GHC.Types.Char])
  {- Arity: 2, Strictness: <L,C(C1(U))><L,U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   (f1 :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                          -> Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                          -> GHC.Types.Bool)
                   (tts :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char])
                   @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (eok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 case s1 of wild { Text.Megaparsec.State.State input ds1 dt9 w ->
                 case ds1 of wild1 { GHC.Base.:| pos z ->
                 let {
                   unexpect :: GHC.Base.NonEmpty Text.Megaparsec.Pos.SourcePos
                               -> Text.Megaparsec.Error.ErrorItem
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                               -> Text.Megaparsec.Error.ParseError
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                     {- Arity: 2 -}
                   = \ (pos' :: GHC.Base.NonEmpty Text.Megaparsec.Pos.SourcePos)
                       (u :: Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                     Text.Megaparsec.Error.TrivialError
                       @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                       @ e
                       pos'
                       (GHC.Base.Just
                          @ (Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                          u)
                       (Data.Set.Internal.$WBin
                          @ (Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                          (GHC.Types.I# 1#)
                          (Text.Megaparsec.Error.Tokens
                             @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                             (case tts
                                     `cast`
                                   (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]) ; ([Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))])_R) of wild2 {
                                []
                                -> Data.List.NonEmpty.cycle1
                                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                : a1 as4
                                -> GHC.Base.:|
                                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                     a1
                                     as4 }))
                          (Data.Set.Internal.Tip
                             @ (Text.Megaparsec.Error.ErrorItem
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                          (Data.Set.Internal.Tip
                             @ (Text.Megaparsec.Error.ErrorItem
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                 } in
                 let {
                   len :: GHC.Types.Int
                   = case GHC.List.$wlenAcc
                            @ GHC.Types.Char
                            tts `cast` (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                            0# of ww2 { DEFAULT ->
                     GHC.Types.I# ww2 }
                 } in
                 case Text.Megaparsec.Stream.$fStream[]_$ctakeN_
                        len
                        input of wild2 {
                   GHC.Base.Nothing
                   -> eerr
                        (unexpect
                           (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos pos z)
                           (Text.Megaparsec.Error.EndOfInput
                              @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                        wild
                   GHC.Base.Just ds2
                   -> case ds2 of wild3 { (,) tts' input' ->
                      case f1 tts tts' of wild4 {
                        GHC.Types.False
                        -> case pos of apos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                           eerr
                             (unexpect
                                (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos apos z)
                                (Text.Megaparsec.Error.Tokens
                                   @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                   (case tts'
                                           `cast`
                                         (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]) ; ([Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))])_R) of wild5 {
                                      []
                                      -> Data.List.NonEmpty.cycle1
                                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                      : a1 as4
                                      -> GHC.Base.:|
                                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                           a1
                                           as4 })))
                             (Text.Megaparsec.State.$WState
                                @ [GHC.Types.Char]
                                input
                                (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos apos z)
                                (GHC.Types.I# dt9)
                                w) }
                        GHC.Types.True
                        -> case Text.Megaparsec.Stream.$fStream[]_$cadvanceN
                                  (Data.Proxy.Proxy @ * @ [GHC.Types.Char])
                                  w
                                  pos
                                  tts' of npos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                           let {
                             st :: Text.Megaparsec.State.State [GHC.Types.Char]
                             = case len of wild5 { GHC.Types.I# y ->
                               Text.Megaparsec.State.$WState
                                 @ [GHC.Types.Char]
                                 input'
                                 (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos npos z)
                                 (GHC.Types.I# (GHC.Prim.+# dt9 y))
                                 w }
                           } in
                           case tts
                                  `cast`
                                (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0])) of wild7 {
                             []
                             -> eok
                                  tts'
                                  st
                                  (GHC.Types.[]
                                     @ (Data.Set.Internal.Set
                                          (Text.Megaparsec.Error.ErrorItem
                                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                    `cast`
                                  (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                            <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                             : ds4 ds5
                             -> cok
                                  tts'
                                  st
                                  (GHC.Types.[]
                                     @ (Data.Set.Internal.Set
                                          (Text.Megaparsec.Error.ErrorItem
                                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                    `cast`
                                  (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                            <Text.Megaparsec.Stream.Token
                                               [GHC.Types.Char]>_N)) } } } } } } })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N).
                 <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                  -> Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                  -> GHC.Types.Bool>_R
                 ->_R <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N
                               <[GHC.Types.Char]>_N
                               <m>_R
                               <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]>_R)) -}
32244d72d40d5423e33a6f547dd4bdbc
  $s$fOrdErrorFancy ::
    GHC.Classes.Ord (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                  SEDEL.Parser.Parser.$s$fEqErrorFancy
                  (Text.Megaparsec.Error.$fOrdErrorFancy_$ccompare
                     @ Data.Void.Void
                     Data.Void.$fOrdVoid)
                  (Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                     @ Data.Void.Void
                     Data.Void.$fOrdVoid)
                  (\ (a :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                     (b :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                   case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                          @ Data.Void.Void
                          Data.Void.$fOrdVoid
                          b
                          a of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (a :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                     (b :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                   Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                     @ Data.Void.Void
                     Data.Void.$fOrdVoid
                     b
                     a)
                  (\ (a :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                     (b :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                   case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                          @ Data.Void.Void
                          Data.Void.$fOrdVoid
                          a
                          b of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (x23 :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                     (y :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                   case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                          @ Data.Void.Void
                          Data.Void.$fOrdVoid
                          y
                          x23 of wild {
                     GHC.Types.False -> y GHC.Types.True -> x23 })
                  (\ (x23 :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                     (y :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                   case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                          @ Data.Void.Void
                          Data.Void.$fOrdVoid
                          y
                          x23 of wild {
                     GHC.Types.False -> x23 GHC.Types.True -> y }) -}
b9036c19f74d691ef6c9bec0e39ecce8
  $s$fOrdErrorFancy_$c<= ::
    Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                   (b :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                 case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                        @ Data.Void.Void
                        Data.Void.$fOrdVoid
                        b
                        a of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
da9623d478e3d5f710e64cec4c5087e6
  $s$fOrdErrorFancy_$c>= ::
    Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                   (b :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                 case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                        @ Data.Void.Void
                        Data.Void.$fOrdVoid
                        a
                        b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
14889613eb96ed7935012cd0107e2551
  $s$fOrdErrorFancy_$cmax ::
    Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x23 :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                   (y :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                 case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                        @ Data.Void.Void
                        Data.Void.$fOrdVoid
                        y
                        x23 of wild {
                   GHC.Types.False -> y GHC.Types.True -> x23 }) -}
e51c5561f8c29dca0f34a940c8c6cd95
  $s$fOrdErrorFancy_$cmin ::
    Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x23 :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                   (y :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                 case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                        @ Data.Void.Void
                        Data.Void.$fOrdVoid
                        y
                        x23 of wild {
                   GHC.Types.False -> x23 GHC.Types.True -> y }) -}
041751d5d7b3269f0edd402a1e30d032
  $s$fOrdErrorItem ::
    GHC.Classes.Ord
      (Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Text.Megaparsec.Error.ErrorItem
                       (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                  SEDEL.Parser.Parser.$s$fEqErrorItem
                  (Text.Megaparsec.Error.$fOrdErrorItem_$ccompare
                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                     GHC.Classes.$fOrdChar
                       `cast`
                     (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R)
                  (Text.Megaparsec.Error.$fOrdErrorItem_$c<
                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                     GHC.Classes.$fOrdChar
                       `cast`
                     (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R)
                  (\ (a :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                     (b :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                   case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          GHC.Classes.$fOrdChar
                            `cast`
                          (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                          b
                          a of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (a :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                     (b :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                   Text.Megaparsec.Error.$fOrdErrorItem_$c<
                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                     GHC.Classes.$fOrdChar
                       `cast`
                     (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                     b
                     a)
                  (\ (a :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                     (b :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                   case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          GHC.Classes.$fOrdChar
                            `cast`
                          (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                          a
                          b of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (x23 :: Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                     (y :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                   case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          GHC.Classes.$fOrdChar
                            `cast`
                          (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                          y
                          x23 of wild {
                     GHC.Types.False -> y GHC.Types.True -> x23 })
                  (\ (x23 :: Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                     (y :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                   case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          GHC.Classes.$fOrdChar
                            `cast`
                          (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                          y
                          x23 of wild {
                     GHC.Types.False -> x23 GHC.Types.True -> y }) -}
8c81ef335d64d39a2f0a2b70af44b9f5
  $s$fOrdErrorItem_$c<= ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (b :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                 case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                        @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                        GHC.Classes.$fOrdChar
                          `cast`
                        (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                        b
                        a of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
0177fc132b9045dc4e2d1a6114df4caa
  $s$fOrdErrorItem_$c>= ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (b :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                 case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                        @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                        GHC.Classes.$fOrdChar
                          `cast`
                        (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                        a
                        b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
9490c51634fdeb27f866b024b66f2158
  $s$fOrdErrorItem_$cmax ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x23 :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (y :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                 case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                        @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                        GHC.Classes.$fOrdChar
                          `cast`
                        (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                        y
                        x23 of wild {
                   GHC.Types.False -> y GHC.Types.True -> x23 }) -}
124b6f2af89d5143937306bad16d245a
  $s$fOrdErrorItem_$cmin ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x23 :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (y :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                 case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                        @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                        GHC.Classes.$fOrdChar
                          `cast`
                        (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                        y
                        x23 of wild {
                   GHC.Types.False -> x23 GHC.Types.True -> y }) -}
10d726d76dc0f00a1bd40937e5e86fec
  $scharLiteral1 ::
    Text.Megaparsec.State.State [GHC.Types.Char]
    -> (GHC.Types.Char
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,U(U,U(U(U,U,U),U),U,U(U))><L,C(C1(C1(U)))><L,C(U)><L,C(C1(C1(U)))><L,C(U)> -}
2ad1e2e442cfeb4ef19ff0142222425d
  $sinsertR_go3 ::
    GHC.Classes.Ord a1 =>
    a1 -> a1 -> Data.Set.Internal.Set a1 -> Data.Set.Internal.Set a1
  {- Arity: 4,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><L,U><S,1*U><S,1*U> -}
f3328abf96bde2b0c1303ad210f08e99
  $sinsert_go3 ::
    GHC.Classes.Ord a1 =>
    a1 -> a1 -> Data.Set.Internal.Set a1 -> Data.Set.Internal.Set a1
  {- Arity: 4,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><L,U><S,1*U><S,1*U> -}
cf218e37297634255e2b70fffc7dd3e8
  $sscientific1 ::
    Text.Megaparsec.State.State [GHC.Types.Char]
    -> (Data.Scientific.Scientific
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> (Data.Scientific.Scientific
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: Data.Scientific.Scientific
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> Data.Functor.Identity.Identity b1)
                   (cerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                            -> Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Data.Functor.Identity.Identity b1)
                   (eok :: Data.Scientific.Scientific
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> Data.Functor.Identity.Identity b1)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                            -> Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Data.Functor.Identity.Identity b1) ->
                 SEDEL.Parser.Parser.$sscientific_m1
                   `cast`
                 (Text.Megaparsec.Internal.N:ParsecT[0]
                      <Data.Void.Void>_N
                      <[GHC.Types.Char]>_N
                      <Data.Functor.Identity.Identity>_R
                      <GHC.Integer.Type.Integer>_R)
                   @ b1
                   s1
                   (\ (x23 :: GHC.Integer.Type.Integer)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    case s' of ww { Text.Megaparsec.State.State ww1 ww2 ww3 ww4 ->
                    case ww2 of ww5 { GHC.Base.:| ww6 ww7 ->
                    SEDEL.Parser.Parser.$wk
                      x23
                      @ b1
                      ww1
                      ww6
                      ww7
                      ww3
                      ww4
                      cok
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ Data.Scientific.Scientific
                         @ [GHC.Types.Char]
                         @ Data.Functor.Identity.Identity
                         @ b1
                         hs
                         cok) } })
                   cerr
                   (\ (x23 :: GHC.Integer.Type.Integer)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    case s' of ww { Text.Megaparsec.State.State ww1 ww2 ww3 ww4 ->
                    case ww2 of ww5 { GHC.Base.:| ww6 ww7 ->
                    SEDEL.Parser.Parser.$wk
                      x23
                      @ b1
                      ww1
                      ww6
                      ww7
                      ww3
                      ww4
                      cok
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ Data.Scientific.Scientific
                         @ [GHC.Types.Char]
                         @ Data.Functor.Identity.Identity
                         @ b1
                         hs
                         eok) } })
                   eerr) -}
453bd27ac62755b1ca993a354662b086
  $sscientific2 ::
    (Text.Megaparsec.Stream.Token [GHC.Types.Char] :: *)
    GHC.Types.~~ (GHC.Types.Char :: *)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Eq#
                   @ *
                   @ *
                   @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                   @ GHC.Types.Char
                   @~ (Text.Megaparsec.Stream.D:R:Token[][0])) -}
e2d4f57130c3fc5146d2561b17cbfd32
  $sscientific_m1 ::
    Text.Megaparsec.Internal.ParsecT
      Data.Void.Void
      [GHC.Types.Char]
      Data.Functor.Identity.Identity
      GHC.Integer.Type.Integer
  {- Unfolding: (Text.Megaparsec.Char.Lexer.decimal_
                   @ Data.Void.Void
                   @ [GHC.Types.Char]
                   @ (Text.Megaparsec.Internal.ParsecT
                        Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity)
                   @ GHC.Integer.Type.Integer
                   (SEDEL.Parser.Parser.$s$fMonadParsecesParsecT
                      @ Data.Functor.Identity.Identity)
                   SEDEL.Parser.Parser.$sscientific2
                     `cast`
                   (Sym (Data.Type.Equality.N:~[0]
                             <*>_N) <Text.Megaparsec.Stream.Token
                                       [GHC.Types.Char]>_N <GHC.Types.Char>_N)
                   GHC.Real.$fIntegralInteger) -}
51d69df5bef42a93aef9075a71acf882
  $sskipBlockComment1 ::
    Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
    -> Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
    -> forall b.
       Text.Megaparsec.State.State [GHC.Types.Char]
       -> (()
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b)
       -> (Text.Megaparsec.Error.ParseError
             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Data.Functor.Identity.Identity b)
       -> (()
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b)
       -> (Text.Megaparsec.Error.ParseError
             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 7,
     Strictness: <S,U><L,U><S(LSLL),1*U(U,U(U(U,U,U),U),U,U(U))><L,C(C(C1(U)))><L,C(U)><L,1*C1(C1(C1(U)))><L,1*C1(U)> -}
e7d23871a9eab169112f98a83d28a967
  $swhen1 ::
    Text.Megaparsec.State.State [GHC.Types.Char]
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b)
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><L,A><L,A><C(C(C(S))),1*C1(C1(C1(U)))><L,A>,
     Unfolding: InlineRule (5, True, True)
                (\ @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (ds :: ()
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b)
                   (ds1 :: Text.Megaparsec.Error.ParseError
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Data.Functor.Identity.Identity b)
                   (eok :: ()
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> Data.Functor.Identity.Identity b)
                   (ds2 :: Text.Megaparsec.Error.ParseError
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Data.Functor.Identity.Identity b) ->
                 eok
                   GHC.Tuple.()
                   s1
                   (GHC.Types.[]
                      @ (Data.Set.Internal.Set
                           (Text.Megaparsec.Error.ErrorItem
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                     `cast`
                   (Sym (Text.Megaparsec.Internal.N:Hints[0]
                             <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))) -}
280e05ef3f4f6ab9c4fda3763cab9d78
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   SEDEL.Parser.Parser.$trModule3
                   SEDEL.Parser.Parser.$trModule1) -}
e57362981111f0011fd96dd7ca8664e9
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Parser.Parser.$trModule2) -}
4b08c24ac71ebec5d40c70575d067dac
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SEDEL.Parser.Parser"#) -}
d83df61e796285ebe0aa51415050a863
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SEDEL.Parser.Parser.$trModule4) -}
bbc5396e5d1c18fa5d08c24b577f6cbb
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("sedel-0.1.0.0-DuOee9DhvYx7Duo7SFFYX4"#) -}
5911f4c44e48660de82b8ab5f79b8a2e
  $w$sskipLineComment ::
    Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
    -> forall b1.
       [GHC.Types.Char]
       -> Text.Megaparsec.Pos.SourcePos
       -> [Text.Megaparsec.Pos.SourcePos]
       -> GHC.Prim.Int#
       -> Text.Megaparsec.Pos.Pos
       -> (()
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b1)
       -> (()
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b1)
       -> (Text.Megaparsec.Error.ParseError
             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Data.Functor.Identity.Identity b1)
       -> Data.Functor.Identity.Identity b1
  {- Arity: 9,
     Strictness: <S,U><L,U><L,U(U,U,U)><L,U><L,U><L,U(U)><L,C(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,1*C1(C1(U))>,
     Inline: [0] -}
a3206abc207d6ae575284926054befb5
  $w$sspace ::
    Text.Megaparsec.Internal.ParsecT
      Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity ()
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity ()
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity ()
    -> forall b.
       Text.Megaparsec.State.State GHC.Base.String
       -> (()
           -> Text.Megaparsec.State.State GHC.Base.String
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token GHC.Base.String)
           -> Data.Functor.Identity.Identity b)
       -> (Text.Megaparsec.Error.ParseError
             (Text.Megaparsec.Stream.Token GHC.Base.String) Data.Void.Void
           -> Text.Megaparsec.State.State GHC.Base.String
           -> Data.Functor.Identity.Identity b)
       -> (()
           -> Text.Megaparsec.State.State GHC.Base.String
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token GHC.Base.String)
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 7,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,U(U,U(U(U,U,U),U),U,U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))>,
     Inline: [0] -}
a9c6c0dce4132634b57f8f1722f8d8b6
  $wgo ::
    ([SEDEL.Source.Syntax.SDecl] -> [SEDEL.Source.Syntax.SDecl])
    -> forall b.
       [GHC.Types.Char]
       -> Text.Megaparsec.Pos.SourcePos
       -> [Text.Megaparsec.Pos.SourcePos]
       -> GHC.Prim.Int#
       -> Text.Megaparsec.Pos.Pos
       -> (([SEDEL.Source.Syntax.SDecl] -> [SEDEL.Source.Syntax.SDecl])
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b)
       -> (Text.Megaparsec.Error.ParseError
             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Data.Functor.Identity.Identity b)
       -> (([SEDEL.Source.Syntax.SDecl] -> [SEDEL.Source.Syntax.SDecl])
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 9,
     Strictness: <L,U><L,U><L,U(U,U,U)><L,U><S,U><L,U(U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))>,
     Inline: [0] -}
2e49df110e517f9f9c4a84c193716f9a
  $wk ::
    GHC.Integer.Type.Integer
    -> forall b.
       [GHC.Types.Char]
       -> Text.Megaparsec.Pos.SourcePos
       -> [Text.Megaparsec.Pos.SourcePos]
       -> GHC.Prim.Int#
       -> Text.Megaparsec.Pos.Pos
       -> (Data.Scientific.Scientific
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b)
       -> (Data.Scientific.Scientific
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 8,
     Strictness: <L,U><S,U><L,U(U,U,U)><L,U><S,U><L,U(U)><L,C(C1(C1(U)))><L,C(C1(C1(U)))>,
     Inline: [0] -}
a9f54a5855a000f0a5fff83762505611
  $wk1 ::
    [SEDEL.Source.Syntax.SDecl]
    -> forall b.
       [GHC.Types.Char]
       -> Text.Megaparsec.Pos.SourcePos
       -> [Text.Megaparsec.Pos.SourcePos]
       -> GHC.Prim.Int#
       -> Text.Megaparsec.Pos.Pos
       -> (SEDEL.Source.Syntax.Module
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b)
       -> (Text.Megaparsec.Error.ParseError
             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Data.Functor.Identity.Identity b)
       -> (SEDEL.Source.Syntax.Module
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 9,
     Strictness: <L,U><L,U><L,U(U,U,U)><L,U><S,U><L,U(U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))>,
     Inline: [0] -}
2f84131c309753b68356760456f8cfd7
  $wlvl ::
    [GHC.Types.Char]
    -> Text.Megaparsec.Pos.SourcePos
    -> [Text.Megaparsec.Pos.SourcePos]
    -> GHC.Prim.Int#
    -> Text.Megaparsec.Pos.Pos
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 7, HasNoCafRefs,
     Strictness: <S,1*U><L,U(U,U,U)><L,U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(C1(U))>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [GHC.Types.Char])
                   (ww1 :: Text.Megaparsec.Pos.SourcePos)
                   (ww2 :: [Text.Megaparsec.Pos.SourcePos])
                   (ww3 :: GHC.Prim.Int#)
                   (ww4 :: Text.Megaparsec.Pos.Pos)
                   (w :: ()
                         -> Text.Megaparsec.State.State [GHC.Types.Char]
                         -> Text.Megaparsec.Internal.Hints
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   []
                   -> w GHC.Tuple.()
                        (Text.Megaparsec.State.State
                           @ [GHC.Types.Char]
                           (GHC.Types.[] @ GHC.Types.Char)
                           (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos ww1 ww2)
                           ww3
                           ww4)
                        (GHC.Types.[]
                           @ (Data.Set.Internal.Set
                                (Text.Megaparsec.Error.ErrorItem
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                          `cast`
                        (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                  <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                   : t ts
                   -> case ww1 of apos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                      w1
                        (Text.Megaparsec.Error.TrivialError
                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           @ Data.Void.Void
                           (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos apos ww2)
                           (GHC.Base.Just
                              @ (Text.Megaparsec.Error.ErrorItem
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              (Text.Megaparsec.Error.Tokens
                                 @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                 (Text.Megaparsec.Internal.nes
                                    @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                    t `cast` (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))))))
                           SEDEL.Parser.Parser.parseModule8)
                        (Text.Megaparsec.State.State
                           @ [GHC.Types.Char]
                           wild
                           (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos apos ww2)
                           ww3
                           ww4) } }) -}
0d950ec3460e5bfbfdeae5cde6a5368d
  $wlvl1 ::
    Text.Megaparsec.State.State [GHC.Types.Char]
    -> (SEDEL.Source.Syntax.Module
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> (SEDEL.Source.Syntax.Module
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 4,
     Strictness: <L,U(U,U(U(U,U,U),U),U,U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))>,
     Inline: [0],
     Unfolding: (\ @ b1
                   (w :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (w1 :: SEDEL.Source.Syntax.Module
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b1)
                   (w2 :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b1)
                   (w3 :: SEDEL.Source.Syntax.Module
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b1) ->
                 SEDEL.Parser.Parser.$w$sspace
                   SEDEL.Parser.Parser.parseModule18
                     `cast`
                   (Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                             <Data.Void.Void>_N
                             <[GHC.Types.Char]>_N
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))
                   SEDEL.Parser.Parser.parseModule15
                     `cast`
                   (Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                             <Data.Void.Void>_N
                             <[GHC.Types.Char]>_N
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))
                   SEDEL.Parser.Parser.parseModule10
                     `cast`
                   (Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                             <Data.Void.Void>_N
                             <[GHC.Types.Char]>_N
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))
                   @ b1
                   w
                   (\ (x23 :: ())
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])[OneShot]
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))[OneShot] ->
                    case s' of ww { Text.Megaparsec.State.State ww1 ww2 ww3 ww4 ->
                    case ww2 of ww5 { GHC.Base.:| ww6 ww7 ->
                    SEDEL.Parser.Parser.$wprog
                      @ b1
                      ww1
                      ww6
                      ww7
                      ww3
                      ww4
                      w1
                      w2
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ SEDEL.Source.Syntax.Module
                         @ [GHC.Types.Char]
                         @ Data.Functor.Identity.Identity
                         @ b1
                         hs
                         w1) } })
                   w2
                   (\ (x23 :: ())
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])[OneShot]
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))[OneShot] ->
                    case s' of ww { Text.Megaparsec.State.State ww1 ww2 ww3 ww4 ->
                    case ww2 of ww5 { GHC.Base.:| ww6 ww7 ->
                    SEDEL.Parser.Parser.$wprog
                      @ b1
                      ww1
                      ww6
                      ww7
                      ww3
                      ww4
                      w1
                      w2
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ SEDEL.Source.Syntax.Module
                         @ [GHC.Types.Char]
                         @ Data.Functor.Identity.Identity
                         @ b1
                         hs
                         w3) } })) -}
634159ec92c45333e1cc9ae925cb7772
  $wprog ::
    [GHC.Types.Char]
    -> Text.Megaparsec.Pos.SourcePos
    -> [Text.Megaparsec.Pos.SourcePos]
    -> GHC.Prim.Int#
    -> Text.Megaparsec.Pos.Pos
    -> (SEDEL.Source.Syntax.Module
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> (SEDEL.Source.Syntax.Module
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 8,
     Strictness: <L,U><L,U(U,U,U)><L,U><S,U><L,U(U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))>,
     Inline: [0],
     Unfolding: (\ @ b1
                   (ww :: [GHC.Types.Char])
                   (ww1 :: Text.Megaparsec.Pos.SourcePos)
                   (ww2 :: [Text.Megaparsec.Pos.SourcePos])
                   (ww3 :: GHC.Prim.Int#)
                   (ww4 :: Text.Megaparsec.Pos.Pos)
                   (w :: SEDEL.Source.Syntax.Module
                         -> Text.Megaparsec.State.State [GHC.Types.Char]
                         -> Text.Megaparsec.Internal.Hints
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         -> Data.Functor.Identity.Identity b1)
                   (w1 :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b1)
                   (w2 :: SEDEL.Source.Syntax.Module
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b1) ->
                 SEDEL.Parser.Parser.$wgo
                   (GHC.Base.id @ [SEDEL.Source.Syntax.SDecl])
                   @ b1
                   ww
                   ww1
                   ww2
                   ww3
                   ww4
                   (\ (x23 :: [SEDEL.Source.Syntax.SDecl]
                              -> [SEDEL.Source.Syntax.SDecl])
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])[OneShot]
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))[OneShot] ->
                    case s' of ww5 { Text.Megaparsec.State.State ww6 ww7 ww8 ww9 ->
                    case ww7 of ww10 { GHC.Base.:| ww11 ww12 ->
                    SEDEL.Parser.Parser.$wk1
                      (x23 (GHC.Types.[] @ SEDEL.Source.Syntax.SDecl))
                      @ b1
                      ww6
                      ww11
                      ww12
                      ww8
                      ww9
                      w
                      w1
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ SEDEL.Source.Syntax.Module
                         @ [GHC.Types.Char]
                         @ Data.Functor.Identity.Identity
                         @ b1
                         hs
                         w) } })
                   w1
                   (\ (x23 :: [SEDEL.Source.Syntax.SDecl]
                              -> [SEDEL.Source.Syntax.SDecl])
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])[OneShot]
                      (hs :: Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))[OneShot] ->
                    case s' of ww5 { Text.Megaparsec.State.State ww6 ww7 ww8 ww9 ->
                    case ww7 of ww10 { GHC.Base.:| ww11 ww12 ->
                    SEDEL.Parser.Parser.$wk1
                      (x23 (GHC.Types.[] @ SEDEL.Source.Syntax.SDecl))
                      @ b1
                      ww6
                      ww11
                      ww12
                      ww8
                      ww9
                      w
                      w1
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ SEDEL.Source.Syntax.Module
                         @ [GHC.Types.Char]
                         @ Data.Functor.Identity.Identity
                         @ b1
                         hs
                         w2) } })) -}
c57933f91ad2002634a65d1cc48f76fe
  $wsc ::
    [GHC.Types.Char]
    -> GHC.IO.FilePath
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> [Text.Megaparsec.Pos.SourcePos]
    -> GHC.Prim.Int#
    -> Text.Megaparsec.Pos.Pos
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 9,
     Strictness: <S,U><L,U><L,U><L,U><L,U><L,U><L,U(U)><L,1*C1(C1(C1(U)))><L,1*C1(C1(U))>,
     Inline: [0],
     Unfolding: (\ @ b1
                   (ww :: [GHC.Types.Char])
                   (ww1 :: GHC.IO.FilePath)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#)
                   (ww4 :: [Text.Megaparsec.Pos.SourcePos])
                   (ww5 :: GHC.Prim.Int#)
                   (ww6 :: Text.Megaparsec.Pos.Pos)
                   (w :: ()
                         -> Text.Megaparsec.State.State [GHC.Types.Char]
                         -> Text.Megaparsec.Internal.Hints
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         -> Data.Functor.Identity.Identity b1)
                   (w1 :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b1) ->
                 case GHC.List.$wspan
                        @ GHC.Types.Char
                        GHC.Unicode.isSpace
                        ww of ww7 { (#,#) ww8 ww9 ->
                 case ww8 of wild {
                   []
                   -> let {
                        ds3 :: Text.Megaparsec.Pos.SourcePos
                        = Text.Megaparsec.Pos.SourcePos ww1 ww2 ww3
                      } in
                      w1
                        (Text.Megaparsec.Error.TrivialError
                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           @ Data.Void.Void
                           (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos ds3 ww4)
                           (GHC.Base.Just
                              @ (Text.Megaparsec.Error.ErrorItem
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              (case ww of wild1 {
                                 []
                                 -> Text.Megaparsec.Error.EndOfInput
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                 : t ts
                                 -> Text.Megaparsec.Error.Tokens
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                      (Text.Megaparsec.Internal.nes
                                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                         t `cast`
                                         (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))) }))
                           SEDEL.Parser.Parser.parseModule20)
                        (Text.Megaparsec.State.State
                           @ [GHC.Types.Char]
                           ww
                           (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos ds3 ww4)
                           ww5
                           ww6)
                   : ds1 ds2
                   -> case Text.Megaparsec.Stream.$w$cadvanceN4
                             (Data.Proxy.Proxy @ * @ GHC.Base.String)
                             ww6
                             ww1
                             ww2
                             ww3
                             wild
                               `cast`
                             (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0]))) of ww10 { (#,,#) ww11 ww12 ww13 ->
                      w GHC.Tuple.()
                        (case GHC.List.$wlenAcc
                                @ GHC.Types.Char
                                wild
                                0# of ww14 { DEFAULT ->
                         Text.Megaparsec.State.State
                           @ [GHC.Types.Char]
                           ww9
                           (GHC.Base.:|
                              @ Text.Megaparsec.Pos.SourcePos
                              (Text.Megaparsec.Pos.SourcePos ww11 ww12 ww13)
                              ww4)
                           (GHC.Prim.+# ww5 ww14)
                           ww6 })
                        SEDEL.Parser.Parser.parseModule19
                          `cast`
                        (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                  <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)) } } }) -}
9b69b765ed8ff79a1aefc39a590f453e
  type Parser =
    Text.Megaparsec.Parsec Data.Void.Void GHC.Base.String :: * -> *
f4d149547bded9d007f88645bf9b6c6e
  parseModule ::
    GHC.Base.String
    -> Data.Either.Either GHC.Base.String SEDEL.Source.Syntax.Module
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (s :: GHC.Base.String) ->
                 case (Text.Megaparsec.Internal.$fApplicativeParsecT1
                         @ [GHC.Types.Char]
                         @ Data.Void.Void
                         @ Data.Functor.Identity.Identity
                         Text.Megaparsec.Stream.$fStream[]
                         @ SEDEL.Source.Syntax.Module
                         @ ()
                         SEDEL.Parser.Parser.parseModule9
                           `cast`
                         (Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                                   <Data.Void.Void>_N
                                   <[GHC.Types.Char]>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <SEDEL.Source.Syntax.Module>_R))
                         SEDEL.Parser.Parser.parseModule7
                           `cast`
                         (Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                                   <Data.Void.Void>_N
                                   <[GHC.Types.Char]>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <()>_R))
                         @ (Text.Megaparsec.Internal.Reply
                              Data.Void.Void GHC.Base.String SEDEL.Source.Syntax.Module)
                         (Text.Megaparsec.State.State
                            @ GHC.Base.String
                            s
                            SEDEL.Parser.Parser.parseModule5
                            0#
                            Text.Megaparsec.Pos.defaultTabWidth_a
                              `cast`
                            (Sym (Text.Megaparsec.Pos.N:Pos[0])))
                         SEDEL.Parser.Parser.parseModule4
                           `cast`
                         (<SEDEL.Source.Syntax.Module>_R
                          ->_R <Text.Megaparsec.State.State GHC.Base.String>_R
                          ->_R <Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token GHC.Base.String)>_R
                          ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                        <Text.Megaparsec.Internal.Reply
                                           Data.Void.Void
                                           GHC.Base.String
                                           SEDEL.Source.Syntax.Module>_R))
                         SEDEL.Parser.Parser.parseModule3
                           `cast`
                         (<Text.Megaparsec.Error.ParseError
                             (Text.Megaparsec.Stream.Token GHC.Base.String) Data.Void.Void>_R
                          ->_R <Text.Megaparsec.State.State GHC.Base.String>_R
                          ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                        <Text.Megaparsec.Internal.Reply
                                           Data.Void.Void
                                           GHC.Base.String
                                           SEDEL.Source.Syntax.Module>_R))
                         SEDEL.Parser.Parser.parseModule2
                           `cast`
                         (<SEDEL.Source.Syntax.Module>_R
                          ->_R <Text.Megaparsec.State.State GHC.Base.String>_R
                          ->_R <Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token GHC.Base.String)>_R
                          ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                        <Text.Megaparsec.Internal.Reply
                                           Data.Void.Void
                                           GHC.Base.String
                                           SEDEL.Source.Syntax.Module>_R))
                         SEDEL.Parser.Parser.parseModule1
                           `cast`
                         (<Text.Megaparsec.Error.ParseError
                             (Text.Megaparsec.Stream.Token GHC.Base.String) Data.Void.Void>_R
                          ->_R <Text.Megaparsec.State.State GHC.Base.String>_R
                          ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                        <Text.Megaparsec.Internal.Reply
                                           Data.Void.Void
                                           GHC.Base.String
                                           SEDEL.Source.Syntax.Module>_R)))
                        `cast`
                      (Data.Functor.Identity.N:Identity[0]
                           <Text.Megaparsec.Internal.Reply
                              Data.Void.Void
                              GHC.Base.String
                              SEDEL.Source.Syntax.Module>_R) of wild { Text.Megaparsec.Internal.Reply s' ds result ->
                 case result of wild1 {
                   Text.Megaparsec.Internal.OK x23
                   -> Data.Either.Right
                        @ GHC.Base.String
                        @ SEDEL.Source.Syntax.Module
                        x23
                   Text.Megaparsec.Internal.Error e1
                   -> Data.Either.Left
                        @ GHC.Base.String
                        @ SEDEL.Source.Syntax.Module
                        (Text.Megaparsec.Error.parseErrorPretty
                           @ GHC.Types.Char
                           @ Data.Void.Void
                           GHC.Classes.$fOrdChar
                           Text.Megaparsec.Error.stringPretty
                             `cast`
                           (Sym (Text.Megaparsec.Error.N:ShowToken[0] <GHC.Types.Char>_N))
                           Text.Megaparsec.Error.$fShowErrorComponentVoid
                           e1
                             `cast`
                           (Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.D:R:Token[][0])
                              <Data.Void.Void>_N)_R) } }) -}
86a86f12b1823029d27633dcb1fc7327
  parseModule1 ::
    Text.Megaparsec.Error.ParseError
      (Text.Megaparsec.Stream.Token GHC.Base.String) Data.Void.Void
    -> Text.Megaparsec.State.State GHC.Base.String
    -> Text.Megaparsec.Internal.Reply
         Data.Void.Void GHC.Base.String SEDEL.Source.Syntax.Module
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m,
     Unfolding: (\ (err :: Text.Megaparsec.Error.ParseError
                             (Text.Megaparsec.Stream.Token GHC.Base.String) Data.Void.Void)
                   (s' :: Text.Megaparsec.State.State GHC.Base.String) ->
                 Text.Megaparsec.Internal.Reply
                   @ Data.Void.Void
                   @ GHC.Base.String
                   @ SEDEL.Source.Syntax.Module
                   s'
                   Text.Megaparsec.Internal.Virgin
                   (Text.Megaparsec.Internal.Error
                      @ (Text.Megaparsec.Stream.Token GHC.Base.String)
                      @ Data.Void.Void
                      @ SEDEL.Source.Syntax.Module
                      err)) -}
e46444334679471d9d1816521dedbec1
  parseModule10 ::
    Text.Megaparsec.State.State [GHC.Types.Char]
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b)
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Unfolding: (SEDEL.Parser.Parser.$sskipBlockComment1
                   SEDEL.Parser.Parser.parseModule13
                     `cast`
                   (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))
                   SEDEL.Parser.Parser.parseModule11
                     `cast`
                   (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))) -}
ae235dd673ad17ec0ed7f6c1f53f23d0
  parseModule11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   SEDEL.Parser.Parser.parseModule12) -}
31d757c48fb9affac74ed32744b0d32f
  parseModule12 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("-}"#) -}
fd6c03d78f9bccf8970685b066fa2c20
  parseModule13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   SEDEL.Parser.Parser.parseModule14) -}
5a6056b93c996b15b6c4fb192042bc14
  parseModule14 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("{-"#) -}
acb07aa4019ebd5c619447e9a6354754
  parseModule15 ::
    Text.Megaparsec.State.State [GHC.Types.Char]
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <S(LSSL),1*U(U,1*U(U(U,U,U),U),U,U(U))><L,C(C1(C1(U)))><L,A><L,1*C1(C1(C1(U)))><L,1*C1(C1(U))>,
     Unfolding: (\ @ b1
                   (w :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (w1 :: ()
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b1)
                   (w2 :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b1)
                   (w3 :: ()
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b1)
                   (w4 :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b1) ->
                 case w of ww { Text.Megaparsec.State.State ww1 ww2 ww3 ww4 ->
                 case ww2 of ww5 { GHC.Base.:| ww6 ww7 ->
                 SEDEL.Parser.Parser.$w$sskipLineComment
                   SEDEL.Parser.Parser.parseModule16
                     `cast`
                   (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))
                   @ b1
                   ww1
                   ww6
                   ww7
                   ww3
                   ww4
                   w1
                   w3
                   w4 } }) -}
890e2838be3a2d4e9d1aa897dd486b67
  parseModule16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   SEDEL.Parser.Parser.parseModule17) -}
cd4a1112b2c0dc019c14d806ac20febc
  parseModule17 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("--"#) -}
f52a03c1b18f6a2663ec63fe9a76b044
  parseModule18 ::
    Text.Megaparsec.State.State [GHC.Types.Char]
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <S(SS(S(LSS)L)SL),1*U(U,1*U(1*U(U,U,U),U),U,U(U))><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(C1(U))>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   (w :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (w1 :: ()
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b1)
                   (w2 :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b1)
                   (w3 :: ()
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b1)
                   (w4 :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b1) ->
                 case w of ww { Text.Megaparsec.State.State ww1 ww2 ww3 ww4 ->
                 case ww2 of ww5 { GHC.Base.:| ww6 ww7 ->
                 case ww6 of ww8 { Text.Megaparsec.Pos.SourcePos ww9 ww10 ww11 ->
                 SEDEL.Parser.Parser.$wsc
                   @ b1
                   ww1
                   ww9
                   ww10
                   ww11
                   ww7
                   ww3
                   ww4
                   w1
                   w4 } } }) -}
de5d2b6b4bea8d5b3924e81a92dc6c30
  parseModule19 ::
    [Data.Set.Internal.Set
       (Text.Megaparsec.Error.ErrorItem
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]))]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Data.Set.Internal.Set
                        (Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                   SEDEL.Parser.Parser.parseModule20
                   (GHC.Types.[]
                      @ (Data.Set.Internal.Set
                           (Text.Megaparsec.Error.ErrorItem
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))) -}
f60ef3baff134ea2aa88b7d409e26b51
  parseModule2 ::
    SEDEL.Source.Syntax.Module
    -> Text.Megaparsec.State.State GHC.Base.String
    -> Text.Megaparsec.Internal.Hints
         (Text.Megaparsec.Stream.Token GHC.Base.String)
    -> Text.Megaparsec.Internal.Reply
         Data.Void.Void GHC.Base.String SEDEL.Source.Syntax.Module
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,A>m,
     Unfolding: (\ (a1 :: SEDEL.Source.Syntax.Module)
                   (s' :: Text.Megaparsec.State.State GHC.Base.String)[OneShot]
                   (ds :: Text.Megaparsec.Internal.Hints
                            (Text.Megaparsec.Stream.Token GHC.Base.String))[OneShot] ->
                 Text.Megaparsec.Internal.Reply
                   @ Data.Void.Void
                   @ GHC.Base.String
                   @ SEDEL.Source.Syntax.Module
                   s'
                   Text.Megaparsec.Internal.Virgin
                   (Text.Megaparsec.Internal.OK
                      @ (Text.Megaparsec.Stream.Token GHC.Base.String)
                      @ Data.Void.Void
                      @ SEDEL.Source.Syntax.Module
                      a1)) -}
5ac91a64481cdd4cc2782614f5b93bea
  parseModule20 ::
    Data.Set.Internal.Set
      (Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
  {- Strictness: m1,
     Unfolding: (Data.Set.Internal.Bin
                   @ (Text.Megaparsec.Error.ErrorItem
                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   1#
                   SEDEL.Parser.Parser.parseModule21
                   (Data.Set.Internal.Tip
                      @ (Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                   (Data.Set.Internal.Tip
                      @ (Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])))) -}
beb0b09dd1d66261cec2f26aabd3d690
  parseModule21 ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
  {- Strictness: m2,
     Unfolding: (Text.Megaparsec.Error.Label
                   @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                   SEDEL.Parser.Parser.parseModule22) -}
af6e35417160783b929fb0b99f925579
  parseModule22 :: GHC.Base.NonEmpty GHC.Types.Char
  {- Strictness: m,
     Unfolding: (GHC.Base.:|
                   @ GHC.Types.Char
                   SEDEL.Parser.Parser.parseModule25
                   SEDEL.Parser.Parser.parseModule23) -}
605b65e98c12193bd0c4f89b169efa32
  parseModule23 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   SEDEL.Parser.Parser.parseModule24) -}
e525eb5fbc6e3f7ab587b308fdcc5536
  parseModule24 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("hite space"#) -}
e97e2685c12089b1f1b1fa287e5b2306
  parseModule25 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'w'#) -}
481f98e8e8c4f9aac77cda311fef9b48
  parseModule3 ::
    Text.Megaparsec.Error.ParseError
      (Text.Megaparsec.Stream.Token GHC.Base.String) Data.Void.Void
    -> Text.Megaparsec.State.State GHC.Base.String
    -> Text.Megaparsec.Internal.Reply
         Data.Void.Void GHC.Base.String SEDEL.Source.Syntax.Module
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m,
     Unfolding: (\ (err :: Text.Megaparsec.Error.ParseError
                             (Text.Megaparsec.Stream.Token GHC.Base.String) Data.Void.Void)
                   (s' :: Text.Megaparsec.State.State GHC.Base.String) ->
                 Text.Megaparsec.Internal.Reply
                   @ Data.Void.Void
                   @ GHC.Base.String
                   @ SEDEL.Source.Syntax.Module
                   s'
                   Text.Megaparsec.Internal.Consumed
                   (Text.Megaparsec.Internal.Error
                      @ (Text.Megaparsec.Stream.Token GHC.Base.String)
                      @ Data.Void.Void
                      @ SEDEL.Source.Syntax.Module
                      err)) -}
5bbc5323051c615e3c7983f458b3feb4
  parseModule4 ::
    SEDEL.Source.Syntax.Module
    -> Text.Megaparsec.State.State GHC.Base.String
    -> Text.Megaparsec.Internal.Hints
         (Text.Megaparsec.Stream.Token GHC.Base.String)
    -> Text.Megaparsec.Internal.Reply
         Data.Void.Void GHC.Base.String SEDEL.Source.Syntax.Module
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,A>m,
     Unfolding: (\ (a1 :: SEDEL.Source.Syntax.Module)
                   (s' :: Text.Megaparsec.State.State GHC.Base.String)[OneShot]
                   (ds :: Text.Megaparsec.Internal.Hints
                            (Text.Megaparsec.Stream.Token GHC.Base.String))[OneShot] ->
                 Text.Megaparsec.Internal.Reply
                   @ Data.Void.Void
                   @ GHC.Base.String
                   @ SEDEL.Source.Syntax.Module
                   s'
                   Text.Megaparsec.Internal.Consumed
                   (Text.Megaparsec.Internal.OK
                      @ (Text.Megaparsec.Stream.Token GHC.Base.String)
                      @ Data.Void.Void
                      @ SEDEL.Source.Syntax.Module
                      a1)) -}
02eec6df2b7a00db2b65d60e99fd5cf1
  parseModule5 :: GHC.Base.NonEmpty Text.Megaparsec.Pos.SourcePos
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Base.:|
                   @ Text.Megaparsec.Pos.SourcePos
                   SEDEL.Parser.Parser.parseModule6
                   (GHC.Types.[] @ Text.Megaparsec.Pos.SourcePos)) -}
7ed2bb81137961339b3647fefafdd704
  parseModule6 :: Text.Megaparsec.Pos.SourcePos
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Text.Megaparsec.Pos.SourcePos
                   (GHC.Types.[] @ GHC.Types.Char)
                   1#
                   1#) -}
8b2cc13390573b383d22f1ad818ff6b5
  parseModule7 ::
    Text.Megaparsec.State.State [GHC.Types.Char]
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b)
    -> (()
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(SSSL),1*U(1*U,1*U(U(U,U,U),U),U,U)><L,A><L,A><L,1*C1(C1(C1(U)))><L,1*C1(C1(U))>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (w1 :: ()
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: ()
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Megaparsec.State.State ww1 ww2 ww3 ww4 ->
                 case ww2 of ww5 { GHC.Base.:| ww6 ww7 ->
                 SEDEL.Parser.Parser.$wlvl @ b ww1 ww6 ww7 ww3 ww4 w3 w4 } }) -}
1c96aa1831e6903d38c82200927d3a6f
  parseModule8 ::
    Data.Set.Internal.Set
      (Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Data.Set.Internal.Bin
                   @ (Text.Megaparsec.Error.ErrorItem
                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   1#
                   (Text.Megaparsec.Error.EndOfInput
                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (Data.Set.Internal.Tip
                      @ (Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                   (Data.Set.Internal.Tip
                      @ (Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])))) -}
f47337020b6c70ad62d4b31356166fb0
  parseModule9 ::
    Text.Megaparsec.State.State [GHC.Types.Char]
    -> (SEDEL.Source.Syntax.Module
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> (SEDEL.Source.Syntax.Module
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U(U,U(U(U,U,U),U),U,U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,A>,
     Inline: [0],
     Unfolding: InlineRule (5, True, True)
                (\ @ b1
                   (w :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (w1 :: SEDEL.Source.Syntax.Module
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b1)
                   (w2 :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b1)
                   (w3 :: SEDEL.Source.Syntax.Module
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> Data.Functor.Identity.Identity b1)
                   (w4 :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Data.Functor.Identity.Identity b1) ->
                 SEDEL.Parser.Parser.$wlvl1 @ b1 w w1 w2 w3) -}
"SPEC/SEDEL.Parser.Parser $fAlternativeParsecT @ Void @ [Char] _" [orphan] forall @ m :: *
                                                                                         -> *
                                                                                  (v1 :: Text.Megaparsec.Stream.Stream
                                                                                           [GHC.Types.Char])
                                                                                  (v :: GHC.Classes.Ord
                                                                                          Data.Void.Void)
  Text.Megaparsec.Internal.$fAlternativeParsecT @ Data.Void.Void
                                                @ [GHC.Types.Char]
                                                @ m
                                                v
                                                v1
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT @ m
"SPEC/SEDEL.Parser.Parser $fAlternativeParsecT1 @ Void @ [Char] _" [orphan] [0] forall @ m :: *
                                                                                              -> *
                                                                                       (w1 :: Text.Megaparsec.Stream.Stream
                                                                                                [GHC.Types.Char])
                                                                                       (w :: GHC.Classes.Ord
                                                                                               Data.Void.Void)
  Text.Megaparsec.Internal.$fAlternativeParsecT1 @ Data.Void.Void
                                                 @ [GHC.Types.Char]
                                                 @ m
                                                 w
                                                 w1
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT1 @ m
"SPEC/SEDEL.Parser.Parser $fAlternativeParsecT3 @ Void @ [Char] _" [orphan] [0] forall @ m :: *
                                                                                              -> *
                                                                                       (w1 :: Text.Megaparsec.Stream.Stream
                                                                                                [GHC.Types.Char])
                                                                                       (w :: GHC.Classes.Ord
                                                                                               Data.Void.Void)
  Text.Megaparsec.Internal.$fAlternativeParsecT3 @ Data.Void.Void
                                                 @ [GHC.Types.Char]
                                                 @ m
                                                 w
                                                 w1
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT3 @ m
"SPEC/SEDEL.Parser.Parser $fApplicativeParsecT @ [Char] _ _" [orphan] forall @ e
                                                                             @ m :: * -> *
                                                                             (v :: Text.Megaparsec.Stream.Stream
                                                                                     [GHC.Types.Char])
  Text.Megaparsec.Internal.$fApplicativeParsecT @ [GHC.Types.Char]
                                                @ e
                                                @ m
                                                v
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT_$s$fApplicativeParsecT
      @ e
      @ m
"SPEC/SEDEL.Parser.Parser $fEqErrorFancy @ Void" [orphan] forall (v :: GHC.Classes.Eq
                                                                         Data.Void.Void)
  Text.Megaparsec.Error.$fEqErrorFancy @ Data.Void.Void v
  = SEDEL.Parser.Parser.$s$fEqErrorFancy
"SPEC/SEDEL.Parser.Parser $fEqErrorFancy_$c/= @ Void" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                                 Data.Void.Void)
  Text.Megaparsec.Error.$fEqErrorFancy_$c/= @ Data.Void.Void $dEq
  = SEDEL.Parser.Parser.$s$fEqErrorFancy_$s$fEqErrorFancy_$c/=
"SPEC/SEDEL.Parser.Parser $fEqErrorItem @ (Token [Char])" [orphan] forall (v :: GHC.Classes.Eq
                                                                                  (Text.Megaparsec.Stream.Token
                                                                                     [GHC.Types.Char]))
  Text.Megaparsec.Error.$fEqErrorItem @ (Text.Megaparsec.Stream.Token
                                           [GHC.Types.Char])
                                      v
  = SEDEL.Parser.Parser.$s$fEqErrorItem
"SPEC/SEDEL.Parser.Parser $fEqErrorItem_$c/= @ (Token [Char])" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                                          (Text.Megaparsec.Stream.Token
                                                                                             [GHC.Types.Char]))
  Text.Megaparsec.Error.$fEqErrorItem_$c/= @ (Text.Megaparsec.Stream.Token
                                                [GHC.Types.Char])
                                           $dEq
  = SEDEL.Parser.Parser.$s$fEqErrorItem_$s$fEqErrorItem_$c/=
"SPEC/SEDEL.Parser.Parser $fMonadParsecT @ [Char] _ _" [orphan] forall @ e
                                                                       @ m :: * -> *
                                                                       (v :: Text.Megaparsec.Stream.Stream
                                                                               [GHC.Types.Char])
  Text.Megaparsec.Internal.$fMonadParsecT @ [GHC.Types.Char]
                                          @ e
                                          @ m
                                          v
  = SEDEL.Parser.Parser.$s$fMonadParsecT @ e @ m
"SPEC/SEDEL.Parser.Parser $fMonadParsecT_$c>> @ [Char] _ _" [orphan] forall @ e
                                                                            @ m :: * -> *
                                                                            ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                           [GHC.Types.Char])
  Text.Megaparsec.Internal.$fMonadParsecT_$c>> @ [GHC.Types.Char]
                                               @ e
                                               @ m
                                               $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecT_$s$fMonadParsecT_$c>>
      @ e
      @ m
"SPEC/SEDEL.Parser.Parser $fMonadParsecesParsecT @ Void @ [Char] _" [orphan] forall @ m :: *
                                                                                           -> *
                                                                                    (v1 :: Text.Megaparsec.Stream.Stream
                                                                                             [GHC.Types.Char])
                                                                                    (v :: GHC.Classes.Ord
                                                                                            Data.Void.Void)
  Text.Megaparsec.Internal.$fMonadParsecesParsecT @ Data.Void.Void
                                                  @ [GHC.Types.Char]
                                                  @ m
                                                  v
                                                  v1
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT @ m
"SPEC/SEDEL.Parser.Parser $fMonadPlusParsecT @ Void @ [Char] _" [orphan] forall @ m :: *
                                                                                       -> *
                                                                                (v1 :: Text.Megaparsec.Stream.Stream
                                                                                         [GHC.Types.Char])
                                                                                (v :: GHC.Classes.Ord
                                                                                        Data.Void.Void)
  Text.Megaparsec.Internal.$fMonadPlusParsecT @ Data.Void.Void
                                              @ [GHC.Types.Char]
                                              @ m
                                              v
                                              v1
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$s$fMonadPlusParsecT
      @ m
"SPEC/SEDEL.Parser.Parser $fOrdErrorFancy @ Void" [orphan] forall (v :: GHC.Classes.Ord
                                                                          Data.Void.Void)
  Text.Megaparsec.Error.$fOrdErrorFancy @ Data.Void.Void v
  = SEDEL.Parser.Parser.$s$fOrdErrorFancy
"SPEC/SEDEL.Parser.Parser $fOrdErrorFancy_$c<= @ Void" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                   Data.Void.Void)
  Text.Megaparsec.Error.$fOrdErrorFancy_$c<= @ Data.Void.Void $dOrd
  = SEDEL.Parser.Parser.$s$fOrdErrorFancy_$c<=
"SPEC/SEDEL.Parser.Parser $fOrdErrorFancy_$c>= @ Void" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                   Data.Void.Void)
  Text.Megaparsec.Error.$fOrdErrorFancy_$c>= @ Data.Void.Void $dOrd
  = SEDEL.Parser.Parser.$s$fOrdErrorFancy_$c>=
"SPEC/SEDEL.Parser.Parser $fOrdErrorFancy_$cmax @ Void" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                    Data.Void.Void)
  Text.Megaparsec.Error.$fOrdErrorFancy_$cmax @ Data.Void.Void $dOrd
  = SEDEL.Parser.Parser.$s$fOrdErrorFancy_$cmax
"SPEC/SEDEL.Parser.Parser $fOrdErrorFancy_$cmin @ Void" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                    Data.Void.Void)
  Text.Megaparsec.Error.$fOrdErrorFancy_$cmin @ Data.Void.Void $dOrd
  = SEDEL.Parser.Parser.$s$fOrdErrorFancy_$cmin
"SPEC/SEDEL.Parser.Parser $fOrdErrorItem @ (Token [Char])" [orphan] forall (v :: GHC.Classes.Ord
                                                                                   (Text.Megaparsec.Stream.Token
                                                                                      [GHC.Types.Char]))
  Text.Megaparsec.Error.$fOrdErrorItem @ (Text.Megaparsec.Stream.Token
                                            [GHC.Types.Char])
                                       v
  = SEDEL.Parser.Parser.$s$fOrdErrorItem
"SPEC/SEDEL.Parser.Parser $fOrdErrorItem_$c<= @ (Token [Char])" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                            (Text.Megaparsec.Stream.Token
                                                                                               [GHC.Types.Char]))
  Text.Megaparsec.Error.$fOrdErrorItem_$c<= @ (Text.Megaparsec.Stream.Token
                                                 [GHC.Types.Char])
                                            $dOrd
  = SEDEL.Parser.Parser.$s$fOrdErrorItem_$c<=
"SPEC/SEDEL.Parser.Parser $fOrdErrorItem_$c>= @ (Token [Char])" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                            (Text.Megaparsec.Stream.Token
                                                                                               [GHC.Types.Char]))
  Text.Megaparsec.Error.$fOrdErrorItem_$c>= @ (Text.Megaparsec.Stream.Token
                                                 [GHC.Types.Char])
                                            $dOrd
  = SEDEL.Parser.Parser.$s$fOrdErrorItem_$c>=
"SPEC/SEDEL.Parser.Parser $fOrdErrorItem_$cmax @ (Token [Char])" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                             (Text.Megaparsec.Stream.Token
                                                                                                [GHC.Types.Char]))
  Text.Megaparsec.Error.$fOrdErrorItem_$cmax @ (Text.Megaparsec.Stream.Token
                                                  [GHC.Types.Char])
                                             $dOrd
  = SEDEL.Parser.Parser.$s$fOrdErrorItem_$cmax
"SPEC/SEDEL.Parser.Parser $fOrdErrorItem_$cmin @ (Token [Char])" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                             (Text.Megaparsec.Stream.Token
                                                                                                [GHC.Types.Char]))
  Text.Megaparsec.Error.$fOrdErrorItem_$cmin @ (Text.Megaparsec.Stream.Token
                                                  [GHC.Types.Char])
                                             $dOrd
  = SEDEL.Parser.Parser.$s$fOrdErrorItem_$cmin
"SPEC/SEDEL.Parser.Parser pAp @ [Char] _ _ _ _" [orphan] forall @ e
                                                                @ m :: * -> *
                                                                @ a
                                                                @ b
                                                                ($dStream :: Text.Megaparsec.Stream.Stream
                                                                               [GHC.Types.Char])
  Text.Megaparsec.Internal.pAp @ [GHC.Types.Char]
                               @ e
                               @ m
                               @ a
                               @ b
                               $dStream
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT_$spAp @ e @ m @ a @ b
"SPEC/SEDEL.Parser.Parser pBind @ [Char] _ _ _ _" [orphan] forall @ e
                                                                  @ m :: * -> *
                                                                  @ a
                                                                  @ b
                                                                  ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                 [GHC.Types.Char])
  Text.Megaparsec.Internal.pBind @ [GHC.Types.Char]
                                 @ e
                                 @ m
                                 @ a
                                 @ b
                                 $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecT_$spBind @ e @ m @ a @ b
"SPEC/SEDEL.Parser.Parser pNotFollowedBy @ [Char] _ _ _" [orphan] forall @ e
                                                                         @ m :: * -> *
                                                                         @ a
                                                                         ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                        [GHC.Types.Char])
  Text.Megaparsec.Internal.pNotFollowedBy @ [GHC.Types.Char]
                                          @ e
                                          @ m
                                          @ a
                                          $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spNotFollowedBy
      @ e
      @ m
      @ a
"SPEC/SEDEL.Parser.Parser pPlus @ Void @ [Char] _ _" [orphan] forall @ m :: *
                                                                            -> *
                                                                     @ a
                                                                     ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                    [GHC.Types.Char])
                                                                     ($dOrd :: GHC.Classes.Ord
                                                                                 Data.Void.Void)
  Text.Megaparsec.Internal.pPlus @ Data.Void.Void
                                 @ [GHC.Types.Char]
                                 @ m
                                 @ a
                                 $dOrd
                                 $dStream
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT_$spPlus @ m @ a
"SPEC/SEDEL.Parser.Parser pTakeP _ @ [Char] _" [orphan] forall @ e
                                                               @ m :: * -> *
                                                               ($dStream :: Text.Megaparsec.Stream.Stream
                                                                              [GHC.Types.Char])
  Text.Megaparsec.Internal.pTakeP @ e @ [GHC.Types.Char] @ m $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spTakeP @ e @ m
"SPEC/SEDEL.Parser.Parser pTakeWhile1P _ @ [Char] _" [orphan] forall @ e
                                                                     @ m :: * -> *
                                                                     ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                    [GHC.Types.Char])
  Text.Megaparsec.Internal.pTakeWhile1P @ e
                                        @ [GHC.Types.Char]
                                        @ m
                                        $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spTakeWhile1P
      @ e
      @ m
"SPEC/SEDEL.Parser.Parser pTakeWhileP _ @ [Char] _" [orphan] forall @ e
                                                                    @ m :: * -> *
                                                                    ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                   [GHC.Types.Char])
  Text.Megaparsec.Internal.pTakeWhileP @ e
                                       @ [GHC.Types.Char]
                                       @ m
                                       $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spTakeWhileP
      @ e
      @ m
"SPEC/SEDEL.Parser.Parser pToken _ @ [Char] _ _" [orphan] forall @ e
                                                                 @ m :: * -> *
                                                                 @ a
                                                                 ($dStream :: Text.Megaparsec.Stream.Stream
                                                                                [GHC.Types.Char])
  Text.Megaparsec.Internal.pToken @ e
                                  @ [GHC.Types.Char]
                                  @ m
                                  @ a
                                  $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spToken @ e @ m @ a
"SPEC/SEDEL.Parser.Parser pTokens _ @ [Char] _" [orphan] forall @ e
                                                                @ m :: * -> *
                                                                ($dStream :: Text.Megaparsec.Stream.Stream
                                                                               [GHC.Types.Char])
  Text.Megaparsec.Internal.pTokens @ e
                                   @ [GHC.Types.Char]
                                   @ m
                                   $dStream
  = SEDEL.Parser.Parser.$s$fMonadParsecesParsecT_$spTokens @ e @ m
"SPEC/SEDEL.Parser.Parser union @ (ErrorFancy Void)" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                 (Text.Megaparsec.Error.ErrorFancy
                                                                                    Data.Void.Void))
  Data.Set.Internal.union @ (Text.Megaparsec.Error.ErrorFancy
                               Data.Void.Void)
                          $dOrd
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT_$sunion
"SPEC/SEDEL.Parser.Parser union @ (ErrorItem (Token [Char]))" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                          (Text.Megaparsec.Error.ErrorItem
                                                                                             (Text.Megaparsec.Stream.Token
                                                                                                [GHC.Types.Char])))
  Data.Set.Internal.union @ (Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                          $dOrd
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT_$sunion1
"SPEC/SEDEL.Parser.Parser withHints @ [Char] _ _ _" [orphan] forall @ e
                                                                    @ m :: * -> *
                                                                    @ b
                                                                    ($dOrd :: GHC.Classes.Ord
                                                                                (Text.Megaparsec.Stream.Token
                                                                                   [GHC.Types.Char]))
  Text.Megaparsec.Internal.withHints @ [GHC.Types.Char]
                                     @ e
                                     @ m
                                     @ b
                                     $dOrd
  = SEDEL.Parser.Parser.$s$fAlternativeParsecT_$swithHints
      @ e
      @ m
      @ b
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

